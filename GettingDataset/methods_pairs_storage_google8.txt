966
#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.get().apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public Response<? extends Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException, ResourceConflictException {
    if (input == null || (input.add == null && input.remove == null)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updatedHashtags = new HashSet<>();
    Set<String> toAdd = new HashSet<>(extractTags(input.add));
    Set<String> toRemove = new HashSet<>(extractTags(input.remove));
    if (toAdd.size() > 0) {
        for (HashtagValidationListener validator : hashtagValidationListeners) {
            try {
                for (String hashtag : toAdd) {
                    validator.onHashtagReceived(hashtag);
                }
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updatedHashtags.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (toAdd.size() > 0 || toRemove.size() > 0) {
        updatedHashtags.addAll(toAdd);
        updatedHashtags.removeAll(toRemove);
        update.setHashtags(updatedHashtags);
        update.commit();
        indexer.index(dbProvider.get(), update.getChange());
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        hooks.doHashtagsChangedHook(req.getChange(), currentUser.getAccount(), toAdd, toRemove, updatedHashtags, dbProvider.get());
    }
    return Response.ok(new TreeSet<String>(updatedHashtags));
}
#method_after
@Override
public Response<? extends Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException, ResourceConflictException {
    if (input == null || (input.add == null && input.remove == null)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> existingHashtags = notes.getHashtags();
    Set<String> updatedHashtags = new HashSet<>();
    Set<String> toAdd = new HashSet<>(extractTags(input.add));
    Set<String> toRemove = new HashSet<>(extractTags(input.remove));
    for (HashtagValidationListener validator : hashtagValidationListeners) {
        try {
            validator.validateHashtags(req.getChange(), toAdd, toRemove);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    if (existingHashtags != null && !existingHashtags.isEmpty()) {
        updatedHashtags.addAll(existingHashtags);
        toAdd.removeAll(existingHashtags);
        toRemove.retainAll(existingHashtags);
    }
    if (toAdd.size() > 0 || toRemove.size() > 0) {
        updatedHashtags.addAll(toAdd);
        updatedHashtags.removeAll(toRemove);
        update.setHashtags(updatedHashtags);
        update.commit();
        indexer.index(dbProvider.get(), update.getChange());
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        hooks.doHashtagsChangedHook(req.getChange(), currentUser.getAccount(), toAdd, toRemove, updatedHashtags, dbProvider.get());
    }
    return Response.ok(new TreeSet<String>(updatedHashtags));
}
#end_block

#method_before
private static void onRemove(NativeEvent event) {
    String hashtag = getDataId(event);
    if (hashtag != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.hashtags(screen.getChangeId().get()).delete(Input.create(hashtag), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemove(NativeEvent event) {
    String hashtags = getDataId(event);
    if (hashtags != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.hashtags(screen.getChangeId().get()).post(PostInput.create(null, hashtags), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private SafeHtmlBuilder formatHashtags(JsArrayString hashtags) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<String> itr = Natives.asList(hashtags).iterator();
    while (itr.hasNext()) {
        String hashtagName = itr.next();
        html.openAnchor().setAttribute("href", "/#/q/hashtag:" + hashtagName).setAttribute("role", "listitem").setAttribute(DATA_ID, hashtagName).setStyleName(style.hashtagName()).append(hashtagName).openElement("button").setAttribute("title", "Remove hashtag").setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
private SafeHtmlBuilder formatHashtags(JsArrayString hashtags) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<String> itr = Natives.asList(hashtags).iterator();
    while (itr.hasNext()) {
        String hashtagName = itr.next();
        html.openSpan().setAttribute(DATA_ID, hashtagName).setStyleName(style.hashtagName()).openAnchor().setAttribute("href", "#" + PageLinks.toChangeQuery("hashtag:" + hashtagName)).setAttribute("role", "listitem").append(hashtagName).closeAnchor().openElement("button").setAttribute("title", "Remove hashtag").setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button").closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
private void addHashtag(final String hashtag) {
    ChangeApi.hashtags(changeId.get()).put(Input.create(hashtag), new GerritCallback<JsArrayString>() {

        public void onSuccess(JsArrayString result) {
            hashtagTextBox.setEnabled(true);
            UIObject.setVisible(error, false);
            error.setInnerText("");
            hashtagTextBox.setText("");
            if (result != null && result.length() > 0) {
                updateHashtagList(result);
            }
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            hashtagTextBox.setEnabled(true);
        }
    });
}
#method_after
private void addHashtag(final String hashtags) {
    ChangeApi.hashtags(changeId.get()).post(PostInput.create(hashtags, null), new GerritCallback<JsArrayString>() {

        public void onSuccess(JsArrayString result) {
            hashtagTextBox.setEnabled(true);
            UIObject.setVisible(error, false);
            error.setInnerText("");
            hashtagTextBox.setText("");
            if (result != null && result.length() > 0) {
                updateHashtagList(result);
            }
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            hashtagTextBox.setEnabled(true);
        }
    });
}
#end_block

#method_before
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key, changeId);
    }
    followUpAction.show();
}
#method_after
@UiHandler("followUp")
void onFollowUp(ClickEvent e) {
    if (followUpAction == null) {
        followUpAction = new FollowUpAction(followUp, project, branch, key);
    }
    followUpAction.show();
}
#end_block

#method_before
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException, ResourceNotFoundException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            ObjectId parentCommit;
            if (input.baseChange != null) {
                List<Change> changes = changeUtil.findChanges(input.baseChange);
                if (changes.isEmpty()) {
                    throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
                }
                Change change = Iterables.getOnlyElement(changes);
                PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
                parentCommit = ObjectId.fromString(ps.getRevision().get());
            } else {
                Ref destRef = git.getRef(refName);
                if (destRef == null) {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
                parentCommit = destRef.getObjectId();
            }
            RevCommit mergeTip = rw.parseCommit(parentCommit);
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(id));
            hide();
        }
    });
}
#method_after
void send(String message) {
    ChangeApi.createChange(project, branch, message, base, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Gerrit.display(PageLinks.toChange(result.legacy_id()));
            hide();
        }
    });
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException, InvalidChangeOperationException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix(me.getAccountId(), change.getId()));
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, commit);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException, InvalidChangeOperationException {
    if (!user.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        IdentifiedUser me = (IdentifiedUser) user.get();
        String editRefPrefix = editRefPrefix(me.getAccountId(), change.getId());
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(editRefPrefix);
        if (refs.isEmpty()) {
            return Optional.absent();
        }
        // TODO(davido): Rather than failing when we encounter the corrupt state
        // where there is more than one ref, we could silently delete all but the
        // current one.
        Ref ref = Iterables.getOnlyElement(refs.values());
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(me, change, ref, commit, basePs));
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            PatchSet basePatchSet = edit.getBasePatchSet();
            if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
                throw new ResourceConflictException("only edit for current patch set can be published");
            }
            insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(repo, rw, inserter, edit.getEditCommit(), basePatchSet));
        } finally {
            inserter.release();
            rw.release();
        }
        // TODO(davido): This should happen in the same BatchRefUpdate.
        ChangeEditModifier.deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#method_after
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            PatchSet basePatchSet = edit.getBasePatchSet();
            if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
                throw new ResourceConflictException("only edit for current patch set can be published");
            }
            insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(repo, rw, inserter, edit.getEditCommit(), basePatchSet));
        } finally {
            inserter.release();
            rw.release();
        }
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public void delete(ChangeEdit edit) throws IOException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        ChangeEditModifier.deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#method_after
public void delete(ChangeEdit edit) throws IOException {
    Change change = edit.getChange();
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        deleteRef(repo, edit);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(Change change, RevCommit commit) throws IOException, InvalidChangeOperationException {
    if (commit.getParentCount() != 1) {
        throw new InvalidChangeOperationException("change edit commit has multiple parents");
    }
    RevCommit parentCommit = commit.getParent(0);
    ObjectId rev = parentCommit.getId();
    RevId parentRev = new RevId(ObjectId.toString(rev));
    try {
        List<PatchSet> r = db.get().patchSets().byRevision(parentRev).toList();
        if (r.isEmpty()) {
            throw new InvalidChangeOperationException(String.format("patch set %s change edit is based on doesn't exist", rev.abbreviate(8).name()));
        }
        if (r.size() > 1) {
            throw new InvalidChangeOperationException(String.format("multiple patch sets for change edit parent %s", rev.abbreviate(8).name()));
        }
        PatchSet parentPatchSet = Iterables.getOnlyElement(r);
        if (!change.getId().equals(parentPatchSet.getId().getParentKey())) {
            throw new InvalidChangeOperationException(String.format("different change edit ID %d and its parent patch set %d", change.getId().get(), parentPatchSet.getId().getParentKey().get()));
        }
        return parentPatchSet;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(Change change, Ref ref) throws IOException, InvalidChangeOperationException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return db.get().patchSets().get(new PatchSet.Id(change.getId(), Integer.valueOf(psId)));
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
static String editRefName(Account.Id accountId, Change.Id changeId, PatchSet.Id psId) {
    return String.format("%s/edit-%d/%d", RefNames.refsUsers(accountId), changeId.get(), psId.get());
}
#method_after
static String editRefName(Account.Id accountId, Change.Id changeId, PatchSet.Id psId) {
    return editRefPrefix(accountId, changeId) + psId.get();
}
#end_block

#method_before
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(change.getProject());
    String refPrefix = editRefPrefix(me.getAccountId(), change.getId());
    try {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit base = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            ObjectId commit = createCommit(me, inserter, base, base, base.getTree());
            inserter.flush();
            return update(repo, me, editRefName(me.getAccountId(), change.getId(), ps.getId()), rw, ObjectId.zeroId(), commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public RefUpdate.Result createEdit(Change change, PatchSet ps) throws AuthException, IOException, ResourceConflictException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(change.getProject());
    String refPrefix = editRefPrefix(me.getAccountId(), change.getId());
    try {
        Map<String, Ref> refs = repo.getRefDatabase().getRefs(refPrefix);
        if (!refs.isEmpty()) {
            throw new ResourceConflictException("edit already exists");
        }
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit base = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
            RevCommit changeBase = base.getParent(0);
            ObjectId commit = createCommit(me, inserter, base, changeBase, base.getTree());
            inserter.flush();
            String editRefName = editRefName(me.getAccountId(), change.getId(), ps.getId());
            return update(repo, me, editRefName, rw, ObjectId.zeroId(), commit);
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
public RefUpdate.Result rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit mergeTip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(editCommit.getParent(0));
            if (m.merge(mergeTip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < mergeTip.getParentCount(); i++) {
                    commit.addParentId(mergeTip.getParent(i));
                }
                commit.setParentId(mergeTip);
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                RefUpdate.Result res = update(repo, me, refName, rw, ObjectId.zeroId(), newEdit);
                switch(res) {
                    case FORCED:
                    case NEW:
                    case NO_CHANGE:
                        deleteRef(repo, edit);
                        return res;
                    default:
                        throw new IOException(String.format("Failed to delete ref %s: %s", refName, res));
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
public void rebaseEdit(ChangeEdit edit, PatchSet current) throws AuthException, InvalidChangeOperationException, IOException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    Change change = edit.getChange();
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    String refName = editRefName(me.getAccountId(), change.getId(), current.getId());
    Repository repo = gitManager.openRepository(change.getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        BatchRefUpdate ru = repo.getRefDatabase().newBatchUpdate();
        ObjectInserter inserter = repo.newObjectInserter();
        try {
            RevCommit editCommit = edit.getEditCommit();
            if (editCommit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Rebase edit against root commit not implemented");
            }
            RevCommit tip = rw.parseCommit(ObjectId.fromString(current.getRevision().get()));
            ThreeWayMerger m = MergeStrategy.RESOLVE.newMerger(repo, true);
            m.setObjectInserter(inserter);
            m.setBase(ObjectId.fromString(edit.getBasePatchSet().getRevision().get()));
            if (m.merge(tip, editCommit)) {
                ObjectId tree = m.getResultTreeId();
                CommitBuilder commit = new CommitBuilder();
                commit.setTreeId(tree);
                for (int i = 0; i < tip.getParentCount(); i++) {
                    commit.addParentId(tip.getParent(i));
                }
                commit.setAuthor(editCommit.getAuthorIdent());
                commit.setCommitter(new PersonIdent(editCommit.getCommitterIdent(), TimeUtil.nowTs()));
                commit.setMessage(editCommit.getFullMessage());
                ObjectId newEdit = inserter.insert(commit);
                inserter.flush();
                ru.addCommand(new ReceiveCommand(ObjectId.zeroId(), newEdit, refName));
                ru.addCommand(new ReceiveCommand(edit.getRef().getObjectId(), ObjectId.zeroId(), edit.getRefName()));
                ru.execute(rw, NullProgressMonitor.INSTANCE);
                for (ReceiveCommand cmd : ru.getCommands()) {
                    if (cmd.getResult() != ReceiveCommand.Result.OK) {
                        throw new IOException("failed: " + cmd);
                    }
                }
            } else {
                // TODO(davido): Allow to resolve conflicts inline
                throw new InvalidChangeOperationException("merge conflict");
            }
        } finally {
            rw.release();
            inserter.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = rw.parseCommit(edit.getRef().getObjectId());
            PatchSet basePs = edit.getBasePatchSet();
            RevCommit base = rw.parseCommit(ObjectId.fromString(basePs.getRevision().get()));
            if (base.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
private RefUpdate.Result modify(TreeOperation op, ChangeEdit edit, String file, byte[] content) throws AuthException, IOException, InvalidChangeOperationException {
    if (!currentUser.get().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser me = (IdentifiedUser) currentUser.get();
    Repository repo = gitManager.openRepository(edit.getChange().getProject());
    try {
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter();
        ObjectReader reader = repo.newObjectReader();
        try {
            String refName = edit.getRefName();
            RevCommit prevEdit = edit.getEditCommit();
            if (prevEdit.getParentCount() == 0) {
                throw new InvalidChangeOperationException("Modify edit against root commit not implemented");
            }
            RevCommit base = prevEdit.getParent(0);
            base = rw.parseCommit(base);
            ObjectId newTree = writeNewTree(op, repo, rw, inserter, prevEdit, reader, file, content, base);
            if (ObjectId.equals(newTree, prevEdit.getTree())) {
                throw new InvalidChangeOperationException("no changes were made");
            }
            ObjectId commit = createCommit(me, inserter, prevEdit, base, newTree);
            inserter.flush();
            return update(repo, me, refName, rw, prevEdit, commit);
        } finally {
            rw.release();
            inserter.release();
            reader.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    state.setEnabled(isOwner);
    submitType.setEnabled(isOwner);
    setEnabledForUseContentMerge();
    newChangeForAllNotInTarget.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, HasEnabled> widgetMap : pluginConfigWidgets.values()) {
            for (HasEnabled widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    state = new ListBox();
    for (ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    newChangeForAllNotInTarget = newInheritedBooleanBox();
    saveEnabler.listenTo(newChangeForAllNotInTarget);
    grid.add(Util.C.createNewChangeForAllNotInTarget(), newChangeForAllNotInTarget);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#method_after
void display(ConfigInfo result) {
    descTxt.setText(result.description());
    setBool(contributorAgreements, result.use_contributor_agreements());
    setBool(signedOffBy, result.use_signed_off_by());
    setBool(contentMerge, result.use_content_merge());
    setBool(newChangeForAllNotInTarget, result.create_new_change_for_all_not_in_target());
    setBool(requireChangeID, result.require_change_id());
    setSubmitType(result.submit_type());
    setState(result.state());
    maxObjectSizeLimit.setText(result.max_object_size_limit().configured_value());
    if (result.max_object_size_limit().inherited_value() != null) {
        effectiveMaxObjectSizeLimit.setVisible(true);
        effectiveMaxObjectSizeLimit.setText(Util.M.effectiveMaxObjectSizeLimit(result.max_object_size_limit().value()));
        effectiveMaxObjectSizeLimit.setTitle(Util.M.globalMaxObjectSizeLimit(result.max_object_size_limit().inherited_value()));
    } else {
        effectiveMaxObjectSizeLimit.setVisible(false);
    }
    saveProject.setEnabled(false);
    initPluginOptions(result);
    initProjectActions(result);
}
#end_block

#method_before
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        if (id.equals("create_change")) {
            ActionInfo create = actions.get(id);
            final Button createChange = new Button(create.label());
            createChange.setTitle(create.title());
            createChange.setEnabled(create.enabled());
            createChange.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(final ClickEvent event) {
                    CreateChangeAction.call(createChange, getProjectKey().toString());
                }
            });
            actionsPanel.add(createChange);
        } else {
            actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
        }
    }
}
#method_after
private void initProjectActions(ConfigInfo info) {
    actionsGrid.clear(true);
    actionsGrid.removeAllRows();
    NativeMap<ActionInfo> actions = info.actions();
    if (actions == null || actions.isEmpty()) {
        return;
    }
    actions.copyKeysIntoChildren("id");
    actionsGrid.addHeader(new SmallHeading(Util.C.headingProjectCommands()));
    FlowPanel actionsPanel = new FlowPanel();
    actionsPanel.setStyleName(Gerrit.RESOURCES.css().projectActions());
    actionsPanel.setVisible(true);
    actionsGrid.add(Util.C.headingCommands(), actionsPanel);
    for (String id : actions.keySet()) {
        actionsPanel.add(new ActionButton(getProjectKey(), actions.get(id)));
    }
    if (Gerrit.isSignedIn()) {
        actionsPanel.add(createChangeAction());
    }
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(newChangeForAllNotInTarget), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    call("create").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String subject, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText("Create");
            message.setText("Insert the description of the change.");
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, this.getDestinationBranch(), this.message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final String project) {
    // TODO Replace CreateChangeDialog with a nicer looking display.
    b.setEnabled(false);
    new CreateChangeDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCreate());
            message.setText(Util.C.buttonCreateDescription());
        }

        @Override
        public void onSend() {
            ChangeApi.createChange(project, getDestinationBranch(), message.getText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
@Override
public String getDisplayString() {
    final String refsHeads = "refs/heads/";
    if (branch.ref().startsWith(refsHeads)) {
        return branch.ref().substring(refsHeads.length());
    }
    return branch.ref();
}
#method_after
@Override
public String getDisplayString() {
    if (branch.ref().startsWith(Branch.R_HEADS)) {
        return branch.ref().substring(Branch.R_HEADS.length());
    }
    return branch.ref();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("open".equals(statusName) || "pending".equals(statusName)) {
        return status_open();
    } else if ("closed".equals(statusName)) {
        return ChangeStatusPredicate.closed(args.db);
    } else if ("reviewed".equalsIgnoreCase(statusName)) {
        return new IsReviewedPredicate();
    } else {
        return new ChangeStatusPredicate(statusName);
    }
}
#method_after
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return new IsReviewedPredicate();
    } else {
        return ChangeStatusPredicate.parse(statusName);
    }
}
#end_block

#method_before
public Predicate<ChangeData> status_open() {
    return ChangeStatusPredicate.open(args.db);
}
#method_after
public Predicate<ChangeData> status_open() {
    return ChangeStatusPredicate.open();
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    return getValue().equals(object.notes().load().getHashtags());
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    return object.notes().load().getHashtags().contains(getValue());
}
#end_block

#method_before
@Override
public Response<Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException {
    if (input == null || Strings.isNullOrEmpty(input.hashtags)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> hashtags = new HashSet<String>();
    Set<String> oldHashtags = notes.getHashtags();
    if (oldHashtags != null) {
        hashtags.addAll(oldHashtags);
    }
    hashtags.removeAll(Arrays.asList(input.hashtags.split(",")));
    update.setHashtags(hashtags);
    update.commit();
    return Response.ok(hashtags);
}
#method_after
@Override
public Response<Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException {
    if (input == null || Strings.isNullOrEmpty(input.hashtags)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> hashtags = new HashSet<String>();
    Set<String> oldHashtags = notes.getHashtags();
    if (oldHashtags != null) {
        hashtags.addAll(oldHashtags);
    }
    hashtags.removeAll(Arrays.asList(input.hashtags.split(",")));
    update.setHashtags(hashtags);
    update.commit();
    return Response.ok(hashtags);
}
#end_block

#method_before
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            for (DynamicMap.Entry<DownloadCommand> e2 : downloadCommands) {
                String commandName = e2.getExportName();
                DownloadCommand command = e2.getProvider().get();
                String c = command.getCommand(scheme, projectName, refName);
                if (c != null) {
                    addCommand(fetchInfo, commandName, c);
                }
            }
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> makeFetchMap(ChangeControl ctl, ChangeData cd, PatchSet in) throws OrmException {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        if (!scheme.isAuthSupported() && !ctl.forUser(anonymous).isPatchVisible(in, db.get())) {
            continue;
        }
        String projectName = ctl.getProject().getNameKey().get();
        String url = scheme.getUrl(projectName);
        String refName = in.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        if (has(DOWNLOAD_COMMANDS)) {
            populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
        }
    }
    return r;
}
#end_block

#method_before
private void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = Maps.newTreeMap();
    }
    fetchInfo.commands.put(commandName, c);
}
#method_after
private static void addCommand(FetchInfo fetchInfo, String commandName, String c) {
    if (fetchInfo.commands == null) {
        fetchInfo.commands = Maps.newTreeMap();
    }
    fetchInfo.commands.put(commandName, c);
}
#end_block

#method_before
@Override
public Response<Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException {
    if (input == null || Strings.isNullOrEmpty(input.hashtags)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> oldHashtags = notes.getHashtags();
    Set<String> hashtags = new HashSet<String>();
    if (oldHashtags != null) {
        hashtags.addAll(oldHashtags);
    }
    hashtags.addAll(Arrays.asList(input.hashtags.split(",")));
    update.setHashtags(hashtags);
    update.commit();
    return Response.ok(hashtags);
}
#method_after
@Override
public Response<Set<String>> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException, BadRequestException {
    if (input == null || Strings.isNullOrEmpty(input.hashtags)) {
        throw new BadRequestException("Hashtags are required");
    }
    ChangeControl control = req.getControl();
    if (!control.canEditHashtags()) {
        throw new AuthException("Editing hashtags not permitted");
    }
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> oldHashtags = notes.getHashtags();
    Set<String> hashtags = new HashSet<String>();
    if (oldHashtags != null) {
        hashtags.addAll(oldHashtags);
    }
    ;
    hashtags.addAll(Lists.newArrayList(Splitter.on(CharMatcher.anyOf(",;")).trimResults().split(input.hashtags)));
    update.setHashtags(hashtags);
    update.commit();
    return Response.ok(hashtags);
}
#end_block

#method_before
@Override
public Response<Set<String>> apply(ChangeResource req) throws AuthException, OrmException, IOException, BadRequestException {
    ChangeControl control = req.getControl();
    ChangeUpdate update = updateFactory.create(control);
    ChangeNotes notes = control.getNotes().load();
    Set<String> hashtags = notes.getHashtags();
    update.setHashtags(hashtags);
    update.commit();
    return Response.ok(hashtags);
}
#method_after
@Override
public Response<Set<String>> apply(ChangeResource req) throws AuthException, OrmException, IOException, BadRequestException {
    ChangeControl control = req.getControl();
    ChangeNotes notes = control.getNotes().load();
    Set<String> hashtags = notes.getHashtags();
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return Response.ok(hashtags);
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    String currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision()).id();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1).id();
    }
    String currentlyViewedPatchSet = info.revision(revision).id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        addFile.setVisible(!editMode.isVisible());
        reviewMode.setVisible(!editMode.isVisible());
    }
    RevisionInfo rev = info.revision(revision);
    editFileAction = new EditFileAction(new PatchSet.Id(changeId, rev._number()), "", "", style, editMessage, reply, edit != null);
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        addFile.setVisible(!editMode.isVisible());
        reviewMode.setVisible(!editMode.isVisible());
    }
    RevisionInfo rev = info.revision(revision);
    editFileAction = new EditFileAction(new PatchSet.Id(changeId, edit == null ? rev._number() : 0), "", "", style, editMessage, reply);
}
#end_block

#method_before
public void set(Id base, Id curr, ChangeScreen2.Style style, Widget editButton, Widget replyButton, boolean editExists) {
    this.base = base;
    this.curr = curr;
    this.style = style;
    this.editButton = editButton;
    this.replyButton = replyButton;
    this.editExists = editExists;
}
#method_after
public void set(PatchSet.Id base, PatchSet.Id curr, ChangeScreen2.Style style, Widget editButton, Widget replyButton, boolean editExists) {
    this.base = base;
    this.curr = curr;
    this.style = style;
    this.editButton = editButton;
    this.replyButton = replyButton;
    this.editExists = editExists;
}
#end_block

#method_before
void onEdit(int idx) {
    final String path = list.get(idx).path();
    ChangeFileApi.getContent(editExists, curr, path, new GerritCallback<String>() {

        @Override
        public void onSuccess(String result) {
            EditFileAction edit = new EditFileAction(curr, result, path, style, editButton, replyButton, editExists);
            edit.onEdit();
        }
    });
}
#method_after
void onEdit(int idx) {
    final String path = list.get(idx).path();
    final PatchSet.Id id = editExists && curr.get() != 0 ? new PatchSet.Id(curr.getParentKey(), 0) : curr;
    ChangeFileApi.getContent(id, path, new GerritCallback<String>() {

        @Override
        public void onSuccess(String result) {
            EditFileAction edit = new EditFileAction(id, result, path, style, editButton, replyButton);
            edit.onEdit();
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    file.set(id, content, editExists);
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            content.setFocus(true);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    file.set(id, content);
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (fileName.isEmpty()) {
                file.setFocus(true);
            } else {
                content.setFocus(true);
            }
        }
    });
}
#end_block

#method_before
@Override
public boolean match(String ref, String username) {
    if (!ref.startsWith(prefix) || username == null) {
        return false;
    }
    String u;
    if (isRE(template.getPattern())) {
        u = Pattern.quote(username);
    } else {
        u = username;
    }
    RefPatternMatcher next = getMatcher(evaluate(template, u));
    return next != null ? next.match(evaluate(ref, u), username) : false;
}
#method_after
@Override
public boolean match(String ref, String username) {
    if (!ref.startsWith(prefix) || username == null) {
        return false;
    }
    String u;
    if (isRE(template.getPattern())) {
        u = Pattern.quote(username);
    } else {
        u = username;
    }
    RefPatternMatcher next = getMatcher(expand(template, u));
    return next != null ? next.match(expand(ref, u), username) : false;
}
#end_block

#method_before
protected Injector createDbInjector(final DataSourceProvider.Context context) {
    final File sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
        }
    };
    modules.add(sitePathModule);
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(new SecureStoreModule(cfg));
    modules.add(new LocalDiskRepositoryManager.Module());
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#method_after
protected Injector createDbInjector(final DataSourceProvider.Context context) {
    final File sitePath = getSitePath();
    final List<Module> modules = new ArrayList<>();
    Module sitePathModule = new AbstractModule() {

        @Override
        protected void configure() {
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            bind(SecureStore.class).toProvider(SecureStoreProvider.class);
        }
    };
    modules.add(sitePathModule);
    modules.add(new LifecycleModule() {

        @Override
        protected void configure() {
            bind(DataSourceProvider.Context.class).toInstance(context);
            if (dsProvider != null) {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(dsProvider).in(SINGLETON);
                if (LifecycleListener.class.isAssignableFrom(dsProvider.getClass())) {
                    listener().toInstance((LifecycleListener) dsProvider);
                }
            } else {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(SiteLibraryBasedDataSourceProvider.class).in(SINGLETON);
                listener().to(SiteLibraryBasedDataSourceProvider.class);
            }
        }
    });
    Module configModule = new GerritServerConfigModule();
    modules.add(configModule);
    Injector cfgInjector = Guice.createInjector(sitePathModule, configModule);
    Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    String dbType;
    if (dsProvider != null) {
        dbType = getDbType(dsProvider);
    } else {
        dbType = cfg.getString("database", null, "type");
    }
    final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(DataSourceType.class).toInstance(dst);
        }
    });
    modules.add(new DatabaseModule());
    modules.add(new SchemaModule());
    modules.add(new LocalDiskRepositoryManager.Module());
    try {
        return Guice.createInjector(PRODUCTION, modules);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof SQLException) {
            throw die("Cannot connect to SQL database", why);
        }
        if (why instanceof OrmException && why.getCause() != null && "Unable to determine driver URL".equals(why.getMessage())) {
            why = why.getCause();
            if (isCannotCreatePoolException(why)) {
                throw die("Cannot connect to SQL database", why.getCause());
            }
            throw die("Cannot connect to SQL database", why);
        }
        final StringBuilder buf = new StringBuilder();
        if (why != null) {
            buf.append(why.getMessage());
            why = why.getCause();
        } else {
            buf.append(first.getMessage());
        }
        while (why != null) {
            buf.append("\n  caused by ");
            buf.append(why.toString());
            why = why.getCause();
        }
        throw die(buf.toString(), new RuntimeException("DbInjector failed", ce));
    }
}
#end_block

#method_before
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, NameKey destBranch, Id patchSetId) throws MergeValidationException {
    try {
        db = schemaFactory.open();
        PatchSetApproval psa = approvalsUtil.getSubmitter(db, commit.notes(), patchSetId);
        if (psa == null) {
            throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
        }
        final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
        if (!submitter.getCapabilities().canAdministrateServer()) {
            throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
        }
    } catch (OrmException e) {
        throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    PatchSetApproval psa = approvalsUtil.getSubmitter(reviewDb.get(), commit.notes(), patchSetId);
    if (psa == null) {
        throw new MergeValidationException(CommitMergeStatus.NO_PATCH_SET);
    }
    IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
    if (!submitter.getCapabilities().canAdministrateServer()) {
        throw new MergeValidationException(CommitMergeStatus.MISSING_DEPENDENCY);
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data);
            Writer w = newWriter(out, res)) {
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
        }
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = Maps.newHashMapWithExpectedSize(2);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        try (OutputStream out = startRenderStreamingHtml(req, res, "gitiles.logDetail", data)) {
            Writer w = newWriter(out, res);
            new LogSoyData(req, access, pretty).renderStreaming(paginator, null, renderer, w, df);
            w.flush();
        }
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    String author = Iterables.getFirst(view.getParameters().get("author"), null);
    if (author != null) {
        walk.setRevFilter(new AuthorRevFilter(author));
    }
    return walk;
}
#end_block

#method_before
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull(), PaginatorFilters.fromQuery(view.getParameters()));
}
#method_after
private static Paginator newPaginator(Repository repo, GitilesView view) throws IOException {
    if (view == null) {
        return null;
    }
    RevWalk walk = null;
    try {
        walk = newWalk(repo, view);
    } catch (IncorrectObjectTypeException e) {
        return null;
    }
    Optional<ObjectId> start;
    try {
        start = getStart(view.getParameters(), walk.getObjectReader());
    } catch (IOException e) {
        walk.release();
        throw e;
    }
    if (start == null) {
        return null;
    }
    return new Paginator(walk, getLimit(view), start.orNull());
}
#end_block

#method_before
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<String>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Hashtags: tag1,tag2\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
}
#method_after
@Test
public void hashtagCommit() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    LinkedHashSet<String> hashtags = new LinkedHashSet<String>();
    hashtags.add("tag1");
    hashtags.add("tag2");
    update.setHashtags(hashtags);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertTrue(commit.getFullMessage().endsWith("Hashtags: tag1,tag2\n"));
    } finally {
        walk.release();
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) {
    if (isEmpty()) {
        return false;
    }
    commit.setAuthor(newIdent(getUser().getAccount(), when));
    commit.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (subject != null) {
        msg.append(subject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (hashtags != null) {
        StringBuilder sb = new StringBuilder();
        for (String hashtag : hashtags) {
            sb.append(hashtag).append(',');
        }
        if (sb.length() > 0) {
            addFooter(msg, FOOTER_HASHTAGS, sb.substring(0, sb.length() - 1));
        }
    }
    for (Map.Entry<Account.Id, ReviewerState> e : reviewers.entrySet()) {
        Account account = accountCache.get(e.getKey()).getAccount();
        PersonIdent ident = newIdent(account, when);
        addFooter(msg, e.getValue().getFooterKey()).append(ident.getName()).append(" <").append(ident.getEmailAddress()).append(">\n");
    }
    for (Map.Entry<String, Optional<Short>> e : approvals.entrySet()) {
        if (!e.getValue().isPresent()) {
            addFooter(msg, FOOTER_LABEL, '-', e.getKey());
        } else {
            addFooter(msg, FOOTER_LABEL, new LabelVote(e.getKey(), e.getValue().get()).formatWithEquals());
        }
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    commit.setMessage(msg.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) {
    if (isEmpty()) {
        return false;
    }
    commit.setAuthor(newIdent(getUser().getAccount(), when));
    commit.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (subject != null) {
        msg.append(subject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerState> e : reviewers.entrySet()) {
        Account account = accountCache.get(e.getKey()).getAccount();
        PersonIdent ident = newIdent(account, when);
        addFooter(msg, e.getValue().getFooterKey()).append(ident.getName()).append(" <").append(ident.getEmailAddress()).append(">\n");
    }
    for (Map.Entry<String, Optional<Short>> e : approvals.entrySet()) {
        if (!e.getValue().isPresent()) {
            addFooter(msg, FOOTER_LABEL, '-', e.getKey());
        } else {
            addFooter(msg, FOOTER_LABEL, new LabelVote(e.getKey(), e.getValue().get()).formatWithEquals());
        }
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    commit.setMessage(msg.toString());
    return true;
}
#end_block

#method_before
private void parseHashtags(RevCommit commit) throws ConfigInvalidException {
    // Commits are parsed in reverse order and only the last set of hashtags should be used.
    if (hashtags != null) {
        return;
    }
    List<String> hashtagsLines = commit.getFooterLines(FOOTER_HASHTAGS);
    if (hashtagsLines.isEmpty()) {
        return;
    } else if (hashtagsLines.size() > 1) {
        throw expectedOneFooter(FOOTER_HASHTAGS, hashtagsLines);
    }
    hashtags = new HashSet<String>(Arrays.asList(hashtagsLines.get(0).split(",")));
}
#method_after
private void parseHashtags(RevCommit commit) throws ConfigInvalidException {
    // Commits are parsed in reverse order and only the last set of hashtags should be used.
    if (hashtags != null) {
        return;
    }
    List<String> hashtagsLines = commit.getFooterLines(FOOTER_HASHTAGS);
    if (hashtagsLines.isEmpty()) {
        return;
    } else if (hashtagsLines.size() > 1) {
        throw expectedOneFooter(FOOTER_HASHTAGS, hashtagsLines);
    }
    hashtags = Sets.newHashSet(Splitter.on(',').split(hashtagsLines.get(0)));
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try (ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        }
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try (ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = Objects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public Response<Result> apply(FileResource resource) throws ResourceConflictException, ResourceNotFoundException, OrmException, AuthException, InvalidChangeOperationException, IOException {
    PatchSet.Id basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.parse(resource.getRevision().getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet().getId();
    }
    AccountDiffPreference prefs = new AccountDiffPreference(new Account.Id(0));
    prefs.setIgnoreWhitespace(ignoreWhitespace.whitespace);
    prefs.setContext(context);
    prefs.setIntralineDifference(intraline);
    try {
        PatchScriptFactory psf = patchScriptFactoryFactory.create(resource.getRevision().getControl(), resource.getPatchKey().getFileName(), basePatchSet, resource.getPatchKey().getParentKey(), prefs);
        psf.setLoadHistory(false);
        psf.setLoadComments(context != AccountDiffPreference.WHOLE_FILE_CONTEXT);
        PatchScript ps = psf.call();
        Content content = new Content(ps);
        for (Edit edit : ps.getEdits()) {
            if (edit.getType() == Edit.Type.EMPTY) {
                continue;
            }
            content.addCommon(edit.getBeginA());
            checkState(content.nextA == edit.getBeginA(), "nextA = %d; want %d", content.nextA, edit.getBeginA());
            checkState(content.nextB == edit.getBeginB(), "nextB = %d; want %d", content.nextB, edit.getBeginB());
            switch(edit.getType()) {
                case DELETE:
                case INSERT:
                case REPLACE:
                    List<Edit> internalEdit = edit instanceof ReplaceEdit ? ((ReplaceEdit) edit).getInternalEdits() : null;
                    content.addDiff(edit.getEndA(), edit.getEndB(), internalEdit);
                    break;
                case EMPTY:
                default:
                    throw new IllegalStateException();
            }
        }
        content.addCommon(ps.getA().size());
        ProjectState state = projectCache.get(resource.getRevision().getChange().getProject());
        Result result = new Result();
        if (ps.getDisplayMethodA() != DisplayMethod.NONE) {
            result.metaA = new FileMeta();
            result.metaA.name = MoreObjects.firstNonNull(ps.getOldName(), ps.getNewName());
            setContentType(result.metaA, state, ps.getFileModeA(), ps.getMimeTypeA());
            result.metaA.lines = ps.getA().size();
        }
        if (ps.getDisplayMethodB() != DisplayMethod.NONE) {
            result.metaB = new FileMeta();
            result.metaB.name = ps.getNewName();
            setContentType(result.metaB, state, ps.getFileModeB(), ps.getMimeTypeB());
            result.metaB.lines = ps.getB().size();
        }
        if (intraline) {
            if (ps.hasIntralineTimeout()) {
                result.intralineStatus = IntraLineStatus.TIMEOUT;
            } else if (ps.hasIntralineFailure()) {
                result.intralineStatus = IntraLineStatus.FAILURE;
            } else {
                result.intralineStatus = IntraLineStatus.OK;
            }
        }
        result.changeType = ps.getChangeType();
        if (ps.getPatchHeader().size() > 0) {
            result.diffHeader = ps.getPatchHeader();
        }
        result.content = content.lines;
        Response<Result> r = Response.ok(result);
        if (resource.isCacheable()) {
            r.caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
        }
        return r;
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (LargeObjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (editBox == null) {
        editBox = new EditFileBox(id, content, file);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(editMessageButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(editBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#method_after
void onEdit() {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (editBox == null) {
        editBox = new EditFileBox(id, content, file);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(editMessageButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(editBox);
    p.showRelativeTo(relativeTo);
    GlobalKey.dialog(p);
    popup = p;
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    String idStr = id.get();
    boolean edit = false;
    if (idStr.endsWith(".edit")) {
        idStr = idStr.substring(0, idStr.length() - 5);
        edit = true;
    }
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, idStr)) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0), edit);
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps).doNotCache();
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#end_block

#method_before
private List<PatchSet> find(ChangeResource change, String id) throws OrmException {
    ReviewDb db = dbProvider.get();
    if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        PatchSet ps = dbProvider.get().patchSets().get(new PatchSet.Id(change.getChange().getId(), Integer.parseInt(id)));
        if (ps != null) {
            return Collections.singletonList(ps);
        }
        return Collections.emptyList();
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else if (id.length() >= 8) {
        // Commit names are rather unique. Query for the commit and later
        // match to the change. This is most likely going to identify 1 or
        // at most 2 patch sets to consider, which is smaller than looking
        // for all patch sets in the change.
        RevId revid = new RevId(id);
        if (revid.isComplete()) {
            return db.patchSets().byRevision(revid).toList();
        } else {
            return db.patchSets().byRevisionRange(revid, revid.max()).toList();
        }
    } else {
        // Chance of collision rises; look at all patch sets on the change.
        List<PatchSet> out = Lists.newArrayList();
        for (PatchSet ps : db.patchSets().byChange(change.getChange().getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(ps);
            }
        }
        return out;
    }
}
#method_after
private List<PatchSet> find(ChangeResource change, String id) throws OrmException {
    ReviewDb db = dbProvider.get();
    if (id.equals("0")) {
        return loadEdit(change, null);
    } else if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        PatchSet ps = dbProvider.get().patchSets().get(new PatchSet.Id(change.getChange().getId(), Integer.parseInt(id)));
        if (ps != null) {
            return Collections.singletonList(ps);
        }
        return Collections.emptyList();
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else if (id.length() >= 8) {
        // Commit names are rather unique. Query for the commit and later
        // match to the change. This is most likely going to identify 1 or
        // at most 2 patch sets to consider, which is smaller than looking
        // for all patch sets in the change.
        RevId revid = new RevId(id);
        if (revid.isComplete()) {
            List<PatchSet> list = db.patchSets().byRevision(revid).toList();
            if (list.isEmpty()) {
                return loadEdit(change, revid);
            }
            return list;
        } else {
            return db.patchSets().byRevisionRange(revid, revid.max()).toList();
        }
    } else {
        // Chance of collision rises; look at all patch sets on the change.
        List<PatchSet> out = Lists.newArrayList();
        for (PatchSet ps : db.patchSets().byChange(change.getChange().getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(ps);
            }
        }
        return out;
    }
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnDeleteRestore(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnDeleteRestore(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnDeleteRestore(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            boolean editeable = isEditeable(info);
            sb.openElement("button").setAttribute("title", editeable ? Resources.C.removeFileInline() : Resources.C.restoreFileInline()).setAttribute("onclick", (editeable ? DELETE : RESTORE) + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(editeable ? Gerrit.RESOURCES.redNot() : Gerrit.RESOURCES.editUndo())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnDeleteRestore(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            boolean editable = isEditable(info);
            sb.openElement("button").setAttribute("title", editable ? Resources.C.removeFileInline() : Resources.C.restoreFileInline()).setAttribute("onclick", (editable ? DELETE : RESTORE) + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(editable ? Gerrit.RESOURCES.redNot() : Gerrit.RESOURCES.editUndo())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnRemove(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#method_after
private void render(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTr();
    sb.openTd().setStyleName(R.css().pointer()).closeTd();
    // to navigate to edit dialog instead of to SBS2.
    if (mode == Mode.REVIEW) {
        columnReviewed(sb, info);
    } else {
        columnEdit(sb, info);
        columnRemove(sb, info);
    }
    columnStatus(sb, info);
    columnPath(sb, info);
    columnComments(sb, info);
    columnDelta1(sb, info);
    columnDelta2(sb, info);
    sb.closeTr();
}
#end_block

#method_before
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnEdit(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().editButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.editFileInline()).setAttribute("onclick", EDIT + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
private void columnRemove(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser && isEditeable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.removeFileInline()).setAttribute("onclick", DELETE + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.redNot())).closeElement("button");
        }
    }
    sb.closeTd();
}
#method_after
private void columnRemove(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().removeButton());
    if (hasUser && isEditable(info)) {
        if (!Patch.COMMIT_MSG.equals(info.path())) {
            sb.openElement("button").setAttribute("title", Resources.C.removeFileInline()).setAttribute("onclick", DELETE + "(event," + info._row() + ")").append(new ImageResourceRenderer().render(Gerrit.RESOURCES.redNot())).closeElement("button");
        }
    }
    sb.closeTd();
}
#end_block

#method_before
@Override
protected void onLoad() {
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    reload.setEnabled(!fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            content.setFocus(true);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    file.set(id, content);
    file.setText(fileName);
    file.setEnabled(fileName.isEmpty());
    content.setText(fileContent);
    save.setEnabled(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            content.setFocus(true);
        }
    });
}
#end_block

#method_before
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        reviewMode.setVisible(!editMode.isVisible());
    }
}
#method_after
private void initEditMode(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.status() == Status.NEW) {
        editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
        reviewMode.setVisible(!editMode.isVisible());
    }
    RevisionInfo rev = info.revision(revision);
    editFileAction = new EditFileAction(new PatchSet.Id(changeId, rev._number()), "", "", style, editMessage, reply);
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // on the last ps or not
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.set(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()), style, editMessage, reply);
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment, fileTableMode);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    initEditFileAction(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            CallbackGroup group = new CallbackGroup();
            commentManager.saveAllDrafts(group);
            group.done();
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    String b = base != null ? base.getId() : null;
                    String rev = revision.getId();
                    Gerrit.display(PageLinks.toChange(changeId, b, rev), new ChangeScreen2(changeId, b, rev, openReplyBox, false));
                }
            });
        }
    };
}
#method_after
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            CallbackGroup group = new CallbackGroup();
            commentManager.saveAllDrafts(group);
            group.done();
            group.addListener(new GerritCallback<Void>() {

                @Override
                public void onSuccess(Void result) {
                    String b = base != null ? base.getId() : null;
                    String rev = revision.getId();
                    Gerrit.display(PageLinks.toChange(changeId, b, rev), new ChangeScreen2(changeId, b, rev, openReplyBox, FileTable.Mode.REVIEW));
                }
            });
        }
    };
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        boolean editMode = false;
        if (panel != null && panel.startsWith("edit")) {
            editMode = true;
            panel = null;
        }
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false, editMode) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, 0, null, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        FileTable.Mode mode = FileTable.Mode.REVIEW;
        if (panel != null && (panel.equals("edit") || panel.startsWith("edit/"))) {
            mode = FileTable.Mode.EDIT;
            panel = null;
        }
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false, mode) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, 0, null, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, FileTable.Mode.REVIEW) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get(), downloadCommands);
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, InvalidChangeOperationException, IOException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(resource.getChange());
    if (!edit.isPresent()) {
        edit = createEdit(resource.getChange());
    }
    if (input != null && !Strings.isNullOrEmpty(input.path) && input.restore != null && input.restore) {
        editModifier.restoreFile(edit.get(), input.path);
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource resource, Post.Input input) throws AuthException, InvalidChangeOperationException, IOException, ResourceConflictException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(resource.getChange());
    if (!edit.isPresent()) {
        edit = createEdit(resource.getChange());
    }
    if (input != null && !Strings.isNullOrEmpty(input.restorePath)) {
        editModifier.restoreFile(edit.get(), input.restorePath);
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    if (input.content == null) {
        throw new ResourceConflictException("no input provided");
    }
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
public static RevisionInfo fromEdit(EditInfo edit) {
    RevisionInfo revisionInfo = (RevisionInfo) createObject();
    revisionInfo.takeFromEdit(edit);
    return revisionInfo;
}
#method_after
public static RevisionInfo fromEdit(EditInfo edit) {
    RevisionInfo revisionInfo = createObject().cast();
    revisionInfo.takeFromEdit(edit);
    return revisionInfo;
}
#end_block

#method_before
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    final int parent_edit_number = findEditParent(list);
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            int a_number = a._number();
            int b_number = b._number();
            if (a_number == 0) {
                a_number = parent_edit_number;
            }
            if (b_number == 0) {
                b_number = parent_edit_number;
            }
            return a_number - b_number;
        }
    });
}
#method_after
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    final int editParent = findEditParent(list);
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return num(a) - num(b);
        }

        private int num(RevisionInfo r) {
            return !r.is_edit() ? 2 * (r._number() - 1) + 1 : 2 * editParent;
        }
    });
}
#end_block

#method_before
private Map<String, FetchInfo> fillFetchMap(ChangeEdit edit) {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        // No fluff, just stuff
        if (!scheme.isAuthSupported()) {
            continue;
        }
        String projectName = edit.getChange().getProject().get();
        String url = scheme.getUrl(projectName);
        String refName = edit.getRefName();
        FetchInfo fetchInfo = new FetchInfo(url, refName);
        r.put(schemeName, fetchInfo);
        for (DynamicMap.Entry<DownloadCommand> e2 : downloadCommands) {
            String commandName = e2.getExportName();
            DownloadCommand command = e2.getProvider().get();
            String c = command.getCommand(scheme, projectName, refName);
            if (c != null) {
                addCommand(fetchInfo, commandName, c);
            }
        }
    }
    return r;
}
#method_after
private Map<String, FetchInfo> fillFetchMap(ChangeEdit edit) {
    Map<String, FetchInfo> r = Maps.newLinkedHashMap();
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        String schemeName = e.getExportName();
        DownloadScheme scheme = e.getProvider().get();
        if (!scheme.isEnabled() || (scheme.isAuthRequired() && !userProvider.get().isIdentifiedUser())) {
            continue;
        }
        // No fluff, just stuff
        if (!scheme.isAuthSupported()) {
            continue;
        }
        String projectName = edit.getChange().getProject().get();
        String refName = edit.getRefName();
        FetchInfo fetchInfo = new FetchInfo(scheme.getUrl(projectName), refName);
        r.put(schemeName, fetchInfo);
        ChangeJson.populateFetchMap(scheme, downloadCommands, projectName, refName, fetchInfo);
    }
    return r;
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw error("abandon and rebase actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw error("json and rebase actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (submitChange) {
            throw error("rebase and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("rebase and delete actions are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
        if (rebaseChange) {
            throw error("abandon and rebase actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
        if (rebaseChange) {
            throw error("json and rebase actions are mutually exclusive");
        }
    }
    if (rebaseChange) {
        if (deleteDraftPatchSet) {
            throw error("rebase and delete actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("rebase and submit actions are mutually exclusive");
        }
    }
    if (deleteDraftPatchSet && submitChange) {
        throw error("delete and submit actions are mutually exclusive");
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.notify = notify;
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void reviewPatchSet(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    if (notify == null) {
        notify = NotifyHandling.ALL;
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.notify = notify;
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            changeApi(patchSet).abandon(input);
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            changeApi(patchSet).restore(input);
            applyReview(patchSet, review);
        } else {
            applyReview(patchSet, review);
        }
        if (rebaseChange) {
            revisionApi(patchSet).rebase();
        }
        if (submitChange) {
            revisionApi(patchSet).submit();
        }
        if (publishPatchSet) {
            revisionApi(patchSet).publish();
        } else if (deleteDraftPatchSet) {
            revisionApi(patchSet).delete();
        }
    } catch (IllegalStateException | RestApiException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                if (GerritTopMenu.PROJECTS.menuName.equals(name)) {
                    for (TopMenuItem item : Natives.asList(menu.getItems())) {
                        String url = item.getUrl();
                        if (url.startsWith("http://") || url.startsWith("https://")) {
                            addExtensionLink(bar, item);
                        } else {
                            addProjectLink(bar, item.getName(), url);
                        }
                    }
                } else {
                    for (TopMenuItem item : Natives.asList(menu.getItems())) {
                        addExtensionLink(bar, item);
                    }
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                if (GerritTopMenu.PROJECTS.menuName.equals(name)) {
                    for (TopMenuItem item : Natives.asList(menu.getItems())) {
                        addProjectLink(bar, item);
                    }
                } else {
                    for (TopMenuItem item : Natives.asList(menu.getItems())) {
                        addExtensionLink(bar, item);
                    }
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
private static LinkMenuItem addProjectLink(final LinkMenuBar m, final String text, final String panel) {
    LinkMenuItem i = new LinkMenuItem(text, "") {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            Screen screen = event.getScreen();
            Project.NameKey projectKey;
            if (screen instanceof ProjectScreen) {
                projectKey = ((ProjectScreen) screen).getProjectKey();
            } else {
                projectKey = ProjectScreen.getSavedKey();
            }
            if (projectKey != null) {
                setVisible(true);
                if (panel.startsWith("/x/")) {
                    setTargetHistoryToken(panel.replace("${projectName}", projectKey.get()));
                } else {
                    setTargetHistoryToken(Dispatcher.toProjectAdmin(projectKey, panel));
                }
            } else {
                setVisible(false);
            }
            super.onScreenLoad(event);
        }
    };
    m.addItem(i);
    return i;
}
#method_after
private static LinkMenuItem addProjectLink(LinkMenuBar m, TopMenuItem item) {
    LinkMenuItem i = new ProjectLinkMenuItem(item.getName(), item.getUrl()) {

        @Override
        protected void onScreenLoad(Project.NameKey project) {
            String p = panel.replace("${projectName}", project.get());
            if (panel.startsWith("/x/")) {
                setTargetHistoryToken(p);
            } else if (isAbsolute(panel)) {
                getElement().setPropertyString("href", p);
            } else {
                getElement().setPropertyString("href", selfRedirect(p));
            }
        }

        @Override
        public void go() {
            String href = getElement().getPropertyString("href");
            if (href.startsWith("#")) {
                super.go();
            } else {
                Window.open(href, getElement().getPropertyString("target"), "");
            }
        }
    };
    if (item.getTarget() != null && !item.getTarget().isEmpty()) {
        i.getElement().setAttribute("target", item.getTarget());
    }
    if (item.getId() != null) {
        i.getElement().setAttribute("id", item.getId());
    }
    m.addItem(i);
    return i;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(String project, String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getPatchSetLinks(String project, String commit) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
public Iterable<Link> getProjectLinks(String project) {
    List<Link> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getImageUrl(), webLink.getProjectUrl(project)));
    }
    return links;
}
#method_after
public Iterable<WebLinkInfo> getProjectLinks(String project) {
    List<WebLinkInfo> links = Lists.newArrayList();
    for (ProjectWebLink webLink : projectLinks) {
        links.add(new WebLinkInfo(webLink.getLinkName(), webLink.getImageUrl(), webLink.getProjectUrl(project)));
    }
    return links;
}
#end_block

#method_before
private void addWebLink(String href, String name, String imageUrl) {
    Anchor a = new Anchor();
    a.setHref(href);
    if (imageUrl != null && !imageUrl.isEmpty()) {
        Image img = new Image();
        img.setAltText(parenthesize(name));
        img.setUrl(imageUrl);
        img.setTitle(name);
        a.getElement().appendChild(img.getElement());
    } else {
        a.setText(parenthesize(name));
    }
    webLinkPanel.add(a);
}
#method_after
private void addWebLink(String href, String name, String imageUrl) {
    Anchor a = new Anchor();
    a.setHref(href);
    if (imageUrl != null && !imageUrl.isEmpty()) {
        Image img = new Image();
        img.setAltText(name);
        img.setUrl(imageUrl);
        img.setTitle(name);
        a.getElement().appendChild(img.getElement());
    } else {
        a.setText(name);
    }
    webLinkPanel.add(a);
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email()));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.user.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new GerritCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                RevisionInfo revisionInfo = revisions.get(i + offset);
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisionInfo._number(), revisionInfo.edit())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    RevisionInfo revisionInfo = info.revision(revision);
    String currentlyViewedPatchSet = revisionInfo.id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision) {
    String currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision()).id();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1).id();
    }
    String currentlyViewedPatchSet = info.revision(revision).id();
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectQuery.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            Gerrit.display(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
        }
    }, ClickEvent.getType());
    projectLink.setText(info.project());
    projectLink.setTargetHistoryToken(PageLinks.toProject(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), info.topic())));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    if (rev.is_edit()) {
        NativeMap<JsArray<CommentInfo>> emptyComment = NativeMap.create();
        files.setRevisions(b != null ? new PatchSet.Id(changeId, b._number()) : null, new PatchSet.Id(changeId, rev._number()));
        files.setValue(info.edit().files(), myLastReply(info), emptyComment, emptyComment);
    } else {
        loadDiff(b, rev, myLastReply(info), group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadDrafts(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                r.add(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    } else {
        r.add(NativeMap.<JsArray<CommentInfo>>create());
    }
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.revision(changeId.get(), rev.name()).view("commit").get(group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(r.id())) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#method_after
private RevisionInfo resolveRevisionOrPatchSetId(ChangeInfo info, String revOrId, String defaultValue) {
    if (revOrId == null) {
        revOrId = defaultValue;
    } else if (!info.revisions().containsKey(revOrId)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revOrId.equals(String.valueOf(r._number()))) {
                revOrId = r.name();
                break;
            }
        }
    }
    return revOrId != null ? info.revision(revOrId) : null;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    RevisionInfo revisionInfo = info.revision(revision);
    if (revisionInfo.edit()) {
        statusText.setInnerText(Util.C.revisionEdit());
    } else {
        if (!current && info.status() == Change.Status.NEW) {
            statusText.setInnerText(Util.C.notCurrent());
        } else {
            statusText.setInnerText(Util.toLongString(info.status()));
        }
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    quickApprove.set(info, revision, replyAction);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    } else {
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), canSubmit);
    } else {
        quickApprove.setVisible(false);
        setVisible(strategy, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        SubmitType type = Project.SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(r.id())) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r.id() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.user.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        CallbackGroup group = new CallbackGroup();
        if (Gerrit.isSignedIn()) {
            // TODO(davido): It shouldn't be necessary to make this call.
            // PatchSetsBox is constructed via PatchSetsAction which is
            // only initialized by CS2 after loading the EditInfo in that path.
            ChangeApi.edit(changeId.get(), group.add(new GerritCallback<EditInfo>() {

                @Override
                public void onSuccess(EditInfo result) {
                    edit = result;
                }
            }));
        }
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(group.addFinal(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                if (edit != null) {
                    edit.set_name(edit.commit().commit());
                    result.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
                }
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r.id());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id());
    if (r.draft()) {
        sb.append(Resources.C.draft()).append(' ');
    }
    if (r.has_draft_comments()) {
        sb.openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan().append(' ');
    }
    sb.append(r._number());
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : "";
    String cn = c.committer() != null ? c.committer().name() : "";
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, r.id());
}
#method_after
private String url(RevisionInfo r) {
    return PageLinks.toChange(changeId, String.valueOf(r._number()));
}
#end_block

#method_before
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, IndexRewriteImpl.DEFAULT_MAX_LIMIT);
}
#method_after
private IndexedChangeQuery query(Predicate<ChangeData> p) throws QueryParseException {
    return query(p, DEFAULT_MAX_QUERY_LIMIT);
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in, int start) throws QueryParseException {
    ChangeIndex index = indexes.getSearchIndex();
    in = basicRewrites.rewrite(in);
    int limit = Objects.firstNonNull(ChangeQueryBuilder.getLimit(in), DEFAULT_MAX_QUERY_LIMIT);
    // Increase the limit rather than skipping, since we don't know how many
    // skipped results would have been filtered out by the enclosing AndSource.
    limit += start;
    limit = Math.max(limit, 1);
    Predicate<ChangeData> out = rewriteImpl(in, index, limit);
    if (in == out || out instanceof IndexPredicate) {
        return new IndexedChangeQuery(index, out, limit);
    } else if (out == null) /* cannot rewrite */
    {
        return in;
    } else {
        return out;
    }
}
#end_block

#method_before
private void checkComments(Map<String, List<Comment>> in) throws BadRequestException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c == null) {
                listItr.remove();
            } else {
                if (c.line < 0) {
                    throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
                }
                c.message = Strings.emptyToNull(c.message).trim();
                if (c.message.isEmpty()) {
                    listItr.remove();
                }
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(Map<String, List<Comment>> in) throws BadRequestException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c == null) {
                listItr.remove();
                continue;
            }
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
private boolean insertComments(RevisionResource rsrc, Map<String, List<Comment>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<Comment>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (Comment c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
            }
            ups.add(e);
        }
    }
    switch(Objects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                ups.add(e);
            }
            break;
    }
    db.get().patchComments().delete(del);
    db.get().patchComments().upsert(ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean insertComments(RevisionResource rsrc, Map<String, List<Comment>> in, DraftHandling draftsHandling) throws OrmException {
    if (in == null) {
        in = Collections.emptyMap();
    }
    Map<String, PatchLineComment> drafts = Collections.emptyMap();
    if (!in.isEmpty() || draftsHandling != DraftHandling.KEEP) {
        drafts = scanDraftComments(rsrc);
    }
    List<PatchLineComment> del = Lists.newArrayList();
    List<PatchLineComment> ups = Lists.newArrayList();
    for (Map.Entry<String, List<Comment>> ent : in.entrySet()) {
        String path = ent.getKey();
        for (Comment c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            PatchLineComment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), path), ChangeUtil.messageUUID(db.get())), c.line, rsrc.getAccountId(), parent, timestamp);
            } else if (parent != null) {
                e.setParentUuid(parent);
            }
            e.setStatus(PatchLineComment.Status.PUBLISHED);
            e.setWrittenOn(timestamp);
            e.setSide(c.side == Side.PARENT ? (short) 0 : (short) 1);
            e.setMessage(c.message);
            if (c.range != null) {
                e.setRange(new CommentRange(c.range.startLine, c.range.startCharacter, c.range.endLine, c.range.endCharacter));
                e.setLine(c.range.endLine);
            }
            ups.add(e);
        }
    }
    switch(Objects.firstNonNull(draftsHandling, DraftHandling.DELETE)) {
        case KEEP:
        default:
            break;
        case DELETE:
            del.addAll(drafts.values());
            break;
        case PUBLISH:
            for (PatchLineComment e : drafts.values()) {
                e.setStatus(PatchLineComment.Status.PUBLISHED);
                e.setWrittenOn(timestamp);
                ups.add(e);
            }
            break;
    }
    db.get().patchComments().delete(del);
    db.get().patchComments().upsert(ups);
    comments.addAll(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    NormalizeCharMap normMap = builder.build();
    return new MappingCharFilter(normMap, reader);
}
#method_after
@Override
protected Reader wrapReader(String fieldName, Reader reader) {
    NormalizeCharMap.Builder builder = new NormalizeCharMap.Builder();
    for (Map.Entry<String, String> e : customMappings.entrySet()) {
        builder.add(e.getKey(), e.getValue());
    }
    return new MappingCharFilter(builder.build(), reader);
}
#end_block

#method_before
private void scanGuiceModules(Set<Class<?>> classes) throws IOException {
    try {
        Class<?> sysModuleBaseClass = Module.class;
        Class<?> httpModuleBaseClass = Class.forName("com.google.inject.servlet.ServletModule");
        Class<?> sshModuleBaseClass = Class.forName("com.google.gerrit.sshd.CommandModule");
        sshModuleClass = null;
        httpModuleClass = null;
        sysModuleClass = null;
        for (Class<?> clazz : classes) {
            if (clazz.isLocalClass())
                continue;
            if (sshModuleBaseClass.isAssignableFrom(clazz)) {
                sshModuleClass = getUniqueGuiceModule(sshModuleBaseClass, sshModuleClass, clazz);
            } else if (httpModuleBaseClass.isAssignableFrom(clazz)) {
                httpModuleClass = getUniqueGuiceModule(httpModuleBaseClass, httpModuleClass, clazz);
            } else if (sysModuleBaseClass.isAssignableFrom(clazz)) {
                sysModuleClass = getUniqueGuiceModule(sysModuleBaseClass, sysModuleClass, clazz);
            }
        }
    } catch (ClassNotFoundException e) {
        throw new IOException("Cannot find base Gerrit classes for Guice Plugin Modules", e);
    }
}
#method_after
private void scanGuiceModules(Set<Class<?>> classes) throws IOException {
    try {
        Class<?> sysModuleBaseClass = Module.class;
        Class<?> httpModuleBaseClass = Class.forName("com.google.inject.servlet.ServletModule");
        Class<?> sshModuleBaseClass = Class.forName("com.google.gerrit.sshd.CommandModule");
        sshModuleClass = null;
        httpModuleClass = null;
        sysModuleClass = null;
        for (Class<?> clazz : classes) {
            if (clazz.isLocalClass()) {
                continue;
            }
            if (sshModuleBaseClass.isAssignableFrom(clazz)) {
                sshModuleClass = getUniqueGuiceModule(sshModuleBaseClass, sshModuleClass, clazz);
            } else if (httpModuleBaseClass.isAssignableFrom(clazz)) {
                httpModuleClass = getUniqueGuiceModule(httpModuleBaseClass, httpModuleClass, clazz);
            } else if (sysModuleBaseClass.isAssignableFrom(clazz)) {
                sysModuleClass = getUniqueGuiceModule(sysModuleBaseClass, sysModuleClass, clazz);
            }
        }
    } catch (ClassNotFoundException e) {
        throw new IOException("Cannot find base Gerrit classes for Guice Plugin Modules", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxNumberLimit = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxNumberLimit != 0 && pending.size() > maxNumberLimit) {
                reject(magicBranch.cmd, "The number of pushed changes in a batch exceeds the max limit " + maxNumberLimit);
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.maxBatchChanges;
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>(), currentUser.getAccount());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PutReview.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
private void validate() throws UnloggedFailure {
    if (active && inactive) {
        throw new UnloggedFailure(1, "--active and --inactive options are mutually exclusive.");
    }
    if (clearHttpPassword && !Strings.isNullOrEmpty(httpPassword)) {
        throw new UnloggedFailure(1, "--http-password and --clear-http-password options are mutually " + "exclusive.");
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw new UnloggedFailure(1, "Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
}
#method_after
private void validate() throws UnloggedFailure {
    if (active && inactive) {
        throw new UnloggedFailure(1, "--active and --inactive options are mutually exclusive.");
    }
    if (clearHttpPassword && !Strings.isNullOrEmpty(httpPassword)) {
        throw new UnloggedFailure(1, "--http-password and --clear-http-password options are mutually " + "exclusive.");
    }
    if (addSshKeys.contains("-") && deleteSshKeys.contains("-")) {
        throw new UnloggedFailure(1, "Only one option may use the stdin");
    }
    if (deleteSshKeys.contains("ALL")) {
        deleteSshKeys = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains("ALL")) {
        deleteEmails = Collections.singletonList("ALL");
    }
    if (deleteEmails.contains(preferredEmail)) {
        throw new UnloggedFailure(1, "--preferred-email and --delete-email options are mutually " + "exclusive for the same email address.");
    }
}
#end_block

#method_before
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    user = genericUserFactory.create(id);
    rsrc = new AccountResource(user);
    try {
        for (String email : addEmails) {
            addEmail(email);
        }
        for (String email : deleteEmails) {
            deleteEmail(email);
        }
        if (preferred != null && !preferred.isEmpty()) {
            putPreferred(preferred);
        }
        if (fullName != null) {
            PutName.Input in = new PutName.Input();
            in.name = fullName;
            putName.apply(rsrc, in);
        }
        if (httpPassword != null || clearHttpPassword) {
            PutHttpPassword.Input in = new PutHttpPassword.Input();
            in.httpPassword = httpPassword;
            putHttpPassword.apply(rsrc, in);
        }
        if (active) {
            putActive.apply(rsrc, null);
        } else if (inactive) {
            try {
                deleteActive.apply(rsrc, null);
            } catch (ResourceNotFoundException e) {
            // user is already inactive
            }
        }
        addSshKeys = readSshKey(addSshKeys);
        if (!addSshKeys.isEmpty()) {
            addSshKeys(addSshKeys);
        }
        deleteSshKeys = readSshKey(deleteSshKeys);
        if (!deleteSshKeys.isEmpty()) {
            deleteSshKeys(deleteSshKeys);
        }
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#method_after
private void setAccount() throws OrmException, IOException, UnloggedFailure {
    user = genericUserFactory.create(id);
    rsrc = new AccountResource(user);
    try {
        for (String email : addEmails) {
            addEmail(email);
        }
        for (String email : deleteEmails) {
            deleteEmail(email);
        }
        if (preferredEmail != null) {
            putPreferred(preferredEmail);
        }
        if (fullName != null) {
            PutName.Input in = new PutName.Input();
            in.name = fullName;
            putName.apply(rsrc, in);
        }
        if (httpPassword != null || clearHttpPassword) {
            PutHttpPassword.Input in = new PutHttpPassword.Input();
            in.httpPassword = httpPassword;
            putHttpPassword.apply(rsrc, in);
        }
        if (active) {
            putActive.apply(rsrc, null);
        } else if (inactive) {
            try {
                deleteActive.apply(rsrc, null);
            } catch (ResourceNotFoundException e) {
            // user is already inactive
            }
        }
        addSshKeys = readSshKey(addSshKeys);
        if (!addSshKeys.isEmpty()) {
            addSshKeys(addSshKeys);
        }
        deleteSshKeys = readSshKey(deleteSshKeys);
        if (!deleteSshKeys.isEmpty()) {
            deleteSshKeys(deleteSshKeys);
        }
    } catch (RestApiException e) {
        throw die(e.getMessage());
    }
}
#end_block

#method_before
private void deleteEmail(String email) throws UnloggedFailure, RestApiException, OrmException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        ;
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#method_after
private void deleteEmail(String email) throws UnloggedFailure, RestApiException, OrmException {
    if (email.equals("ALL")) {
        List<EmailInfo> emails = getEmails.apply(rsrc);
        for (EmailInfo e : emails) {
            deleteEmail.apply(new AccountResource.Email(user, e.email), new DeleteEmail.Input());
        }
    } else {
        deleteEmail.apply(new AccountResource.Email(user, email), new DeleteEmail.Input());
    }
}
#end_block

#method_before
private void putPreferred(String email) throws RestApiException, OrmException {
    List<EmailInfo> emails = getEmails.apply(rsrc);
    for (EmailInfo e : emails) {
        if (e.email.equals(email)) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
        }
    }
}
#method_after
private void putPreferred(String email) throws RestApiException, OrmException {
    for (EmailInfo e : getEmails.apply(rsrc)) {
        if (e.email.equals(email)) {
            putPreferred.apply(new AccountResource.Email(user, email), null);
            return;
        }
    }
    stderr.println("preferred email not found: " + email);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine(impl);
    final PrintWriter stdout = toPrintWriter(out);
    try {
        impl.display(stdout);
    } finally {
        stdout.flush();
    }
}
#method_after
@Override
public void run() throws Exception {
    impl.display(stdout);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine(impl);
    impl.display(stdout);
}
#method_after
@Override
public void run() throws Exception {
    impl.display(stdout);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine(impl);
    if (!impl.getFormat().isJson()) {
        List<String> showBranch = impl.getShowBranch();
        if (impl.isShowTree() && (showBranch != null) && !showBranch.isEmpty()) {
            throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
        }
        if (impl.isShowTree() && impl.isShowDescription()) {
            throw new UnloggedFailure(1, "fatal: --tree and --description options are not compatible.");
        }
    }
    impl.display(out);
}
#method_after
@Override
public void run() throws Exception {
    if (!impl.getFormat().isJson()) {
        List<String> showBranch = impl.getShowBranch();
        if (impl.isShowTree() && (showBranch != null) && !showBranch.isEmpty()) {
            throw new UnloggedFailure(1, "fatal: --tree and --show-branch options are not compatible.");
        }
        if (impl.isShowTree() && impl.isShowDescription()) {
            throw new UnloggedFailure(1, "fatal: --tree and --description options are not compatible.");
        }
    }
    impl.display(out);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine(impl);
    if (impl.getUser() != null && !impl.getProjects().isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --user and --project options are not compatible.");
    }
    final PrintWriter stdout = toPrintWriter(out);
    try {
        impl.display(stdout);
    } finally {
        stdout.flush();
    }
}
#method_after
@Override
public void run() throws Exception {
    if (impl.getUser() != null && !impl.getProjects().isEmpty()) {
        throw new UnloggedFailure(1, "fatal: --user and --project options are not compatible.");
    }
    impl.display(stdout);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine();
    verifyCommandLine();
    runGC();
}
#method_after
@Override
public void run() throws Exception {
    verifyCommandLine();
    runGC();
}
#end_block

#method_before
@Override
public void run() throws Exception {
    parseCommandLine();
    validate();
    setAccount();
}
#method_after
@Override
public void run() throws Exception {
    validate();
    setAccount();
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource) throws UnsupportedEncodingException {
    format = OutputFormat.JSON;
    return display(null);
}
#method_after
@Override
public Object apply(TopLevelResource resource) {
    format = OutputFormat.JSON;
    return display(null);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    put(FILE_KIND, "content").to(PutContent.class);
    delete(FILE_KIND, "content").to(DeleteContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    Git git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
    String changeId = newChange(git, admin.getIdent());
    change = getChange(changeId);
    ps = getCurrentPatchSet(changeId);
    assertNotNull(ps);
    changeId = newChange2(git, admin.getIdent());
    change2 = getChange(changeId);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#method_after
@Before
public void setUp() throws Exception {
    db = reviewDbProvider.open();
    changeId = newChange(git, admin.getIdent());
    ps = getCurrentPatchSet(changeId);
    amendChange(git, admin.getIdent(), changeId);
    change = getChange(changeId);
    assertNotNull(ps);
    String changeId2 = newChange2(git, admin.getIdent());
    change2 = getChange(changeId2);
    assertNotNull(change2);
    ps2 = getCurrentPatchSet(changeId2);
    assertNotNull(ps2);
    session = new RestSession(server, admin);
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
    final long clockStepMs = MILLISECONDS.convert(1, SECONDS);
    final AtomicLong clockMs = new AtomicLong(new DateTime(2009, 9, 30, 17, 0, 0).getMillis());
    DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {

        @Override
        public long getMillis() {
            return clockMs.getAndAdd(clockStepMs);
        }
    });
}
#end_block

#method_before
@After
public void cleanup() {
    db.close();
}
#method_after
@After
public void cleanup() {
    DateTimeUtils.setCurrentMillisSystem();
    db.close();
}
#end_block

#method_before
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#method_after
@Test
public void publishEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW2));
    editUtil.publish(editUtil.byChange(change).get());
    assertFalse(editUtil.byChange(change).isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, EditInfo> result = toEditInfoMap(r);
    assertEquals(1, result.size());
    EditInfo info = Iterables.getOnlyElement(result.values());
    assertEquals(0, info._number);
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlGet());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    assertEquals(0, toEditInfoMap(r).size());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Input in = new Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(204, session.putRaw(urlPut(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlPut());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(new String(CONTENT_NEW2, UTF_8), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(PutContent.class);
    delete(CHANGE_EDIT_KIND).to(DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(GetEditFileContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ListChangeEdits.Factory.class);
            factory(CreateOrModifyChangeEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    child(CHANGE_KIND, "publish_edit").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "rebase_edit").to(RebaseChangeEdit.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteEdit.Factory.class);
        }
    });
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
@Override
public RestView<ChangeResource> list() {
    return detail.get();
}
#method_after
@Override
public RestView<ChangeResource> list() {
    return detail;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on to pof current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Test
public void publishEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, getCurrentPatchSet(changeId)));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void publishEditRest() throws Exception {
    PatchSet oldCurrentPatchSet = getCurrentPatchSet(changeId);
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, oldCurrentPatchSet));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.post(urlPublish());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
    PatchSet newCurrentPatchSet = getCurrentPatchSet(changeId);
    assertFalse(oldCurrentPatchSet.getId().equals(newCurrentPatchSet.getId()));
}
#end_block

#method_before
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(HttpStatus.SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#method_after
@Test
public void deleteEditRest() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(editUtil.byChange(change).get(), FILE_NAME, CONTENT_NEW));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    RestResponse r = session.delete(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    edit = editUtil.byChange(change);
    assertFalse(edit.isPresent());
}
#end_block

#method_before
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo();
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#method_after
@Test
public void retrieveEdit() throws Exception {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    edit = editUtil.byChange(change);
    EditInfo info = toEditInfo(false);
    assertEquals(edit.get().getRevision().get(), info.commit.commit);
    assertEquals(1, info.commit.parents.size());
    edit = editUtil.byChange(change);
    editUtil.delete(edit.get());
    r = session.get(urlEdit());
    assertEquals(SC_NO_CONTENT, r.getStatusCode());
}
#end_block

#method_before
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    RestResponse r = session.get(urlGetFiles());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    Map<String, FileInfo> result = toFileInfoMap(r);
    assertEquals(2, result.size());
    List<String> l = Lists.newArrayList(result.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#method_after
@Test
public void retrieveFilesInEdit() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW));
    EditInfo info = toEditInfo(true);
    assertEquals(2, info.files.size());
    List<String> l = Lists.newArrayList(info.files.keySet());
    assertEquals("/COMMIT_MSG", l.get(0));
    assertEquals("foo", l.get(1));
}
#end_block

#method_before
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Put.Input in = new Put.Input();
    in.restore = true;
    assertEquals(SC_NO_CONTENT, session.post(urlEditFile2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void restoreDeletedFileInPatchSetRest() throws Exception {
    Post.Input in = new Post.Input();
    in.restorePath = FILE_NAME;
    assertEquals(SC_NO_CONTENT, session.post(urlEdit2(), in).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change2);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void createEmptyEditRest() throws Exception {
    Put.Input in = new Put.Input();
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
    in.content = RestSession.newRawInput(CONTENT_NEW2);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW2, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#method_after
@Test
public void createEmptyEditRest() throws Exception {
    assertEquals(SC_NO_CONTENT, session.post(urlEdit()).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_OLD, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME)));
}
#end_block

#method_before
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#method_after
@Test
public void getFileContentRest() throws Exception {
    Put.Input in = new Put.Input();
    in.content = RestSession.newRawInput(CONTENT_NEW);
    assertEquals(SC_NO_CONTENT, session.putRaw(urlEditFile(), in.content).getStatusCode());
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME, CONTENT_NEW2));
    edit = editUtil.byChange(change);
    RestResponse r = session.get(urlEditFile());
    assertEquals(SC_OK, r.getStatusCode());
    String content = r.getEntityContent();
    assertEquals(StringUtils.newStringUtf8(CONTENT_NEW2), StringUtils.newStringUtf8(Base64.decodeBase64(content)));
}
#end_block

#method_before
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#method_after
@Test
public void addNewFile() throws Exception {
    assertEquals(RefUpdate.Result.NEW, modifier.createEdit(change, ps));
    Optional<ChangeEdit> edit = editUtil.byChange(change);
    assertEquals(RefUpdate.Result.FORCED, modifier.modifyFile(edit.get(), FILE_NAME2, CONTENT_NEW));
    edit = editUtil.byChange(change);
    assertArrayEquals(CONTENT_NEW, toBytes(fileUtil.getContent(edit.get().getChange().getProject(), edit.get().getRevision().get(), FILE_NAME2)));
}
#end_block

#method_before
private EditInfo toEditInfo() throws IOException {
    RestResponse r = session.get(urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#method_after
private EditInfo toEditInfo(boolean files) throws IOException {
    RestResponse r = session.get(files ? urlGetFiles() : urlEdit());
    assertEquals(SC_OK, r.getStatusCode());
    return newGson().fromJson(r.getReader(), EditInfo.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Create post(ChangeResource parent) throws RestApiException {
    return createFactory.create(parent.getChange(), null);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Post post(ChangeResource parent) throws RestApiException {
    return post;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wipped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new ResourceConflictException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, DeleteEdit.Input in) throws IOException, AuthException, ResourceConflictException, OrmException, InvalidChangeOperationException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent() && path == null) {
        // Edit is wiped out
        editUtil.delete(edit.get());
    } else if (!edit.isPresent() && path != null) {
        // Edit is created on top of current patch set by deleting path.
        // Even if the latest patch set changed since the user triggered
        // the operation, deleting the whole file is probably still what
        // they intended.
        editModifier.createEdit(rsrc.getChange(), db.get().patchSets().get(rsrc.getChange().currentPatchSetId()));
        edit = editUtil.byChange(rsrc.getChange());
        editModifier.deleteFile(edit.get(), path);
    } else {
        // Bad request
        throw new BadRequestException("change edit doesn't exist and no path was provided");
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc) throws AuthException, IOException, NoSuchChangeException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (edit.isPresent()) {
        if (list) {
            PatchSet basePatchSet = null;
            if (base != null) {
                RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
                basePatchSet = baseResource.getPatchSet();
            }
            try {
                return Response.ok(fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet));
            } catch (PatchListNotAvailableException e) {
                throw new ResourceNotFoundException(e.getMessage());
            }
        } else {
            return Response.ok(editJson.toEditInfo(edit.get()));
        }
    }
    return Response.none();
}
#method_after
@Override
public Response<EditInfo> apply(ChangeResource rsrc) throws AuthException, IOException, InvalidChangeOperationException, ResourceNotFoundException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        return Response.none();
    }
    EditInfo editInfo = editJson.toEditInfo(edit.get());
    if (list) {
        PatchSet basePatchSet = null;
        if (base != null) {
            RevisionResource baseResource = revisions.parse(rsrc, IdString.fromDecoded(base));
            basePatchSet = baseResource.getPatchSet();
        }
        try {
            editInfo.files = fileInfoJson.toFileInfoMap(rsrc.getChange(), edit.get().getRevision(), basePatchSet);
        } catch (PatchListNotAvailableException e) {
            throw new ResourceNotFoundException(e.getMessage());
        }
    }
    return Response.ok(editInfo);
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    String path = rsrc.getPath();
    byte[] content = null;
    if (input.content != null) {
        content = ByteStreams.toByteArray(input.content.getInputStream());
    }
    try {
        if (input.restore) {
            editModifier.restoreFile(rsrc.getChangeEdit(), path);
        } else {
            editModifier.modifyFile(rsrc.getChangeEdit(), path, content);
        }
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, Input input) throws AuthException, ResourceConflictException, IOException {
    try {
        editModifier.modifyFile(rsrc.getChangeEdit(), rsrc.getPath(), ByteStreams.toByteArray(input.content.getInputStream()));
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc, DeleteContent.Input input) throws AuthException, ResourceConflictException {
    try {
        editModifier.deleteFile(rsrc.getChangeEdit(), rsrc.getPath());
    } catch (InvalidChangeOperationException | IOException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public BinaryResult apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException, InvalidChangeOperationException {
    try {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath());
    } catch (ResourceNotFoundException rnfe) {
        return fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getBasePatchSet().getRevision().get(), rsrc.getPath());
    }
}
#method_after
@Override
public Response<?> apply(ChangeEditResource rsrc) throws ResourceNotFoundException, IOException {
    try {
        return Response.ok(fileContentUtil.getContent(rsrc.getChangeEdit().getChange().getProject(), rsrc.getChangeEdit().getRevision().get(), rsrc.getPath()));
    } catch (ResourceNotFoundException rnfe) {
        return Response.none();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    put(FILE_KIND, "content").to(PutContent.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
        }
    });
}
#end_block

#method_before
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (treeId != null) {
            if (removedAllComments.get()) {
                batch.removeRef(getRefName());
            } else {
                builder.setTreeId(treeId);
                batch.write(builder);
            }
        }
    }
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        AtomicBoolean removedAllComments = new AtomicBoolean();
        ObjectId treeId = storeCommentsInNotes(removedAllComments);
        if (treeId != null) {
            if (removedAllComments.get()) {
                batch.removeRef(getRefName());
            } else {
                builder.setTreeId(treeId);
                batch.write(builder);
            }
        }
    }
}
#end_block

#method_before
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(builder);
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.write()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(builder);
}
#end_block

#method_before
/*@SuppressWarnings("unchecked")
  @Override
  public void insert(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
      if (cd.change().getStatus().isOpen()) {
        Futures.allAsList(
            closedIndex.delete(id),
            openIndex.insert(doc)).get();
      } else {
        Futures.allAsList(
            openIndex.delete(id),
            closedIndex.insert(doc)).get();
      }
    } catch (OrmException | ExecutionException | InterruptedException e) {
      throw new IOException(e);
    }
  }*/
@SuppressWarnings("unchecked")
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
/*@Override
  public void insert(ChangeData cd) {
    throw new UnsupportedOperationException();
  }*/
@Override
public void replace(ChangeData cd) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
public void replace(ChangeData cd) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
/*@Override
  public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
      if (cd.change().getStatus().isOpen()) {
        closedIndex.deleteById(id);
        openIndex.add(doc);
      } else {
        openIndex.deleteById(id);
        closedIndex.add(doc);
      }
    } catch (OrmException | SolrServerException e) {
      throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
  }*/
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (OrmException | SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (OrmException | SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    util = new Util();
    project = new ProjectConfig(new Project.NameKey("project"));
    InMemoryRepository inMemoryRepo = util.add(project);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#method_after
@Before
public void setUp() throws Exception {
    Injector injector = Guice.createInjector(new InMemoryModule());
    injector.injectMembers(this);
    lifecycle = new LifecycleManager();
    lifecycle.add(injector);
    lifecycle.start();
    db = schemaFactory.open();
    schemaCreator.create(db);
    Account.Id userId = accountManager.authenticate(AuthRequest.forUser("user")).getAccountId();
    user = userFactory.create(userId);
    Project.NameKey name = new Project.NameKey("project");
    InMemoryRepository inMemoryRepo = repoManager.createRepository(name);
    project = new ProjectConfig(name);
    project.load(inMemoryRepo);
    repo = new TestRepository<InMemoryRepository>(inMemoryRepo);
}
#end_block

#method_before
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id)));
}
#method_after
@Test
public void canReadCommitWhenAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    ObjectId id = repo.branch("master").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id)));
}
#end_block

#method_before
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id2)));
}
#method_after
@Test
public void canReadCommitIfRefVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    ObjectId id1 = repo.branch("branch1").commit().create();
    ObjectId id2 = repo.branch("branch2").commit().create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id2)));
}
#end_block

#method_before
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    deny(project, READ, DEVS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(parent2)));
}
#method_after
@Test
public void canReadCommitIfReachableFromVisibleRef() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    deny(project, READ, REGISTERED_USERS, "refs/heads/branch2");
    RevCommit parent1 = repo.commit().create();
    repo.branch("branch1").commit().parent(parent1).create();
    RevCommit parent2 = repo.commit().create();
    repo.branch("branch2").commit().parent(parent2).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(parent2)));
}
#end_block

#method_before
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, DEVS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void cannotReadAfterRollbackWithRestrictedRead() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/heads/branch1");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, DEVS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = util.user(project, DEVS);
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(rw, rw.parseCommit(id1)));
}
#method_after
@Test
public void canReadAfterRollbackWithAllRefsVisible() throws Exception {
    allow(project, READ, REGISTERED_USERS, "refs/*");
    RevCommit parent1 = repo.commit().create();
    ObjectId id1 = repo.branch("branch1").commit().parent(parent1).create();
    ProjectControl pc = newProjectControl();
    RevWalk rw = repo.getRevWalk();
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
    repo.branch("branch1").update(parent1);
    assertTrue(pc.canReadCommit(db, rw, rw.parseCommit(parent1)));
    assertFalse(pc.canReadCommit(db, rw, rw.parseCommit(id1)));
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible() {
    return allRefsAreVisible(Collections.<String>emptySet());
}
#end_block

#method_before
public boolean allRefsAreVisible() {
    return allRefsAreVisibleExcept(Collections.<String>emptySet());
}
#method_after
public boolean allRefsAreVisible(Set<String> ignore) {
    return user instanceof InternalUser || canPerformOnAllRefs(Permission.READ, ignore);
}
#end_block

#method_before
private boolean canPerformOnAllRefs(String permission, Set<String> except) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (except.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#method_after
private boolean canPerformOnAllRefs(String permission, Set<String> ignore) {
    boolean canPerform = false;
    Set<String> patterns = allRefPatterns(permission);
    if (patterns.contains(AccessSection.ALL)) {
        // 
        for (final String pattern : patterns) {
            if (controlForRef(pattern).canPerform(permission)) {
                canPerform = true;
            } else if (ignore.contains(pattern)) {
                continue;
            } else {
                return false;
            }
        }
    }
    return canPerform;
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            List<Ref> allRefs = Lists.newLinkedList();
            allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values());
            allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values());
            List<Ref> canReadRefs = Lists.newLinkedList();
            for (Ref r : allRefs) {
                if (controlForRef(r.getName()).canPerform(Permission.READ)) {
                    canReadRefs.add(r);
                }
            }
            if (!canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs)) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return false;
}
#method_after
public boolean canReadCommit(ReviewDb db, RevWalk rw, RevCommit commit) {
    try {
        Repository repo = repoManager.openRepository(getProject().getNameKey());
        try {
            VisibleRefFilter filter = new VisibleRefFilter(tagCache, changeCache, repo, this, db, true);
            Map<String, Ref> visibleRefs = filter.filter(repo.getAllRefs(), true);
            if (!visibleRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, visibleRefs.values())) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    int patchSetId = PatchSet.Id.fromRef(ref, ce);
    if (patchSetId >= 0 || ref.substring(ce).equals(RefNames.META_SUFFIX)) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#method_after
public static Id fromRef(String ref) {
    int cs = startIndex(ref);
    if (cs < 0) {
        return null;
    }
    int ce = nextNonDigit(ref, cs);
    if (ref.substring(ce).equals(RefNames.META_SUFFIX) || PatchSet.Id.fromRef(ref, ce) >= 0) {
        return new Change.Id(Integer.parseInt(ref.substring(cs, ce)));
    }
    return null;
}
#end_block

#method_before
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#method_after
static int startIndex(String ref) {
    if (ref == null || !ref.startsWith(REFS_CHANGES)) {
        return -1;
    }
    // Last 2 digits.
    int ls = REFS_CHANGES.length();
    int le = nextNonDigit(ref, ls);
    if (le - ls != 2 || le >= ref.length() || ref.charAt(le) != '/') {
        return -1;
    }
    // Change ID.
    int cs = le + 1;
    if (cs >= ref.length() || ref.charAt(cs) == '0') {
        return -1;
    }
    int ce = nextNonDigit(ref, cs);
    if (ce >= ref.length() || ref.charAt(ce) != '/') {
        return -1;
    }
    switch(ce - cs) {
        case 0:
            return -1;
        case 1:
            if (ref.charAt(ls) != '0' || ref.charAt(ls + 1) != ref.charAt(cs)) {
                return -1;
            }
            break;
        default:
            if (ref.charAt(ls) != ref.charAt(ce - 2) || ref.charAt(ls + 1) != ref.charAt(ce - 1)) {
                return -1;
            }
            break;
    }
    return cs;
}
#end_block

#method_before
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
}
#method_after
@Test
public void parsePatchSetRefNames() {
    assertRef(1, "refs/changes/01/1/1");
    assertRef(1234, "refs/changes/34/1234/56");
    // Invalid characters.
    assertNotRef("refs/changes/0x/1/1");
    assertNotRef("refs/changes/01/x/1");
    assertNotRef("refs/changes/01/1/x");
    // Truncations.
    assertNotRef("refs/changes/");
    assertNotRef("refs/changes/1");
    assertNotRef("refs/changes/01");
    assertNotRef("refs/changes/01/");
    assertNotRef("refs/changes/01/1/");
    assertNotRef("refs/changes/01/1/1/");
    assertNotRef("refs/changes/01//1/1");
    // Leading zeroes.
    assertNotRef("refs/changes/01/01/1");
    assertNotRef("refs/changes/01/1/01");
    // Mismatched last 2 digits.
    assertNotRef("refs/changes/35/1234/56");
    // Something other than patch set after change.
    assertNotRef("refs/changes/34/1234/0");
    assertNotRef("refs/changes/34/1234/foo");
    assertNotRef("refs/changes/34/1234|56");
    assertNotRef("refs/changes/34/1234foo");
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    boolean ok = true;
    for (final PatchSet patchSet : patchSets) {
        try {
            approveOne(patchSet);
        } catch (UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while approving " + patchSet.getId() + "\n");
            log.error("internal error while approving " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw new UnloggedFailure(1, "one or more approvals failed;" + " review output above");
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (abandonChange) {
        if (restoreChange) {
            throw error("abandon and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("abandon and submit actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("abandon and publish actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("abandon and delete actions are mutually exclusive");
        }
    }
    if (publishPatchSet) {
        if (restoreChange) {
            throw error("publish and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("publish and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("publish and delete actions are mutually exclusive");
        }
    }
    if (json) {
        if (restoreChange) {
            throw error("json and restore actions are mutually exclusive");
        }
        if (submitChange) {
            throw error("json and submit actions are mutually exclusive");
        }
        if (deleteDraftPatchSet) {
            throw error("json and delete actions are mutually exclusive");
        }
        if (publishPatchSet) {
            throw error("json and publish actions are mutually exclusive");
        }
        if (abandonChange) {
            throw error("json and abandon actions are mutually exclusive");
        }
        if (changeComment != null) {
            throw error("json and message are mutually exclusive");
        }
    }
    boolean ok = true;
    ReviewInput input = null;
    if (json) {
        input = reviewFromJson();
    }
    for (final PatchSet patchSet : patchSets) {
        try {
            if (input != null) {
                applyReview(patchSet, input);
            } else {
                reviewPatchSet(patchSet);
            }
        } catch (RestApiException | UnloggedFailure e) {
            ok = false;
            writeError("error: " + e.getMessage() + "\n");
        } catch (NoSuchChangeException e) {
            ok = false;
            writeError("no such change " + patchSet.getId().getParentKey().get());
        } catch (Exception e) {
            ok = false;
            writeError("fatal: internal server error while reviewing " + patchSet.getId() + "\n");
            log.error("internal error while reviewing " + patchSet.getId(), e);
        }
    }
    if (!ok) {
        throw error("one or more reviews failed; review output above");
    }
}
#end_block

#method_before
private void applyReview(PatchSet patchSet, final ReviewInput review) throws Exception {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#method_after
private void applyReview(PatchSet patchSet, final ReviewInput review) throws RestApiException {
    gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).review(review);
}
#end_block

#method_before
public void testBlockLabelRange_ParentBlocksChild() {
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testBlockLabelRange_ParentBlocksChild() {
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    grant(util.getParentConfig(), LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*").setBlock();
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -1", range.contains(-1));
    assertTrue("u can vote +1", range.contains(1));
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRange() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#method_after
public void testUnblockRange() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertTrue("u can vote -2", range.contains(-2));
    assertTrue("u can vote +2", range.contains(2));
}
#end_block

#method_before
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnMoreSpecificRef_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/master");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockRangeOnLargerScope_Fails() {
    grantLabel(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#method_after
public void testUnblockRangeOnLargerScope_Fails() {
    grant(local, LABEL + "Code-Review", -1, +1, ANONYMOUS, "refs/heads/master").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote +2", range.contains(-2));
}
#end_block

#method_before
public void testUnblockInLocalRange_Fails() {
    grantLabel(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grantLabel(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#method_after
public void testUnblockInLocalRange_Fails() {
    grant(util.getParentConfig(), LABEL + "Code-Review", -1, 1, ANONYMOUS, "refs/heads/*").setBlock();
    grant(local, LABEL + "Code-Review", -2, +2, DEVS, "refs/heads/*");
    ProjectControl u = util.user(local, DEVS);
    PermissionRange range = u.controlForRef("refs/heads/master").getRange(LABEL + "Code-Review");
    assertFalse("u can't vote -2", range.contains(-2));
    assertFalse("u can't vote 2", range.contains(2));
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    notes.load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes().load();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
private void audit(Context ctx, Object result, String cmd, Multimap<String, ?> params) {
    final long created = ctx == null ? TimeUtil.nowMs() : ctx.created;
    final SshSession session = ctx == null ? null : ctx.getSession();
    final String sid = session == null ? null : IdGenerator.format(session.getSessionId());
    final CurrentUser user = session == null ? null : session.getCurrentUser();
    auditService.dispatch(new SshAuditEvent(sid, user, cmd, created, params, result));
}
#method_after
private void audit(Context ctx, Object result, String cmd, Multimap<String, ?> params) {
    String sessionId;
    CurrentUser currentUser;
    long created;
    if (ctx == null) {
        sessionId = null;
        currentUser = null;
        created = TimeUtil.nowMs();
    } else {
        SshSession session = ctx.getSession();
        sessionId = IdGenerator.format(session.getSessionId());
        currentUser = session.getCurrentUser();
        created = ctx.created;
    }
    auditService.dispatch(new SshAuditEvent(sessionId, currentUser, cmd, created, params, result));
}
#end_block

#method_before
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    if (args.length > 1) {
        return commandName + "." + args[1];
    } else {
        return commandName;
    }
}
#method_after
private String extractWhat(DispatchCommand dcmd) {
    String commandName = dcmd.getCommandName();
    String[] args = dcmd.getArguments();
    if (args.length > 1) {
        return commandName + "." + args[1];
    }
    return commandName;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        log.debug("scheduling replication {}:{} => {}", project, ref, uri);
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            stateLog.warn(String.format("project %s is not visible", project), state);
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        log.debug("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    try {
        repLog.debug("scheduling replication {}:{} => {}", project, ref, uri);
        boolean visible = threadScoper.scope(new Callable<Boolean>() {

            @Override
            public Boolean call() throws NoSuchProjectException {
                return controlFor(project).isVisible();
            }
        }).call();
        if (!visible) {
            stateLog.warn(String.format("project %s is not visible", project), state);
            return;
        }
    } catch (NoSuchProjectException err) {
        stateLog.error(String.format("source project %s not available", project), err, state);
        return;
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.debug("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (remoteNameStyle.equals("basenameOnly")) {
                name = FilenameUtils.getBaseName(name);
            } else if (!remoteNameStyle.equals("slash")) {
                repLog.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name, isSingleProjectMatch());
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#method_after
private Iterable<Project.NameKey> scan() throws BadRequestException {
    if (matchPrefix != null) {
        return projectCache.byName(matchPrefix);
    } else if (matchSubstring != null) {
        return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

            public boolean apply(Project.NameKey in) {
                return in.get().toLowerCase(Locale.US).contains(matchSubstring.toLowerCase(Locale.US));
            }
        });
    } else if (matchRegex != null) {
        if (matchRegex.startsWith("^")) {
            matchRegex = matchRegex.substring(1);
            if (matchRegex.endsWith("$") && !matchRegex.endsWith("\\$")) {
                matchRegex = matchRegex.substring(0, matchRegex.length() - 1);
            }
        }
        if (matchRegex.equals(".*")) {
            return projectCache.all();
        }
        try {
            final RunAutomaton a = new RunAutomaton(new RegExp(matchRegex).toAutomaton());
            return Iterables.filter(projectCache.all(), new Predicate<Project.NameKey>() {

                public boolean apply(Project.NameKey in) {
                    return a.run(in.get());
                }
            });
        } catch (IllegalArgumentException e) {
            throw new BadRequestException(e.getMessage());
        }
    } else {
        return projectCache.all();
    }
}
#end_block

#method_before
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            ReviewerFilterSection found = findReviewerSection(sections, reviewDb, change);
            if (found == null || found.getReviewers().isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(found.getReviewers(), projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#method_after
@Override
public void onChangeEvent(ChangeEvent event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = new Project.NameKey(e.change.project);
    // TODO(davido): we have to cache per project configuration
    ReviewersConfig config = configFactory.create(projectName);
    List<ReviewerFilterSection> sections = config.getReviewerFilterSections();
    if (sections.isEmpty()) {
        return;
    }
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            Change.Id changeId = new Change.Id(Integer.parseInt(e.change.number));
            PatchSet.Id psId = new PatchSet.Id(changeId, Integer.parseInt(e.patchSet.number));
            PatchSet ps = reviewDb.patchSets().get(psId);
            if (ps == null) {
                log.warn("Patch set " + psId.get() + " not found.");
                return;
            }
            final Change change = reviewDb.changes().get(psId.getParentKey());
            if (change == null) {
                log.warn("Change " + changeId.get() + " not found.");
                return;
            }
            Set<String> reviewers = findReviewers(sections, reviewDb, change);
            if (reviewers.isEmpty()) {
                return;
            }
            final Runnable task = reviewersFactory.create(change, toAccounts(reviewers, projectName, e.uploader.email));
            workQueue.getDefaultQueue().submit(new Runnable() {

                public void run() {
                    RequestContext old = tl.setContext(new RequestContext() {

                        @Override
                        public CurrentUser getCurrentUser() {
                            return identifiedUserFactory.create(change.getOwner());
                        }

                        @Override
                        public Provider<ReviewDb> getReviewDbProvider() {
                            return new Provider<ReviewDb>() {

                                @Override
                                public ReviewDb get() {
                                    if (db == null) {
                                        try {
                                            db = schemaFactory.open();
                                        } catch (OrmException e) {
                                            throw new ProvisionException("Cannot open ReviewDb", e);
                                        }
                                    }
                                    return db;
                                }
                            };
                        }
                    });
                    try {
                        task.run();
                    } finally {
                        tl.setContext(old);
                        if (db != null) {
                            db.close();
                            db = null;
                        }
                    }
                }
            });
        } catch (OrmException | QueryParseException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<PatchLineComment>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<PatchLineComment>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        List<PatchLineComment> baseCommentsForThisPs = new ArrayList<>(allCommentsOnBases.get(psId));
        baseCommentsForThisPs.addAll(commentsForBase);
        commentsUtil.writeCommentsToNoteMap(noteMap, baseCommentsForThisPs, inserter);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        List<PatchLineComment> commentsForThisPs = new ArrayList<>(allCommentsOnPs.get(psId));
        commentsForThisPs.addAll(commentsForPs);
        commentsUtil.writeCommentsToNoteMap(noteMap, commentsForThisPs, inserter);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
protected Project.NameKey getProjectName() {
    return getProjectName(ctl);
}
#method_after
@Override
protected Project.NameKey getProjectName() {
    return getProjectName(ctl);
}
#end_block

#method_before
protected boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    NoteMap noteMap = null;
    Iterator<Note> notes = null;
    if (ref != null) {
        RevCommit commit = walk.parseCommit(ref.getObjectId());
        noteMap = NoteMap.read(walk.getObjectReader(), commit);
        notes = noteMap.iterator();
    } else {
        return null;
    }
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#method_after
public static NoteMap parseCommentsFromNotes(Repository repo, String refName, RevWalk walk, Change.Id changeId, Multimap<PatchSet.Id, PatchLineComment> commentsForBase, Multimap<PatchSet.Id, PatchLineComment> commentsForPs) throws IOException, ConfigInvalidException {
    Ref ref = repo.getRef(refName);
    if (ref == null) {
        return null;
    }
    RevCommit commit = walk.parseCommit(ref.getObjectId());
    NoteMap noteMap = NoteMap.read(walk.getObjectReader(), commit);
    for (Note note : noteMap) {
        byte[] bytes = walk.getObjectReader().open(note.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
    return noteMap;
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, ?> json_data = buildData(req);
    renderJson(req, res, json_data, json_data.getClass());
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesAccess access = getAccess(req);
    RepositoryDescription desc = access.getRepositoryDescription();
    renderJson(req, res, desc, new TypeToken<RepositoryDescription>() {
    }.getType());
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayInfo = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowInfoInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy();
        if (label.rejected() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayInfo && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayInfo = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowInfoInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayInfo && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
public static AccountInfo asInfo(com.google.gerrit.common.data.AccountInfo acct) {
    if (acct == null) {
        return AccountInfo.create(0, null, null, null);
    }
    return AccountInfo.create(acct.getId() != null ? acct.getId().get() : 0, acct.getFullName(), acct.getPreferredEmail(), acct.getPreferredUserName());
}
#method_after
public static AccountInfo asInfo(com.google.gerrit.common.data.AccountInfo acct) {
    if (acct == null) {
        return AccountInfo.create(0, null, null, null);
    }
    return AccountInfo.create(acct.getId() != null ? acct.getId().get() : 0, acct.getFullName(), acct.getPreferredEmail(), acct.getUsername());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), COMMIT_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    put(BRANCH_KIND).to(PutBranch.class);
    get(BRANCH_KIND).to(GetBranch.class);
    delete(BRANCH_KIND).to(DeleteBranch.class);
    install(new FactoryModuleBuilder().build(CreateBranch.Factory.class));
    get(BRANCH_KIND, "reflog").to(GetReflog.class);
    child(BRANCH_KIND, "files").to(FilesCollection.class);
    get(FILE_KIND, "content").to(GetContent.class);
    child(PROJECT_KIND, "commits").to(CommitsCollection.class);
    get(COMMIT_KIND).to(GetCommit.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
    put(PROJECT_KIND, "config").to(PutConfig.class);
}
#end_block

#method_before
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, AuthException, IOException {
    if (!parent.getControl().isOwner()) {
        throw new AuthException("no project owner");
    }
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
@Override
public CommitResource parse(ProjectResource parent, IdString id) throws ResourceNotFoundException, IOException {
    ObjectId objectId;
    try {
        objectId = ObjectId.fromString(id.get());
    } catch (IllegalArgumentException e) {
        throw new ResourceNotFoundException(id);
    }
    Repository repo = repoManager.openRepository(parent.getNameKey());
    try {
        RevWalk rw = new RevWalk(repo);
        try {
            RevCommit commit = rw.parseCommit(objectId);
            if (!parent.getControl().canReadCommit(rw, commit)) {
                throw new ResourceNotFoundException(id);
            }
            for (int i = 0; i < commit.getParentCount(); i++) {
                rw.parseCommit(commit.getParent(i));
            }
            return new CommitResource(parent.getControl(), commit);
        } catch (MissingObjectException | IncorrectObjectTypeException e) {
            throw new ResourceNotFoundException(id);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded("refs/meta/config").encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#method_after
@Test
public void getCommit() throws IOException {
    RestResponse r = adminSession.get("/projects/" + project.get() + "/branches/" + IdString.fromDecoded(RefNames.REFS_CONFIG).encoded());
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    BranchInfo branchInfo = newGson().fromJson(r.getReader(), BranchInfo.class);
    r.consume();
    r = adminSession.get("/projects/" + project.get() + "/commits/" + branchInfo.revision);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    CommitInfo commitInfo = newGson().fromJson(r.getReader(), CommitInfo.class);
    assertEquals(branchInfo.revision, commitInfo.commit);
    assertEquals("Created project", commitInfo.subject);
    assertEquals("Created project\n", commitInfo.message);
    assertNotNull(commitInfo.author);
    assertEquals("Administrator", commitInfo.author.name);
    assertNotNull(commitInfo.committer);
    assertEquals("Gerrit Code Review", commitInfo.committer.name);
    assertTrue(commitInfo.parents.isEmpty());
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key.get()).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("PatchLineComment{");
    builder.append("key=").append(key).append(',');
    builder.append("lineNbr=").append(lineNbr).append(',');
    builder.append("author=").append(author.get()).append(',');
    builder.append("writtenOn=").append(writtenOn.toString()).append(',');
    builder.append("status=").append(status).append(',');
    builder.append("side=").append(side).append(',');
    builder.append("message=").append(Objects.toString(message, "")).append(',');
    builder.append("parentUuid=").append(Objects.toString(parentUuid, "")).append(',');
    builder.append("range=").append(Objects.toString(range, "")).append(',');
    builder.append("revId=").append(revId != null ? revId.get() : "");
    builder.append('}');
    return builder.toString();
}
#end_block

#method_before
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#method_after
public List<PatchLineComment> publishedByChangeFile(ReviewDb db, ChangeNotes notes, Change.Id changeId, String file) throws OrmException {
    if (!migration.readPublishedComments()) {
        return db.patchComments().publishedByChangeFile(changeId, file).toList();
    }
    notes.load();
    List<PatchLineComment> commentsOnFile = new ArrayList<PatchLineComment>();
    // We must iterate through all comments to find the ones on this file.
    addCommentsInFile(commentsOnFile, notes.getBaseComments().values(), file);
    addCommentsInFile(commentsOnFile, notes.getPatchSetComments().values(), file);
    Collections.sort(commentsOnFile, ChangeNotes.PatchLineCommentComparator);
    return commentsOnFile;
}
#end_block

#method_before
private Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#method_after
private static Collection<PatchLineComment> addCommentsInFile(Collection<PatchLineComment> commentsOnFile, Collection<PatchLineComment> allComments, String file) {
    for (PatchLineComment c : allComments) {
        String currentFilename = c.getKey().getParentKey().getFileName();
        if (currentFilename.equals(file)) {
            commentsOnFile.add(c);
        }
    }
    return commentsOnFile;
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (final PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    ChangeNotes notes = control.getNotes();
    for (PatchLineComment c : plcUtil.publishedByPatchSet(db, notes, psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user.isIdentifiedUser()) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(changes.parse(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    // Here, we are writing the comments to the notedb so that we can
    // read from and test the notedb when the noteDb config is enabled.
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    update.putComment(plc1);
    update.putComment(plc3);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    update.putComment(plc2);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#method_after
@Before
public void setUp() throws Exception {
    @SuppressWarnings("unchecked")
    final DynamicMap<RestView<CommentResource>> views = createMock(DynamicMap.class);
    final TypeLiteral<DynamicMap<RestView<CommentResource>>> viewsType = new TypeLiteral<DynamicMap<RestView<CommentResource>>>() {
    };
    final AccountInfo.Loader.Factory alf = createMock(AccountInfo.Loader.Factory.class);
    final ReviewDb db = createMock(ReviewDb.class);
    final FakeAccountCache accountCache = new FakeAccountCache();
    final PersonIdent serverIdent = new PersonIdent("Gerrit Server", "noreply@gerrit.com", TimeUtil.nowTs(), TZ);
    project = new Project.NameKey("test-project");
    repoManager = new InMemoryRepositoryManager();
    @SuppressWarnings("unused")
    InMemoryRepository repo = repoManager.createRepository(project);
    AbstractModule mod = new AbstractModule() {

        @Override
        protected void configure() {
            bind(viewsType).toInstance(views);
            bind(AccountInfo.Loader.Factory.class).toInstance(alf);
            bind(ReviewDb.class).toProvider(Providers.<ReviewDb>of(db));
            bind(Config.class).annotatedWith(GerritServerConfig.class).toInstance(config);
            bind(ProjectCache.class).toProvider(Providers.<ProjectCache>of(null));
            install(new GitModule());
            bind(GitRepositoryManager.class).toInstance(repoManager);
            bind(CapabilityControl.Factory.class).toProvider(Providers.<CapabilityControl.Factory>of(null));
            bind(String.class).annotatedWith(AnonymousCowardName.class).toProvider(AnonymousCowardNameProvider.class);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toInstance("http://localhost:8080/");
            bind(GroupBackend.class).to(SystemGroupBackend.class).in(SINGLETON);
            bind(AccountCache.class).toInstance(accountCache);
            bind(GitReferenceUpdated.class).toInstance(GitReferenceUpdated.DISABLED);
            bind(PersonIdent.class).annotatedWith(GerritPersonIdent.class).toInstance(serverIdent);
        }
    };
    injector = Guice.createInjector(mod);
    NotesMigration migration = injector.getInstance(NotesMigration.class);
    plcUtil = new PatchLineCommentsUtil(migration);
    Account co = new Account(new Account.Id(1), TimeUtil.nowTs());
    co.setFullName("Change Owner");
    co.setPreferredEmail("change@owner.com");
    accountCache.put(co);
    Account.Id ownerId = co.getId();
    Account ou = new Account(new Account.Id(2), TimeUtil.nowTs());
    ou.setFullName("Other Account");
    ou.setPreferredEmail("other@account.com");
    accountCache.put(ou);
    Account.Id otherUserId = ou.getId();
    IdentifiedUser.GenericFactory userFactory = injector.getInstance(IdentifiedUser.GenericFactory.class);
    changeOwner = userFactory.create(ownerId);
    IdentifiedUser otherUser = userFactory.create(otherUserId);
    AccountInfo.Loader accountLoader = createMock(AccountInfo.Loader.class);
    accountLoader.fill();
    expectLastCall().anyTimes();
    expect(accountLoader.get(ownerId)).andReturn(new AccountInfo(ownerId)).anyTimes();
    expect(accountLoader.get(otherUserId)).andReturn(new AccountInfo(otherUserId)).anyTimes();
    expect(alf.create(true)).andReturn(accountLoader).anyTimes();
    replay(accountLoader, alf);
    PatchLineCommentAccess plca = createMock(PatchLineCommentAccess.class);
    expect(db.patchComments()).andReturn(plca).anyTimes();
    Change change = newChange();
    PatchSet.Id psId1 = new PatchSet.Id(change.getId(), 1);
    PatchSet ps1 = new PatchSet(psId1);
    PatchSet.Id psId2 = new PatchSet.Id(change.getId(), 2);
    PatchSet ps2 = new PatchSet(psId2);
    long timeBase = TimeUtil.nowMs();
    plc1 = newPatchLineComment(psId1, "Comment1", null, "FileOne.txt", Side.REVISION, 3, ownerId, timeBase, "First Comment", new CommentRange(1, 2, 3, 4));
    plc1.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc2 = newPatchLineComment(psId1, "Comment2", "Comment1", "FileOne.txt", Side.REVISION, 3, otherUserId, timeBase + 1000, "Reply to First Comment", new CommentRange(1, 2, 3, 4));
    plc2.setRevId(new RevId("ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD"));
    plc3 = newPatchLineComment(psId1, "Comment3", "Comment1", "FileOne.txt", Side.PARENT, 3, ownerId, timeBase + 2000, "First Parent Comment", new CommentRange(1, 2, 3, 4));
    plc3.setRevId(new RevId("CDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEFCDEF"));
    List<PatchLineComment> commentsByOwner = Lists.newArrayList();
    commentsByOwner.add(plc1);
    commentsByOwner.add(plc3);
    List<PatchLineComment> commentsByReviewer = Lists.newArrayList();
    commentsByReviewer.add(plc2);
    plca.upsert(commentsByOwner);
    expectLastCall().anyTimes();
    plca.upsert(commentsByReviewer);
    expectLastCall().anyTimes();
    expect(plca.publishedByPatchSet(psId1)).andAnswer(results(plc1, plc2, plc3)).anyTimes();
    expect(plca.publishedByPatchSet(psId2)).andAnswer(results()).anyTimes();
    replay(db, plca);
    ChangeUpdate update = newUpdate(change, changeOwner);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByOwner);
    update.commit();
    update = newUpdate(change, otherUser);
    update.setPatchSetId(psId1);
    plcUtil.addPublishedComments(db, update, commentsByReviewer);
    update.commit();
    ChangeControl ctl = stubChangeControl(change);
    revRes1 = new RevisionResource(new ChangeResource(ctl), ps1);
    revRes2 = new RevisionResource(new ChangeResource(ctl), ps2);
}
#end_block

#method_before
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return ChangesForTestUtil.stubChangeControl(repoManager, c, changeOwner);
}
#method_after
private ChangeControl stubChangeControl(Change c) throws OrmException {
    return TestChanges.stubChangeControl(repoManager, c, changeOwner);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(roundTimestampToSecond(plc.getWrittenOn()), roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#method_after
private static void assertComment(PatchLineComment plc, CommentInfo ci) {
    assertEquals(plc.getKey().get(), ci.id);
    assertEquals(plc.getParentUuid(), ci.inReplyTo);
    assertEquals(plc.getMessage(), ci.message);
    assertNotNull(ci.author);
    assertEquals(plc.getAuthor(), ci.author._id);
    assertEquals(plc.getLine(), (int) ci.line);
    assertEquals(plc.getSide() == 0 ? Side.PARENT : Side.REVISION, Objects.firstNonNull(ci.side, Side.REVISION));
    assertEquals(TimeUtil.roundTimestampToSecond(plc.getWrittenOn()), TimeUtil.roundTimestampToSecond(ci.updated));
    assertEquals(plc.getRange(), ci.range);
}
#end_block

#method_before
private Change newChange() {
    return ChangesForTestUtil.newChange(project, changeOwner);
}
#method_after
private Change newChange() {
    return TestChanges.newChange(project, changeOwner);
}
#end_block

#method_before
private ChangeUpdate newUpdate(Change c, final IdentifiedUser user) throws Exception {
    return ChangesForTestUtil.newUpdate(injector, repoManager, c, user);
}
#method_after
private ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws Exception {
    return TestChanges.newUpdate(injector, repoManager, c, user);
}
#end_block

#method_before
private ViewData view(RestResource rsrc, RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws AmbiguousViewException, RestApiException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    } else if ("HEAD".equals(method)) {
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        String viewname = p.get(1);
        if (Strings.isNullOrEmpty(viewname)) {
            viewname = "/";
        }
        RestView<RestResource> view = views.get(p.get(0), method + "." + viewname);
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        view = views.get(p.get(0), "GET." + viewname);
        if (view != null) {
            if (view instanceof AcceptsPost && "POST".equals(method)) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ap = (AcceptsPost<RestResource>) view;
                return new ViewData(p.get(0), ap.post(rsrc));
            }
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    } else {
        name = "GET." + p.get(0);
        core = views.get("gerrit", name);
        if (core != null) {
            if (core instanceof AcceptsPost && "POST".equals(method)) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ap = (AcceptsPost<RestResource>) core;
                return new ViewData(null, ap.post(rsrc));
            }
        }
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: %s", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private ViewData view(RestResource rsrc, RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws AmbiguousViewException, RestApiException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    } else if ("HEAD".equals(method)) {
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        String viewname = p.get(1);
        if (Strings.isNullOrEmpty(viewname)) {
            viewname = "/";
        }
        RestView<RestResource> view = views.get(p.get(0), method + "." + viewname);
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        view = views.get(p.get(0), "GET." + viewname);
        if (view != null) {
            if (view instanceof AcceptsPost && "POST".equals(method)) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ap = (AcceptsPost<RestResource>) view;
                return new ViewData(p.get(0), ap.post(rsrc));
            }
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    } else {
        name = "GET." + p.get(0);
        core = views.get("gerrit", name);
        if (core instanceof AcceptsPost && "POST".equals(method)) {
            @SuppressWarnings("unchecked")
            AcceptsPost<RestResource> ap = (AcceptsPost<RestResource>) core;
            return new ViewData(null, ap.post(rsrc));
        }
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: %s", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RemoteCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(createIndexModule());
    if (Objects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    modules.add(GarbageCollectionRunner.module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("TABLE address_id");
    drop("TABLE addresses");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE foo");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try {
        FileOutputStream out = new FileOutputStream(tmp);
        try {
            byte[] data = new byte[8192];
            int n;
            while ((n = in.read(data)) > 0) {
                out.write(data, 0, n);
            }
            keep = true;
            return tmp;
        } finally {
            out.close();
        }
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#method_after
static File asTemp(InputStream in, String prefix, String suffix, File dir) throws IOException {
    File tmp = File.createTempFile(prefix, suffix, dir);
    boolean keep = false;
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        byte[] data = new byte[8192];
        int n;
        while ((n = in.read(data)) > 0) {
            out.write(data, 0, n);
        }
        keep = true;
        return tmp;
    } finally {
        if (!keep) {
            tmp.delete();
        }
    }
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : jarsFirstSortedPluginsSet(activePlugins)) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJsPlugin(fileName) && !serverPluginFactory.handles(file)) {
            log.warn("No Plugin provider was found that handles this file format: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        if (newPlugin.getCleanupHandle() != null) {
            cleanupHandles.put(newPlugin, newPlugin.getCleanupHandle());
        }
        /*
       * Pluggable plugin provider may have assigned a plugin name that could be
       * actually different from the initial one assigned during scan. It is
       * safer then to reassign it.
       */
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        name = serverPluginFactory.getPluginName(srcPlugin);
        return loadServerPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (serverPluginFactory.handles(srcPlugin)) {
        return loadServerPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private ServerPlugin loadServerPlugin(String name, File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    return serverPluginFactory.get(scriptFile, pluginUserFactory.create(name), snapshot, getPluginCanonicalWebUrl(name), getPluginDataDir(name));
}
#method_after
private ServerPlugin loadServerPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = serverPluginFactory.getPluginName(scriptFile);
    return serverPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getGerritJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#method_after
@Override
public String getPluginName(File srcFile) {
    try {
        return Objects.firstNonNull(getJarPluginName(srcFile), PluginLoader.nameOf(srcFile));
    } catch (IOException e) {
        throw new IllegalArgumentException("Invalid plugin file " + srcFile + ": cannot get plugin name", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(File srcFile, PluginUser pluginUser, FileSnapshot snapshot, String pluginCanonicalWebUrl, File pluginDataDir) throws InvalidPluginException {
    try {
        File tmp;
        String name = getPluginName(srcFile);
        FileInputStream in = new FileInputStream(srcFile);
        String extension = getExtension(srcFile);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, pluginCanonicalWebUrl, pluginUser, pluginDataDir);
        } finally {
            in.close();
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription description) throws InvalidPluginException {
    try {
        String name = getPluginName(srcFile);
        String extension = getExtension(srcFile);
        try (FileInputStream in = new FileInputStream(srcFile)) {
            File tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
            return loadJarPlugin(name, srcFile, snapshot, tmp, description);
        }
    } catch (IOException | ClassNotFoundException e) {
        throw new InvalidPluginException("Cannot load Jar plugin " + srcFile, e);
    }
}
#end_block

#method_before
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, String pluginCanonicalWebUrl, PluginUser pluginUser, File pluginDataDir) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, pluginCanonicalWebUrl, pluginUser, srcJar, snapshot, new JarScanner(srcJar), pluginDataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private ServerPlugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp, PluginDescription description) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), PluginLoader.parentFor(type));
        ServerPlugin plugin = new ServerPlugin(name, description.canonicalUrl, description.user, srcJar, snapshot, new JarScanner(srcJar), description.dataDir, pluginLoader);
        plugin.setCleanupHandle(new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Injector getPluginInjector(File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getGerritJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#method_after
private Injector getPluginInjector(final File jarFile) throws IOException {
    final String pluginName = Objects.firstNonNull(JarPluginProvider.getJarPluginName(jarFile), PluginLoader.nameOf(jarFile));
    return initInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    change.revision(revision);
    setWebLinks(change, revision, revInfo);
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.linkUrl(), link.linkName());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        addWebLink(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            addWebLink(link.link_url(), link.link_name());
        }
    }
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    out.webLinks = Lists.newArrayList();
    for (WebLinks.Link link : webLinkFactory.create().getPatchSetLinks(project, in.getRevision().get())) {
        out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in, String project) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change().currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(changes.parse(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    if (has(WEB_LINKS)) {
        out.webLinks = Lists.newArrayList();
        for (WebLinks.Link link : webLinks.get().getPatchSetLinks(project, in.getRevision().get())) {
            out.webLinks.add(new RevisionInfo.WebLinkInfo(link.name, link.url));
        }
    }
    return out;
}
#end_block

#method_before
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    ArrayList<Link> links = new ArrayList<Link>();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#method_after
public Iterable<Link> getPatchSetLinks(final String project, final String commit) {
    List<Link> links = Lists.newArrayList();
    for (PatchSetWebLink webLink : patchSetLinks) {
        links.add(new Link(webLink.getLinkName(), webLink.getPatchSetUrl(project, commit)));
    }
    return links;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(WebLinks.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getKey()));
    this.psId = psId;
}
#method_after
public void setPatchSetId(PatchSet.Id psId) {
    checkArgument(psId == null || psId.getParentKey().equals(getChange().getId()));
    this.psId = psId;
}
#end_block

#method_before
public void putComment(PatchLineComment comment) {
    commentsToAdd.add(comment);
}
#method_after
public void putComment(PatchLineComment comment) {
    checkArgument(psId != null, "setPatchSetId must be called before putComment");
    checkArgument(getCommentPsId(comment).equals(psId), "Comment on %s doesn't match previous patch set %s", getCommentPsId(comment), psId);
    checkArgument(comment.getRevId() != null);
    if (comment.getSide() == 0) {
        commentsForBase.add(comment);
    } else {
        commentsForPs.add(comment);
    }
}
#end_block

#method_before
private void storeCommentsInNotes(RevCommit c) throws OrmException, IOException {
    if (commentsToAdd.isEmpty()) {
        return;
    }
    // assume you can only add comments to one patchset at a time
    PatchSet.Id psId = commentsToAdd.get(0).getKey().getParentKey().getParentKey();
    ChangeNotes notes = ctl.getNotes();
    LinkedListMultimap<PatchSet.Id, PatchLineComment> allComments = LinkedListMultimap.create(notes.getPublishedComments());
    List<PatchLineComment> commentsOnSamePs = allComments.get(psId);
    // add all comments and re-sort list
    commentsOnSamePs.addAll(commentsToAdd);
    commentsOnSamePs = ChangeNotes.COMMENT_ORDERING.sortedCopy(commentsOnSamePs);
    String noteContents = PatchLineCommentsUtil.buildNote(accountCache, commentsOnSamePs);
    AnyObjectId oId = c.getId();
    NoteMap noteMap = notes.getNoteMap();
    noteMap.set(oId, noteContents, this.inserter);
    this.inserter.flush();
}
#method_after
private ObjectId storeCommentsInNotes() throws OrmException, IOException {
    ChangeNotes notes = ctl.getNotes();
    NoteMap noteMap = notes.getNoteMap();
    if (noteMap == null) {
        noteMap = NoteMap.newEmptyMap();
    }
    if (commentsForPs.isEmpty() && commentsForBase.isEmpty()) {
        return null;
    }
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnBases = notes.getBaseComments();
    Multimap<PatchSet.Id, PatchLineComment> allCommentsOnPs = notes.getPatchSetComments();
    // This writes all comments for the base of this PS to the note map.
    if (!commentsForBase.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnBases, commentsForBase);
    }
    // This write all comments for this PS to the note map.
    if (!commentsForPs.isEmpty()) {
        writeCommentsToNoteMap(noteMap, allCommentsOnPs, commentsForPs);
    }
    return noteMap.writeTree(inserter);
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        batch.write(new CommitBuilder());
        RevCommit c = batch.commit();
        storeCommentsInNotes(c);
        return c;
    } catch (OrmException e) {
        // TODO(yyonas): what to do with this exception?
        return null;
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        CommitBuilder builder = new CommitBuilder();
        if (migration.write()) {
            ObjectId treeId = storeCommentsInNotes();
            if (treeId != null) {
                builder.setTreeId(treeId);
            }
        }
        batch.write(builder);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#method_after
private boolean isEmpty() {
    return approvals.isEmpty() && reviewers.isEmpty() && commentsForBase.isEmpty() && commentsForPs.isEmpty() && status == null && submitRecords == null && changeMessage == null;
}
#end_block

#method_before
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        publishedCommentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = publishedCommentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = parseNote(bytes);
        if (result == null) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        publishedComments.putAll(psId, result);
    }
}
#method_after
private void parseComments(RevCommit commit) throws IOException, ConfigInvalidException, ParseException {
    Ref sharedMeta = repo.getRef(ChangeNoteUtil.changeRefName(changeId));
    if (sharedMeta != null) {
        RevCommit sharedBaseCommit = walk.parseCommit(sharedMeta.getObjectId());
        commentNoteMap = NoteMap.read(walk.getObjectReader(), sharedBaseCommit);
    }
    Iterator<Note> notes = commentNoteMap.iterator();
    while (notes.hasNext()) {
        Note next = notes.next();
        byte[] bytes = walk.getObjectReader().open(next.getData(), Constants.OBJ_BLOB).getBytes();
        List<PatchLineComment> result = CommentsInNotesUtil.parseNote(bytes, changeId);
        if ((result == null) || (result.isEmpty())) {
            continue;
        }
        PatchSet.Id psId = result.get(0).getKey().getParentKey().getParentKey();
        short side = result.get(0).getSide();
        if (side == 0) {
            commentsForBase.putAll(psId, result);
        } else {
            commentsForPs.putAll(psId, result);
        }
    }
}
#end_block

#method_before
private ConfigInvalidException parseException(String fmt, Object... args) {
    return new ConfigInvalidException("Change " + changeId + ": " + String.format(fmt, args));
}
#method_after
private ConfigInvalidException parseException(String fmt, Object... args) {
    return ChangeNotes.parseException(changeId, fmt, args);
}
#end_block

#method_before
public NoteMap getNoteMap() {
    return noteMap;
}
#method_after
NoteMap getNoteMap() {
    return noteMap;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        publishedComments = ImmutableListMultimap.copyOf(parser.publishedComments);
        noteMap = parser.publishedCommentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
    // TODO(yyonas): figure out how to handle this exception
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change, rev, walk, repoManager);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessages = parser.buildMessages();
        commentsForBase = ImmutableListMultimap.copyOf(parser.commentsForBase);
        commentsForPS = ImmutableListMultimap.copyOf(parser.commentsForPs);
        noteMap = parser.commentNoteMap;
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } catch (ParseException e1) {
        // TODO(yyonas): figure out how to handle this exception
        throw new IOException(e1);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    publishedComments = ImmutableListMultimap.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
    commentsForBase = ImmutableListMultimap.of();
    commentsForPS = ImmutableListMultimap.of();
}
#end_block

#method_before
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("Skipping non-plugin file " + fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> pluginsFiles = prunePlugins(pluginsDir);
    if (pluginsFiles.isEmpty()) {
        return;
    }
    syncDisabledPlugins(pluginsFiles);
    Map<String, File> activePlugins = filterDisabled(pluginsFiles);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File file = entry.getValue();
        String fileName = file.getName();
        if (!isJarPlugin(fileName) && !isJsPlugin(fileName) && !externalPluginFactory.handles(file)) {
            log.warn("File is not a JAR nor JS plugin and " + "no Plugin provider was found that handles it: {}", fileName);
            continue;
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(file)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(file)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, file, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        name = newPlugin.getName();
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File plugin, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(plugin);
    try {
        Plugin newPlugin = loadPlugin(name, plugin, snapshot);
        // Pluggable plugin provider may have assigned
        name = newPlugin.getName();
        // a plugin name that could be actually
        // different from the initial
        // one assigned during scan. It is safer then
        // to reassign it.
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        name = externalPluginFactory.getPluginName(srcPlugin);
        return loadExternalPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else if (externalPluginFactory.handles(srcPlugin)) {
        return loadExternalPlugin(srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: %s", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new ServerPlugin(name, getPluginCanonicalWebUrl(name), pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), getPluginDataDir(name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private ServerPlugin loadExternalPlugin(String name, File scriptFile, FileSnapshot snapshot) {
    return externalPluginFactory.get(name, scriptFile, pluginUserFactory.create(name), snapshot);
}
#method_after
private ServerPlugin loadExternalPlugin(File scriptFile, FileSnapshot snapshot) throws InvalidPluginException {
    String name = externalPluginFactory.getPluginName(scriptFile);
    return externalPluginFactory.get(scriptFile, snapshot, new PluginDescription(pluginUserFactory.create(name), getPluginCanonicalWebUrl(name), getPluginDataDir(name)));
}
#end_block

#method_before
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name. Values are
// the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#method_after
// Scan the $site_path/plugins directory and fetch all files and directories.
// The Key in returned multimap is the plugin name initially assigned from its filename.
// Values are the files. Plugins can optionally provide their name in MANIFEST file.
// If multiple plugin files provide the same plugin name, then only
// the first plugin remains active and all other plugins with the same
// name are disabled.
// 
// NOTE: Bear in mind that the plugin name can be reassigned after load by the
public Multimap<String, File> prunePlugins(File pluginsDir) {
    List<File> pluginFiles = scanFilesInPluginsDirectory(pluginsDir);
    Multimap<String, File> map;
    try {
        map = asMultimap(pluginFiles);
        for (String plugin : map.keySet()) {
            Collection<File> files = map.asMap().get(plugin);
            if (files.size() == 1) {
                continue;
            }
            // retrieve enabled plugins
            Iterable<File> enabled = filterDisabledPlugins(files);
            // If we have only one (the winner) plugin, nothing to do
            if (!Iterables.skip(enabled, 1).iterator().hasNext()) {
                continue;
            }
            File winner = Iterables.getFirst(enabled, null);
            assert (winner != null);
            // Disable all loser plugins by renaming their file names to
            // "file.disabled" and replace the disabled files in the multimap.
            Collection<File> elementsToRemove = Lists.newArrayList();
            Collection<File> elementsToAdd = Lists.newArrayList();
            for (File loser : Iterables.skip(enabled, 1)) {
                log.warn(String.format("Plugin <%s> was disabled, because" + " another plugin <%s>" + " with the same name <%s> already exists", loser, winner, plugin));
                File disabledPlugin = new File(loser + ".disabled");
                elementsToAdd.add(disabledPlugin);
                elementsToRemove.add(loser);
                loser.renameTo(disabledPlugin);
            }
            Iterables.removeAll(files, elementsToRemove);
            Iterables.addAll(files, elementsToAdd);
        }
    } catch (IOException e) {
        log.warn("Cannot prune plugin list", e.getCause());
        return LinkedHashMultimap.create();
    }
    return map;
}
#end_block

#method_before
public static String getGerritJarPluginName(File srcFile) throws IOException {
    JarFile jarFile = new JarFile(srcFile);
    try {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    } finally {
        jarFile.close();
    }
}
#method_after
public static String getGerritJarPluginName(File srcFile) throws IOException {
    try (JarFile jarFile = new JarFile(srcFile)) {
        return jarFile.getManifest().getMainAttributes().getValue("Gerrit-PluginName");
    }
}
#end_block

#method_before
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<InitStep>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#method_after
public Collection<InitStep> getInitSteps() {
    List<File> jars = scanJarsInPluginsDirectory();
    ArrayList<InitStep> pluginsInitSteps = new ArrayList<>();
    for (File jar : jars) {
        InitStep init = loadInitStep(jar);
        if (init != null) {
            pluginsInitSteps.add(init);
        }
    }
    return pluginsInitSteps;
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Override
public ServerPlugin get(String name, File srcFile, PluginUser pluginUser, FileSnapshot snapshot) {
    return providerOf(srcFile).get(name, srcFile, pluginUser, snapshot);
}
#method_after
@Override
public ServerPlugin get(File srcFile, FileSnapshot snapshot, PluginDescription pluginDescription) throws InvalidPluginException {
    return providerOf(srcFile).get(srcFile, snapshot, pluginDescription);
}
#end_block

#method_before
@Override
public boolean handles(File srcFile) {
    for (ServerPluginProvider scriptingFactory : serverPluginProviders) {
        if (scriptingFactory.handles(srcFile)) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean handles(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return true;
        case 0:
            return false;
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
private ServerPluginProvider providerOf(File srcFile) {
    for (ServerPluginProvider provider : serverPluginProviders) {
        if (provider.handles(srcFile)) {
            return provider;
        }
    }
    throw new IllegalArgumentException(srcFile.getAbsolutePath() + " is not a supported Gerrit plugin format");
}
#method_after
private ServerPluginProvider providerOf(File srcFile) {
    List<ServerPluginProvider> providers = providersForHandlingPlugin(srcFile);
    switch(providers.size()) {
        case 1:
            return providers.get(0);
        case 0:
            throw new IllegalArgumentException("No ServerPluginProvider found/loaded to handle plugin file " + srcFile.getAbsolutePath());
        default:
            throw new MultipleProvidersForPluginException(srcFile, providers);
    }
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE cnt");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    if (executor == null) {
        return;
    }
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            } catch (InsertException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, InsertException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, InsertException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (InsertException err) {
        log.error("Can't insert change/patchset for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj, allRefs.values().contains(obj))) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.setCmdLineParser(clp);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                walk.markUninteresting(c);
            }
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
CheckedFuture<Void, OrmException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<Void, InsertException> insertChange() throws IOException {
    rp.getRevWalk().parseBody(commit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<Void> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<Void>() {

        @Override
        public Void call() throws OrmException, IOException {
            if (caller == Thread.currentThread()) {
                insertChange(db);
            } else {
                ReviewDb db = schemaFactory.open();
                try {
                    insertChange(db);
                } finally {
                    db.close();
                }
            }
            synchronized (newProgress) {
                newProgress.update(1);
            }
            return null;
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException, IOException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, ps.getCreatedOn(), ps.getId());
    msg.setMessage("Uploaded patch set " + ps.getPatchSetId() + ".");
    ins.setReviewers(recipients.getReviewers()).setApprovals(approvals).setMessage(msg).setSendMail(false).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, InsertException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        ChangeKind changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        String message = "Uploaded patch set " + newPatchSet.getPatchSetId();
        switch(changeKind) {
            case TRIVIAL_REBASE:
                message += ": Patch Set " + priorPatchSet.get() + " was rebased";
                break;
            case NO_CODE_CHANGE:
                message += ": Commit message was updated";
                break;
        }
        msg.setMessage(message + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) throws NoSuchChangeException {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (InsertException e) {
        log.error("Can't insert patchset", e);
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<Change.Key, Change.Id>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#method_after
private Map<Change.Key, Change.Id> openChangesByKey(Branch.NameKey branch) throws OrmException {
    final Map<Change.Key, Change.Id> r = new HashMap<>();
    for (Change c : db.changes().byBranchOpenAll(branch)) {
        r.put(c.getKey(), c.getId());
    }
    return r;
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(msg));
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Override
public Object apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, ResourceConflictException, MethodNotAllowedException, OrmException, IOException, AuthException {
    if (!canDelete(rsrc)) {
        throw new AuthException("not allowed to delete project");
    }
    Project project = rsrc.getControl().getProject();
    if (project.getNameKey().equals(allProjectsName)) {
        throw new MethodNotAllowedException();
    }
    ListChildProjects listChildProjects = listChildProjectsProvider.get();
    List<ProjectInfo> children = listChildProjects.apply(rsrc);
    if (!children.isEmpty()) {
        StringBuilder sb = new StringBuilder();
        for (ProjectInfo projectInfo : children) {
            if (!(sb.length() == 0)) {
                sb.append(", ");
            }
            sb.append(projectInfo.name);
        }
        throw new ResourceConflictException("Cannot delete project because " + "it has children: " + sb.toString());
    }
    try {
        dbHandler.assertCanDelete(project);
    } catch (CannotDeleteProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    if (input == null || !input.force) {
        Collection<String> warnings = dbHandler.getWarnings(project);
        if (!warnings.isEmpty()) {
            throw new ResourceConflictException(String.format("Project %s has open changes", project.getName()));
        }
    }
    dbHandler.delete(project);
    try {
        fsHandler.delete(project, input == null ? false : input.preserve);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    }
    cacheHandler.delete(project);
    return Response.none();
}
#method_after
@Override
public Object apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, ResourceConflictException, OrmException, IOException, AuthException {
    if (!canDelete(rsrc)) {
        throw new AuthException("not allowed to delete project");
    }
    try {
        pcHandler.assertCanDelete(rsrc);
    } catch (CannotDeleteProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    Project project = rsrc.getControl().getProject();
    try {
        dbHandler.assertCanDelete(project);
    } catch (CannotDeleteProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    if (input == null || !input.force) {
        Collection<String> warnings = dbHandler.getWarnings(project);
        if (!warnings.isEmpty()) {
            throw new ResourceConflictException(String.format("Project %s has open changes", project.getName()));
        }
    }
    dbHandler.delete(project);
    try {
        fsHandler.delete(project, input == null ? false : input.preserve);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException();
    }
    cacheHandler.delete(project);
    return Response.none();
}
#end_block

#method_before
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(uploadValidatorsFactory.create(project, repo));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
    // UploadValidationException is used by the UploadValidationListener to
    // stop the uploadPack. We do not want this exception to go beyond this
    // point otherwise it would print a stacktrace in the logs and return an
    // internal server error to the client.
    }
}
#method_after
@Override
protected void runImpl() throws IOException, Failure {
    if (!projectControl.canRunUploadPack()) {
        throw new Failure(1, "fatal: upload-pack not permitted on this server");
    }
    final UploadPack up = new UploadPack(repo);
    if (!projectControl.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, projectControl, db.get(), true));
    }
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    List<PreUploadHook> allPreUploadHooks = Lists.newArrayList(preUploadHooks);
    allPreUploadHooks.add(uploadValidatorsFactory.create(project, repo, session.getRemoteAddressAsString()));
    up.setPreUploadHook(PreUploadHookChain.newChain(allPreUploadHooks));
    try {
        up.upload(in, out, err);
    } catch (UploadValidationException e) {
        // internal server error to the client.
        if (!e.isOutput()) {
            up.sendMessage(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(preUploadHooks)));
    return up;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    up.setPreUploadHook(uploadValidatorsFactory.create(pc.getProject(), repo));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain next) throws IOException, ServletException {
    // The Resolver above already checked READ access for us.
    Repository repo = ServletUtils.getRepository(request);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    UploadPack up = (UploadPack) request.getAttribute(ServletUtils.ATTRIBUTE_HANDLER);
    if (!pc.canRunUploadPack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "upload-pack not permitted on this server");
        return;
    }
    // We use getRemoteHost() here instead of getRemoteAddr() because REMOTE_ADDR
    // may have been overridden by a proxy server -- we'll try to avoid this.
    UploadValidators uploadValidators = uploadValidatorsFactory.create(pc.getProject(), repo, request.getRemoteHost());
    up.setPreUploadHook(PreUploadHookChain.newChain(Lists.newArrayList(up.getPreUploadHook(), uploadValidators)));
    if (!pc.allRefsAreVisible()) {
        up.setAdvertiseRefsHook(new VisibleRefFilter(tagCache, changeCache, repo, pc, db.get(), true));
    }
    next.doFilter(request, response);
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    rp.getAdvertiseRefsHook().advertiseRefs(rp);
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser().isIdentifiedUser())) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        validator.onPreUpload(repository, project, wants, haves);
    }
}
#method_after
@Override
public void onSendPack(UploadPack up, Collection<? extends ObjectId> wants, Collection<? extends ObjectId> haves) throws ServiceMayNotContinueException {
    for (UploadValidationListener validator : uploadValidationListeners) {
        try {
            validator.onPreUpload(repository, project, remoteHost, up, wants, haves);
        } catch (ValidationException e) {
            throw new UploadValidationException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    org.h2.Driver.load();
    db = DriverManager.getConnection("jdbc:h2:mem:DialectH2Test");
    executor = new JdbcExecutor(db);
    dialect = new DialectH2().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.h2.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    final String database = "gwtorm";
    final String user = "gwtorm";
    final String pass = "gwtorm";
    try {
        db = DriverManager.getConnection("jdbc:postgresql:" + database, user, pass);
    } catch (Throwable t) {
        assumeNoException(t);
    }
    executor = new JdbcExecutor(db);
    dialect = new DialectPostgreSQL().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.postgresql.Driver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    // Database content must be flushed because
    // tests assume that the database is empty
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null && isUnconditionalRequestOnModifiedDate(req)) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            PluginContentScanner scanner = holder.plugin.getContentScanner();
            Optional<PluginEntry> entry = scanner.getEntry(file);
            if (entry.isPresent()) {
                if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                    rsc.send(req, res);
                } else {
                    sendResource(scanner, entry.get(), key, res);
                }
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        PluginContentScanner scanner = holder.plugin.getContentScanner();
        Optional<PluginEntry> entry = scanner.getEntry(file);
        if (!entry.isPresent()) {
            entry = findSource(scanner, file);
        }
        if (!entry.isPresent() && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            long pluginLastModified = holder.plugin.getSrcFile().lastModified();
            if (hasUpToDateCachedResource(rsc, pluginLastModified)) {
                rsc.send(req, res);
            } else {
                sendAutoIndex(scanner, pfx, holder.plugin.getName(), key, res, pluginLastModified);
            }
        } else if (entry.isPresent() && entry.get().getName().endsWith(".md")) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendMarkdownAsHtml(scanner, entry.get(), holder.plugin.getName(), key, res);
            }
        } else if (entry.isPresent()) {
            sendResource(scanner, entry.get(), key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null && req.getHeader(HttpHeaders.IF_MODIFIED_SINCE) == null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            PluginContentScanner scanner = holder.plugin.getContentScanner();
            Optional<PluginEntry> entry = scanner.getEntry(file);
            if (entry.isPresent()) {
                if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                    rsc.send(req, res);
                } else {
                    sendResource(scanner, entry.get(), key, res);
                }
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        PluginContentScanner scanner = holder.plugin.getContentScanner();
        Optional<PluginEntry> entry = scanner.getEntry(file);
        if (!entry.isPresent()) {
            entry = findSource(scanner, file);
        }
        if (!entry.isPresent() && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            long pluginLastModified = holder.plugin.getSrcFile().lastModified();
            if (hasUpToDateCachedResource(rsc, pluginLastModified)) {
                rsc.send(req, res);
            } else {
                sendAutoIndex(scanner, pfx, holder.plugin.getName(), key, res, pluginLastModified);
            }
        } else if (entry.isPresent() && entry.get().getName().endsWith(".md")) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendMarkdownAsHtml(scanner, entry.get(), holder.plugin.getName(), key, res);
            }
        } else if (entry.isPresent()) {
            if (hasUpToDateCachedResource(rsc, entry.get().getTime())) {
                rsc.send(req, res);
            } else {
                sendResource(scanner, entry.get(), key, res);
            }
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private boolean hasUpToDateCachedResource(Resource cachedResource, long lastUpdateTime) {
    return cachedResource != null && cachedResource.isUpToDate(lastUpdateTime);
}
#method_after
private boolean hasUpToDateCachedResource(Resource cachedResource, long lastUpdateTime) {
    return cachedResource != null && cachedResource.isUnchanged(lastUpdateTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.setDateHeader("Last-Modified", lastModifiedTime);
    res.getOutputStream().write(html);
}
#end_block

#method_before
@Override
public void setReviewed(String unencodedFilePath) throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public void setReviewed(String path, boolean reviewed) throws RestApiException {
    throw new NotImplementedException();
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<PluginEntry>() {

        @Override
        public int compare(PluginEntry a, PluginEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.setDateHeader("Last-Modified", lastModifiedTime);
    res.getOutputStream().write(html);
}
#end_block

#method_before
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    }
}
#method_after
@Override
public synchronized void schedule(final Branch.NameKey branch) {
    MergeEntry e = active.get(branch);
    if (e == null) {
        e = new MergeEntry(branch);
        active.put(branch, e);
        e.needMerge = true;
        scheduleJob(e);
    } else {
        e.needMerge = true;
    }
}
#end_block

#method_before
private void threadSummary() {
    List<String> prefixes = Lists.newArrayList("HTTP", "IntraLineDiff", "ReceiveCommits", "SSH git-receive-pack", "SSH git-upload-pack", "SSH-Interactive-Worker", "SSH-Stream-Worker", "SshCommandStart");
    Runtime r = Runtime.getRuntime();
    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    stdout.format("Threads: %d cpus available, %d threads\n", r.availableProcessors(), threadMXBean.getThreadCount());
    Table<String, Thread.State, Integer> count = HashBasedTable.create();
    for (long id : threadMXBean.getAllThreadIds()) {
        ThreadInfo info = threadMXBean.getThreadInfo(id);
        if (info == null) {
            continue;
        }
        String name = info.getThreadName();
        for (String p : prefixes) {
            if (name.startsWith(p)) {
                Thread.State state = info.getThreadState();
                Integer c = count.get(p, state);
                count.put(p, info.getThreadState(), c != null ? c++ : 1);
            }
        }
    }
    stdout.print(String.format("  %22s", ""));
    for (Thread.State s : Thread.State.values()) {
        stdout.print(String.format(" %14s", s.name()));
    }
    stdout.print('\n');
    for (String p : prefixes) {
        stdout.print(String.format("  %-22s", p));
        for (Thread.State s : Thread.State.values()) {
            stdout.print(String.format(" %14d", nullToZero(count.get(p, s))));
        }
        stdout.print('\n');
    }
    stdout.print('\n');
}
#method_after
private void threadSummary() {
    List<String> prefixes = Arrays.asList("HTTP", "IntraLineDiff", "ReceiveCommits", "SSH git-receive-pack", "SSH git-upload-pack", "SSH-Interactive-Worker", "SSH-Stream-Worker", "SshCommandStart");
    String other = "Other";
    Runtime r = Runtime.getRuntime();
    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
    stdout.format("Threads: %d CPUs available, %d threads\n", r.availableProcessors(), threadMXBean.getThreadCount());
    if (showThreads) {
        Table<String, Thread.State, Integer> count = HashBasedTable.create();
        for (long id : threadMXBean.getAllThreadIds()) {
            ThreadInfo info = threadMXBean.getThreadInfo(id);
            if (info == null) {
                continue;
            }
            String name = info.getThreadName();
            Thread.State state = info.getThreadState();
            String group = other;
            for (String p : prefixes) {
                if (name.startsWith(p)) {
                    group = p;
                    break;
                }
            }
            Integer c = count.get(group, state);
            count.put(group, state, c != null ? c + 1 : 1);
        }
        stdout.print(String.format("  %22s", ""));
        for (Thread.State s : Thread.State.values()) {
            stdout.print(String.format(" %14s", s.name()));
        }
        stdout.print('\n');
        for (String p : prefixes) {
            printThreadCounts(p, count.row(p));
        }
        printThreadCounts(other, count.row(other));
    }
    stdout.print('\n');
}
#end_block

#method_before
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    if (req.getQueryString() == null || req.getQueryString().isEmpty()) {
        // No query string? They want the project list, which we don't
        // currently support. Return to Gerrit's own web UI.
        // 
        rsp.sendRedirect(req.getContextPath() + "/");
        return;
    }
    final Map<String, String> params = getParameters(req);
    if (deniedActions.contains(params.get("a"))) {
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String name = params.get("p");
    if (name == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (name.endsWith(".git")) {
        name = name.substring(0, name.length() - 4);
    }
    final Project.NameKey nameKey = new Project.NameKey(name);
    final ProjectControl project;
    try {
        project = projectControl.validateFor(nameKey);
        if (!project.allRefsAreVisible() && !project.isOwner()) {
            // Pretend the project doesn't exist
            throw new NoSuchProjectException(nameKey);
        }
    } catch (NoSuchProjectException e) {
        if (project.getCurrentUser().isIdentifiedUser()) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            // allow anonymous users a chance to login
            // avoid leaking information by not distinguishing between project not existing and no access rights
            rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        }
        return;
    }
    final Repository repo;
    try {
        repo = repoManager.openRepository(nameKey);
    } catch (RepositoryNotFoundException e) {
        getServletContext().log("Cannot open repository", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    try {
        CacheHeaders.setNotCacheable(rsp);
        exec(req, rsp, project, repo);
    } finally {
        repo.close();
    }
}
#method_after
@Override
protected void service(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    if (req.getQueryString() == null || req.getQueryString().isEmpty()) {
        // No query string? They want the project list, which we don't
        // currently support. Return to Gerrit's own web UI.
        // 
        rsp.sendRedirect(req.getContextPath() + "/");
        return;
    }
    final Map<String, String> params = getParameters(req);
    if (deniedActions.contains(params.get("a"))) {
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    String name = params.get("p");
    if (name == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (name.endsWith(".git")) {
        name = name.substring(0, name.length() - 4);
    }
    final Project.NameKey nameKey = new Project.NameKey(name);
    final ProjectControl project;
    try {
        project = projectControl.validateFor(nameKey);
        if (!project.allRefsAreVisible() && !project.isOwner()) {
            // Pretend the project doesn't exist
            throw new NoSuchProjectException(nameKey);
        }
    } catch (NoSuchProjectException e) {
        if (userProvider.get().isIdentifiedUser()) {
            rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        } else {
            // Allow anonymous users a chance to login.
            // Avoid leaking information by not distinguishing between
            // project not existing and no access rights.
            rsp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        }
        return;
    }
    final Repository repo;
    try {
        repo = repoManager.openRepository(nameKey);
    } catch (RepositoryNotFoundException e) {
        getServletContext().log("Cannot open repository", e);
        rsp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        return;
    }
    try {
        CacheHeaders.setNotCacheable(rsp);
        exec(req, rsp, project, repo);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static Map<String, String> getParameters(HttpServletRequest req) {
    final Map<String, String> params = new HashMap<String, String>();
    for (final String pair : req.getQueryString().split("[&;]")) {
        final int eq = pair.indexOf('=');
        if (0 < eq) {
            String name = pair.substring(0, eq);
            String value = pair.substring(eq + 1);
            name = Url.decode(name);
            value = Url.decode(value);
            params.put(name, value);
        }
    }
    return params;
}
#method_after
private static Map<String, String> getParameters(HttpServletRequest req) {
    final Map<String, String> params = new HashMap<>();
    for (final String pair : req.getQueryString().split("[&;]")) {
        final int eq = pair.indexOf('=');
        if (0 < eq) {
            String name = pair.substring(0, eq);
            String value = pair.substring(eq + 1);
            name = Url.decode(name);
            value = Url.decode(value);
            params.put(name, value);
        }
    }
    return params;
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        if (changeMessage != null) {
            Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
            ChangeControl otherControl = refControl.getProjectControl().controlFor(otherChange);
            ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, change.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
            updateForOtherChange.commit();
        }
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = refControl.getProjectControl().controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = refControl.getProjectControl().getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, change, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (messageIsForChange()) {
        update.commit();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    }
    if (sendMail) {
        try {
            CreateChangeSender cm = createChangeSenderFactory.create(change);
            cm.setFrom(change.getOwner());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.addReviewers(reviewers);
            cm.addExtraCC(extraCC);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email for new change " + change.getId(), err);
        }
    }
    f.checkedGet();
    return change;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control);
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    f.checkedGet();
    return result;
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            if (changeMessage != null) {
                Change otherChange = db.changes().get(changeMessage.getPatchSetId().getParentKey());
                ChangeControl otherControl = ctlFactory.controlFor(otherChange, user);
                ChangeUpdate updateForOtherChange = updateFactory.create(otherControl, updatedChange.getLastUpdatedOn());
                cmUtil.addChangeMessage(db, updateForOtherChange, changeMessage);
                updateForOtherChange.commit();
            }
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException, NoSuchChangeException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(ctl, patchSet.getCreatedOn());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet);
        }
        db.commit();
        if (messageIsForChange()) {
            update.commit();
        }
        if (!messageIsForChange()) {
            commitMessageNotForChange(updatedChange);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(updatedChange).reindex().runAsync();
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, AbandonInput input) throws AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    ChangeMessage message;
    ChangeUpdate update;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        // TODO(yyonas): atomic update was not propagated
        update = updateFactory.create(control, change.getLastUpdatedOn());
        message = newMessage(input, caller, change);
        cmUtil.addChangeMessage(db, update, message);
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#method_after
private static List<ChangeMessage> sortChangeMessages(Iterable<ChangeMessage> changeMessage) {
    return ChangeNotes.MESSAGE_BY_TIME.sortedCopy(changeMessage);
}
#end_block

#method_before
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    List<ChangeMessage> changeMessages;
    if (!migration.readChangeMessages()) {
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> result = ImmutableListMultimap.builder();
        for (ChangeMessage cm : db.changeMessages().byChange(notes.getChangeId())) {
            result.put(cm.getPatchSetId(), cm);
        }
        changeMessages = sortChangeMessages(result.build().values());
    } else {
        changeMessages = sortChangeMessages(notes.load().getChangeMessages().values());
    }
    return changeMessages;
}
#method_after
public List<ChangeMessage> byChange(ReviewDb db, ChangeNotes notes) throws OrmException {
    if (!migration.readChangeMessages()) {
        return sortChangeMessages(db.changeMessages().byChange(notes.getChangeId()));
    } else {
        return sortChangeMessages(notes.load().getChangeMessages().values());
    }
}
#end_block

#method_before
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    List<ChangeMessage> cms = cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId());
    return Iterables.getFirst(Iterables.filter(Lists.reverse(cms), new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }), null);
}
#method_after
public ChangeMessage getConflictMessage(RevisionResource rsrc) throws OrmException {
    return FluentIterable.from(cmUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), rsrc.getPatchSet().getId())).filter(new Predicate<ChangeMessage>() {

        @Override
        public boolean apply(ChangeMessage input) {
            return input.getAuthor() == null;
        }
    }).last().orNull();
}
#end_block

#method_before
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    Collections.sort(msgs, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return b.getWrittenOn().compareTo(a.getWrittenOn());
        }
    });
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#method_after
private boolean isChangeReviewed(Account.Id self, ChangeData cd, List<ChangeMessage> msgs) throws OrmException {
    // Sort messages to keep the most recent ones at the beginning.
    msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy(msgs);
    Account.Id changeOwnerId = cd.change().getOwner();
    for (ChangeMessage cm : msgs) {
        if (self.equals(cm.getAuthor())) {
            return true;
        } else if (changeOwnerId.equals(cm.getAuthor())) {
            return false;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(summary);
        ChangeUpdate update;
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            // TODO(yyonas): atomic update was not propagated
            update = updateFactory.create(control);
            cmUtil.addChangeMessage(db, update, cmsg);
            db.commit();
        } finally {
            db.rollback();
        }
        update.commit();
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(submitter.getAccountId()));
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // I didn't see how this function was going to do anything different
        // if I did what was below or put it in the function and kept the lines in
        // there...I commented out the method below because ATM, it's not used.
        // addMergedMessage(submitter, msg);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException, NoSuchChangeException {
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // TODO(yyonas): we need to be able to change the author of the message
        // is not the person for whom the change was made. addMergedMessage
        // did this in the past.
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
    update.commit();
}
#end_block

#method_before
// private void addMergedMessage(PatchSetApproval submitter, ChangeMessage msg)
// throws OrmException {
// if (msg != null) {
// if (submitter != null && msg.getAuthor() == null) {
// msg.setAuthor(submitter.getAccountId());
// }
// db.changeMessages().insert(Collections.singleton(msg));
// }
// }
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO: atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change.getId());
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control, change.getCreatedOn());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
@Override
public void run() {
    try {
        rc.processCommands(commands, progress);
    } catch (NoSuchChangeException e) {
        // TODO(yyonas): Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void run() {
    rc.processCommands(commands, progress);
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) throws NoSuchChangeException {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c) || isConfig(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            try {
                switch(c.getType()) {
                    case CREATE:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case // otherwise known as a fast-forward
                    UPDATE:
                        tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case UPDATE_NONFASTFORWARD:
                        if (isHead(c) || isConfig(c)) {
                            autoCloseChanges(c);
                        }
                        break;
                    case DELETE:
                        break;
                }
                if (isConfig(c)) {
                    projectCache.evict(project);
                    ProjectState ps = projectCache.get(project.getNameKey());
                    // 
                    repoManager.setProjectDescription(// 
                    project.getNameKey(), ps.getProject().getDescription());
                }
                if (!MagicBranch.isMagicBranch(c.getRefName())) {
                    // We only fire gitRefUpdated for direct refs updates.
                    // Events for change refs are fired when they are created.
                    // 
                    gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
                }
            } catch (NoSuchChangeException e) {
                c.setResult(REJECTED_OTHER_REASON, "No such change: " + e.getMessage());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change));
        }
        addMessage("");
    }
    Iterable<ReplaceRequest> updated = Iterables.filter(replaceByChange.values(), new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    });
    if (!Iterables.isEmpty(updated)) {
        addMessage("");
        addMessage("Updated Changes:");
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change));
        }
        addMessage("");
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, NoSuchChangeException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.getLabels();
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, info, change, changeCtl, approvals);
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        cmUtil.addChangeMessage(db, update, msg);
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.newCheck().addChange(change).reindex().runAsync();
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException, NoSuchChangeException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result) throws OrmException, IOException, NoSuchChangeException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        ChangeControl control = ctlFactory.controlFor(change, currentUser);
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open").get();
    assertEquals(1, results.size());
    results = gApi.changes().query("status:closed").get();
    assertTrue(results.isEmpty());
}
#method_after
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = query("status:open");
    assertEquals(1, results.size());
    results = query("status:closed");
    assertTrue(results.isEmpty());
}
#end_block

#method_before
@Test
public void queryChangesOneTerm() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open").get();
    assertEquals(2, results.size());
    assertEquals(r2.getChangeId(), results.get(0).changeId);
    assertEquals(r1.getChangeId(), results.get(1).changeId);
}
#method_after
@Test
public void queryChangesOneTerm() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = query("status:open");
    assertEquals(2, results.size());
    assertEquals(r2.getChangeId(), results.get(0).changeId);
    assertEquals(r1.getChangeId(), results.get(1).changeId);
}
#end_block

#method_before
@Test
public void queryChangesMultipleTerms() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query("status:open " + r1.getChangeId()).get();
    assertEquals(r1.getChangeId(), Iterables.getOnlyElement(results).changeId);
}
#method_after
@Test
public void queryChangesMultipleTerms() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = query("status:open " + r1.getChangeId());
    assertEquals(r1.getChangeId(), Iterables.getOnlyElement(results).changeId);
}
#end_block

#method_before
@Test
public void queryChangesNoOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertNull(result.labels);
    assertNull(result.messages);
    assertNull(result.revisions);
    assertNull(result.actions);
}
#method_after
@Test
public void queryChangesNoOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(query(r.getChangeId()));
    assertNull(result.labels);
    assertNull(result.messages);
    assertNull(result.revisions);
    assertNull(result.actions);
}
#end_block

#method_before
@Test
public void queryChangesReviewerAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    QueryRequest q = gApi.changes().query("owner:self");
    assertEquals(r.getChangeId(), Iterables.getOnlyElement(q.get()).changeId);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setAccountContext(user);
    revision(r).review(ReviewInput.recommend());
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertTrue(result.reviewed);
}
#method_after
@Test
public void queryChangesReviewerAfterReview() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertNull(get(r.getChangeId()).reviewed);
    revision(r).review(ReviewInput.recommend());
    assertTrue(get(r.getChangeId()).reviewed);
}
#end_block

#method_before
@Test
public void queryChangesReviewerNotReviewed() throws Exception {
    PushOneCommit.Result r = createChange();
    QueryRequest q = gApi.changes().query("owner:self");
    assertEquals(r.getChangeId(), Iterables.getOnlyElement(q.get()).changeId);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setAccountContext(user);
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertNull(result.reviewed);
}
#method_after
@Test
public void queryChangesReviewerNotReviewed() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id("p~master~" + r.getChangeId()).addReviewer(in);
    setApiUser(user);
    assertNull(get(r.getChangeId()).reviewed);
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        args.db.changes().update(Collections.singletonList(n.change));
        args.db.patchSetApprovals().insert(approvals);
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(TimeUtil.nowTs());
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    final RefUpdate ru;
    args.db.changes().beginTransaction(n.change.getId());
    try {
        insertAncestors(args.db, ps.getId(), newCommit);
        args.db.patchSets().insert(Collections.singleton(ps));
        n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
        args.db.changes().update(Collections.singletonList(n.change));
        final List<PatchSetApproval> approvals = Lists.newArrayList();
        for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
            approvals.add(new PatchSetApproval(ps.getId(), a));
        }
        args.db.patchSetApprovals().insert(approvals);
        ru = args.repo.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(args.rw) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
        }
        args.db.commit();
    } finally {
        args.db.rollback();
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        if (holder.plugin.getApiType() == ApiType.JS) {
            sendJsPlugin(holder.plugin, key, req, res);
        } else {
            JarFile jar = new JarFile(holder.plugin.getSrcFile());
            try {
                JarEntry entry = jar.getJarEntry(file);
                if (exists(entry)) {
                    sendResource(jar, entry, key, res);
                } else {
                    resourceCache.put(key, Resource.NOT_FOUND);
                    Resource.NOT_FOUND.send(req, res);
                }
            } finally {
                jar.close();
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix) && holder.plugin.getSrcFile().getName().endsWith(".jar")) {
        JarFile jar = new JarFile(holder.plugin.getSrcFile());
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = jarFileOf(holder.plugin);
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res, holder.plugin.getSrcFile().lastModified());
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(String md, String pluginName, ResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws UnsupportedEncodingException, IOException {
    Map<String, String> macros = Maps.newHashMap();
    macros.put("PLUGIN", pluginName);
    macros.put("SSH_HOST", sshHost);
    macros.put("SSH_PORT", "" + sshPort);
    String url = webUrl.get();
    if (Strings.isNullOrEmpty(url)) {
        url = "http://review.example.com/";
    }
    macros.put("URL", url);
    Matcher m = Pattern.compile("(\\\\)?@([A-Z_]+)@").matcher(md);
    StringBuffer sb = new StringBuffer();
    while (m.find()) {
        String key = m.group(2);
        String val = macros.get(key);
        if (m.group(1) != null) {
            m.appendReplacement(sb, "@" + key + "@");
        } else if (val != null) {
            m.appendReplacement(sb, val);
        } else {
            m.appendReplacement(sb, "@" + key + "@");
        }
    }
    m.appendTail(sb);
    byte[] html = new MarkdownFormatter().markdownToDocHtml(sb.toString(), "UTF-8");
    resourceCache.put(cacheKey, new SmallResource(html).setContentType("text/html").setCharacterEncoding("UTF-8").setLastModified(lastModifiedTime));
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(html.length);
    res.getOutputStream().write(html);
}
#end_block

#method_before
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res);
}
#method_after
private void sendMarkdownAsHtml(JarFile jar, JarEntry entry, String pluginName, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] rawmd = readWholeEntry(jar, entry);
    String encoding = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        encoding = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    String txtmd = RawParseUtils.decode(Charset.forName(encoding != null ? encoding : "UTF-8"), rawmd);
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    sendMarkdownAsHtml(txtmd, pluginName, key, res, time);
}
#end_block

#method_before
private static String getPrefix(Plugin plugin, String attr, String def) {
    File srcFile = plugin.getSrcFile();
    if (srcFile == null || !srcFile.getName().endsWith(".jar")) {
        return def;
    }
    try {
        JarFile jarFile = new JarFile(plugin.getSrcFile());
        try {
            String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
            if (prefix != null) {
                return CharMatcher.is('/').trimFrom(prefix) + "/";
            } else {
                return def;
            }
        } finally {
            jarFile.close();
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#method_after
private static String getPrefix(Plugin plugin, String attr, String def) {
    JarFile jarFile = jarFileOf(plugin);
    if (jarFile == null) {
        return def;
    }
    try {
        String prefix = jarFile.getManifest().getMainAttributes().getValue(attr);
        if (prefix != null) {
            return CharMatcher.is('/').trimFrom(prefix) + "/";
        } else {
            return def;
        }
    } catch (IOException e) {
        log.warn(String.format("Error getting %s for plugin %s, using default", attr, plugin.getName()), e);
        return null;
    }
}
#end_block

#method_before
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile)).toLowerCase();
}
#method_after
public static String getPluginName(File srcFile) throws IOException {
    return Objects.firstNonNull(getGerritPluginName(srcFile), nameOf(srcFile));
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    persistentCacheFactory.onStop(plugin);
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    env.onStopPlugin(plugin);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarScanner(srcJar), manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new ServerPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, new JarFile(srcJar), new JarScanner(srcJar), new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Manifest getPluginManifest(PluginScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#method_after
private Manifest getPluginManifest(PluginContentScanner scanner) throws InvalidPluginException {
    try {
        return scanner.getManifest();
    } catch (IOException e) {
        throw new InvalidPluginException("Cannot get plugin manifest", e);
    }
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps1, changeMessages.get(0).getPatchSetId());
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Just a little code change.\n", cm.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm.getAuthor());
    assertEquals(ps1, cm.getPatchSetId());
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(0).getAuthor());
    assertEquals(ps2, changeMessages.get(0).getPatchSetId());
    assertEquals("This is the change message for the first PS.", changeMessages.get(1).getMessage());
    assertEquals(changeOwner.getAccount().getId(), changeMessages.get(1).getAuthor());
    assertEquals(ps1, changeMessages.get(1).getPatchSetId());
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("This is the change message for the first PS.", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
    ChangeMessage cm2 = Iterables.getOnlyElement(changeMessages.get(ps2));
    assertEquals(ps1, cm1.getPatchSetId());
    assertEquals("This is the change message for the second PS.", cm2.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm2.getAuthor());
    assertEquals(ps2, cm2.getPatchSetId());
}
#end_block

#method_before
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.size());
}
#method_after
@Test
public void noChangeMessage() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(0, changeMessages.keySet().size());
}
#end_block

#method_before
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing trailing double newline\n" + "\n", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithTrailingDoubleNewline() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing trailing double newline\n" + "\n");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing trailing double newline\n" + "\n" + "\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing trailing double newline\n" + "\n", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    List<ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", changeMessages.get(0).getMessage());
}
#method_after
@Test
public void changeMessageWithMultipleParagraphs() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    RevWalk walk = new RevWalk(repo);
    try {
        RevCommit commit = walk.parseCommit(update.getRevision());
        walk.parseBody(commit);
        assertEquals("Update patch set 1\n" + "\n" + "Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3\n" + "\n" + "Patch-set: 1\n", commit.getFullMessage());
    } finally {
        walk.release();
    }
    ChangeNotes notes = newNotes(c);
    ListMultimap<PatchSet.Id, ChangeMessage> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.keySet().size());
    ChangeMessage cm1 = Iterables.getOnlyElement(changeMessages.get(ps1));
    assertEquals("Testing paragraph 1\n" + "\n" + "Testing paragraph 2\n" + "\n" + "Testing paragraph 3", cm1.getMessage());
    assertEquals(changeOwner.getAccount().getId(), cm1.getAuthor());
}
#end_block

#method_before
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessageString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMessageString);
    changeMessages.add(changeMessage);
}
#method_after
private void parseChangeMessage(PatchSet.Id psId, Account.Id accountId, RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMsgString = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(psId.getParentKey(), commit.name()), accountId, new Timestamp(commit.getCommitterIdent().getWhen().getTime()), psId);
    changeMessage.setMessage(changeMsgString);
    changeMessages.put(psId, changeMessage);
}
#end_block

#method_before
public ImmutableList<ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessages() {
    return changeMessages;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
        changeMessages = ImmutableList.copyOf(parser.changeMessages);
    } finally {
        walk.release();
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    RevWalk walk = new RevWalk(reader);
    try {
        Parser parser = new Parser(change.getId(), rev, walk);
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        ImmutableSetMultimap.Builder<ReviewerState, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerState> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        ImmutableListMultimap.Builder<PatchSet.Id, ChangeMessage> cms = ImmutableListMultimap.builder();
        for (Map.Entry<PatchSet.Id, ChangeMessage> e : parser.changeMessages.entries()) {
            cms.put(e.getKey(), e.getValue());
        }
        this.changeMessages = cms.build();
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableList.of();
}
#method_after
private void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    changeMessages = ImmutableListMultimap.of();
}
#end_block

#method_before
private void parseChangeMessage(RevCommit commit) {
    final byte[] raw = commit.getRawBuffer();
    final int size = raw.length;
    final Charset enc = RawParseUtils.parseEncoding(raw);
    final int headerStart = RawParseUtils.commitMessage(raw, 0);
    if (headerStart < 0)
        return;
    int headerEnd = RawParseUtils.endOfParagraph(raw, headerStart);
    if (headerEnd == size)
        return;
    int changeMsgStart = headerEnd + 2;
    // 2 is for the \n\n that will be between the subject line and the
    // message we want
    int changeMsgEnd = RawParseUtils.endOfParagraph(raw, changeMsgStart);
    if (changeMsgEnd == size)
        return;
    String str = RawParseUtils.decode(enc, raw, changeMsgStart, changeMsgEnd);
    changeMessages.add(str);
}
#method_after
private void parseChangeMessage(RevCommit commit) {
    byte[] raw = commit.getRawBuffer();
    int size = raw.length;
    Charset enc = RawParseUtils.parseEncoding(raw);
    int subjectStart = RawParseUtils.commitMessage(raw, 0);
    if (subjectStart < 0 || subjectStart >= size) {
        return;
    }
    int subjectEnd = RawParseUtils.endOfParagraph(raw, subjectStart);
    if (subjectEnd == size) {
        return;
    }
    int changeMessageStart;
    if (raw[subjectEnd] == '\n') {
        // \n\n ends paragraph
        changeMessageStart = subjectEnd + 2;
    } else if (raw[subjectEnd] == '\r') {
        // \r\n\r\n ends paragraph
        changeMessageStart = subjectEnd + 4;
    } else {
        return;
    }
    int ptr = size - 1;
    int changeMessageEnd = -1;
    while (ptr > changeMessageStart) {
        ptr = RawParseUtils.prevLF(raw, ptr, '\r');
        if (ptr == -1) {
            break;
        }
        if (raw[ptr] == '\n') {
            changeMessageEnd = ptr - 1;
            break;
        } else if (raw[ptr] == '\r') {
            changeMessageEnd = ptr - 3;
            break;
        }
    }
    if (ptr <= changeMessageStart) {
        return;
    }
    String changeMessage = RawParseUtils.decode(enc, raw, changeMessageStart, changeMessageEnd + 1);
    changeMessages.add(changeMessage);
}
#end_block

#method_before
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\nTesting new line");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\nTesting new line", changeMessages.get(0));
}
#method_after
@Test
public void changeMessageOnePatchSet() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("Just a little code change.\n");
    update.commit();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(1, changeMessages.size());
    assertEquals("Just a little code change.\n", changeMessages.get(0));
}
#end_block

#method_before
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#method_after
@Test
public void changeMessagesMultiplePatchSets() throws Exception {
    Change c = newChange();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.setChangeMessage("This is the change message for the first PS.");
    update.commit();
    PatchSet.Id ps1 = c.currentPatchSetId();
    incrementPatchSet(c);
    update = newUpdate(c, changeOwner);
    update.setChangeMessage("This is the change message for the second PS.");
    update.commit();
    PatchSet.Id ps2 = c.currentPatchSetId();
    ChangeNotes notes = newNotes(c);
    List<String> changeMessages = notes.getChangeMessages();
    assertEquals(2, changeMessages.size());
    assertEquals("This is the change message for the second PS.", changeMessages.get(0));
    assertEquals("This is the change message for the first PS.", changeMessages.get(1));
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    return new UiAction.Description().setLabel(label).setTitle(String.format(tooltip, resource.getPatchSet().getPatchSetId(), resource.getChange().getDest().getShortName())).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    RevId revId = resource.getPatchSet().getRevision();
    Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
    return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(!resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit());
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo actionInfo = actions.get("submit");
            submit.setTitle(actionInfo.title());
            submit.setText(actionInfo.label());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            ActionInfo action = actions.get("submit");
            submit.setTitle(action.title());
            submit.setHTML(new SafeHtmlBuilder().openDiv().append(action.label()).closeDiv());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    ownerPanel.insert(new AvatarImage(info.owner()), 0);
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        p.insert(new AvatarImage(AccountInfo.create(0, person.name(), person.email())), 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email()));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public ChangeApi create(ChangeInfo in) throws RestApiException {
    try {
        ChangeJson.ChangeInfo out = createChangeFactory.create().apply(TopLevelResource.INSTANCE, in).value();
        return api.create(changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(out.changeId)));
    } catch (OrmException | IOException | InvalidChangeOperationException e) {
        throw new RestApiException("Cannot create change", e);
    }
}
#method_after
@Override
public ChangeApi create(ChangeInfo in) throws RestApiException {
    try {
        ChangeJson.ChangeInfo out = createChange.apply(TopLevelResource.INSTANCE, in).value();
        return api.create(changes.parse(TopLevelResource.INSTANCE, IdString.fromUrl(out.changeId)));
    } catch (OrmException | IOException | InvalidChangeOperationException e) {
        throw new RestApiException("Cannot create change", e);
    }
}
#end_block

#method_before
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, true, ValidatePolicy.GERRIT);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#method_after
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db.get(), change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, true, ValidatePolicy.GERRIT);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
private void postAdd(Change change, List<PatchSetApproval> added) throws OrmException, EmailException {
    if (added.isEmpty()) {
        return;
    }
    // Execute hook for added reviewers
    // 
    PatchSet patchSet = dbProvider.get().patchSets().get(change.currentPatchSetId());
    for (PatchSetApproval psa : added) {
        Account account = accountCache.get(psa.getAccountId()).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, dbProvider.get());
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    IdentifiedUser idenitifiedUser = (IdentifiedUser) currentUser.get();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(idenitifiedUser.getAccountId())) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change);
            cm.setFrom(idenitifiedUser.getAccountId());
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void postAdd(Change change, List<PatchSetApproval> added) throws OrmException, EmailException {
    if (added.isEmpty()) {
        return;
    }
    // Execute hook for added reviewers
    // 
    PatchSet patchSet = dbProvider.get().patchSets().get(change.currentPatchSetId());
    for (PatchSetApproval psa : added) {
        Account account = accountCache.get(psa.getAccountId()).getAccount();
        hooks.doReviewerAddedHook(change, account, patchSet, dbProvider.get());
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    IdentifiedUser identifiedUser = (IdentifiedUser) currentUser.get();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(identifiedUser.getAccountId())) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change);
            cm.setFrom(identifiedUser.getAccountId());
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChangeFactory.create();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public CreateChange post(TopLevelResource parent) throws RestApiException {
    return createChange;
}
#end_block

#method_before
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.get().parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            Ref destRef = git.getRef(refName);
            if (destRef == null) {
                throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
            }
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit mergeTip = rw.parseCommit(destRef.getObjectId());
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#method_after
@Override
public Response<ChangeJson.ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws AuthException, OrmException, BadRequestException, UnprocessableEntityException, IOException, InvalidChangeOperationException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
    }
    String refName = input.branch;
    if (!refName.startsWith(Constants.R_REFS)) {
        refName = Constants.R_HEADS + input.branch;
    }
    ProjectResource rsrc = projectsCollection.get().parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    Repository git = gitManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(git);
        try {
            Ref destRef = git.getRef(refName);
            if (destRef == null) {
                throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
            }
            Timestamp now = TimeUtil.nowTs();
            IdentifiedUser me = (IdentifiedUser) userProvider.get();
            PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
            RevCommit mergeTip = rw.parseCommit(destRef.getObjectId());
            ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(git, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), me.getAccountId(), new Branch.NameKey(project, destRef.getName()), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c);
            validateCommit(git, refControl, c, me, ins);
            updateRef(git, rw, c, change, ins.getPatchSet());
            change.setTopic(input.topic);
            change.setStatus(ChangeInfoMapper.changeStatus2Status(input.status));
            ins.insert();
            return Response.created(json.format(change.getId()));
        } finally {
            rw.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = control2(cd);
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(control2(cd)), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Set<Change.Id> reviewed, Optional<PatchSet.Id> limitToPsId) throws OrmException {
    ChangeControl ctl = cd.changeControl().forUser(userProvider.get());
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = userProvider.get().getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && has(REVIEWED) && reviewed.contains(cd.getId()) ? true : null;
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, cd, out.labels.values());
    }
    Map<PatchSet.Id, PatchSet> src = loadPatchSets(cd, limitToPsId);
    if (has(MESSAGES)) {
        out.messages = messages(ctl, cd, src);
    }
    out.finish();
    if (has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent()) {
        out.revisions = revisions(ctl, cd, limitToPsId, out.project, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(changeViews, changes.parse(ctl), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    return out;
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    final CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!(user.isIdentifiedUser())) {
        throw new ResourceNotFoundException();
    }
    if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.indexOf('.');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#method_after
@Override
public CacheResource parse(ConfigResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    CurrentUser user = self.get();
    if (user instanceof AnonymousUser) {
        throw new AuthException("Authentication required");
    } else if (!user.isIdentifiedUser()) {
        throw new ResourceNotFoundException();
    } else if (!user.getCapabilities().canViewCaches()) {
        throw new AuthException("not allowed to view caches");
    }
    String cacheName = id.get();
    String pluginName = "gerrit";
    int i = cacheName.lastIndexOf('-');
    if (i != -1) {
        pluginName = cacheName.substring(0, i);
        cacheName = cacheName.length() > i + 1 ? cacheName.substring(i + 1) : "";
    }
    Provider<Cache<?, ?>> cacheProvider = cacheMap.byPlugin(pluginName).get(cacheName);
    if (cacheProvider == null) {
        throw new ResourceNotFoundException(id);
    }
    return new CacheResource(pluginName, cacheName, cacheProvider);
}
#end_block

#method_before
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryCoreCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (!cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains(".") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#method_after
private void printMemoryPluginCaches(Collection<CacheInfo> caches) {
    for (CacheInfo cache : caches) {
        if (cache.name.contains("-") && CacheType.MEM.equals(cache.type)) {
            printCache(cache);
        }
    }
}
#end_block

#method_before
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsProcent(cache.hitRatio.mem), formatAsProcent(cache.hitRatio.disk)));
}
#method_after
private void printCache(CacheInfo cache) {
    stdout.print(String.format("%1s %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", CacheType.DISK.equals(cache.type) ? "D" : "", cache.name, nullToEmpty(cache.entries.mem), nullToEmpty(cache.entries.disk), Strings.nullToEmpty(cache.entries.space), Strings.nullToEmpty(cache.averageGet), formatAsPercent(cache.hitRatio.mem), formatAsPercent(cache.hitRatio.disk)));
}
#end_block

#method_before
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (Map.Entry<String, Cache<?, ?>> entry : getCaches().entrySet()) {
        cacheInfos.put(entry.getKey(), new CacheInfo(entry.getValue()));
    }
    return cacheInfos;
}
#method_after
@Override
public Map<String, CacheInfo> apply(ConfigResource rsrc) {
    Map<String, CacheInfo> cacheInfos = new TreeMap<>();
    for (DynamicMap.Entry<Cache<?, ?>> e : cacheMap) {
        cacheInfos.put(cacheNameOf(e.getPluginName(), e.getExportName()), new CacheInfo(e.getProvider().get()));
    }
    return cacheInfos;
}
#end_block

#method_before
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "." + name;
    }
}
#method_after
private static String cacheNameOf(String plugin, String name) {
    if ("gerrit".equals(plugin)) {
        return name;
    } else {
        return plugin + "-" + name;
    }
}
#end_block

#method_before
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private static String duration(double ns) {
    if (ns < 0.5) {
        return null;
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s";
    }
    return String.format("%4.1f%s", ns, suffix).trim();
}
#end_block

#method_before
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix);
}
#method_after
private static String bytes(double value) {
    value /= 1024;
    String suffix = "k";
    if (value > 1024) {
        value /= 1024;
        suffix = "m";
    }
    if (value > 1024) {
        value /= 1024;
        suffix = "g";
    }
    return String.format("%1$6.2f%2$s", value, suffix).trim();
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    change.getProject();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    result.submitType = submitType.apply(resource);
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Map<String, Ref> refs = git.getRefDatabase().getRefs(RefDatabase.ALL);
        Ref ref = refs.get(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, result.submitType, git, refs, ref);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            ProjectConfig cfg = projectCache.get(change.getProject()).getConfig();
            BranchOrderSection branchOrder = cfg.getBranchOrderSection();
            int prefixLen = Constants.R_HEADS.length();
            for (String n : branchOrder.getMoreStable(ref.getName())) {
                Ref other = git.getRef(n);
                if (isMergeable(change, ps, SubmitType.CHERRY_PICK, git, refs, other)) {
                    result.mergeableInto.add(other.getName().substring(prefixLen));
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    result.submitType = submitType.apply(resource);
    result.mergeable = change.isMergeable();
    Repository git = gitManager.openRepository(change.getProject());
    try {
        Map<String, Ref> refs = git.getRefDatabase().getRefs(RefDatabase.ALL);
        Ref ref = refs.get(change.getDest().get());
        if (force || isStale(change, ref)) {
            result.mergeable = refresh(change, ps, result.submitType, git, refs, ref);
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectCache.get(change.getProject()).getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = refs.get(n);
                    if (other == null) {
                        continue;
                    }
                    if (isMergeable(change, ps, SubmitType.CHERRY_PICK, git, refs, other)) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    } finally {
        git.close();
    }
    return result;
}
#end_block

#method_before
public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
        return order.subList(i + 1, order.size());
    } else {
        return Collections.emptyList();
    }
}
#method_after
public List<String> getMoreStable(String branch) {
    int i = order.indexOf(fullName(branch));
    if (0 <= i) {
        return order.subList(i + 1, order.size());
    } else {
        return ImmutableList.of();
    }
}
#end_block

#method_before
private void loadBranchOrderSection(Config rc) {
    branchOrderSection = new BranchOrderSection(rc.getStringList(BRANCH_ORDER, null, BRANCH));
}
#method_after
private void loadBranchOrderSection(Config rc) {
    if (rc.getSections().contains(BRANCH_ORDER)) {
        branchOrderSection = new BranchOrderSection(rc.getStringList(BRANCH_ORDER, null, BRANCH));
    }
}
#end_block

#method_before
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public List<ProjectInfo> get() throws RestApiException {
            return ProjectsImpl.this.list(this);
        }
    };
}
#method_after
@Override
public ListRequest list() {
    return new ListRequest() {

        @Override
        public List<ProjectInfo> get() throws RestApiException {
            return list(this);
        }
    };
}
#end_block

#method_before
private List<ProjectInfo> list(final ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());
    Map<String, ProjectInfo> result = lp.apply();
    return ImmutableList.copyOf(result.values());
}
#method_after
private List<ProjectInfo> list(ListRequest request) throws RestApiException {
    ListProjects lp = listProvider.get();
    lp.setShowDescription(request.getDescription());
    lp.setLimit(request.getLimit());
    lp.setStart(request.getStart());
    lp.setMatchPrefix(request.getPrefix());
    return ImmutableList.copyOf(lp.apply().values());
}
#end_block

#method_before
@Test
public void listProjects() throws Exception {
    List<ProjectInfo> initialProjects = gApi.projects().list().get();
    createProject(sshSession, "foo");
    createProject(sshSession, "bar");
    List<ProjectInfo> results = gApi.projects().list().get();
    assertEquals(initialProjects.size() + 2, results.size());
}
#method_after
@Test
public void listProjects() throws Exception {
    List<ProjectInfo> initialProjects = gApi.projects().list().get();
    gApi.projects().name("foo").create();
    gApi.projects().name("bar").create();
    List<ProjectInfo> allProjects = gApi.projects().list().get();
    assertEquals(initialProjects.size() + 2, allProjects.size());
    List<ProjectInfo> projectsWithDescription = gApi.projects().list().withDescription(true).get();
    assertNotNull(projectsWithDescription.get(0).description);
    List<ProjectInfo> projectsWithoutDescription = gApi.projects().list().withDescription(false).get();
    assertNull(projectsWithoutDescription.get(0).description);
    List<ProjectInfo> noMatchingProjects = gApi.projects().list().withPrefix("fox").get();
    assertEquals(0, noMatchingProjects.size());
    List<ProjectInfo> matchingProject = gApi.projects().list().withPrefix("fo").get();
    assertEquals(1, matchingProject.size());
    List<ProjectInfo> limitOneProject = gApi.projects().list().withLimit(1).get();
    assertEquals(1, limitOneProject.size());
    List<ProjectInfo> startAtOneProjects = gApi.projects().list().withStart(1).get();
    assertEquals(allProjects.size() - 1, startAtOneProjects.size());
}
#end_block

#method_before
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
    } else {
        addStyleName(style.hideA());
    }
}
#method_after
void setVisibleA(boolean show) {
    visibleA = show;
    if (show) {
        removeStyleName(style.hideA());
        // match B's viewport
        parent.syncScroll(DisplaySide.B);
    } else {
        addStyleName(style.hideA());
    }
}
#end_block

#method_before
void set(JsArray<RevisionInfo> list, DiffInfo info) {
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    if (info.change_type() == ChangeType.ADDED) {
        // TODO(davido): Add user preference to control it,
        // as not all users would probably like this per default
        setVisibleA(false);
    }
}
#method_after
void set(DiffPreferences prefs, JsArray<RevisionInfo> list, DiffInfo info) {
    this.changeType = info.change_type();
    patchSetSelectBoxA.setUpPatchSetNav(list, info.meta_a());
    patchSetSelectBoxB.setUpPatchSetNav(list, info.meta_b());
    JsArrayString hdr = info.diff_header();
    if (hdr != null) {
        StringBuilder b = new StringBuilder();
        for (int i = 1; i < hdr.length(); i++) {
            String s = hdr.get(i);
            if (s.startsWith("diff --git ") || s.startsWith("index ") || s.startsWith("+++ ") || s.startsWith("--- ")) {
                continue;
            }
            b.append(s).append('\n');
        }
        String hdrTxt = b.toString().trim();
        header = !hdrTxt.isEmpty();
        diffHeaderText.setInnerText(hdrTxt);
        UIObject.setVisible(diffHeaderRow, header);
    } else {
        header = false;
        UIObject.setVisible(diffHeaderRow, false);
    }
    setHideEmptyPane(prefs.hideEmptyPane());
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId base = projectConfig.getRevision();
            projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, projectConfig.getRevision())) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), base, projectConfig.getRevision(), user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            ObjectId baseRev = projectConfig.getRevision();
            ObjectId commitRev = projectConfig.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                IdentifiedUser user = (IdentifiedUser) currentUser.get();
                hooks.doRefUpdatedHook(new Branch.NameKey(projectName, GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            ;
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), config, views);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId base = config.getRevision();
            config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(base, config.getRevision())) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), base, config.getRevision(), user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public Object apply(ProjectResource resource, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, IOException {
    if (input == null) {
        // Delete would set description to null.
        input = new Input();
    }
    ProjectControl ctl = resource.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!ctl.isOwner()) {
        throw new AuthException("not project owner");
    }
    try {
        MetaDataUpdate md = updateFactory.create(resource.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setDescription(Strings.emptyToNull(input.description));
            String msg = Objects.firstNonNull(Strings.emptyToNull(input.commitMessage), "Updated description.\n");
            if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            ObjectId baseRev = config.getRevision();
            ObjectId commitRev = config.commit(md);
            // Only fire hook if project was actually changed.
            if (!Objects.equal(baseRev, commitRev)) {
                hooks.doRefUpdatedHook(new Branch.NameKey(resource.getNameKey(), GitRepositoryManager.REF_CONFIG), baseRev, commitRev, user.getAccount());
            }
            cache.evict(ctl.getProject());
            gitMgr.setProjectDescription(resource.getNameKey(), project.getDescription());
            return Strings.isNullOrEmpty(project.getDescription()) ? Response.none() : project.getDescription();
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(resource.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
@Test
public void listPatchesAgainstBase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException {
    // Change 1, 1 (+FILE_A)
    add(git, FILE_A, "1");
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/for/master", false);
    // Compare Change 1,1 with Base (+FILE_A)
    List<PatchListEntry> entries = getCurrentPatches(c.getChangeId());
    assertEquals(2, entries.size());
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_A, entries.get(1));
    // Change 1,2 (+FILE_A, +FILE_B)
    add(git, FILE_B, "2");
    c = amendCommit(git, admin.getIdent(), SUBJECT_1, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    entries = getCurrentPatches(c.getChangeId());
    assertEquals(3, entries.size());
    // Compare Change 1,2 with Base (+FILE_A, +FILE_B)
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_A, entries.get(1));
    assertName(FILE_B, entries.get(2));
}
#method_after
@Test
public void listPatchesAgainstBase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException, RestApiException {
    add(git, FILE_D, "4");
    createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/heads/master", false);
    // Change 1, 1 (+FILE_A, -FILE_D)
    add(git, FILE_A, "1");
    rm(git, FILE_D);
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    // Compare Change 1,1 with Base (+FILE_A, -FILE_D)
    List<PatchListEntry> entries = getCurrentPatches(c.getChangeId());
    assertEquals(3, entries.size());
    assertAdded(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_A, entries.get(1));
    assertDeleted(FILE_D, entries.get(2));
    // Change 1,2 (+FILE_A, +FILE_B, -FILE_D)
    add(git, FILE_B, "2");
    c = amendCommit(git, admin.getIdent(), SUBJECT_2, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    entries = getCurrentPatches(c.getChangeId());
    // Compare Change 1,2 with Base (+FILE_A, +FILE_B, -FILE_D)
    assertEquals(4, entries.size());
    assertAdded(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_A, entries.get(1));
    assertAdded(FILE_B, entries.get(2));
    assertDeleted(FILE_D, entries.get(3));
}
#end_block

#method_before
@Test
public void listPatchesAgainstBaseWithRebase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException {
    // Change 1,1 (+FILE_A)
    add(git, FILE_A, "1");
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/for/master", false);
    List<PatchListEntry> entries = getCurrentPatches(c.getChangeId());
    assertEquals(2, entries.size());
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_A, entries.get(1));
    // Change 2,1 (+FILE_B)
    git.reset().setMode(ResetType.HARD).setRef("HEAD~1").call();
    add(git, FILE_B, "2");
    createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    // Change 1,2 (+FILE_A)
    git.cherryPick().include(c.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    // Compare Change 1,2 with Base (+FILE_A)
    entries = getCurrentPatches(c.getChangeId());
    assertEquals(2, entries.size());
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_A, entries.get(1));
}
#method_after
@Test
public void listPatchesAgainstBaseWithRebase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException, RestApiException {
    add(git, FILE_D, "4");
    createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/heads/master", false);
    // Change 1,1 (+FILE_A, -FILE_D)
    add(git, FILE_A, "1");
    rm(git, FILE_D);
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    List<PatchListEntry> entries = getCurrentPatches(c.getChangeId());
    assertEquals(3, entries.size());
    assertAdded(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_A, entries.get(1));
    assertDeleted(FILE_D, entries.get(2));
    // Change 2,1 (+FILE_B)
    git.reset().setMode(ResetType.HARD).setRef("HEAD~1").call();
    add(git, FILE_B, "2");
    createCommit(git, admin.getIdent(), SUBJECT_3);
    pushHead(git, "refs/for/master", false);
    // Change 1,2 (+FILE_A, -FILE_D))
    git.cherryPick().include(c.getCommit()).call();
    pushHead(git, "refs/for/master", false);
    // Compare Change 1,2 with Base (+FILE_A, -FILE_D))
    entries = getCurrentPatches(c.getChangeId());
    assertEquals(3, entries.size());
    assertAdded(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_A, entries.get(1));
    assertDeleted(FILE_D, entries.get(2));
}
#end_block

#method_before
@Test
public void listPatchesAgainstOtherPatchSet() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException {
    // Change 1,1 (+FILE_A)
    add(git, FILE_A, "1");
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/for/master", false);
    ObjectId a = getCurrentRevisionId(c.getChangeId());
    // Change 1,2 (+FILE_A, +FILE_B)
    add(git, FILE_B, "2");
    c = amendCommit(git, admin.getIdent(), SUBJECT_1, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    ObjectId b = getCurrentRevisionId(c.getChangeId());
    // Compare Change 1,1 with Change 1,2 (+FILE_B)
    List<PatchListEntry> entries = getPatches(a, b);
    assertEquals(2, entries.size());
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_B, entries.get(1));
}
#method_after
@Test
public void listPatchesAgainstOtherPatchSet() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException, RestApiException {
    add(git, FILE_D, "4");
    createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/heads/master", false);
    // Change 1,1 (+FILE_A, +FILE_C, -FILE_D)
    add(git, FILE_A, "1");
    add(git, FILE_C, "3");
    rm(git, FILE_D);
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    ObjectId a = getCurrentRevisionId(c.getChangeId());
    // Change 1,2 (+FILE_A, +FILE_B, -FILE_D)
    add(git, FILE_B, "2");
    rm(git, FILE_C);
    c = amendCommit(git, admin.getIdent(), SUBJECT_2, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    ObjectId b = getCurrentRevisionId(c.getChangeId());
    // Compare Change 1,1 with Change 1,2
    // expected: +FILE_B
    // actual: +FILE_B, -FILE_C
    // -FILE_C is wrongly returned, it is not contained in Change 1,2
    // but was only added in Change 1,1
    List<PatchListEntry> entries = getPatches(a, b);
    assertEquals(3, entries.size());
    assertModified(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_B, entries.get(1));
    assertDeleted(FILE_C, entries.get(2));
}
#end_block

#method_before
@Test
public void listPatchesAgainstOtherPatchSetWithRebase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException {
    // Change 1,1 (+FILE_A)
    add(git, FILE_A, "1");
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/for/master", false);
    ObjectId a = getCurrentRevisionId(c.getChangeId());
    // Change 2,1 (+FILE_B)
    git.reset().setMode(ResetType.HARD).setRef("HEAD~1").call();
    add(git, FILE_B, "2");
    createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    // Change 1,2 (+FILE_A, +FILE_C)
    git.cherryPick().include(c.getCommit()).call();
    add(git, FILE_C, "2");
    c = amendCommit(git, admin.getIdent(), SUBJECT_1, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    ObjectId b = getCurrentRevisionId(c.getChangeId());
    // Compare Change 1,1 with Change 1,2
    // expected: +FILE_C
    // actual: +FILE_B, +FILE_C
    // +FILE_B is wrongly returned, it is neither contained in Change 1,1
    // nor in Change 1,2, but was only changed due to the rebase
    // on Change 2,1
    List<PatchListEntry> entries = getPatches(a, b);
    assertEquals(3, entries.size());
    assertName(Patch.COMMIT_MSG, entries.get(0));
    assertName(FILE_B, entries.get(1));
    assertName(FILE_C, entries.get(2));
}
#method_after
@Test
public void listPatchesAgainstOtherPatchSetWithRebase() throws GitAPIException, IOException, PatchListNotAvailableException, OrmException, RestApiException {
    add(git, FILE_D, "4");
    createCommit(git, admin.getIdent(), SUBJECT_1);
    pushHead(git, "refs/heads/master", false);
    // Change 1,1 (+FILE_A, -FILE_D)
    add(git, FILE_A, "1");
    rm(git, FILE_D);
    Commit c = createCommit(git, admin.getIdent(), SUBJECT_2);
    pushHead(git, "refs/for/master", false);
    ObjectId a = getCurrentRevisionId(c.getChangeId());
    // Change 2,1 (+FILE_B)
    git.reset().setMode(ResetType.HARD).setRef("HEAD~1").call();
    add(git, FILE_B, "2");
    createCommit(git, admin.getIdent(), SUBJECT_3);
    pushHead(git, "refs/for/master", false);
    // Change 1,2 (+FILE_A, +FILE_C, -FILE_D)
    git.cherryPick().include(c.getCommit()).call();
    add(git, FILE_C, "2");
    c = amendCommit(git, admin.getIdent(), SUBJECT_2, c.getChangeId());
    pushHead(git, "refs/for/master", false);
    ObjectId b = getCurrentRevisionId(c.getChangeId());
    // Compare Change 1,1 with Change 1,2
    // expected: +FILE_C
    // actual: +FILE_B, +FILE_C
    // +FILE_B is wrongly returned, it is neither contained in Change 1,1
    // nor in Change 1,2, but was only changed due to the rebase
    // on Change 2,1
    List<PatchListEntry> entries = getPatches(a, b);
    assertEquals(3, entries.size());
    assertModified(Patch.COMMIT_MSG, entries.get(0));
    assertAdded(FILE_B, entries.get(1));
    assertAdded(FILE_C, entries.get(2));
}
#end_block

#method_before
private List<PatchListEntry> getCurrentPatches(String changeId) throws PatchListNotAvailableException, OrmException {
    return patchListCache.get(getKey(null, getCurrentRevisionId(changeId))).getPatches();
}
#method_after
private List<PatchListEntry> getCurrentPatches(String changeId) throws PatchListNotAvailableException, OrmException, RestApiException {
    return patchListCache.get(getKey(null, getCurrentRevisionId(changeId))).getPatches();
}
#end_block

#method_before
private ObjectId getCurrentRevisionId(String changeId) throws OrmException {
    return ObjectId.fromString(getCurrentPatchSet(changeId).getRevision().get());
}
#method_after
private ObjectId getCurrentRevisionId(String changeId) throws RestApiException {
    return ObjectId.fromString(gApi.changes().id(changeId).get().currentRevision);
}
#end_block

#method_before
@Override
public ListParameter list() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public ListRequest list() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryParameter query() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query() {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public QueryParameter query() throws RestApiException {
    throw new NotImplementedException();
}
#method_after
@Override
public QueryRequest query(String query) {
    throw new NotImplementedException();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    return obj instanceof SecureStoreData && storeName.hashCode() == obj.hashCode();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof SecureStoreData) {
        SecureStoreData o = (SecureStoreData) obj;
        return storeName.equals(o.storeName);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return storeName.hashCode();
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(storeName);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "draft").to(DropDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND, "draft").to(DropDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "delete").to(DeleteDraftChange.Action.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    post(REVISION_KIND, "delete").to(DeleteDraftPatchSet.Action.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    review.waitForCommit = true;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSet.getId().getParentKey());
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            applyReview(ctl, patchSet, review);
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
                applyReview(ctl, patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(ctl, patchSet, review);
        }
        if (submitChange) {
            Submit submit = submitProvider.get();
            Submit.Input input = new Submit.Input();
            input.waitForMerge = true;
            submit.apply(new RevisionResource(new ChangeResource(ctl), patchSet), input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            dropDraftPatchSet.apply(new RevisionResource(new ChangeResource(ctl), patchSet), new DropDraftPatchSet.Input());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    PostReview.Input review = new PostReview.Input();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = PostReview.DraftHandling.PUBLISH;
    review.strictLabels = false;
    review.waitForCommit = true;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        ChangeControl ctl = changeControlFactory.controlFor(patchSet.getId().getParentKey());
        if (abandonChange) {
            final Abandon abandon = abandonProvider.get();
            final Abandon.Input input = new Abandon.Input();
            input.message = changeComment;
            applyReview(ctl, patchSet, review);
            try {
                abandon.apply(new ChangeResource(ctl), input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            final Restore restore = restoreProvider.get();
            final Restore.Input input = new Restore.Input();
            input.message = changeComment;
            try {
                restore.apply(new ChangeResource(ctl), input);
                applyReview(ctl, patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(ctl, patchSet, review);
        }
        if (submitChange) {
            Submit submit = submitProvider.get();
            Submit.Input input = new Submit.Input();
            input.waitForMerge = true;
            submit.apply(new RevisionResource(new ChangeResource(ctl), patchSet), input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            deleteDraftPatchSetImpl.apply(new RevisionResource(new ChangeResource(ctl), patchSet), new DeleteDraftPatchSet.Input());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc, Input input) throws IOException, NoSuchChangeException, OrmException, PatchSetInfoNotAvailableException {
    final PatchSet updatedPatchSet = dbProvider.get().patchSets().atomicUpdate(rsrc.getPatchSet().getId(), new AtomicUpdate<PatchSet>() {

        @Override
        public PatchSet update(PatchSet patchset) {
            patchset.setDraft(false);
            return patchset;
        }
    });
    final Change updatedChange = dbProvider.get().changes().atomicUpdate(rsrc.getChange().getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus() == Change.Status.DRAFT) {
                change.setStatus(Change.Status.NEW);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
    if (!updatedPatchSet.isDraft() || updatedChange.getStatus() == Change.Status.NEW) {
        indexer.index(updatedChange);
        hooks.doDraftPublishedHook(updatedChange, updatedPatchSet, dbProvider.get());
        sender.send(rsrc.getChange().getStatus() == Change.Status.DRAFT, rsrc.getUser(), updatedChange, updatedPatchSet, rsrc.getControl().getLabelTypes());
    }
    return Response.none();
}
#method_after
@Override
public Object apply(RevisionResource rsrc, Input input) throws IOException, ResourceNotFoundException, ResourceConflictException, OrmException, AuthException {
    if (!rsrc.getPatchSet().isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!rsrc.getControl().canPublish(dbProvider.get())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    PatchSet updatedPatchSet = updateDraftPatchSet(rsrc);
    Change updatedChange = updateDraftChange(rsrc);
    try {
        if (!updatedPatchSet.isDraft() || updatedChange.getStatus() == Change.Status.NEW) {
            indexer.index(updatedChange);
            hooks.doDraftPublishedHook(updatedChange, updatedPatchSet, dbProvider.get());
            sender.send(rsrc.getChange().getStatus() == Change.Status.DRAFT, rsrc.getUser(), updatedChange, updatedPatchSet, rsrc.getControl().getLabelTypes());
        }
    } catch (PatchSetInfoNotAvailableException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
    return Response.none();
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    try {
        return new UiAction.Description().setTitle(String.format("Publish Revision %d", resource.getPatchSet().getPatchSetId())).setVisible(resource.getPatchSet().isDraft() && resource.getPatchSet().getId().equals(current) && resource.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    PatchSet.Id current = rsrc.getChange().currentPatchSetId();
    try {
        return new UiAction.Description().setTitle(String.format("Publish Revision %d", rsrc.getPatchSet().getPatchSetId())).setVisible(rsrc.getPatchSet().isDraft() && rsrc.getPatchSet().getId().equals(current) && rsrc.getControl().canPublish(dbProvider.get()));
    } catch (OrmException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, NoSuchChangeException, PatchSetInfoNotAvailableException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    return publish.apply(new RevisionResource(rsrc, ps), input);
}
#method_after
@Override
public Object apply(ChangeResource rsrc, Input input) throws AuthException, ResourceConflictException, ResourceConflictException, IOException, OrmException, ResourceNotFoundException, AuthException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    return publish.apply(new RevisionResource(rsrc, ps), input);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    wrapper = new ContextMapper(config.getServletContext().getContextPath());
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, base + name);
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#method_after
private GuiceFilter load(Plugin plugin) {
    if (plugin.getHttpInjector() != null) {
        final String name = plugin.getName();
        final GuiceFilter filter;
        try {
            filter = plugin.getHttpInjector().getInstance(GuiceFilter.class);
        } catch (RuntimeException e) {
            log.warn(String.format("Plugin %s cannot load GuiceFilter", name), e);
            return null;
        }
        try {
            ServletContext ctx = PluginServletContext.create(plugin, wrapper.getFullPath(name));
            filter.init(new WrappedFilterConfig(ctx));
        } catch (ServletException e) {
            log.warn(String.format("Plugin %s failed to initialize HTTP", name), e);
            return null;
        }
        plugin.add(new RegistrationHandle() {

            @Override
            public void remove() {
                filter.destroy();
            }
        });
        return filter;
    }
    return null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    HttpServletRequest wr = wrapper.create(req, name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String pathInfo = req.getPathInfo();
    if (pathInfo.length() < 1) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = pathInfo.substring(1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    String uri = req.getRequestURI();
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data;
        // Allow the user to select a logView variant with the "pretty" param.
        List<String> pretty_values = view.getParameters().get(PRETTY_PARAM);
        if (pretty_values.isEmpty()) {
            data = new LogSoyData(req, view).toSoyData(paginator, null, df);
            GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        } else {
            data = new LogSoyData(req, view, true).toSoyData(paginator, null, df);
            String variant = pretty_values.get(0);
            data.put("logPrettyVariant", pretty_values.get(0));
        }
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitilesAccess access = getAccess(req);
        Config config = access.getConfig();
        DateFormatter df = new DateFormatter(access, Format.DEFAULT);
        // Allow the user to select a logView variant with the "pretty" param.
        String pretty = Iterables.getFirst(view.getParameters().get(PRETTY_PARAM), "default");
        Map<String, Object> data = new LogSoyData(req, view, config.getBoolean("logFormat", pretty, "verbose", false)).toSoyData(paginator, null, df);
        String variant = config.getString("logFormat", pretty, "variant");
        data.put("logEntryPretty", pretty);
        data.put("logEntryVariant", Objects.firstNonNull(variant, pretty));
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        DateFormatter df = new DateFormatter(getAccess(req), Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setTreeFilter(AndTreeFilter.create(PathFilter.create(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#method_after
private static RevWalk newWalk(Repository repo, GitilesView view) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    RevWalk walk = new RevWalk(repo);
    walk.markStart(walk.parseCommit(view.getRevision().getId()));
    if (view.getOldRevision() != Revision.NULL) {
        walk.markUninteresting(walk.parseCommit(view.getOldRevision().getId()));
    }
    if (!Strings.isNullOrEmpty(view.getPathPart())) {
        walk.setRewriteParents(false);
        walk.setTreeFilter(AndTreeFilter.create(PathFilterGroup.createFromStrings(view.getPathPart()), TreeFilter.ANY_DIFF));
    }
    return walk;
}
#end_block

#method_before
public Map<String, Object> toSoyData(Paginator paginator, @Nullable String revision, GitDateFormatter df) throws IOException {
    Map<String, Object> data = Maps.newHashMapWithExpectedSize(3);
    List<Map<String, Object>> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
    for (RevCommit c : paginator) {
        if (verbose) {
            entries.add(new CommitSoyData().setRevWalk(paginator.getWalk()).toSoyData(req, c, VERBOSE_FIELDS, df));
        } else {
            entries.add(new CommitSoyData().toSoyData(req, c, FIELDS, df));
        }
    }
    data.put("entries", entries);
    ObjectId next = paginator.getNextStart();
    // TODO(mmoss): These urls don't include the n or pretty params.
    if (next != null) {
        data.put("nextUrl", copyAndCanonicalize(view, revision).replaceParam(LogServlet.START_PARAM, next.name()).toUrl());
    }
    ObjectId prev = paginator.getPreviousStart();
    if (prev != null) {
        GitilesView.Builder prevView = copyAndCanonicalize(view, revision);
        if (!prevView.getRevision().getId().equals(prev)) {
            prevView.replaceParam(LogServlet.START_PARAM, prev.name());
        }
        data.put("previousUrl", prevView.toUrl());
    }
    return data;
}
#method_after
public Map<String, Object> toSoyData(RevWalk walk, int limit, @Nullable String revision, @Nullable ObjectId start, DateFormatter df) throws IOException {
    return toSoyData(new Paginator(walk, limit, start), revision, df);
}
#end_block

#method_before
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        resp.getWriter().println("Created account.");
    } catch (IOException e) {
        resp.getWriter().println("Account creation failed: " + e.getCause());
        throw e;
    }
}
#method_after
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    try {
        setAccountIdentity(user, req);
        setAccoutPublicKeys(user, hubLogin, req);
        log.info("Created account '" + user.getUserName() + "'");
    } catch (IOException e) {
        log.error("Account '" + user.getUserName() + "' creation failed", e);
        throw e;
    }
}
#end_block

#method_before
private Collection<ChangeMessageInfo> messages(ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    List<ChangeMessage> messages = db.get().changeMessages().byChange(cd.getId()).toList();
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    // chronological order
    Collections.sort(messages, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return a.getWrittenOn().compareTo(b.getWrittenOn());
        }
    });
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = map.get(patchNum);
        Preconditions.checkNotNull(ps);
        if (ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#method_after
private Collection<ChangeMessageInfo> messages(ChangeData cd, Map<PatchSet.Id, PatchSet> map) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    List<ChangeMessage> messages = db.get().changeMessages().byChange(cd.getId()).toList();
    if (messages.isEmpty()) {
        return Collections.emptyList();
    }
    // chronological order
    Collections.sort(messages, new Comparator<ChangeMessage>() {

        @Override
        public int compare(ChangeMessage a, ChangeMessage b) {
            return a.getWrittenOn().compareTo(b.getWrittenOn());
        }
    });
    List<ChangeMessageInfo> result = Lists.newArrayListWithCapacity(messages.size());
    for (ChangeMessage message : messages) {
        PatchSet.Id patchNum = message.getPatchSetId();
        PatchSet ps = patchNum != null ? map.get(patchNum) : null;
        if (patchNum == null || ctl.isPatchVisible(ps, db.get())) {
            ChangeMessageInfo cmi = new ChangeMessageInfo();
            cmi.id = message.getKey().get();
            cmi.author = accountLoader.get(message.getAuthor());
            cmi.date = message.getWrittenOn();
            cmi.message = message.getMessage();
            cmi._revisionNumber = patchNum != null ? patchNum.get() : null;
            result.add(cmi);
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#method_after
@Override
protected void configure() {
    bind(DataSourceType.class).annotatedWith(Names.named("h2")).to(H2.class);
    bind(DataSourceType.class).annotatedWith(Names.named("jdbc")).to(JDBC.class);
    bind(DataSourceType.class).annotatedWith(Names.named("mysql")).to(MySql.class);
    bind(DataSourceType.class).annotatedWith(Names.named("oracle")).to(Oracle.class);
    bind(DataSourceType.class).annotatedWith(Names.named("postgresql")).to(PostgreSQL.class);
    /*
     * DatabaseMetaData.getDatabaseProductName() returns "sap db" for MaxDB.
     * For auto-detection of the DB type (com.google.gerrit.pgm.util.SiteProgram#getDbType)
     * we have to map "sap db" additionally to "maxdb", which is used for explicit configuration.
     */
    bind(DataSourceType.class).annotatedWith(Names.named("maxdb")).to(MaxDb.class);
    bind(DataSourceType.class).annotatedWith(Names.named("sap db")).to(MaxDb.class);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.get().put(key.token, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String sid, String auth) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = nowMs();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (sid == null) {
        sid = newUniqueToken(who);
    }
    if (auth == null) {
        auth = newUniqueToken(who);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, expiresAt, sid, auth);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    Val val = self.get().getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.get().invalidate(key.token);
        return null;
    }
    return val;
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= nowMs()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
void destroy(final Key key) {
    self.get().invalidate(key.token);
}
#method_after
void destroy(final Key key) {
    self.invalidate(key.token);
}
#end_block

#method_before
boolean needsCookieRefresh() {
    return refreshCookieAt <= now();
}
#method_after
boolean needsCookieRefresh() {
    return refreshCookieAt <= nowMs();
}
#end_block

#method_before
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        if (title != null) {
            Matcher matcher = SECTION_HEADER.matcher(title);
            if (matcher.matches()) {
                title = matcher.group(1);
            }
        } else {
            title = "";
        }
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    return directory;
}
#method_after
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        if (file.length() == 0) {
            continue;
        }
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        Matcher matcher = SECTION_HEADER.matcher(title);
        if (matcher.matches()) {
            title = matcher.group(1);
        }
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    return directory;
}
#end_block

#method_before
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        ArrayList<Plugin> plugins = new ArrayList<Plugin>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#method_after
public Iterable<Plugin> getPlugins(boolean all) {
    if (!all) {
        return running.values();
    } else {
        List<Plugin> plugins = new ArrayList<>(running.values());
        plugins.addAll(disabled.values());
        return plugins;
    }
}
#end_block

#method_before
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    List<String> filePaths = changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet());
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in patch set %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#method_after
private void checkComments(RevisionResource revision, Map<String, List<Comment>> in) throws BadRequestException, OrmException {
    Iterator<Map.Entry<String, List<Comment>>> mapItr = in.entrySet().iterator();
    Set<String> filePaths = Sets.newHashSet(changeDataFactory.create(db.get(), revision.getChange()).filePaths(revision.getPatchSet()));
    while (mapItr.hasNext()) {
        Map.Entry<String, List<Comment>> ent = mapItr.next();
        String path = ent.getKey();
        if (!filePaths.contains(path) && !Patch.COMMIT_MSG.equals(path)) {
            throw new BadRequestException(String.format("file %s not found in revision %s", path, change.currentPatchSetId()));
        }
        List<Comment> list = ent.getValue();
        if (list == null) {
            mapItr.remove();
            continue;
        }
        Iterator<Comment> listItr = list.iterator();
        while (listItr.hasNext()) {
            Comment c = listItr.next();
            if (c.line < 0) {
                throw new BadRequestException(String.format("negative line number %d not allowed on %s", c.line, path));
            }
            c.message = Strings.emptyToNull(c.message).trim();
            if (c.message.isEmpty()) {
                listItr.remove();
            }
        }
        if (list.isEmpty()) {
            mapItr.remove();
        }
    }
}
#end_block

#method_before
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(Integer.valueOf(ps.getPatchSetId()), ImmutableList.copyOf(filePaths));
    }
}
#method_after
public void setCurrentFilePaths(List<String> filePaths) throws OrmException {
    PatchSet ps = currentPatchSet();
    if (ps != null) {
        files.put(ps.getPatchSetId(), ImmutableList.copyOf(filePaths));
    }
}
#end_block

#method_before
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(Integer.valueOf(ps.getPatchSetId()))) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(Integer.valueOf(ps.getPatchSetId()), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(Integer.valueOf(ps.getPatchSetId()), Collections.unmodifiableList(r));
    }
    return files.get(Integer.valueOf(ps.getPatchSetId()));
}
#method_after
public List<String> filePaths(PatchSet ps) throws OrmException {
    if (!files.containsKey(ps.getPatchSetId())) {
        Change c = change();
        if (c == null) {
            return null;
        }
        PatchList p;
        try {
            p = patchListCache.get(c, ps);
        } catch (PatchListNotAvailableException e) {
            List<String> emptyFileList = Collections.emptyList();
            files.put(ps.getPatchSetId(), emptyFileList);
            return emptyFileList;
        }
        List<String> r = new ArrayList<String>(p.getPatches().size());
        for (PatchListEntry e : p.getPatches()) {
            if (Patch.COMMIT_MSG.equals(e.getNewName())) {
                continue;
            }
            switch(e.getChangeType()) {
                case ADDED:
                case MODIFIED:
                case DELETED:
                case COPIED:
                case REWRITE:
                    r.add(e.getNewName());
                    break;
                case RENAMED:
                    r.add(e.getOldName());
                    r.add(e.getNewName());
                    break;
            }
        }
        Collections.sort(r);
        files.put(ps.getPatchSetId(), Collections.unmodifiableList(r));
    }
    return files.get(ps.getPatchSetId());
}
#end_block

#method_before
@Provides
GitilesUrls getGitilesUrls(@GerritServerConfig Config gerritConfig, @Nullable @CanonicalWebUrl String gerritUrl, @SshAdvertisedAddresses List<String> advertisedSshAddresses) throws MalformedURLException, UnknownHostException {
    URL u;
    String hostName;
    if (gerritUrl != null) {
        u = new URL(gerritUrl);
        hostName = u.getHost() != null ? u.getHost() : getLocalHostName();
    } else {
        u = null;
        hostName = "Gerrit";
    }
    // Arbitrarily prefer SSH, then HTTP, then git.
    // TODO: Use user preferences.
    String gitUrl;
    if (!advertisedSshAddresses.isEmpty()) {
        String addr = advertisedSshAddresses.get(0);
        int index = addr.indexOf(":");
        String port = "";
        if (index != -1) {
            port = addr.substring(index);
        }
        if (addr.startsWith("*:") || "".equals(addr)) {
            if (u != null && u.getHost() != null) {
                addr = u.getHost();
            } else {
                addr = getLocalHostName();
            }
        }
        gitUrl = "ssh://" + addr + port + "/";
    } else {
        gitUrl = gerritConfig.getString("gerrit", null, "gitHttpUrl");
        if (gitUrl == null) {
            gitUrl = gerritConfig.getString("gerrit", null, "canonicalGitUrl");
        }
    }
    if (gitUrl == null) {
        throw new ProvisionException("Unable to determine any canonical git URL from gerrit.config");
    }
    return new DefaultUrls(hostName, gitUrl, gerritUrl);
}
#method_after
@Provides
GitilesUrls getGitilesUrls(@GerritServerConfig Config gerritConfig, @Nullable @CanonicalWebUrl String gerritUrl, @SshAdvertisedAddresses List<String> advertisedSshAddresses) throws MalformedURLException, UnknownHostException {
    URL u;
    String hostName;
    if (gerritUrl != null) {
        u = new URL(gerritUrl);
        hostName = u.getHost() != null ? u.getHost() : getLocalHostName();
    } else {
        u = null;
        hostName = "Gerrit";
    }
    // Arbitrarily prefer SSH, then HTTP, then git.
    // TODO: Use user preferences.
    String gitUrl;
    if (!advertisedSshAddresses.isEmpty()) {
        String addr = advertisedSshAddresses.get(0);
        int index = addr.indexOf(":");
        String port = "";
        if (index != -1) {
            port = addr.substring(index);
        }
        if (addr.startsWith("*:") || "".equals(addr)) {
            if (u != null && u.getHost() != null) {
                addr = u.getHost();
            } else {
                addr = getLocalHostName();
            }
        } else {
            if (index != -1) {
                addr = addr.substring(0, index);
            }
        }
        gitUrl = "ssh://" + addr + port + "/";
    } else {
        gitUrl = gerritConfig.getString("gerrit", null, "gitHttpUrl");
        if (gitUrl == null) {
            gitUrl = gerritConfig.getString("gerrit", null, "canonicalGitUrl");
        }
    }
    if (gitUrl == null) {
        throw new ProvisionException("Unable to determine any canonical git URL from gerrit.config");
    }
    return new DefaultUrls(hostName, gitUrl, gerritUrl);
}
#end_block

#method_before
@Override
public void start() {
    try {
        server.httpd.start();
    } catch (Exception e) {
        throw new IllegalStateException("Cannot start HTTP daemon", e);
    }
}
#method_after
@Override
public void start() {
    try {
        String origUrl = cfg.getString("httpd", null, "listenUrl");
        boolean rewrite = !Strings.isNullOrEmpty(origUrl) && origUrl.endsWith(":0/");
        server.httpd.start();
        if (rewrite) {
            Connector con = server.httpd.getConnectors()[0];
            if (con instanceof ServerConnector) {
                @SuppressWarnings("resource")
                ServerConnector serverCon = (ServerConnector) con;
                String host = serverCon.getHost();
                int port = serverCon.getLocalPort();
                String url = String.format("http://%s:%d", host, port);
                cfg.setString("gerrit", null, "canonicalWebUrl", url);
                cfg.setString("httpd", null, "listenUrl", url);
            }
        }
    } catch (Exception e) {
        throw new IllegalStateException("Cannot start HTTP daemon", e);
    }
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = newServerConnector(server, acceptors, config);
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = newServerConnector(server, acceptors, config);
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new HttpConfiguration.Customizer() {

                @Override
                public void customize(Connector connector, HttpConfiguration channelConfig, Request request) {
                    request.setScheme(HttpScheme.HTTPS.asString());
                    request.setSecure(true);
                }
            });
            c = newServerConnector(server, acceptors, config);
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 <= r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
private StringListPanel renderStringListPanel(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    StringListPanel p = new StringListPanel(null, Arrays.asList(getDisplayName(param)), saveProject, true);
    List<List<String>> values = new ArrayList<>();
    for (String v : Natives.asList(param.values())) {
        values.add(Arrays.asList(v));
    }
    p.display(values);
    if (!param.editable()) {
        p.setEnabled(false);
    }
    addWidget(g, p, param);
    return p;
}
#method_after
private StringListPanel renderStringListPanel(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    StringListPanel p = new StringListPanel(null, Arrays.asList(getDisplayName(param)), saveProject, false);
    List<List<String>> values = new ArrayList<>();
    for (String v : Natives.asList(param.values())) {
        values.add(Arrays.asList(v));
    }
    p.display(values);
    if (!param.editable()) {
        p.setEnabled(false);
    }
    addWidget(g, p, param);
    return p;
}
#end_block

#method_before
@Test
public void test() throws Exception {
    test(5);
}
#method_after
@Test
// we know it works now, so let's not clone a project 500 times ;-)
@Ignore
public void test() throws Exception {
    test(5);
}
#end_block

#method_before
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String reviewer = Gerrit.getUserAccountInfo().name();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("addme")
void onAddMe(ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen && currentMenu == null) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                for (TopMenuItem item : Natives.asList(prefs.my())) {
                    addExtensionLink(myBar, item);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
public void onScreenLoad(ScreenLoadEvent event) {
    if (event.getScreen().getToken().equals(getTargetHistoryToken())) {
        Gerrit.currentMenu = null;
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#method_after
public void onScreenLoad(ScreenLoadEvent event) {
    if (match(event.getScreen().getToken())) {
        Gerrit.selectMenu(bar);
        addStyleName(Gerrit.RESOURCES.css().activeRow());
    } else {
        removeStyleName(Gerrit.RESOURCES.css().activeRow());
    }
}
#end_block

#method_before
private void initCommentVisibilityStrategy(Button expandAll, Button collapseAll) {
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    long AGE = 7 * 24 * 60 * 60 * 1000L;
    Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    int n = getWidgetCount();
    for (int i = 0; i < n; i++) {
        Message msg = (Message) getWidget(i);
        boolean isRecent;
        if (i == n - 1) {
            isRecent = true;
        } else {
            isRecent = msg.getMessageInfo().date().after(aged);
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
                isOpen = i == n - 1;
                break;
            case EXPAND_RECENT:
            default:
                isOpen = isRecent;
                break;
        }
        msg.setOpen(isOpen);
    }
    if (commentVisibilityStrategy == COLLAPSE_ALL) {
        expandAll.setVisible(true);
        collapseAll.setVisible(false);
    } else if (commentVisibilityStrategy == EXPAND_ALL) {
        expandAll.setVisible(false);
        collapseAll.setVisible(true);
    }
}
#method_after
private void initCommentVisibilityStrategy(Button expandAll, Button collapseAll) {
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    int n = getWidgetCount();
    for (int i = 0; i < n; i++) {
        Message msg = (Message) getWidget(i);
        boolean isRecent = (i == n - 1) ? true : msg.getMessageInfo().date().after(aged);
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
                isOpen = i == n - 1;
                break;
            case EXPAND_RECENT:
            default:
                isOpen = isRecent;
                break;
        }
        msg.setOpen(isOpen);
    }
    if (commentVisibilityStrategy == COLLAPSE_ALL) {
        expandAll.setVisible(true);
        collapseAll.setVisible(false);
    } else if (commentVisibilityStrategy == EXPAND_ALL) {
        expandAll.setVisible(false);
        collapseAll.setVisible(true);
    }
}
#end_block

#method_before
private List<TopMenu.MenuItem> my(ProjectState allUsers, String ref) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = allUsers.getConfig(PREFERENCES, ref).get();
    for (String subsection : cfg.getSubsections(MY)) {
        my.add(new TopMenu.MenuItem(subsection, my(cfg, subsection, KEY_URL, "#/"), my(cfg, subsection, KEY_TARGET, null), my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#method_after
private List<TopMenu.MenuItem> my(ProjectState allUsers, String ref) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = allUsers.getConfig(PREFERENCES, ref).get();
    for (String subsection : cfg.getSubsections(MY)) {
        String url = my(cfg, subsection, KEY_URL, "#/");
        String target = my(cfg, subsection, KEY_TARGET, url.startsWith("#") ? null : "_blank");
        my.add(new TopMenu.MenuItem(subsection, url, target, my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#end_block

#method_before
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    return Objects.firstNonNull(Strings.emptyToNull(cfg.getString(MY, subsection, key)), defaultValue);
}
#method_after
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    String val = cfg.getString(MY, subsection, key);
    return !Strings.isNullOrEmpty(val) ? val : defaultValue;
}
#end_block

#method_before
public PatchLink createLink(int index, PatchScreen.Type patchType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    boolean newScrren = Dispatcher.isChangeScreen2();
    if (newScrren && (detail.getPatches().get(index).getPatchType().equals(PatchType.BINARY) || Gerrit.getUserAccount().getGeneralPreferences().getDiffView().equals(DiffView.UNIFIED_DIFF)) || !newScrren && patchType == PatchScreen.Type.UNIFIED) {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#method_after
public PatchLink createLink(int index, PatchScreen.Type screenType, SafeHtml before, SafeHtml after) {
    Patch patch = patchList.get(index);
    Key thisKey = patch.getKey();
    PatchLink link;
    if (isUnifiedPatchLink(patch, screenType)) {
        link = new PatchLink.Unified("", base, thisKey, index, detail, this);
    } else {
        link = new PatchLink.SideBySide("", base, thisKey, index, detail, this);
    }
    SafeHtmlBuilder text = new SafeHtmlBuilder();
    text.append(before);
    text.append(getFileNameOnly(patch));
    text.append(after);
    SafeHtml.set(link, text);
    return link;
}
#end_block

#method_before
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    try {
        if (name == null) {
            throw new RestApiException("Project already exists");
        }
        if (in.name != null && !name.equals(in.name)) {
            throw new RestApiException("name must match input.name");
        }
        createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in);
        return projectApi.create(projects.parse(name));
    } catch (BadRequestException | UnprocessableEntityException | ResourceConflictException | ResourceNotFoundException | ProjectCreationFailedException | IOException e) {
        throw new RestApiException("Cannot create project", e);
    }
}
#method_after
@Override
public ProjectApi create(ProjectInput in) throws RestApiException {
    try {
        if (name == null) {
            throw new ResourceConflictException("Project already exists");
        }
        if (in.name != null && !name.equals(in.name)) {
            throw new RestApiException("name must match input.name");
        }
        createProjectFactory.get().create(name).apply(TopLevelResource.INSTANCE, in);
        return projectApi.create(projects.parse(name));
    } catch (BadRequestException | UnprocessableEntityException | ResourceNotFoundException | ProjectCreationFailedException | IOException e) {
        throw new RestApiException("Cannot create project", e);
    }
}
#end_block

#method_before
@Test(expected = RestApiException.class)
public void createProjectDuplicate() throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = "baz";
    gApi.projects().name("baz").create(in);
    gApi.projects().name("baz").create(in);
}
#method_after
@Test(expected = ResourceConflictException.class)
public void createProjectDuplicate() throws RestApiException {
    ProjectInput in = new ProjectInput();
    in.name = "baz";
    gApi.projects().name("baz").create(in);
    gApi.projects().name("baz").create(in);
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }));
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                List<TopMenuItem> myMenuItems = Natives.asList(prefs.my());
                String url = null;
                if (!myMenuItems.isEmpty()) {
                    if (myMenuItems.get(0).getUrl().startsWith("#")) {
                        url = myMenuItems.get(0).getUrl().substring(1);
                    }
                    for (TopMenuItem item : myMenuItems) {
                        addExtensionLink(myBar, item);
                    }
                }
                defaultScreenToken = url;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    refreshMenuBar(true);
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        final LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        AccountApi.self().view("preferences").get(new AsyncCallback<Preferences>() {

            @Override
            public void onSuccess(Preferences prefs) {
                List<TopMenuItem> myMenuItems = Natives.asList(prefs.my());
                String url = null;
                if (!myMenuItems.isEmpty()) {
                    if (myMenuItems.get(0).getUrl().startsWith("#")) {
                        url = myMenuItems.get(0).getUrl().substring(1);
                    }
                    for (TopMenuItem item : myMenuItems) {
                        addExtensionLink(myBar, item);
                    }
                }
                defaultScreenToken = url;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    if (item.getUrl().startsWith("#") && (item.getTarget() == null || item.getTarget().isEmpty())) {
        LinkMenuItem a = new LinkMenuItem(item.getName(), item.getUrl().substring(1));
        if (item.getId() != null) {
            a.getElement().setAttribute("id", item.getId());
        }
        m.add(a);
    } else {
        Anchor atag = anchor(item.getName(), isAbsolute(item.getUrl()) ? item.getUrl() : selfRedirect(item.getUrl()));
        if (item.getTarget() != null && !item.getTarget().isEmpty()) {
            atag.setTarget(item.getTarget());
        }
        if (item.getId() != null) {
            atag.getElement().setAttribute("id", item.getId());
        }
        m.add(atag);
    }
}
#end_block

#method_before
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#method_after
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.equals("self")) {
        if (Gerrit.isSignedIn()) {
            Gerrit.display(token, new AccountDashboardScreen(Gerrit.getUserAccount().getId()));
        } else {
            Screen s = new AccountDashboardScreen(null);
            s.setRequiresSignIn(true);
            Gerrit.display(token, s);
        }
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#end_block

#method_before
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    if (checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
    skipNum.setText(PatchUtil.C.patchSkipRegionStart() + " " + Integer.toString(length) + " " + PatchUtil.C.patchSkipRegionEnd());
}
#method_after
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    if (checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
    skipNum.setText(PatchUtil.M.patchSkipRegion(Integer.toString(length)));
}
#end_block

#method_before
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(String.valueOf(numSkipLines));
    checkAndUpdateArrows();
}
#method_after
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(PatchUtil.M.patchSkipRegion(Integer.toString(numSkipLines)));
    checkAndUpdateArrows();
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setDownloadArchive(cfg.getBoolean("download", "archive", false));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordSettingsEnabled(!authConfig.isGitBasicAuth());
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    List<ArchiveFormat> allArchiveFormats = ConfigUtil.getEnumList(cfg, "download", null, "archive", ArchiveFormat.OFF);
    config.setArchiveFormats(new HashSet<>(allArchiveFormats));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
private void insertArchive() {
    if (!Gerrit.getConfig().getDownloadArchive()) {
        return;
    }
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    Set<ArchiveFormat> activated = Gerrit.getConfig().getArchiveFormats();
    if (activated.contains(ArchiveFormat.OFF)) {
        return;
    }
    List<Anchor> anchors = new ArrayList<>(activated.size());
    for (String f : ARCHIVE) {
        if (activated.contains(ArchiveFormat.valueOf(f.toUpperCase()))) {
            Anchor archive = new Anchor(f);
            archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
            anchors.add(archive);
        }
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = anchors.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
private Module copy(Injector src) {
    Set<TypeLiteral<?>> dynamicTypes = Sets.newHashSet();
    for (Map.Entry<Key<?>, Binding<?>> e : src.getBindings().entrySet()) {
        TypeLiteral<?> type = e.getKey().getTypeLiteral();
        if (type.getRawType() == DynamicSet.class || type.getRawType() == DynamicMap.class) {
            ParameterizedType t = (ParameterizedType) type.getType();
            dynamicTypes.add(TypeLiteral.get(t.getActualTypeArguments()[0]));
        }
    }
    final Map<Key<?>, Binding<?>> bindings = Maps.newLinkedHashMap();
    for (Map.Entry<Key<?>, Binding<?>> e : src.getBindings().entrySet()) {
        if (dynamicTypes.contains(e.getKey().getTypeLiteral()) && e.getKey().getAnnotation() != null) {
            // exported to plugins.
            continue;
        } else if (shouldCopy(e.getKey())) {
            bindings.put(e.getKey(), e.getValue());
        }
    }
    bindings.remove(Key.get(Injector.class));
    bindings.remove(Key.get(java.util.logging.Logger.class));
    return new AbstractModule() {

        @SuppressWarnings("unchecked")
        @Override
        protected void configure() {
            for (Map.Entry<Key<?>, Binding<?>> e : bindings.entrySet()) {
                Key<Object> k = (Key<Object>) e.getKey();
                Binding<Object> b = (Binding<Object>) e.getValue();
                bind(k).toProvider(b.getProvider());
            }
        }
    };
}
#method_after
private Module copy(Injector src) {
    Set<TypeLiteral<?>> dynamicTypes = Sets.newHashSet();
    Set<TypeLiteral<?>> dynamicItemTypes = Sets.newHashSet();
    for (Map.Entry<Key<?>, Binding<?>> e : src.getBindings().entrySet()) {
        TypeLiteral<?> type = e.getKey().getTypeLiteral();
        if (type.getRawType() == DynamicItem.class) {
            ParameterizedType t = (ParameterizedType) type.getType();
            dynamicItemTypes.add(TypeLiteral.get(t.getActualTypeArguments()[0]));
        } else if (type.getRawType() == DynamicSet.class || type.getRawType() == DynamicMap.class) {
            ParameterizedType t = (ParameterizedType) type.getType();
            dynamicTypes.add(TypeLiteral.get(t.getActualTypeArguments()[0]));
        }
    }
    final Map<Key<?>, Binding<?>> bindings = Maps.newLinkedHashMap();
    for (Map.Entry<Key<?>, Binding<?>> e : src.getBindings().entrySet()) {
        if (dynamicTypes.contains(e.getKey().getTypeLiteral()) && e.getKey().getAnnotation() != null) {
            // exported to plugins.
            continue;
        } else if (dynamicItemTypes.contains(e.getKey().getTypeLiteral())) {
            continue;
        } else if (shouldCopy(e.getKey())) {
            bindings.put(e.getKey(), e.getValue());
        }
    }
    bindings.remove(Key.get(Injector.class));
    bindings.remove(Key.get(java.util.logging.Logger.class));
    @Nullable
    final Binding<HttpServletRequest> requestBinding = src.getExistingBinding(Key.get(HttpServletRequest.class));
    @Nullable
    final Binding<HttpServletResponse> responseBinding = src.getExistingBinding(Key.get(HttpServletResponse.class));
    return new AbstractModule() {

        @SuppressWarnings("unchecked")
        @Override
        protected void configure() {
            for (Map.Entry<Key<?>, Binding<?>> e : bindings.entrySet()) {
                Key<Object> k = (Key<Object>) e.getKey();
                Binding<Object> b = (Binding<Object>) e.getValue();
                bind(k).toProvider(b.getProvider());
            }
            if (requestBinding != null) {
                bind(HttpServletRequest.class).annotatedWith(RootRelative.class).toProvider(requestBinding.getProvider());
            }
            if (responseBinding != null) {
                bind(HttpServletResponse.class).annotatedWith(RootRelative.class).toProvider(responseBinding.getProvider());
            }
        }
    };
}
#end_block

#method_before
private boolean shouldCopy(Key<?> key) {
    if (copyConfigKeys.contains(key)) {
        return false;
    }
    Class<?> type = key.getTypeLiteral().getRawType();
    if (LifecycleListener.class.isAssignableFrom(type)) {
        return false;
    }
    if (StartPluginListener.class.isAssignableFrom(type)) {
        return false;
    }
    if (type.getName().startsWith("com.google.inject.")) {
        return false;
    }
    if (is("org.apache.sshd.server.Command", type)) {
        return false;
    }
    if (is("javax.servlet.Filter", type)) {
        return false;
    }
    if (is("javax.servlet.ServletContext", type)) {
        return false;
    }
    if (is("javax.servlet.ServletRequest", type) && !is("javax.servlet.http.HttpServletRequest", type)) {
        return false;
    }
    if (is("javax.servlet.ServletResponse", type) && !is("javax.servlet.http.HttpServletResponse", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpServlet", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpSession", type)) {
        return false;
    }
    if (Map.class.isAssignableFrom(type) && key.getAnnotationType() != null && "com.google.inject.servlet.RequestParameters".equals(key.getAnnotationType().getName())) {
        return false;
    }
    if (type.getName().startsWith("com.google.gerrit.httpd.GitOverHttpServlet$")) {
        return false;
    }
    return true;
}
#method_after
private boolean shouldCopy(Key<?> key) {
    if (copyConfigKeys.contains(key)) {
        return false;
    }
    Class<?> type = key.getTypeLiteral().getRawType();
    if (LifecycleListener.class.isAssignableFrom(type)) {
        return false;
    }
    if (StartPluginListener.class.isAssignableFrom(type)) {
        return false;
    }
    if (type.getName().startsWith("com.google.inject.")) {
        return false;
    }
    if (is("org.apache.sshd.server.Command", type)) {
        return false;
    }
    if (is("javax.servlet.Filter", type)) {
        return false;
    }
    if (is("javax.servlet.ServletContext", type)) {
        return false;
    }
    if (is("javax.servlet.ServletRequest", type)) {
        return false;
    }
    if (is("javax.servlet.ServletResponse", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpServlet", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpServletRequest", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpServletResponse", type)) {
        return false;
    }
    if (is("javax.servlet.http.HttpSession", type)) {
        return false;
    }
    if (Map.class.isAssignableFrom(type) && key.getAnnotationType() != null && "com.google.inject.servlet.RequestParameters".equals(key.getAnnotationType().getName())) {
        return false;
    }
    if (type.getName().startsWith("com.google.gerrit.httpd.GitOverHttpServlet$")) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    boolean admin;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            admin = getCurrentUser().getCapabilities().canAdministrateServer();
            break;
        default:
            owner = false;
            admin = false;
    }
    if (object instanceof RevCommit) {
        return admin || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), commit.getParent(0).getId(), commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#method_after
@Override
protected ProjectAccess updateProjectConfig(ProjectConfig config, MetaDataUpdate md) throws IOException, NoSuchProjectException, ConfigInvalidException {
    RevCommit commit = config.commit(md);
    hooks.doRefUpdatedHook(new Branch.NameKey(config.getProject().getNameKey(), GitRepositoryManager.REF_CONFIG), base, commit.getId(), user.getAccount());
    projectCache.evict(config.getProject());
    return projectAccessFactory.create(projectName).call();
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_ALWAYS;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_ALWAYS;
}
#end_block

#method_before
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(ProjectSubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(ProjectSubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(ProjectSubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(ProjectSubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#method_after
private void loadProject(ResultSet rs, Project project) throws SQLException, OrmException {
    project.setDescription(rs.getString("description"));
    project.setUseContributorAgreements(asInheritableBoolean(rs, "use_contributor_agreements"));
    switch(rs.getString("submit_type").charAt(0)) {
        case 'F':
            project.setSubmitType(SubmitType.FAST_FORWARD_ONLY);
            break;
        case 'M':
            project.setSubmitType(SubmitType.MERGE_IF_NECESSARY);
            break;
        case 'A':
            project.setSubmitType(SubmitType.MERGE_ALWAYS);
            break;
        case 'C':
            project.setSubmitType(SubmitType.CHERRY_PICK);
            break;
        default:
            throw new OrmException("Unsupported submit_type=" + rs.getString("submit_type") + " on project " + project.getName());
    }
    project.setUseSignedOffBy(asInheritableBoolean(rs, "use_signed_off_by"));
    project.setRequireChangeID(asInheritableBoolean(rs, "require_change_id"));
    project.setUseContentMerge(asInheritableBoolean(rs, "use_content_merge"));
    project.setParentName(rs.getString("parent_name"));
}
#end_block

#method_before
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.ACTIVE);
}
#method_after
public boolean canWrite() {
    return getProjectControl().getProject().getState().equals(ProjectState.ACTIVE);
}
#end_block

#method_before
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectStatus.READ_ONLY) || canWrite();
}
#method_after
public boolean canRead() {
    return getProjectControl().getProject().getState().equals(ProjectState.READ_ONLY) || canWrite();
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object, boolean existsOnServer) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return getCurrentUser().getCapabilities().canAdministrateServer() || (owner && !isBlocked(Permission.CREATE)) || (canPerform(Permission.CREATE) && (!existsOnServer && canUpdate() || projectControl.canReadCommit(rw, (RevCommit) object)));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.WEB_LINKS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    String email = info.owner().email() != null ? info.owner().email() : name;
    ownerText.setInnerText(name);
    ownerText.setTitle(email);
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#end_block

#method_before
private void renderSubmitType(String action) {
    try {
        ProjectSubmitType type = ProjectSubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#method_after
private void renderSubmitType(String action) {
    try {
        SubmitType type = SubmitType.valueOf(action);
        submitActionText.setInnerText(com.google.gerrit.client.admin.Util.toLongString(type));
    } catch (IllegalArgumentException e) {
        submitActionText.setInnerText(action);
    }
}
#end_block

#method_before
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    ProjectSubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#method_after
@Override
public Operation exec(Prolog engine) throws PrologException {
    engine.setB0();
    Term a1 = arg1.dereference();
    ChangeControl control = StoredValues.CHANGE_CONTROL.get(engine);
    SubmitType submitType = control.getProject().getSubmitType();
    if (!a1.unify(term[submitType.ordinal()], engine.trail)) {
        return engine.fail();
    }
    return cont;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.MERGE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.MERGE_IF_NECESSARY;
}
#end_block

#method_before
public static String toLongString(final ProjectStatus type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case ACTIVE:
            return C.projectState_ACTIVE();
        case READ_ONLY:
            return C.projectState_READ_ONLY();
        case HIDDEN:
            return C.projectState_HIDDEN();
        default:
            return type.name();
    }
}
#method_after
public static String toLongString(final SubmitType type) {
    if (type == null) {
        return "";
    }
    switch(type) {
        case FAST_FORWARD_ONLY:
            return C.projectSubmitType_FAST_FORWARD_ONLY();
        case MERGE_IF_NECESSARY:
            return C.projectSubmitType_MERGE_IF_NECESSARY();
        case REBASE_IF_NECESSARY:
            return C.projectSubmitType_REBASE_IF_NECESSARY();
        case MERGE_ALWAYS:
            return C.projectSubmitType_MERGE_ALWAYS();
        case CHERRY_PICK:
            return C.projectSubmitType_CHERRY_PICK();
        default:
            return type.name();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p");
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p2");
}
#end_block

#method_before
private void setSubmitType(ProjectSubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void setSubmitType(SubmitType submitType) throws IOException {
    PutConfig.Input in = new PutConfig.Input();
    in.submitType = submitType;
    in.useContentMerge = InheritableBoolean.FALSE;
    RestResponse r = adminSession.put("/projects/" + project.get() + "/config", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = ProjectSubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#method_after
@Test
public void testCreateProjectWithProperties() throws IOException {
    final String newProjectName = "newProject";
    ProjectInput in = new ProjectInput();
    in.description = "Test description";
    in.submitType = SubmitType.CHERRY_PICK;
    in.useContributorAgreements = InheritableBoolean.TRUE;
    in.useSignedOffBy = InheritableBoolean.TRUE;
    in.useContentMerge = InheritableBoolean.TRUE;
    in.requireChangeId = InheritableBoolean.TRUE;
    RestResponse r = adminSession.put("/projects/" + newProjectName, in);
    ProjectInfo p = newGson().fromJson(r.getReader(), ProjectInfo.class);
    assertEquals(newProjectName, p.name);
    Project project = projectCache.get(new Project.NameKey(newProjectName)).getProject();
    assertProjectInfo(project, p);
    assertEquals(in.description, project.getDescription());
    assertEquals(in.submitType, project.getSubmitType());
    assertEquals(in.useContributorAgreements, project.getUseContributorAgreements());
    assertEquals(in.useSignedOffBy, project.getUseSignedOffBy());
    assertEquals(in.useContentMerge, project.getUseContentMerge());
    assertEquals(in.requireChangeId, project.getRequireChangeID());
}
#end_block

#method_before
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    TestAccount user = accounts.create("user", "user@example.com", "User");
    RestResponse r = new RestSession(server, user).put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#method_after
@Test
public void testCreateProjectWithoutCapability_Forbidden() throws OrmException, JSchException, IOException {
    RestResponse r = userSession.put("/projects/newProject");
    assertEquals(HttpStatus.SC_FORBIDDEN, r.getStatusCode());
}
#end_block

#method_before
public ProjectStatus getState() {
    return control.getProject().getState();
}
#method_after
public ProjectState getState() {
    return control.getProject().getState();
}
#end_block

#method_before
public final ProjectStatus state() {
    return ProjectStatus.valueOf(getStringState());
}
#method_after
public final ProjectState state() {
    return ProjectState.valueOf(getStringState());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    RestApi call = ChangeApi.detail(patchSetId.getParentKey().get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
    call.get(group.add(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            detail = result;
        }
    }));
    ChangeApi.revision(patchSetId).view("submit_type").get(group.add(new GerritCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            submitTypeRecord = SubmitTypeRecord.OK(SubmitType.valueOf(result.asString()));
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId.getParentKey().get(), "" + patchSetId.get()).view("drafts").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            drafts = result;
        }

        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.revision(patchSetId).view("review").get(group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
            preDisplay(result);
        }
    }));
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == ProjectSubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, ProjectInput input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, ResourceNotFoundException, IOException {
    if (input == null) {
        input = new ProjectInput();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    if (input.pluginConfigValues != null) {
        try {
            ProjectControl projectControl = projectControlFactory.controlFor(p.getNameKey(), currentUser.get());
            PutConfig.Input in = new PutConfig.Input();
            in.pluginConfigValues = input.pluginConfigValues;
            putConfig.get().apply(new ProjectResource(projectControl), in);
        } catch (NoSuchProjectException e) {
            throw new ResourceNotFoundException(p.getName());
        }
    }
    return Response.created(json.format(p));
}
#end_block

#method_before
public final ProjectSubmitType submit_type() {
    return ProjectSubmitType.valueOf(submit_typeRaw());
}
#method_after
public final SubmitType submit_type() {
    return SubmitType.valueOf(submit_typeRaw());
}
#end_block

#method_before
public final ProjectStatus state() {
    if (stateRaw() == null) {
        return ProjectStatus.ACTIVE;
    }
    return ProjectStatus.valueOf(stateRaw());
}
#method_after
public final ProjectState state() {
    if (stateRaw() == null) {
        return ProjectState.ACTIVE;
    }
    return ProjectState.valueOf(stateRaw());
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            commentLinks.add(new RawFindReplace(cl.match(), cl.html()));
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.CHERRY_PICK;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.CHERRY_PICK;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (Strings.emptyToNull(v.getValue()) != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#method_after
@Test
public void filterOutMoreThanOnePageOfResults() throws Exception {
    TestRepository<InMemoryRepository> repo = createProject("repo");
    Change change = newChange(repo, null, null, userId.get(), null).insert();
    int user2 = accountManager.authenticate(AuthRequest.forUser("anotheruser")).getAccountId().get();
    for (int i = 0; i < 5; i++) {
        newChange(repo, null, null, user2, null).insert();
    }
    // assertResultEquals(change, queryOne("status:new ownerin:Administrators"));
    assertResultEquals(change, queryOne("status:new ownerin:Administrators limit:2"));
}
#end_block

#method_before
private static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#method_after
protected static long lastUpdatedMs(Change c) {
    return c.getLastUpdatedOn().getTime();
}
#end_block

#method_before
public static void setConfig(Project.NameKey name, String description, com.google.gerrit.extensions.common.InheritableBoolean useContributorAgreements, com.google.gerrit.extensions.common.InheritableBoolean useContentMerge, com.google.gerrit.extensions.common.InheritableBoolean useSignedOffBy, com.google.gerrit.extensions.common.InheritableBoolean requireChangeId, String maxObjectSizeLimit, com.google.gerrit.extensions.common.ProjectSubmitType submitType, com.google.gerrit.extensions.common.ProjectStatus state, Map<String, Map<String, String>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#method_after
public static void setConfig(Project.NameKey name, String description, InheritableBoolean useContributorAgreements, InheritableBoolean useContentMerge, InheritableBoolean useSignedOffBy, InheritableBoolean requireChangeId, String maxObjectSizeLimit, SubmitType submitType, ProjectState state, Map<String, Map<String, ConfigParameterValue>> pluginConfigValues, AsyncCallback<ConfigInfo> cb) {
    ConfigInput in = ConfigInput.create();
    in.setDescription(description);
    in.setUseContributorAgreements(useContributorAgreements);
    in.setUseContentMerge(useContentMerge);
    in.setUseSignedOffBy(useSignedOffBy);
    in.setRequireChangeId(requireChangeId);
    in.setMaxObjectSizeLimit(maxObjectSizeLimit);
    in.setSubmitType(submitType);
    in.setState(state);
    in.setPluginConfigValues(pluginConfigValues);
    project(name).view("config").put(in, cb);
}
#end_block

#method_before
final void setUseContributorAgreements(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#method_after
final void setUseContributorAgreements(InheritableBoolean v) {
    setUseContributorAgreementsRaw(v.name());
}
#end_block

#method_before
final void setUseContentMerge(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#method_after
final void setUseContentMerge(InheritableBoolean v) {
    setUseContentMergeRaw(v.name());
}
#end_block

#method_before
final void setUseSignedOffBy(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#method_after
final void setUseSignedOffBy(InheritableBoolean v) {
    setUseSignedOffByRaw(v.name());
}
#end_block

#method_before
final void setRequireChangeId(com.google.gerrit.extensions.common.InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#method_after
final void setRequireChangeId(InheritableBoolean v) {
    setRequireChangeIdRaw(v.name());
}
#end_block

#method_before
final void setSubmitType(com.google.gerrit.extensions.common.ProjectSubmitType t) {
    setSubmitTypeRaw(t.name());
}
#method_after
final void setSubmitType(SubmitType t) {
    setSubmitTypeRaw(t.name());
}
#end_block

#method_before
final void setState(com.google.gerrit.extensions.common.ProjectStatus s) {
    setStateRaw(s.name());
}
#method_after
final void setState(ProjectState s) {
    setStateRaw(s.name());
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, ConfigParameterValue>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<ConfigParameterValueMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, ConfigParameterValue>> e : pluginConfigValues.entrySet()) {
            ConfigParameterValueMap values = ConfigParameterValueMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, ConfigParameterValue> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectSubmitType type : com.google.gerrit.extensions.common.ProjectSubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final com.google.gerrit.extensions.common.ProjectStatus stateValue : com.google.gerrit.extensions.common.ProjectStatus.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#method_after
private void initProjectOptions() {
    grid.addHeader(new SmallHeading(Util.C.headingProjectOptions()));
    submitType = new ListBox();
    for (final SubmitType type : SubmitType.values()) {
        submitType.addItem(Util.toLongString(type), type.name());
    }
    submitType.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            setEnabledForUseContentMerge();
        }
    });
    saveEnabler.listenTo(submitType);
    grid.add(Util.C.headingProjectSubmitType(), submitType);
    state = new ListBox();
    for (final ProjectState stateValue : ProjectState.values()) {
        state.addItem(Util.toLongString(stateValue), stateValue.name());
    }
    saveEnabler.listenTo(state);
    grid.add(Util.C.headingProjectState(), state);
    contentMerge = newInheritedBooleanBox();
    saveEnabler.listenTo(contentMerge);
    grid.add(Util.C.useContentMerge(), contentMerge);
    requireChangeID = newInheritedBooleanBox();
    saveEnabler.listenTo(requireChangeID);
    grid.addHtml(Util.C.requireChangeID(), requireChangeID);
    maxObjectSizeLimit = new NpTextBox();
    saveEnabler.listenTo(maxObjectSizeLimit);
    effectiveMaxObjectSizeLimit = new Label();
    effectiveMaxObjectSizeLimit.setStyleName(Gerrit.RESOURCES.css().maxObjectSizeLimitEffectiveLabel());
    HorizontalPanel p = new HorizontalPanel();
    p.add(maxObjectSizeLimit);
    p.add(effectiveMaxObjectSizeLimit);
    grid.addHtml(Util.C.headingMaxObjectSizeLimit(), p);
}
#end_block

#method_before
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (com.google.gerrit.extensions.common.InheritableBoolean b : com.google.gerrit.extensions.common.InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#method_after
private static ListBox newInheritedBooleanBox() {
    ListBox box = new ListBox();
    for (InheritableBoolean b : InheritableBoolean.values()) {
        box.addItem(b.name(), b.name());
    }
    return box;
}
#end_block

#method_before
private void setEnabledForUseContentMerge() {
    if (com.google.gerrit.extensions.common.ProjectSubmitType.FAST_FORWARD_ONLY.equals(com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(com.google.gerrit.extensions.common.InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#method_after
private void setEnabledForUseContentMerge() {
    if (SubmitType.FAST_FORWARD_ONLY.equals(SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())))) {
        contentMerge.setEnabled(false);
        InheritedBooleanInfo b = InheritedBooleanInfo.create();
        b.setConfiguredValue(InheritableBoolean.FALSE);
        setBool(contentMerge, b);
    } else {
        contentMerge.setEnabled(submitType.isEnabled());
    }
}
#end_block

#method_before
private void setSubmitType(final com.google.gerrit.extensions.common.ProjectSubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#method_after
private void setSubmitType(final SubmitType newSubmitType) {
    int index = -1;
    if (submitType != null) {
        for (int i = 0; i < submitType.getItemCount(); i++) {
            if (newSubmitType.name().equals(submitType.getValue(i))) {
                index = i;
                break;
            }
        }
        submitType.setSelectedIndex(index);
        setEnabledForUseContentMerge();
    }
}
#end_block

#method_before
private void setState(final com.google.gerrit.extensions.common.ProjectStatus newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#method_after
private void setState(final ProjectState newState) {
    if (state != null) {
        for (int i = 0; i < state.getItemCount(); i++) {
            if (newState.name().equals(state.getValue(i))) {
                state.setSelectedIndex(i);
                break;
            }
        }
    }
}
#end_block

#method_before
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(com.google.gerrit.extensions.common.InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#method_after
private void setBool(ListBox box, InheritedBooleanInfo inheritedBoolean) {
    int inheritedIndex = -1;
    for (int i = 0; i < box.getItemCount(); i++) {
        if (box.getValue(i).startsWith(InheritableBoolean.INHERIT.name())) {
            inheritedIndex = i;
        }
        if (box.getValue(i).startsWith(inheritedBoolean.configured_value().name())) {
            box.setSelectedIndex(i);
        }
    }
    if (inheritedIndex >= 0) {
        if (getProjectKey().equals(Gerrit.getConfig().getWildProject())) {
            if (box.getSelectedIndex() == inheritedIndex) {
                for (int i = 0; i < box.getItemCount(); i++) {
                    if (box.getValue(i).equals(InheritableBoolean.FALSE.name())) {
                        box.setSelectedIndex(i);
                        break;
                    }
                }
            }
            box.removeItem(inheritedIndex);
        } else {
            box.setItemText(inheritedIndex, InheritableBoolean.INHERIT.name() + " (" + inheritedBoolean.inherited_value() + ")");
        }
    }
}
#end_block

#method_before
private static com.google.gerrit.extensions.common.InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(com.google.gerrit.extensions.common.InheritableBoolean.INHERIT.name())) {
            return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
        }
        return com.google.gerrit.extensions.common.InheritableBoolean.valueOf(selectedValue);
    }
    return com.google.gerrit.extensions.common.InheritableBoolean.INHERIT;
}
#method_after
private static InheritableBoolean getBool(ListBox box) {
    int i = box.getSelectedIndex();
    if (i >= 0) {
        final String selectedValue = box.getValue(i);
        if (selectedValue.startsWith(InheritableBoolean.INHERIT.name())) {
            return InheritableBoolean.INHERIT;
        }
        return InheritableBoolean.valueOf(selectedValue);
    }
    return InheritableBoolean.INHERIT;
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), com.google.gerrit.extensions.common.ProjectSubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), com.google.gerrit.extensions.common.ProjectStatus.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    enableForm(false);
    saveProject.setEnabled(false);
    ProjectApi.setConfig(getProjectKey(), descTxt.getText().trim(), getBool(contributorAgreements), getBool(contentMerge), getBool(signedOffBy), getBool(requireChangeID), maxObjectSizeLimit.getText().trim(), SubmitType.valueOf(submitType.getValue(submitType.getSelectedIndex())), ProjectState.valueOf(state.getValue(state.getSelectedIndex())), getPluginConfigValues(), new GerritCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            enableForm();
            display(result);
        }

        @Override
        public void onFailure(Throwable caught) {
            enableForm();
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
        }
    }
}
#method_after
@Override
public void populateDownloadCommandLinks() {
    if (!urls.isEmpty()) {
        if (allowedCommands.contains(DownloadCommand.CHECKOUT) || allowedCommands.contains(DownloadCommand.DEFAULT_DOWNLOADS)) {
            commands.add(cmdLinkfactory.new CloneCommandLink());
            if (Gerrit.getConfig().getSshdAddress() != null && hasUserName()) {
                commands.add(cmdLinkfactory.new CloneWithCommitMsgHookCommandLink(getProjectKey()));
            }
        }
    }
}
#end_block

#method_before
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(ProjectSubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#method_after
@Override
public void onValueChange(final ValueChangeEvent<ChangeDetail> event) {
    if (isAttached() && isLastValueChangeHandler()) {
        // Until this screen is fully migrated to the new API, these calls must
        // happen sequentially after the ChangeDetail lookup, because we can't
        // start an async get at the source of every call that might trigger a
        // value change.
        CallbackGroup cbs1 = new CallbackGroup();
        final CallbackGroup cbs2 = new CallbackGroup();
        final PatchSet.Id psId = event.getValue().getCurrentPatchSet().getId();
        final Map<String, Patch> patches = new HashMap<String, Patch>();
        String revId = event.getValue().getCurrentPatchSetDetail().getInfo().getRevId();
        if (event.getValue().getChange().getStatus().isOpen()) {
            ChangeApi.revision(changeId.get(), "current").view("submit_type").get(cbs1.add(new GerritCallback<NativeString>() {

                @Override
                public void onSuccess(NativeString result) {
                    event.getValue().setSubmitTypeRecord(SubmitTypeRecord.OK(SubmitType.valueOf(result.asString())));
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        if (Gerrit.isSignedIn()) {
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("related").get(cbs1.add(new AsyncCallback<RelatedChanges.RelatedInfo>() {

                @Override
                public void onSuccess(RelatedChanges.RelatedInfo info) {
                    if (info.changes() != null) {
                        dependsOn(info);
                        neededBy(info);
                    }
                }

                private void dependsOn(RelatedChanges.RelatedInfo info) {
                    ChangeAndCommit self = null;
                    Map<String, ChangeAndCommit> m = new HashMap<String, ChangeAndCommit>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (changeId.equals(c.legacy_id())) {
                            self = c;
                        }
                        if (c.commit() != null && c.commit().commit() != null) {
                            m.put(c.commit().commit(), c);
                        }
                    }
                    if (self != null && self.commit() != null && self.commit().parents() != null) {
                        List<ChangeInfo> d = new ArrayList<ChangeInfo>();
                        for (CommitInfo p : Natives.asList(self.commit().parents())) {
                            ChangeAndCommit pc = m.get(p.commit());
                            if (pc != null && pc.has_change_number()) {
                                ChangeInfo i = new ChangeInfo();
                                load(pc, i);
                                d.add(i);
                            }
                        }
                        event.getValue().setDependsOn(d);
                    }
                }

                private void neededBy(RelatedChanges.RelatedInfo info) {
                    Set<String> mine = new HashSet<String>();
                    for (PatchSet ps : event.getValue().getPatchSets()) {
                        mine.add(ps.getRevision().get());
                    }
                    List<ChangeInfo> n = new ArrayList<ChangeInfo>();
                    for (int i = 0; i < info.changes().length(); i++) {
                        ChangeAndCommit c = info.changes().get(i);
                        if (c.has_change_number() && c.commit() != null && c.commit().parents() != null) {
                            for (int j = 0; j < c.commit().parents().length(); j++) {
                                CommitInfo p = c.commit().parents().get(j);
                                if (mine.contains(p.commit())) {
                                    ChangeInfo u = new ChangeInfo();
                                    load(c, u);
                                    n.add(u);
                                    break;
                                }
                            }
                        }
                    }
                    event.getValue().setNeededBy(n);
                }

                private void load(final ChangeAndCommit pc, final ChangeInfo i) {
                    RestApi call = ChangeApi.change(pc.legacy_id().get());
                    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.CURRENT_REVISION));
                    call.get(cbs2.add(new AsyncCallback<com.google.gerrit.client.changes.ChangeInfo>() {

                        public void onFailure(Throwable caught) {
                        }

                        public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                            i.set(ChangeDetailCache.toChange(result), pc.patch_set_id());
                            i.setStarred(result.starred());
                            event.getValue().getAccounts().merge(ChangeDetailCache.users(result));
                        }
                    }));
                }

                public void onFailure(Throwable caught) {
                }
            }));
            ChangeApi.revision(changeId.get(), revId).view("files").addParameterTrue("reviewed").get(cbs1.add(new AsyncCallback<JsArrayString>() {

                @Override
                public void onSuccess(JsArrayString result) {
                    for (int i = 0; i < result.length(); i++) {
                        String path = result.get(i);
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setReviewedByCurrentUser(true);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
            final Set<PatchSet.Id> withDrafts = new HashSet<PatchSet.Id>();
            event.getValue().setPatchSetsWithDraftComments(withDrafts);
            for (PatchSet ps : event.getValue().getPatchSets()) {
                if (!ps.getId().equals(psId)) {
                    final PatchSet.Id id = ps.getId();
                    ChangeApi.revision(changeId.get(), "" + id.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                        @Override
                        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                            if (!result.isEmpty()) {
                                withDrafts.add(id);
                            }
                        }

                        public void onFailure(Throwable caught) {
                        }
                    }));
                }
            }
            ChangeApi.revision(changeId.get(), "" + psId.get()).view("drafts").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                    for (String path : result.keySet()) {
                        Patch p = patches.get(path);
                        if (p == null) {
                            p = new Patch(new Patch.Key(psId, path));
                            patches.put(path, p);
                        }
                        p.setDraftCount(result.get(path).length());
                    }
                    if (!result.isEmpty()) {
                        withDrafts.add(psId);
                    }
                }

                public void onFailure(Throwable caught) {
                }
            }));
        }
        ChangeApi.revision(changeId.get(), revId).view("comments").get(cbs1.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
                for (String path : result.keySet()) {
                    Patch p = patches.get(path);
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, path));
                        patches.put(path, p);
                    }
                    p.setCommentCount(result.get(path).length());
                }
            }

            public void onFailure(Throwable caught) {
            }
        }));
        DiffApi.list(changeId.get(), null, revId, new AsyncCallback<NativeMap<FileInfo>>() {

            @Override
            public void onSuccess(NativeMap<FileInfo> result) {
                JsArray<FileInfo> fileInfos = result.values();
                FileInfo.sortFileInfoByPath(fileInfos);
                List<Patch> list = new ArrayList<Patch>(fileInfos.length());
                for (FileInfo f : Natives.asList(fileInfos)) {
                    Patch p = patches.get(f.path());
                    if (p == null) {
                        p = new Patch(new Patch.Key(psId, f.path()));
                        patches.put(f.path(), p);
                    }
                    p.setInsertions(f.lines_inserted());
                    p.setDeletions(f.lines_deleted());
                    p.setPatchType(f.binary() ? PatchType.BINARY : PatchType.UNIFIED);
                    if (f.status() == null) {
                        p.setChangeType(ChangeType.MODIFIED);
                    } else {
                        p.setChangeType(ChangeType.forCode(f.status().charAt(0)));
                    }
                    list.add(p);
                }
                event.getValue().getCurrentPatchSetDetail().setPatches(list);
            }

            public void onFailure(Throwable caught) {
            }
        });
        ConfigInfoCache.get(event.getValue().getChange().getProject(), cbs1.add(new GerritCallback<ConfigInfoCache.Entry>() {

            @Override
            public void onSuccess(ConfigInfoCache.Entry result) {
                commentLinkProcessor = result.getCommentLinkProcessor();
                setTheme(result.getTheme());
            }

            @Override
            public void onFailure(Throwable caught) {
            // Handled by last callback's onFailure.
            }
        }));
        ChangeApi.detail(changeId.get(), cbs1.addFinal(new GerritCallback<com.google.gerrit.client.changes.ChangeInfo>() {

            @Override
            public void onSuccess(com.google.gerrit.client.changes.ChangeInfo result) {
                changeInfo = result;
                cbs2.addFinal(new AsyncCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        display(event.getValue());
                    }

                    public void onFailure(Throwable caught) {
                    }
                }).onSuccess(null);
            }
        }));
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", ProjectSubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
private boolean isHidden() {
    return getProject().getState().equals(ProjectStatus.HIDDEN);
}
#method_after
private boolean isHidden() {
    return getProject().getState().equals(com.google.gerrit.extensions.api.projects.ProjectState.HIDDEN);
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.REBASE_IF_NECESSARY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.REBASE_IF_NECESSARY;
}
#end_block

#method_before
private boolean refresh(Change change, PatchSet ps, ProjectSubmitType type, Repository git, Map<String, Ref> refs, Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().get(change.getId());
        if (c != null) {
            c.setMergeable(mergeable);
            c.setLastSha1MergeTested(toRevId(ref));
            db.get().changes().update(Collections.singleton(c));
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#method_after
private boolean refresh(Change change, final PatchSet ps, SubmitType type, Repository git, Map<String, Ref> refs, final Ref ref) throws IOException, OrmException {
    RevWalk rw = new RevWalk(git) {

        @Override
        protected CodeReviewCommit createCommit(AnyObjectId id) {
            return new CodeReviewCommit(id);
        }
    };
    try {
        ObjectId id;
        try {
            id = ObjectId.fromString(ps.getRevision().get());
        } catch (IllegalArgumentException e) {
            log.error(String.format("Invalid revision on patch set %d of %d", ps.getId().get(), change.getId().get()));
            return false;
        }
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = parse(rw, id);
        rev.add(canMerge);
        final boolean mergeable;
        if (ref == null || ref.getObjectId() == null) {
            // Assume yes on new branch.
            mergeable = true;
        } else {
            CodeReviewCommit tip = parse(rw, ref.getObjectId());
            Set<RevCommit> accepted = alreadyAccepted(rw, refs.values());
            accepted.add(tip);
            accepted.addAll(Arrays.asList(rev.getParents()));
            mergeable = submitStrategyFactory.create(type, db.get(), git, rw, null, /*inserter*/
            canMerge, accepted, change.getDest()).dryRun(tip, rev);
        }
        Change c = db.get().changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change c) {
                if (c.getStatus().isOpen() && ps.getId().equals(c.currentPatchSetId())) {
                    c.setMergeable(mergeable);
                    c.setLastSha1MergeTested(toRevId(ref));
                    return c;
                } else {
                    return null;
                }
            }
        });
        if (c != null) {
            indexer.index(db.get(), c);
        }
        return mergeable;
    } catch (MergeException | IOException | NoSuchProjectException e) {
        log.error(String.format("Cannot merge test change %d", change.getId().get()), e);
        return false;
    } finally {
        rw.release();
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                ProjectSubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private ProjectSubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = args.changeDataFactory.create(db.get(), c).currentFilePaths();
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            args.conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = args.changeControlGenericFactory.controlFor(change, args.userFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
public void setSubmitType(final ProjectSubmitType type) {
    submitType = type;
}
#method_after
public void setSubmitType(final SubmitType type) {
    submitType = type;
}
#end_block

#method_before
public ProjectStatus getState() {
    return state;
}
#method_after
public ProjectState getState() {
    return state;
}
#end_block

#method_before
public void setState(final ProjectStatus newState) {
    state = newState;
}
#method_after
public void setState(final ProjectState newState) {
    state = newState;
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getCurrentUser().equals(who)) {
        return this;
    }
    return new ChangeControl(approvalsUtil, changeDataFactory, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(ProjectSubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#method_after
public SubmitTypeRecord getSubmitTypeRecord(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd) {
    cd = changeData(db, cd);
    try {
        if (getChange().getStatus() == Change.Status.DRAFT && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
        if (patchSet.isDraft() && !isDraftVisible(db, cd)) {
            return typeRuleError("Patch set " + patchSet.getPatchSetId() + " not found");
        }
    } catch (OrmException err) {
        return logTypeRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results;
    SubmitRuleEvaluator evaluator;
    try {
        evaluator = new SubmitRuleEvaluator(db, patchSet, getProjectControl(), this, getChange(), cd, false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results");
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        return logTypeRuleError(e.getMessage(), e);
    }
    if (results.isEmpty()) {
        // Should never occur for a well written rule
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " has no solution.");
        return typeRuleError("Project submit rule has no solution");
    }
    Term typeTerm = results.get(0);
    if (!typeTerm.isSymbol()) {
        log.error("Submit rule '" + evaluator.getSubmitRule() + "' for change " + getChange().getId() + " of " + getProject().getName() + " did not return a symbol.");
        return typeRuleError("Project submit rule has invalid solution");
    }
    String typeName = ((SymbolTerm) typeTerm).name();
    try {
        return SubmitTypeRecord.OK(SubmitType.valueOf(typeName.toUpperCase()));
    } catch (IllegalArgumentException e) {
        return logInvalidType(evaluator.getSubmitRule(), typeName);
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return ProjectSubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#method_after
@Override
public SubmitType apply(RevisionResource rsrc, Input input) throws AuthException, BadRequestException {
    if (input == null) {
        input = new Input();
    }
    if (input.rule != null && !rules.isProjectRulesEnabled()) {
        throw new AuthException("project rules are disabled");
    }
    input.filters = Objects.firstNonNull(input.filters, filters);
    SubmitRuleEvaluator evaluator = new SubmitRuleEvaluator(db, rsrc.getPatchSet(), rsrc.getControl().getProjectControl(), rsrc.getControl(), rsrc.getChange(), changeDataFactory.create(db, rsrc.getChange()), false, "locate_submit_type", "get_submit_type", "locate_submit_type_filter", "filter_submit_type_results", input.filters == Filters.SKIP, input.rule != null ? new ByteArrayInputStream(input.rule.getBytes(UTF_8)) : null);
    List<Term> results;
    try {
        results = evaluator.evaluate();
    } catch (RuleEvalException e) {
        throw new BadRequestException(String.format("rule failed with exception: %s", e.getMessage()));
    }
    if (results.isEmpty()) {
        throw new BadRequestException(String.format("rule %s has no solution", evaluator.getSubmitRule()));
    }
    Term type = results.get(0);
    if (!type.isSymbol()) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
    String typeName = ((SymbolTerm) type).name();
    try {
        return SubmitType.valueOf(typeName.toUpperCase());
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(String.format("rule %s produced invalid result: %s", evaluator.getSubmitRule().toString(), type));
    }
}
#end_block

#method_before
@Override
public ProjectSubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#method_after
@Override
public SubmitType apply(RevisionResource resource) throws AuthException, BadRequestException {
    return test.apply(resource, null);
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            gApi.projects().create(input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | OrmException | NoSuchProjectException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        if (!suggestParent) {
            if (projectName == null) {
                throw new UnloggedFailure(1, "fatal: Project name is required.");
            }
            ProjectInput input = new ProjectInput();
            input.name = projectName;
            if (ownerIds != null) {
                input.owners = Lists.transform(ownerIds, new Function<AccountGroup.UUID, String>() {

                    @Override
                    public String apply(AccountGroup.UUID uuid) {
                        return uuid.get();
                    }
                });
            }
            if (newParent != null) {
                input.parent = newParent.getProject().getName();
            }
            input.permissionsOnly = permissionsOnly;
            input.description = projectDescription;
            input.submitType = submitType;
            input.useContributorAgreements = contributorAgreements;
            input.useSignedOffBy = signedOffBy;
            input.useContentMerge = contentMerge;
            input.requireChangeId = requireChangeID;
            input.branches = branch;
            input.createEmptyCommit = createEmptyCommit;
            input.maxObjectSizeLimit = maxObjectSizeLimit;
            if (pluginConfigValues != null) {
                input.pluginConfigValues = parsePluginConfigValues(pluginConfigValues);
            }
            createProjectFactory.get().create(projectName).apply(TopLevelResource.INSTANCE, input);
        } else {
            List<Project.NameKey> parentCandidates = suggestParentCandidatesFactory.create().getNameKeys();
            for (Project.NameKey parent : parentCandidates) {
                stdout.print(parent + "\n");
            }
        }
    } catch (RestApiException | ProjectCreationFailedException | IOException | NoSuchProjectException | OrmException err) {
        throw new UnloggedFailure(1, "fatal: " + err.getMessage(), err);
    }
}
#end_block

#method_before
private Map<String, Map<String, String>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, String>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String value = s[1];
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, String> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#method_after
@VisibleForTesting
Map<String, Map<String, ConfigValue>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, ConfigValue>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'" + " or '<plugin-name>.<parameter-name>=<value1,value2,...>'");
        }
        ConfigValue value = new ConfigValue();
        String v = s[1];
        if (v.contains(",")) {
            value.values = Lists.newArrayList(Splitter.on(",").split(v));
        } else {
            value.value = v;
        }
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, ConfigValue> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<ProjectSubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<ProjectSubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<ProjectSubmitType> submitTypes = new HashSet<ProjectSubmitType>(toMerge.keySet());
            for (final ProjectSubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.statusCode = null;
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes, message(commit.getChange(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge() throws MergeException {
    setDestProject();
    try {
        openSchema();
        openRepository();
        RefUpdate branchUpdate = openBranch();
        boolean reopen = false;
        final ListMultimap<SubmitType, Change> toSubmit = validateChangeList(db.changes().submitted(destBranch).toList());
        final ListMultimap<SubmitType, CodeReviewCommit> toMergeNextTurn = ArrayListMultimap.create();
        final List<CodeReviewCommit> potentiallyStillSubmittableOnNextRun = new ArrayList<CodeReviewCommit>();
        while (!toMerge.isEmpty()) {
            toMergeNextTurn.clear();
            final Set<SubmitType> submitTypes = new HashSet<SubmitType>(toMerge.keySet());
            for (final SubmitType submitType : submitTypes) {
                if (reopen) {
                    branchUpdate = openBranch();
                }
                final SubmitStrategy strategy = createStrategy(submitType);
                preMerge(strategy, toMerge.get(submitType));
                RefUpdate update = updateBranch(strategy, branchUpdate);
                reopen = true;
                updateChangeStatus(toSubmit.get(submitType));
                updateSubscriptions(toSubmit.get(submitType));
                if (update != null) {
                    fireRefUpdated(update);
                }
                for (final Iterator<CodeReviewCommit> it = potentiallyStillSubmittable.iterator(); it.hasNext(); ) {
                    final CodeReviewCommit commit = it.next();
                    if (containsMissingCommits(toMerge, commit) || containsMissingCommits(toMergeNextTurn, commit)) {
                        // change has missing dependencies, but all commits which are
                        // missing are still attempted to be merged with another submit
                        // strategy, retry to merge this commit in the next turn
                        it.remove();
                        commit.setStatusCode(null);
                        commit.missing = null;
                        toMergeNextTurn.put(submitType, commit);
                    }
                }
                potentiallyStillSubmittableOnNextRun.addAll(potentiallyStillSubmittable);
                potentiallyStillSubmittable.clear();
            }
            toMerge.clear();
            toMerge.putAll(toMergeNextTurn);
        }
        updateChangeStatus(toUpdate);
        for (final CodeReviewCommit commit : potentiallyStillSubmittableOnNextRun) {
            final Capable capable = isSubmitStillPossible(commit);
            if (capable != Capable.OK) {
                sendMergeFail(commit.notes(), message(commit.change(), capable.getMessage()), false);
            }
        }
    } catch (NoSuchProjectException noProject) {
        log.warn(String.format("Project %s no longer exists, abandoning open changes", destBranch.getParentKey().get()));
        abandonAllOpenChanges();
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (repo != null) {
            repo.close();
        }
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private boolean containsMissingCommits(final ListMultimap<ProjectSubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean containsMissingCommits(final ListMultimap<SubmitType, CodeReviewCommit> map, final CodeReviewCommit commit) {
    if (!isSubmitForMissingCommitsStillPossible(commit)) {
        return false;
    }
    for (final CodeReviewCommit missingCommit : commit.missing) {
        if (!map.containsValue(missingCommit)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        loadChangeInfo(missingCommit);
        if (missingCommit.patchsetId == null) {
            // 
            return false;
        }
        if (!missingCommit.getChange().currentPatchSetId().equals(missingCommit.patchsetId)) {
            // 
            return false;
        }
    }
    return true;
}
#method_after
private boolean isSubmitForMissingCommitsStillPossible(final CodeReviewCommit commit) {
    if (commit.missing == null || commit.missing.isEmpty()) {
        return false;
    }
    for (CodeReviewCommit missingCommit : commit.missing) {
        try {
            loadChangeInfo(missingCommit);
        } catch (NoSuchChangeException | OrmException e) {
            log.error("Cannot check if missing commits can be submitted", e);
            return false;
        }
        if (missingCommit.getPatchsetId() == null) {
            // 
            return false;
        }
        if (!missingCommit.change().currentPatchSetId().equals(missingCommit.getPatchsetId())) {
            // 
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private SubmitStrategy createStrategy(final ProjectSubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#end_block

#method_before
private ListMultimap<ProjectSubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<ProjectSubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        commit.notes = notesFactory.create(chg);
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final ProjectSubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            toUpdate.add(chg);
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            toUpdate.add(chg);
            continue;
        }
        try {
            commit.setControl(changeControlFactory.controlFor(chg, identifiedUserFactory.create(chg.getOwner())));
        } catch (NoSuchChangeException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        commit.setPatchsetId(ps.getId());
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        SubmitType submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private ProjectSubmitType getSubmitType(final Change change, final PatchSet ps) {
    try {
        final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db, ps);
        if (r.status != SubmitTypeRecord.Status.OK) {
            log.error("Failed to get submit type for " + change.getKey());
            return null;
        }
        return r.type;
    } catch (NoSuchChangeException e) {
        log.error("Failed to get submit type for " + change.getKey(), e);
        return null;
    }
}
#method_after
private SubmitType getSubmitType(ChangeControl ctl, PatchSet ps) {
    SubmitTypeRecord r = ctl.getSubmitTypeRecord(db, ps);
    if (r.status != SubmitTypeRecord.Status.OK) {
        log.error("Failed to get submit type for " + ctl.getChange().getKey());
        return null;
    }
    return r.type;
}
#end_block

#method_before
private void updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if ((branchTip == null && mergeTip == null) || branchTip == mergeTip) {
        // nothing to do
        return;
    }
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip)) {
        if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, mergeTip);
            } catch (Exception e) {
                throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
            }
        }
        branchUpdate.setRefLogIdent(refLogIdent);
        branchUpdate.setForceUpdate(false);
        branchUpdate.setNewObjectId(mergeTip);
        branchUpdate.setRefLogMessage("merged", true);
        try {
            switch(branchUpdate.update(rw)) {
                case NEW:
                case FAST_FORWARD:
                    if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                        tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                    }
                    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                        projectCache.evict(destProject.getProject());
                        destProject = projectCache.get(destProject.getProject().getNameKey());
                        repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                    }
                    gitRefUpdated.fire(destBranch.getParentKey(), branchUpdate);
                    Account account = null;
                    PatchSetApproval submitter = approvalsUtil.getSubmitter(db, mergeTip.notes, mergeTip.patchsetId);
                    if (submitter != null) {
                        account = accountCache.get(submitter.getAccountId()).getAccount();
                    }
                    hooks.doRefUpdatedHook(destBranch, branchUpdate, account);
                    break;
                case LOCK_FAILURE:
                    String msg;
                    if (strategy.retryOnLockFailure()) {
                        mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                        msg = "will retry";
                    } else {
                        msg = "will not retry";
                    }
                    throw new IOException(branchUpdate.getResult().name() + ", " + msg);
                default:
                    throw new IOException(branchUpdate.getResult().name());
            }
        } catch (IOException e) {
            throw new MergeException("Cannot update " + branchUpdate.getName(), e);
        }
    }
}
#method_after
private RefUpdate updateBranch(final SubmitStrategy strategy, final RefUpdate branchUpdate) throws MergeException {
    if (branchTip == mergeTip || mergeTip == null) {
        // nothing to do
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, mergeTip);
        } catch (Exception e) {
            throw new MergeException("Submit would store invalid" + " project configuration " + mergeTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(mergeTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        switch(branchUpdate.update(rw)) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), mergeTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    projectCache.evict(destProject.getProject());
                    destProject = projectCache.get(destProject.getProject().getNameKey());
                    repoManager.setProjectDescription(destProject.getProject().getNameKey(), destProject.getProject().getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                String msg;
                if (strategy.retryOnLockFailure()) {
                    mergeQueue.recheckAfter(destBranch, LOCK_FAILURE_RETRY_DELAY, MILLISECONDS);
                    msg = "will retry";
                } else {
                    msg = "will not retry";
                }
                throw new IOException(branchUpdate.getResult().name() + ", " + msg);
            default:
                throw new IOException(branchUpdate.getResult().name());
        }
    } catch (IOException e) {
        throw new MergeException("Cannot update " + branchUpdate.getName(), e);
    }
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(commit, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.getChange();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.getChange().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.patchsetId != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.patchsetId.get());
                m.append(" of ");
                m.append(missingCommit.getChange().getKey().abbreviate());
                if (missingCommit.patchsetId.get() != missingCommit.getChange().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.getChange().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#method_after
private Capable isSubmitStillPossible(final CodeReviewCommit commit) {
    final Capable capable;
    final Change c = commit.change();
    final boolean submitStillPossible = isSubmitForMissingCommitsStillPossible(commit);
    final long now = TimeUtil.nowMs();
    final long waitUntil = c.getLastUpdatedOn().getTime() + DEPENDENCY_DELAY;
    if (submitStillPossible && now < waitUntil) {
        // If we waited a short while we might still be able to get
        // this change submitted. Reschedule an attempt in a bit.
        // 
        mergeQueue.recheckAfter(destBranch, waitUntil - now, MILLISECONDS);
        capable = Capable.OK;
    } else if (submitStillPossible) {
        // It would be possible to submit the change if the missing
        // dependencies are also submitted. Perhaps the user just
        // forgot to submit those.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change could not be merged because of a missing dependency.");
        m.append("\n");
        m.append("\n");
        m.append("The following changes must also be submitted:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            m.append("* ");
            m.append(missingCommit.change().getKey().get());
            m.append("\n");
        }
        capable = new Capable(m.toString());
    } else {
        // It is impossible to submit this change as-is. The author
        // needs to rebase it in order to work around the missing
        // dependencies.
        // 
        StringBuilder m = new StringBuilder();
        m.append("Change cannot be merged due to unsatisfiable dependencies.\n");
        m.append("\n");
        m.append("The following dependency errors were found:\n");
        m.append("\n");
        for (CodeReviewCommit missingCommit : commit.missing) {
            if (missingCommit.getPatchsetId() != null) {
                m.append("* Depends on patch set ");
                m.append(missingCommit.getPatchsetId().get());
                m.append(" of ");
                m.append(missingCommit.change().getKey().abbreviate());
                if (missingCommit.getPatchsetId().get() != missingCommit.change().currentPatchSetId().get()) {
                    m.append(", however the current patch set is ");
                    m.append(missingCommit.change().currentPatchSetId().get());
                }
                m.append(".\n");
            } else {
                m.append("* Depends on commit ");
                m.append(missingCommit.name());
                m.append(" which has no change associated with it.\n");
            }
        }
        m.append("\n");
        m.append("Please rebase the change and upload a replacement commit.");
        capable = new Capable(m.toString());
    }
    return capable;
}
#end_block

#method_before
private void loadChangeInfo(final CodeReviewCommit commit) {
    if (commit.notes == null) {
        try {
            List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
            if (matches.size() == 1) {
                final PatchSet ps = matches.get(0);
                commit.patchsetId = ps.getId();
                commit.notes = notesFactory.create(db.changes().get(ps.getId().getParentKey()));
            }
        } catch (OrmException e) {
        }
    }
}
#method_after
private void loadChangeInfo(final CodeReviewCommit commit) throws NoSuchChangeException, OrmException {
    if (commit.getControl() == null) {
        List<PatchSet> matches = db.patchSets().byRevision(new RevId(commit.name())).toList();
        if (matches.size() == 1) {
            PatchSet ps = matches.get(0);
            commit.setPatchsetId(ps.getId());
            commit.setControl(changeControl(db.changes().get(ps.getId().getParentKey())));
        }
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.getChange().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#method_after
private void setMerged(Change c, ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change().currentPatchSetId();
        c = setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = approvalsUtil.getSubmitter(db, commit.notes(), merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(merged), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(db, c);
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                final ChangeControl control = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner()));
                final MergedSender cm = mergedSenderFactory.create(control);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(changeControl(c));
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes, msg, true);
}
#method_after
private void setNew(CodeReviewCommit c, ChangeMessage msg) {
    sendMergeFail(c.notes(), msg, true);
}
#end_block

#method_before
public ProjectSubmitType getSubmitType() {
    return submitType;
}
#method_after
public SubmitType getSubmitType() {
    return submitType;
}
#end_block

#method_before
@Override
protected ProjectSubmitType getSubmitType() {
    return ProjectSubmitType.FAST_FORWARD_ONLY;
}
#method_after
@Override
protected SubmitType getSubmitType() {
    return SubmitType.FAST_FORWARD_ONLY;
}
#end_block

#method_before
public static SubmitTypeRecord OK(ProjectSubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#method_after
public static SubmitTypeRecord OK(SubmitType type) {
    SubmitTypeRecord r = new SubmitTypeRecord();
    r.status = Status.OK;
    r.type = type;
    return r;
}
#end_block

#method_before
public boolean authenticate(String username, PublicKey key, ServerSession session) {
    Map<PublicKey, Boolean> map = sessionCache.get(session);
    if (map == null) {
        map = new HashMap<>();
        sessionCache.put(session, map);
        session.addListener(this);
    }
    if (map.containsKey(key)) {
        return map.get(key);
    }
    boolean result = authenticator.authenticate(username, key, session);
    map.put(key, result);
    return result;
}
#method_after
@Override
public boolean authenticate(String username, PublicKey key, ServerSession session) {
    Map<PublicKey, Boolean> m = sessionCache.get(session);
    if (m == null) {
        m = new HashMap<>();
        sessionCache.put(session, m);
        session.addListener(this);
    }
    if (m.containsKey(key)) {
        return m.get(key);
    }
    boolean r = authenticator.authenticate(username, key, session);
    m.put(key, r);
    return r;
}
#end_block

#method_before
public void sessionCreated(Session session) {
}
#method_after
@Override
public void sessionCreated(Session session) {
}
#end_block

#method_before
public void sessionEvent(Session sesssion, Event event) {
}
#method_after
@Override
public void sessionEvent(Session sesssion, Event event) {
}
#end_block

#method_before
public void sessionClosed(Session session) {
    sessionCache.remove(session);
}
#method_after
@Override
public void sessionClosed(Session session) {
    sessionCache.remove(session);
}
#end_block

#method_before
@Override
@SuppressWarnings("deprecation")
public synchronized void stop() {
    if (acceptor != null) {
        try {
            acceptor.dispose();
            log.info("Stopped Gerrit SSHD");
        } finally {
            acceptor = null;
        }
    }
}
#method_after
@Override
public synchronized void stop() {
    if (acceptor != null) {
        try {
            acceptor.close(true).await();
            log.info("Stopped Gerrit SSHD");
        } catch (InterruptedException e) {
            log.warn("Exception caught while closing", e);
        } finally {
            acceptor = null;
        }
    }
}
#end_block

#method_before
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    for (H2CacheImpl<?, ?> cache : caches) {
        cache.stop();
    }
}
#method_after
@Override
public void stop() {
    if (executor != null) {
        try {
            cleanup.shutdownNow();
            List<Runnable> pending = executor.shutdownNow();
            if (executor.awaitTermination(15, TimeUnit.MINUTES)) {
                if (pending != null && !pending.isEmpty()) {
                    log.info(String.format("Finishing %d disk cache updates", pending.size()));
                    for (Runnable update : pending) {
                        update.run();
                    }
                }
            } else {
                log.info("Timeout waiting for disk cache to close");
            }
        } catch (InterruptedException e) {
            log.warn("Interrupted waiting for disk cache to shutdown");
        }
    }
    synchronized (caches) {
        for (H2CacheImpl<?, ?> cache : caches) {
            cache.stop();
        }
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    caches.add(cache);
    return cache;
}
#method_after
@SuppressWarnings({ "unchecked", "cast" })
@Override
public <K, V> Cache<K, V> build(CacheBinding<K, V> def) {
    long limit = config.getLong("cache", def.name(), "diskLimit", 128 << 20);
    if (cacheDir == null || limit <= 0) {
        return defaultFactory.build(def);
    }
    SqlStore<K, V> store = newSqlStore(def.name(), def.keyType(), limit);
    H2CacheImpl<K, V> cache = new H2CacheImpl<K, V>(executor, store, def.keyType(), (Cache<K, ValueHolder<V>>) defaultFactory.create(def, true).build());
    synchronized (caches) {
        caches.add(cache);
    }
    return cache;
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        renderHtml(req, res, template_name, data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> data = new LogSoyData(req, view).toSoyData(paginator, null, df);
        if (!view.getRevision().nameIsId()) {
            List<Map<String, Object>> tags = Lists.newArrayListWithExpectedSize(1);
            for (RevObject o : RevisionServlet.listObjects(paginator.getWalk(), view.getRevision())) {
                if (o instanceof RevTag) {
                    tags.add(new TagSoyData(linkifier, req).toSoyData((RevTag) o, df));
                }
            }
            if (!tags.isEmpty()) {
                data.put("tags", tags);
            }
        }
        String title = "Log - ";
        if (view.getOldRevision() != Revision.NULL) {
            title += view.getRevisionRange();
        } else {
            title += view.getRevision().getName();
        }
        data.put("title", title);
        GitilesConfig.putVariant(getAccess(req).getConfig(), "logEntry", "logEntryVariant", data);
        renderHtml(req, res, "gitiles.logDetail", data);
    } catch (RevWalkException e) {
        log.warn("Error in rev walk", e);
        res.setStatus(SC_INTERNAL_SERVER_ERROR);
        return;
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(CommitJsonData.toJsonData(c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Repository repo = ServletUtils.getRepository(req);
    GitilesView view = getView(req, repo);
    Paginator paginator = newPaginator(repo, view);
    if (paginator == null) {
        res.setStatus(SC_NOT_FOUND);
        return;
    }
    try {
        GitDateFormatter df = new GitDateFormatter(Format.DEFAULT);
        Map<String, Object> result = Maps.newLinkedHashMap();
        List<CommitJsonData.Commit> entries = Lists.newArrayListWithCapacity(paginator.getLimit());
        for (RevCommit c : paginator) {
            paginator.getWalk().parseBody(c);
            entries.add(new CommitJsonData().setRevWalk(paginator.getWalk()).toJsonData(req, c, df));
        }
        result.put("log", entries);
        if (paginator.getPreviousStart() != null) {
            result.put("previous", paginator.getPreviousStart().name());
        }
        if (paginator.getNextStart() != null) {
            result.put("next", paginator.getNextStart().name());
        }
        renderJson(req, res, result, new TypeToken<Map<String, Object>>() {
        }.getType());
    } finally {
        paginator.getWalk().release();
    }
}
#end_block

#method_before
@Override
public void addDocument(Iterable<? extends IndexableField> doc) throws IOException {
    super.addDocument(doc);
}
#method_after
@Override
public void addDocument(Iterable<? extends IndexableField> doc) throws IOException {
    super.addDocument(doc);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Term... terms) throws IOException {
    super.deleteDocuments(terms);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Term term) throws IOException {
    super.deleteDocuments(term);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Query... queries) throws IOException {
    super.deleteDocuments(queries);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Term... terms) throws IOException {
    super.deleteDocuments(terms);
    autoFlush();
}
#end_block

#method_before
@Override
public void deleteDocuments(Query... queries) throws IOException {
    super.deleteDocuments(queries);
    autoFlush();
}
#method_after
@Override
public void deleteDocuments(Query query) throws IOException {
    super.deleteDocuments(query);
    autoFlush();
}
#end_block

#method_before
void manualFlush() throws IOException {
    flush(true, true);
}
#method_after
void manualFlush() throws IOException {
    flush(true, true);
    if (autoCommit) {
        commit();
    }
}
#end_block

#method_before
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<String>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
boolean set(ChangeInfo info, boolean current) {
    List<String> names = new ArrayList<>(info.labels());
    Collections.sort(names);
    boolean canSubmit = info.status().isOpen();
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
        if (canSubmit && info.status() == Change.Status.NEW) {
            switch(label.status()) {
                case NEED:
                    if (current) {
                        statusText.setInnerText("Needs " + name);
                    }
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (current) {
                        statusText.setInnerText("Not " + name);
                    }
                    canSubmit = false;
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<Integer, List<ApprovalInfo>>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<ApprovalInfo>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), Collections.<Integer>emptySet(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<Integer>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#method_after
private static List<Integer> sort(Set<Integer> keySet, int a, int b) {
    List<Integer> r = new ArrayList<>(keySet);
    Collections.sort(r);
    if (keySet.contains(a)) {
        r.remove(Integer.valueOf(a));
        r.add(0, a);
    } else if (keySet.contains(b)) {
        r.remove(Integer.valueOf(b));
        r.add(0, b);
    }
    return r;
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, ApprovalDetail> votable) {
    List<AccountInfo> users = new ArrayList<AccountInfo>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String nonVotableCategories = "";
        if (votable != null) {
            Set<String> nonVotable = votable.get(ai._account_id()).nonVotable();
            if (!nonVotable.isEmpty()) {
                StringBuilder sb = new StringBuilder("Non votable: ");
                for (Iterator<String> it = nonVotable.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                nonVotableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", nonVotableCategories).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button").setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE + "(event)").append(new ImageResourceRenderer().render(Resources.I.remove_reviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element reviewersText) {
    this.style = style;
    this.reviewersText = reviewersText;
}
#method_after
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<Integer>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, ApprovalDetail> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = new HashSet<>();
    if (info.removable_reviewers() != null) {
        for (AccountInfo a : Natives.asList(info.removable_reviewers())) {
            removable.add(a._account_id());
        }
    }
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
}
#end_block

#method_before
private static Map<Integer, ApprovalDetail> votable(ChangeInfo change) {
    Map<Integer, ApprovalDetail> d = new HashMap<Integer, ApprovalDetail>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                ApprovalDetail ad = d.get(id);
                if (ad == null) {
                    ad = new ApprovalDetail(new Account.Id(id));
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
                ad.value(name, ai.has_value() ? ai.value() : 0);
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change)).insert();
    return change.getId();
}
#method_after
private Change.Id createNewChange(Repository git, RevWalk revWalk, Change.Key changeKey, Project.NameKey project, PatchSet.Id patchSetId, Ref destRef, RevCommit cherryPickCommit, RefControl refControl) throws OrmException, InvalidChangeOperationException, IOException {
    Change change = new Change(changeKey, new Change.Id(db.nextChangeId()), currentUser.getAccountId(), new Branch.NameKey(project, destRef.getName()), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(refControl, change, cherryPickCommit);
    PatchSet newPatchSet = ins.getPatchSet();
    CommitValidators commitValidators = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), cherryPickCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), cherryPickCommit, currentUser);
    try {
        commitValidators.validateForGerritCommits(commitReceivedEvent);
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(cherryPickCommit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    ins.setMessage(buildChangeMessage(patchSetId, change, cherryPickCommit)).insert();
    return change.getId();
}
#end_block

#method_before
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Cherry Picked");
    msgBuf.append("\n\n");
    msgBuf.append("This patchset was cherry picked to branch: " + dest.getDest().get());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#method_after
private ChangeMessage buildChangeMessage(PatchSet.Id patchSetId, Change dest, RevCommit cherryPickCommit) throws OrmException {
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), patchSetId);
    String destBranchName = dest.getDest().get();
    StringBuilder msgBuf = new StringBuilder("Patch Set ").append(patchSetId.get()).append(": Cherry Picked").append("\n\n").append("This patchset was cherry picked to branch ").append(destBranchName.substring(destBranchName.indexOf("refs/heads/") + "refs/heads/".length())).append(" as commit ").append(cherryPickCommit.getId().getName());
    cmsg.setMessage(msgBuf.toString());
    return cmsg;
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null && db.accountExternalIds().get(getEmailKey(input.email)) != null) {
        throw new UnprocessableEntityException("email '" + input.email + "' already exists");
    }
    if (input.email != null && !EmailValidator.getInstance().isValid(input.email)) {
        throw new BadRequestException("invalid email address");
    }
    try {
        db.accountExternalIds().insert(Collections.singleton(extUser));
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    if (key != null) {
        db.accountSshKeys().insert(Collections.singleton(key));
    }
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, currentUser.getAccountId(), TimeUtil.nowTs())));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    sshKeyCache.evict(username);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountInfo.Loader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    try {
        db.accountExternalIds().insert(Collections.singleton(extUser));
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    if (key != null) {
        db.accountSshKeys().insert(Collections.singleton(key));
    }
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, currentUser.getAccountId(), TimeUtil.nowTs())));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    sshKeyCache.evict(username);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountInfo.Loader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                new ErrorDialog(e.getMessage()).center();
            }
        }
    }
    return commentLinks;
}
#method_after
final List<FindReplace> commentlinks() {
    JsArray<CommentLinkInfo> cls = commentlinks0().values();
    List<FindReplace> commentLinks = new ArrayList<FindReplace>(cls.length());
    for (int i = 0; i < cls.length(); i++) {
        CommentLinkInfo cl = cls.get(i);
        if (!cl.enabled()) {
            continue;
        }
        if (cl.link() != null) {
            commentLinks.add(new LinkFindReplace(cl.match(), cl.link()));
        } else {
            try {
                FindReplace fr = new RawFindReplace(cl.match(), cl.html());
                commentLinks.add(fr);
            } catch (RuntimeException e) {
                int index = e.getMessage().indexOf("at Object");
                new ErrorDialog("Invalid commentlink configuration: " + (index == -1 ? e.getMessage() : e.getMessage().substring(0, index))).center();
            }
        }
    }
    return commentLinks;
}
#end_block

#method_before
@UiHandler("theme")
void onTheme(ChangeEvent e) {
    prefs.theme(Theme.valueOf(theme.getValue(theme.getSelectedIndex())));
    view.operation(new Runnable() {

        @Override
        public void run() {
            String t = prefs.theme().name().toLowerCase();
            view.getCmFromSide(DisplaySide.A).setOption("theme", t);
            view.getCmFromSide(DisplaySide.B).setOption("theme", t);
        }
    });
}
#method_after
@UiHandler("theme")
void onTheme(ChangeEvent e) {
    prefs.theme(Theme.valueOf(theme.getValue(theme.getSelectedIndex())));
    view.setThemeStyles(prefs.theme().isDark());
    view.operation(new Runnable() {

        @Override
        public void run() {
            String t = prefs.theme().name().toLowerCase();
            view.getCmFromSide(DisplaySide.A).setOption("theme", t);
            view.getCmFromSide(DisplaySide.B).setOption("theme", t);
        }
    });
}
#end_block

#method_before
private void display(final CommentsCollections comments) {
    setShowTabs(prefs.showTabs());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(DiffTable.style.showLineNumbers());
    }
    cmA = newCM(diff.meta_a(), diff.text_a(), DisplaySide.A, diffTable.cmA);
    cmB = newCM(diff.meta_b(), diff.text_b(), DisplaySide.B, diffTable.cmB);
    diffTable.overview.init(cmB);
    chunkManager = new ChunkManager(this, cmA, cmB, diffTable.overview, prefs.theme().isDark());
    skipManager = new SkipManager(this, commentManager);
    columnMarginA = DOM.createDiv();
    columnMarginB = DOM.createDiv();
    columnMarginA.setClassName(DiffTable.style.columnMargin());
    columnMarginB.setClassName(DiffTable.style.columnMargin());
    cmA.getMoverElement().appendChild(columnMarginA);
    cmB.getMoverElement().appendChild(columnMarginB);
    operation(new Runnable() {

        public void run() {
            // Estimate initial CM3 height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    prefsAction = new PreferencesAction(this, prefs);
    header.init(prefsAction);
    if (largeFile && prefs.syntaxHighlighting()) {
        Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

            @Override
            public boolean execute() {
                if (prefs.syntaxHighlighting() && isAttached()) {
                    setSyntaxHighlighting(prefs.syntaxHighlighting());
                }
                return false;
            }
        }, 250);
    }
}
#method_after
private void display(final CommentsCollections comments) {
    setThemeStyles(prefs.theme().isDark());
    setShowTabs(prefs.showTabs());
    setShowIntraline(prefs.intralineDifference());
    if (prefs.showLineNumbers()) {
        diffTable.addStyleName(DiffTable.style.showLineNumbers());
    }
    cmA = newCM(diff.meta_a(), diff.text_a(), DisplaySide.A, diffTable.cmA);
    cmB = newCM(diff.meta_b(), diff.text_b(), DisplaySide.B, diffTable.cmB);
    diffTable.overview.init(cmB);
    chunkManager = new ChunkManager(this, cmA, cmB, diffTable.overview);
    skipManager = new SkipManager(this, commentManager);
    columnMarginA = DOM.createDiv();
    columnMarginB = DOM.createDiv();
    columnMarginA.setClassName(DiffTable.style.columnMargin());
    columnMarginB.setClassName(DiffTable.style.columnMargin());
    cmA.getMoverElement().appendChild(columnMarginA);
    cmB.getMoverElement().appendChild(columnMarginB);
    operation(new Runnable() {

        public void run() {
            // Estimate initial CM3 height, fixed up in onShowView.
            int height = Window.getClientHeight() - (Gerrit.getHeaderFooterHeight() + 18);
            cmA.setHeight(height);
            cmB.setHeight(height);
            render(diff);
            commentManager.render(comments, prefs.expandAllComments());
            skipManager.render(prefs.context(), diff);
        }
    });
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    new ScrollSynchronizer(diffTable, cmA, cmB, chunkManager.getLineMapper());
    prefsAction = new PreferencesAction(this, prefs);
    header.init(prefsAction);
    if (largeFile && prefs.syntaxHighlighting()) {
        Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

            @Override
            public boolean execute() {
                if (prefs.syntaxHighlighting() && isAttached()) {
                    setSyntaxHighlighting(prefs.syntaxHighlighting());
                }
                return false;
            }
        }, 250);
    }
}
#end_block

#method_before
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    patchZip = new Anchor(id + ".tar.gz");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#method_after
private void insertPatch() {
    String id = revision.substring(0, 7);
    Anchor patchBase64 = new Anchor(id + ".diff.base64");
    patchBase64.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("download").url());
    Anchor patchZip = new Anchor(id + ".diff.zip");
    patchZip.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("zip").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(patchBase64);
    InlineLabel spacer = new InlineLabel("|");
    spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
    p.add(spacer);
    p.add(patchZip);
    insertCommand("Patch-File", p);
}
#end_block

#method_before
private void insertArchive() {
    String id = revision.substring(0, 7);
    Anchor archive = new Anchor(id + ".tar.gz");
    archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("patch").addParameterTrue("archive").url());
    HorizontalPanel p = new HorizontalPanel();
    p.add(archive);
    insertCommand("Archive", p);
}
#method_after
private void insertArchive() {
    List<Anchor> formats = new ArrayList<>(ARCHIVE.length);
    for (String f : ARCHIVE) {
        Anchor archive = new Anchor(f);
        archive.setHref(new RestApi("/changes/").id(psId.getParentKey().get()).view("revisions").id(revision).view("archive").addParameter("format", f).url());
        formats.add(archive);
    }
    HorizontalPanel p = new HorizontalPanel();
    Iterator<Anchor> it = formats.iterator();
    while (it.hasNext()) {
        Anchor a = it.next();
        p.add(a);
        if (it.hasNext()) {
            InlineLabel spacer = new InlineLabel("|");
            spacer.setStyleName(Gerrit.RESOURCES.css().downloadBoxSpacer());
            p.add(spacer);
        }
    }
    insertCommand("Archive", p);
}
#end_block

#method_before
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long refreshCookieAt = now() + refresh;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken);
    self.put(key, val);
    return val;
}
#method_after
Val createVal(final Key key, final Account.Id who, final boolean remember, final AccountExternalId.Key lastLogin, String xsrfToken) {
    // Refresh the cookie every hour or when it is half-expired.
    // This reduces the odds that the user session will be kicked
    // early but also avoids us needing to refresh the cookie on
    // every single request.
    // 
    final long halfAgeRefresh = sessionMaxAgeMillis >>> 1;
    final long minRefresh = MILLISECONDS.convert(1, HOURS);
    final long refresh = Math.min(halfAgeRefresh, minRefresh);
    final long now = now();
    final long refreshCookieAt = now + refresh;
    final long expiresAt = now + sessionMaxAgeMillis;
    if (xsrfToken == null) {
        // If we don't yet have a token for this session, establish one.
        // 
        final int nonceLen = 20;
        final byte[] rnd = new byte[nonceLen];
        prng.nextBytes(rnd);
        xsrfToken = CookieBase64.encode(rnd);
    }
    Val val = new Val(who, refreshCookieAt, remember, lastLogin, xsrfToken, expiresAt);
    self.put(key.token, val);
    return val;
}
#end_block

#method_before
Val get(final Key key) {
    return self.getIfPresent(key.token);
}
#method_after
Val get(final Key key) {
    Val val = self.getIfPresent(key.token);
    if (val != null && val.expiresAt <= now()) {
        self.invalidate(key.token);
        return null;
    }
    return val;
}
#end_block

#method_before
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 0);
}
#method_after
private void writeObject(final ObjectOutputStream out) throws IOException {
    writeVarInt32(out, 1);
    writeVarInt32(out, accountId.get());
    writeVarInt32(out, 2);
    writeFixInt64(out, refreshCookieAt);
    writeVarInt32(out, 3);
    writeVarInt32(out, persistentCookie ? 1 : 0);
    if (externalId != null) {
        writeVarInt32(out, 4);
        writeString(out, externalId.get());
    }
    writeVarInt32(out, 5);
    writeString(out, xsrfToken);
    writeVarInt32(out, 6);
    writeFixInt64(out, expiresAt);
    writeVarInt32(out, 0);
}
#end_block

#method_before
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
}
#method_after
private void readObject(final ObjectInputStream in) throws IOException {
    PARSE: for (; ; ) {
        final int tag = readVarInt32(in);
        switch(tag) {
            case 0:
                break PARSE;
            case 1:
                accountId = new Account.Id(readVarInt32(in));
                continue;
            case 2:
                refreshCookieAt = readFixInt64(in);
                continue;
            case 3:
                persistentCookie = readVarInt32(in) != 0;
                continue;
            case 4:
                externalId = new AccountExternalId.Key(readString(in));
                continue;
            case 5:
                xsrfToken = readString(in);
                continue;
            case 6:
                expiresAt = readFixInt64(in);
                continue;
            default:
                throw new IOException("Unknown tag found in object: " + tag);
        }
    }
    if (expiresAt == 0) {
        expiresAt = refreshCookieAt + TimeUnit.HOURS.toMillis(2);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new MasterNodeStartup());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sshInjector.getInstance(WebModule.class));
    modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).memoryLimit(// very large items, cache only a few
            128).populateWith(PatchListLoader.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).memoryLimit(// very large items, cache only a few
            128).populateWith(IntraLineLoader.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(FILE_NAME, PatchListKey.class, PatchList.class).maximumWeight(10 << 20).loader(PatchListLoader.class).weigher(PatchListWeigher.class);
            persist(INTRA_NAME, IntraLineDiffKey.class, IntraLineDiff.class).maximumWeight(10 << 20).loader(IntraLineLoader.class).weigher(IntraLineWeigher.class);
            bind(PatchListCacheImpl.class);
            bind(PatchListCache.class).to(PatchListCacheImpl.class);
        }
    };
}
#end_block

#method_before
public PatchList get(PatchListKey key) {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        // TODO Handle PatchList errors in callers.
        return null;
    }
}
#method_after
@Override
public PatchList get(PatchListKey key) throws PatchListNotAvailableException {
    try {
        return fileCache.get(key);
    } catch (ExecutionException e) {
        PatchListLoader.log.warn("Error computing " + key, e);
        throw new PatchListNotAvailableException(e.getCause());
    }
}
#end_block

#method_before
public PatchList get(final Change change, final PatchSet patchSet) {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#method_after
@Override
public PatchList get(final Change change, final PatchSet patchSet) throws PatchListNotAvailableException {
    final Project.NameKey projectKey = change.getProject();
    final ObjectId a = null;
    final ObjectId b = ObjectId.fromString(patchSet.getRevision().get());
    final Whitespace ws = Whitespace.IGNORE_NONE;
    return get(new PatchListKey(projectKey, a, b, ws));
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).populateWith(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Iterable<SshKeyCacheEntry>>() {
            }).loader(Loader.class);
            bind(SshKeyCacheImpl.class);
            bind(SshKeyCache.class).to(SshKeyCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Inject
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.store = factory;
}
#method_after
@Inject(optional = true)
void setPersistentCacheFactory(@Nullable PersistentCacheFactory factory) {
    this.persistentCacheFactory = factory;
}
#end_block

#method_before
CacheBinding<K, V> persist(boolean p) {
    persist = p;
    return this;
}
#method_after
CacheBinding<K, V> persist(boolean p) {
    Preconditions.checkState(!frozen, "binding frozen, cannot be modified");
    persist = p;
    return this;
}
#end_block

#method_before
@Override
public Cache<K, V> get() {
    CacheBuilder<K, V> builder = newCacheBuilder();
    builder.maximumSize(maxSize);
    if (0 < maxAge) {
        builder.expireAfterWrite(maxAge, TimeUnit.SECONDS);
    }
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && store != null) {
            return store.build(name, keyType, valType, builder, ldr);
        }
        return builder.build(ldr);
    } else if (persist && store != null) {
        return store.build(name, keyType, valType, builder);
    } else {
        return builder.build();
    }
}
#method_after
@Override
public Cache<K, V> get() {
    frozen = true;
    if (loader != null) {
        CacheLoader<K, V> ldr = loader.get();
        if (persist && persistentCacheFactory != null) {
            return persistentCacheFactory.build(this, ldr);
        }
        return memoryCacheFactory.build(this, ldr);
    } else if (persist && persistentCacheFactory != null) {
        return persistentCacheFactory.build(this);
    } else {
        return memoryCacheFactory.build(this);
    }
}
#end_block

#method_before
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(name, keyType, valType, this);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.memoryLimit(1024);
}
#method_after
protected <K, V> CacheBinding<K, V> cache(String name, TypeLiteral<K> keyType, TypeLiteral<V> valType) {
    Type type = Types.newParameterizedType(Cache.class, keyType.getType(), valType.getType());
    @SuppressWarnings("unchecked")
    Key<Cache<K, V>> key = (Key<Cache<K, V>>) Key.get(type, Names.named(name));
    CacheProvider<K, V> m = new CacheProvider<K, V>(this, name, keyType, valType);
    bind(key).toProvider(m).in(Scopes.SINGLETON);
    bind(ANY_CACHE).annotatedWith(Exports.named(name)).to(key);
    return m.maximumWeight(1024);
}
#end_block

#method_before
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType.getType(), m.valType.getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType.getType(), m.valType.getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType.getType(), m.valType.getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#method_after
<K, V> Provider<CacheLoader<K, V>> bindCacheLoader(CacheProvider<K, V> m, Class<? extends CacheLoader<K, V>> impl) {
    Type type = Types.newParameterizedType(Cache.class, m.keyType().getType(), m.valueType().getType());
    Type loadingType = Types.newParameterizedType(LoadingCache.class, m.keyType().getType(), m.valueType().getType());
    Type loaderType = Types.newParameterizedType(CacheLoader.class, m.keyType().getType(), m.valueType().getType());
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> key = (Key<LoadingCache<K, V>>) Key.get(type, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<LoadingCache<K, V>> loadingKey = (Key<LoadingCache<K, V>>) Key.get(loadingType, Names.named(m.name));
    @SuppressWarnings("unchecked")
    Key<CacheLoader<K, V>> loaderKey = (Key<CacheLoader<K, V>>) Key.get(loaderType, Names.named(m.name));
    bind(loaderKey).to(impl).in(Scopes.SINGLETON);
    bind(loadingKey).to(key);
    return getProvider(loaderKey);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).memoryLimit(// reasonable default for many sites
            1024).maxAge(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            persist(WebSessionManager.CACHE_NAME, String.class, Val.class).maximumWeight(// reasonable default for many sites
            1024).expireAfterWrite(MAX_AGE_MINUTES, // expire sessions if they are inactive
            MINUTES);
            bind(WebSessionManager.class);
            bind(WebSession.class).to(CacheBasedWebSession.class).in(RequestScoped.class);
        }
    };
}
#end_block

#method_before
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "");
}
#method_after
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, "", 0);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).populateWith(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).memoryLimit(1).populateWith(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, ProjectState.class).loader(Loader.class);
            cache(CACHE_LIST, ListKey.class, new TypeLiteral<SortedSet<Project.NameKey>>() {
            }).maximumWeight(1).loader(Lister.class);
            bind(ProjectCacheImpl.class);
            bind(ProjectCache.class).to(ProjectCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).populateWith(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYINCLUDE_NAME, AccountGroup.UUID.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
            }).loader(ByIncludeLoader.class);
            bind(GroupIncludeCacheImpl.class);
            bind(GroupIncludeCache.class).to(GroupIncludeCacheImpl.class);
        }
    };
}
#end_block

#method_before
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2BackedCache<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2BackedCache<?, ?>> entry : disks.entrySet()) {
        H2BackedCache<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2BackedCache.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#method_after
@Override
protected void run() {
    nw = columns - 50;
    Date now = new Date();
    stdout.format("%-25s %-20s      now  %16s\n", "Gerrit Code Review", Version.getVersion() != null ? Version.getVersion() : "", new SimpleDateFormat("HH:mm:ss   zzz").format(now));
    stdout.format("%-25s %-20s   uptime %16s\n", "", "", uptime(now.getTime() - serverStarted));
    stdout.print('\n');
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%-21s|  %-5s |%-9s|\n", // 
    "", // 
    "Name", // 
    "Entries", // 
    "AvgGet", // 
    "Hit Ratio"));
    stdout.print(// 
    String.format(// 
    "%1s %-" + nw + "s|%6s %6s %7s|  %-5s  |%-4s %-4s|\n", // 
    "", // 
    "", // 
    "Mem", // 
    "Disk", // 
    "Space", // 
    "", // 
    "Mem", // 
    "Disk"));
    stdout.print("--");
    for (int i = 0; i < nw; i++) {
        stdout.print('-');
    }
    stdout.print("+---------------------+---------+---------+\n");
    Map<String, H2CacheImpl<?, ?>> disks = Maps.newTreeMap();
    printMemoryCaches(disks, sortedCoreCaches());
    printMemoryCaches(disks, sortedPluginCaches());
    for (Map.Entry<String, H2CacheImpl<?, ?>> entry : disks.entrySet()) {
        H2CacheImpl<?, ?> cache = entry.getValue();
        CacheStats stat = cache.stats();
        H2CacheImpl.DiskStats disk = cache.diskStats();
        stdout.print(String.format("D %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), count(disk.size()), bytes(disk.space()), duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), percent(disk.hitCount(), disk.requestCount())));
    }
    stdout.print('\n');
    if (gc) {
        System.gc();
        System.runFinalization();
        System.gc();
    }
    sshSummary();
    taskSummary();
    memSummary();
    if (showJVM) {
        jvmSummary();
    }
    stdout.flush();
}
#end_block

#method_before
private void printMemoryCaches(Map<String, H2BackedCache<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2BackedCache) {
            disks.put(entry.getKey(), (H2BackedCache<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#method_after
private void printMemoryCaches(Map<String, H2CacheImpl<?, ?>> disks, Map<String, Cache<?, ?>> caches) {
    for (Map.Entry<String, Cache<?, ?>> entry : caches.entrySet()) {
        Cache<?, ?> cache = entry.getValue();
        if (cache instanceof H2CacheImpl) {
            disks.put(entry.getKey(), (H2CacheImpl<?, ?>) cache);
            continue;
        }
        CacheStats stat = cache.stats();
        stdout.print(String.format("  %-" + nw + "s|%6s %6s %7s| %7s |%4s %4s|\n", entry.getKey(), count(cache.size()), "", "", duration(stat.averageLoadPenalty()), percent(stat.hitCount(), stat.requestCount()), ""));
    }
}
#end_block

#method_before
private String duration(double ns) {
    if (Math.abs(ns) < 0.01) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#method_after
private String duration(double ns) {
    if (ns < 0.5) {
        return "";
    }
    String suffix = "ns";
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "us";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "ms";
    }
    if (ns >= 1000.0) {
        ns /= 1000.0;
        suffix = "s ";
    }
    return String.format("%4.1f%s", ns, suffix);
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).populateWith(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(CACHE_NAME, String.class, new TypeLiteral<Set<Account.Id>>() {
            }).loader(Loader.class);
            bind(AccountByEmailCacheImpl.class);
            bind(AccountByEmailCache.class).to(AccountByEmailCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).populateWith(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).populateWith(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, Account.Id.class, AccountState.class).loader(ByIdLoader.class);
            cache(BYUSER_NAME, String.class, new TypeLiteral<Optional<Account.Id>>() {
            }).loader(ByNameLoader.class);
            bind(AccountCacheImpl.class);
            bind(AccountCache.class).to(AccountCacheImpl.class);
        }
    };
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).populateWith(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).populateWith(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(BYID_NAME, AccountGroup.Id.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByIdLoader.class);
            cache(BYNAME_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByNameLoader.class);
            cache(BYUUID_NAME, String.class, new TypeLiteral<Optional<AccountGroup>>() {
            }).loader(ByUUIDLoader.class);
            cache(BYEXT_NAME, String.class, new TypeLiteral<Collection<AccountGroup>>() {
            }).loader(ByExternalNameLoader.class);
            bind(GroupCacheImpl.class);
            bind(GroupCache.class).to(GroupCacheImpl.class);
        }
    };
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InMemoryCacheModule());
    modules.add(new H2BackedPersistentCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(RequestContextFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new InMemoryCacheModule());
            install(new H2BackedPersistentCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    if (threads <= 0) {
        threads = 1;
    }
    dbInjector = createDbInjector(MULTI_USER);
    gitInjector = dbInjector.createChildInjector(new AbstractModule() {

        @Override
        protected void configure() {
            install(SchemaVersionCheck.module());
            bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(Scopes.SINGLETON);
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class).in(Scopes.SINGLETON);
            install(AccountCacheImpl.module());
            install(GroupCacheImpl.module());
            install(new DefaultCacheFactory.Module());
            install(new FactoryModule() {

                @Override
                protected void configure() {
                    factory(CreateCodeReviewNotes.Factory.class);
                }
            });
            install(new LifecycleModule() {

                @Override
                protected void configure() {
                    listener().to(LocalDiskRepositoryManager.Lifecycle.class);
                }
            });
        }
    });
    manager.add(dbInjector, gitInjector);
    manager.start();
    gitInjector.injectMembers(this);
    List<Change> allChangeList = allChanges();
    monitor.beginTask("Scanning changes", allChangeList.size());
    changes = cluster(allChangeList);
    allChangeList = null;
    monitor.startWorkers(threads);
    for (int tid = 0; tid < threads; tid++) {
        new Worker().start();
    }
    monitor.waitForCompletion();
    monitor.endTask();
    manager.stop();
    return 0;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score != 0) {
        if (score == type.getMin().getValue()) {
            if (type.getFunctionName().equalsIgnoreCase("NoBlock")) {
                label.disliked = accountLoader.get(accountId);
            } else {
                label.rejected = accountLoader.get(accountId);
            }
        } else if (score == type.getMax().getValue()) {
            label.approved = accountLoader.get(accountId);
        } else if (score < 0) {
            label.disliked = accountLoader.get(accountId);
            label.value = score;
        } else if (score > 0 && label.disliked == null) {
            label.recommended = accountLoader.get(accountId);
            label.value = score;
        }
    }
    return;
}
#method_after
private void setLabelScores(LabelType type, LabelInfo label, short score, Account.Id accountId) throws OrmException {
    if (label.approved != null || label.rejected != null) {
        return;
    }
    if (type.getMin() == null || type.getMax() == null) {
        // Can't set score for unknown or misconfigured type.
        return;
    }
    if (score < 0) {
        label.disliked = accountLoader.get(accountId);
        label.value = score;
    } else if (score > 0 && label.disliked == null) {
        label.recommended = accountLoader.get(accountId);
        label.value = score;
    }
}
#end_block

#method_before
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#method_after
private Map<String, Map<String, ConfigParameterInfo>> getPluginConfig(ProjectState project, DynamicMap<ProjectConfigEntry> pluginConfigEntries, PluginConfigFactory cfgFactory, AllProjectsNameProvider allProjects) {
    TreeMap<String, Map<String, ConfigParameterInfo>> pluginConfig = new TreeMap<>();
    for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
        ProjectConfigEntry configEntry = e.getProvider().get();
        PluginConfig cfg = cfgFactory.getFromProjectConfig(project, e.getPluginName());
        String configuredValue = cfg.getString(e.getExportName());
        ConfigParameterInfo p = new ConfigParameterInfo();
        p.displayName = configEntry.getDisplayName();
        p.description = configEntry.getDescription();
        p.warning = configEntry.getWarning(project);
        p.type = configEntry.getType();
        p.permittedValues = configEntry.getPermittedValues();
        p.editable = configEntry.isEditable(project) ? true : null;
        if (configEntry.isInheritable() && !allProjects.get().equals(project.getProject().getNameKey())) {
            PluginConfig cfgWithInheritance = cfgFactory.getFromProjectConfigWithInheritance(project, e.getPluginName());
            p.inheritable = true;
            p.value = cfgWithInheritance.getString(e.getExportName(), configEntry.getDefaultValue());
            p.configuredValue = configuredValue;
            p.inheritedValue = getInheritedValue(project, cfgFactory, e);
        } else {
            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                p.values = Arrays.asList(cfg.getStringList(e.getExportName()));
            } else {
                p.value = configuredValue != null ? configuredValue : configEntry.getDefaultValue();
            }
        }
        Map<String, ConfigParameterInfo> pc = pluginConfig.get(e.getPluginName());
        if (pc == null) {
            pc = new TreeMap<>();
            pluginConfig.put(e.getPluginName(), pc);
        }
        pc.put(e.getExportName(), p);
    }
    return !pluginConfig.isEmpty() ? pluginConfig : null;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (configEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                                List<String> l = Arrays.asList(projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getStringList(e.getExportName()));
                                oldValue = Joiner.on("\n").join(l);
                            }
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    Change c;
    try {
        // Force submit even if submit rule evaluation fails.
        c = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else if ("MULTIPLE".equals(param.type())) {
                w = renderTextArea(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            switch(param.type()) {
                case "STRING":
                case "INT":
                case "LONG":
                    w = renderTextBox(g, param);
                    break;
                case "BOOLEAN":
                    w = renderCheckBox(g, param);
                    break;
                case "LIST":
                    w = renderListBox(g, param);
                    break;
                case "ARRAY":
                    w = renderTextArea(g, param);
                    break;
                default:
                    throw new UnsupportedOperationException("unsupported widget type");
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = param.type().equals("STRING") ? new NpTextBox() : new NpIntTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        addWidget(g, p, param);
    } else {
        textBox.setValue(param.value());
        addWidget(g, textBox, param);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#method_after
private ListBox renderListBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    if (param.permittedValues() == null) {
        return null;
    }
    ListBox listBox = new ListBox();
    if (param.inheritable()) {
        listBox.addItem(Util.M.pluginProjectInheritedListValue(param.inheritedValue()));
        if (param.configuredValue() == null) {
            listBox.setSelectedIndex(0);
        }
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.configuredValue())) {
                listBox.setSelectedIndex(i + 1);
            }
        }
    } else {
        for (int i = 0; i < param.permittedValues().length(); i++) {
            String pv = param.permittedValues().get(i);
            listBox.addItem(pv);
            if (pv.equals(param.value())) {
                listBox.setSelectedIndex(i);
            }
        }
    }
    if (param.editable()) {
        saveEnabler.listenTo(listBox);
        addWidget(g, listBox, param);
    } else {
        listBox.setEnabled(false);
        if (param.inheritable() && listBox.getSelectedIndex() != 0) {
            // the inherited value is not selected,
            // since the listBox is disabled the inherited value cannot be
            // seen and we have to display it explicitly
            Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
            inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
            HorizontalPanel p = new HorizontalPanel();
            p.add(listBox);
            p.add(inheritedLabel);
            addWidget(g, p, param);
        } else {
            addWidget(g, listBox, param);
        }
    }
    return listBox;
}
#end_block

#method_before
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    param.values();
    return txtArea;
}
#method_after
private NpTextArea renderTextArea(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextArea txtArea = new NpTextArea();
    txtArea.setVisibleLines(4);
    txtArea.setCharacterWidth(40);
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < param.values().length(); i++) {
        String v = param.values().get(i);
        sb.append(v).append("\n");
    }
    txtArea.setText(sb.toString());
    if (param.editable()) {
        saveEnabler.listenTo(txtArea);
    } else {
        txtArea.setEnabled(false);
    }
    addWidget(g, txtArea, param);
    return txtArea;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            } else if (widget instanceof NpTextArea) {
                NpTextArea txtArea = (NpTextArea) widget;
                values.put(e2.getKey(), txtArea.getText().trim());
            } else {
                throw new UnsupportedOperationException("unupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, ConfigParameterValue>> getPluginConfigValues() {
    Map<String, Map<String, ConfigParameterValue>> pluginConfigValues = new HashMap<>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, ConfigParameterValue> values = new HashMap<>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(((TextBox) widget).getValue().trim()));
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), ConfigParameterValue.create().value(Boolean.toString(((CheckBox) widget).getValue())));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), ConfigParameterValue.create().value(value));
            } else if (widget instanceof NpTextArea) {
                String text = ((NpTextArea) widget).getText().trim();
                values.put(e2.getKey(), ConfigParameterValue.create().values(text.split("\n")));
            } else {
                throw new UnsupportedOperationException("unsupported widget type");
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.MULTIPLE) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                }
                if (v.getValue() != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                case MULTIPLE:
                                    cfg.setStringList(v.getKey(), Lists.newArrayList(Splitter.on("\n").split(v.getValue())));
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, ConfigValue>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, ConfigValue>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, ConfigValue> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                String value = v.getValue().value;
                if (projectConfigEntry.getType() == ProjectConfigEntry.Type.ARRAY) {
                    List<String> l = Arrays.asList(cfg.getStringList(v.getKey()));
                    oldValue = Joiner.on("\n").join(l);
                    value = Joiner.on("\n").join(v.getValue().values);
                }
                if (Strings.emptyToNull(value) != null) {
                    if (!value.equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(value);
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(value);
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(value);
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", value, v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), value);
                                    break;
                                case ARRAY:
                                    cfg.setStringList(v.getKey(), v.getValue().values);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private static List<PluginData> listPlugins(SitePaths site, boolean deleteTempPluginFile, GerritDistributionLocator distroLocator) throws IOException {
    final File myWar = distroLocator.locate();
    final List<PluginData> result = Lists.newArrayList();
    try {
        if (myWar.isFile()) {
            final ZipFile zf = new ZipFile(myWar);
            try {
                final Enumeration<? extends ZipEntry> e = zf.entries();
                while (e.hasMoreElements()) {
                    final ZipEntry ze = e.nextElement();
                    if (ze.isDirectory()) {
                        continue;
                    }
                    if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                        final String pluginJarName = new File(ze.getName()).getName();
                        final String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                        final InputStream in = zf.getInputStream(ze);
                        final File tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                        final String pluginVersion = getVersion(tmpPlugin);
                        if (deleteTempPluginFile) {
                            tmpPlugin.delete();
                        }
                        result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
                    }
                }
            } finally {
                zf.close();
            }
        } else {
            File pluginDir = new File(myWar, PLUGIN_DIR);
            for (File p : pluginDir.listFiles()) {
                String pluginJarName = p.getName();
                String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                File tmpPlugin;
                InputStream in = new FileInputStream(p);
                try {
                    tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                } finally {
                    in.close();
                }
                String pluginVersion = getVersion(tmpPlugin);
                if (deleteTempPluginFile) {
                    tmpPlugin.delete();
                }
                result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
            }
        }
    } catch (IOException e) {
        throw new IOException("Failure during plugin installation", e);
    }
    return result;
}
#method_after
public static List<PluginData> listPlugins(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, false, pluginsDistribution);
}
#end_block

#method_before
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, GerritDistributionLocator distroLocator) throws IOException {
    return listPlugins(site, true, distroLocator);
}
#method_after
public static List<PluginData> listPluginsAndRemoveTempFiles(SitePaths site, PluginsDistribution pluginsDistribution) throws IOException {
    return listPlugins(site, true, pluginsDistribution);
}
#end_block

#method_before
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, distroLocator);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#method_after
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site, pluginsDistribution);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!(initFlags.installPlugins.contains(pluginName) || ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version))) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.name + ".jar");
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#end_block

#method_before
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, distroLocator);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#method_after
@Override
protected boolean beforeInit(SiteInit init) throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (!skipPlugins) {
        final List<PluginData> plugins = InitPlugins.listPluginsAndRemoveTempFiles(init.site, pluginsDistribution);
        ConsoleUI ui = ConsoleUI.getInstance(false);
        verifyInstallPluginList(ui, plugins);
        if (listPlugins) {
            if (!plugins.isEmpty()) {
                ui.message("Available plugins:\n");
                for (PluginData plugin : plugins) {
                    ui.message(" * %s version %s\n", plugin.name, plugin.version);
                }
            } else {
                ui.message("No plugins found.\n");
            }
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (initDb) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    step().to(InitPlugins.class);
}
#end_block

#method_before
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, distroLocator).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, distroLocator).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
public void init() {
    try {
        if (sitePath != null) {
            File site = new File(sitePath);
            LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
            new BaseInit(site, false, true, pluginsDistribution).run();
            return;
        }
        Connection conn = connectToDb();
        try {
            File site = getSiteFromReviewDb(conn);
            if (site == null && initPath != null) {
                site = new File(initPath);
            }
            if (site != null) {
                LOG.info(String.format("Initializing site at %s", site.getAbsolutePath()));
                new BaseInit(site, new ReviewDbDataSourceProvider(), false, false, pluginsDistribution).run();
            }
        } finally {
            conn.close();
        }
    } catch (Exception e) {
        LOG.error("Site init failed", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
protected List<String> getInstallPlugins() {
    File root;
    try {
        root = distroLocator.locate();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't open folder containing plugins." + " No plugin will be installed");
        return null;
    }
    ArrayList<String> result = Lists.newArrayList();
    File plugins = new File(root, InitPlugins.PLUGIN_DIR);
    for (File p : plugins.listFiles()) {
        String pluginJarName = p.getName();
        String pluginName = pluginJarName.substring(0, pluginJarName.length() - InitPlugins.JAR.length());
        result.add(pluginName);
    }
    return result;
}
#method_after
protected List<String> getInstallPlugins() {
    try {
        return pluginsDistribution.listPluginNames();
    } catch (FileNotFoundException e) {
        log.warn("Couldn't find distribution archive location." + " No plugin will be installed");
        return null;
    }
}
#end_block

#method_before
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(GerritDistributionLocator.class).toInstance(distroLocator);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#method_after
private SiteInit createSiteInit() {
    final ConsoleUI ui = getConsoleUI();
    final File sitePath = getSitePath();
    final List<Module> m = new ArrayList<Module>();
    m.add(new InitModule(standalone, initDb));
    m.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(ConsoleUI.class).toInstance(ui);
            bind(File.class).annotatedWith(SitePath.class).toInstance(sitePath);
            List<String> plugins = Objects.firstNonNull(getInstallPlugins(), Lists.<String>newArrayList());
            bind(new TypeLiteral<List<String>>() {
            }).annotatedWith(InstallPlugins.class).toInstance(plugins);
            bind(PluginsDistribution.class).toInstance(pluginsDistribution);
        }
    });
    try {
        return Guice.createInjector(PRODUCTION, m).getInstance(SiteInit.class);
    } catch (CreationException ce) {
        final Message first = ce.getErrorMessages().iterator().next();
        Throwable why = first.getCause();
        if (why instanceof Die) {
            throw (Die) why;
        }
        final StringBuilder buf = new StringBuilder(ce.getMessage());
        while (why != null) {
            buf.append("\n");
            buf.append(why.getMessage());
            why = why.getCause();
            if (why != null) {
                buf.append("\n  caused by ");
            }
        }
        throw die(buf.toString(), new RuntimeException("InitInjector failed", ce));
    }
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new WebAppLocator(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = new File(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext)).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setCfgInjector(cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException {
    if (input == null) {
        input = new Input();
    }
    ReviewDb db = dbProvider.get();
    Account a = db.accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        if (realm instanceof LdapRealm && db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, a.getUserName())) == null) {
        // make it possible to update the full name of manually created account
        // in Gerrit using LDAP backend.
        } else {
            throw new MethodNotAllowedException("realm does not allow editing name");
        }
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#method_after
public Response<String> apply(IdentifiedUser user, Input input) throws MethodNotAllowedException, ResourceNotFoundException, OrmException {
    if (input == null) {
        input = new Input();
    }
    ReviewDb db = dbProvider.get();
    Account a = db.accounts().get(user.getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME) && !(realm instanceof LdapRealm && db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, a.getUserName())) == null)) {
        throw new MethodNotAllowedException("realm does not allow editing name");
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.<String>none() : Response.ok(a.getFullName());
}
#end_block

#method_before
@Override
public boolean match(ChangeData cd) throws OrmException {
    return cd.change().getLastUpdatedOn().getTime() <= cut.getTime();
}
#method_after
@Override
public boolean match(ChangeData cd) throws OrmException {
    return cd.change().getLastUpdatedOn().getTime() >= cut.getTime();
}
#end_block

#method_before
@Override
public String getDescription() {
    return "Administrate the Cookbook";
}
#method_after
@Override
public String getDescription() {
    return "Administrate Cookbook";
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    stdout.print("Hello, cookbook administrator");
}
#method_after
@Override
protected void run() {
    stdout.print("Hello, cookbook administrator\n");
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (!control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    checkSubmitRule(rsrc);
    change = submit(rsrc, caller);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    change = submit(rsrc, caller, false);
    if (change == null) {
        throw new ResourceConflictException("change is " + status(dbProvider.get().changes().get(rsrc.getChange().getId())));
    }
    if (input.waitForMerge) {
        mergeQueue.merge(change.getDest());
        change = dbProvider.get().changes().get(change.getId());
    } else {
        mergeQueue.schedule(change.getDest());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
public Change submit(RevisionResource rsrc, IdentifiedUser caller) throws OrmException, IOException {
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        approve(rsrc, update, caller, timestamp);
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#method_after
public Change submit(RevisionResource rsrc, IdentifiedUser caller, boolean force) throws ResourceConflictException, OrmException, IOException {
    List<SubmitRecord> submitRecords = checkSubmitRule(rsrc, force);
    final Timestamp timestamp = TimeUtil.nowTs();
    Change change = rsrc.getChange();
    ChangeUpdate update = updateFactory.create(rsrc.getControl(), timestamp);
    update.submit(submitRecords);
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        BatchMetaDataUpdate batch = approve(rsrc, update, caller, timestamp);
        // Write update commit after all normalized label commits.
        batch.write(update, new CommitBuilder());
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.SUBMITTED);
                    change.setLastUpdatedOn(timestamp);
                    ChangeUtil.computeSortKey(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            return null;
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    return change;
}
#end_block

#method_before
private void approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    List<PatchSetApproval> approvals = approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), psId);
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMapWithExpectedSize(approvals.size());
    for (PatchSetApproval psa : approvals) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    approvals = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(approvals);
}
#method_after
private BatchMetaDataUpdate approve(RevisionResource rsrc, ChangeUpdate update, IdentifiedUser caller, Timestamp timestamp) throws OrmException {
    PatchSet.Id psId = rsrc.getPatchSet().getId();
    List<PatchSetApproval> approvals = approvalsUtil.byPatchSet(dbProvider.get(), rsrc.getNotes(), psId);
    Map<PatchSetApproval.Key, PatchSetApproval> byKey = Maps.newHashMapWithExpectedSize(approvals.size());
    for (PatchSetApproval psa : approvals) {
        if (!byKey.containsKey(psa.getKey())) {
            byKey.put(psa.getKey(), psa);
        }
    }
    PatchSetApproval submit = ApprovalsUtil.getSubmitter(psId, byKey.values());
    if (submit == null || submit.getAccountId() != caller.getAccountId()) {
        submit = new PatchSetApproval(new PatchSetApproval.Key(rsrc.getPatchSet().getId(), caller.getAccountId(), LabelId.SUBMIT), (short) 1, TimeUtil.nowTs());
        byKey.put(submit.getKey(), submit);
    }
    submit.setValue((short) 1);
    submit.setGranted(timestamp);
    // Flatten out existing approvals for this patch set based upon the current
    // permissions. Once the change is closed the approvals are not updated at
    // presentation view time, except for zero votes used to indicate a reviewer
    // was added. So we need to make sure votes are accurate now. This way if
    // permissions get modified in the future, historical records stay accurate.
    LabelNormalizer.Result normalized = labelNormalizer.normalize(rsrc.getControl(), byKey.values());
    // TODO(dborowitz): Don't use a label in notedb; just check when status
    // change happened.
    update.putApproval(submit.getLabel(), submit.getValue());
    dbProvider.get().patchSetApprovals().upsert(normalized.getNormalized());
    dbProvider.get().patchSetApprovals().delete(normalized.getDeleted());
    try {
        return saveToBatch(rsrc, update, normalized, timestamp);
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void checkSubmitRule(RevisionResource rsrc) throws ResourceConflictException {
    List<SubmitRecord> results = rsrc.getControl().canSubmit(dbProvider.get(), rsrc.getPatchSet());
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
        }
    }
}
#method_after
private List<SubmitRecord> checkSubmitRule(RevisionResource rsrc, boolean force) throws ResourceConflictException {
    List<SubmitRecord> results = rsrc.getControl().canSubmit(dbProvider.get(), rsrc.getPatchSet());
    Optional<SubmitRecord> ok = findOkRecord(results);
    if (ok.isPresent()) {
        // Rules supplied a valid solution.
        return ImmutableList.of(ok.get());
    } else if (force) {
        return results;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("ChangeControl.canSubmit returned empty list for %s in %s", rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException(String.format("rule error: %s", record.errorMessage));
            case NOT_READY:
                StringBuilder msg = new StringBuilder();
                for (SubmitRecord.Label lbl : record.labels) {
                    switch(lbl.status) {
                        case OK:
                        case MAY:
                            continue;
                        case REJECT:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("blocked by ").append(lbl.label);
                            continue;
                        case NEED:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label);
                            continue;
                        case IMPOSSIBLE:
                            if (msg.length() > 0)
                                msg.append("; ");
                            msg.append("needs ").append(lbl.label).append(" (check project access)");
                            continue;
                        default:
                            throw new IllegalStateException(String.format("Unsupported SubmitRecord.Label %s for %s in %s", lbl.toString(), rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
                    }
                }
                throw new ResourceConflictException(msg.toString());
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, rsrc.getPatchSet().getId(), rsrc.getChange().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#method_after
private RevisionResource onBehalfOf(RevisionResource rsrc, SubmitInput in) throws AuthException, UnprocessableEntityException, OrmException {
    ChangeControl caller = rsrc.getControl();
    if (!caller.canSubmit()) {
        throw new AuthException("submit not permitted");
    }
    if (!caller.canSubmitAs()) {
        throw new AuthException("submit on behalf of not permitted");
    }
    ChangeControl target = caller.forUser(accounts.parse(in.onBehalfOf));
    return new RevisionResource(changes.parse(target), rsrc.getPatchSet());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
    admin2 = accounts.admin2();
    user = accounts.user();
}
#method_after
@Before
public void setUp() throws Exception {
    admin2 = accounts.admin2();
}
#end_block

#method_before
@Test
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    in.waitForMerge = true;
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit(in);
}
#end_block

#method_before
@Override
public String toString() {
    return "push " + uri;
}
#method_after
@Override
public String toString() {
    if (retryCount == 0) {
        return "push " + uri;
    }
    return "(retry " + retryCount + ") " + "push " + uri;
}
#end_block

#method_before
void setToRetry() {
    retrying = true;
}
#method_after
void setToRetry() {
    retrying = true;
    retryCount++;
}
#end_block

#method_before
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    }
}
#method_after
@Override
public void run() {
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() {
                runPushOperation();
                return null;
            }
        }).call();
    } catch (Exception e) {
        throw Throwables.propagate(e);
    } finally {
        statesCleanUp();
    }
}
#end_block

#method_before
private void runPushOperation() {
    // Lock the queue, and remove ourselves, so we can't be modified once
    // we start replication (instead a new instance, with the same URI, is
    // created and scheduled for a future point in time.)
    // 
    pool.notifyStarting(this);
    // since the canceled flag would be set locking the queue.
    if (!canceled) {
        try {
            git = gitManager.openRepository(projectName);
            runImpl();
        } catch (RepositoryNotFoundException e) {
            log.error("Cannot replicate " + projectName + "; " + e.getMessage());
        } catch (NoRemoteRepositoryException e) {
            log.error("Cannot replicate to " + uri + "; repository not found");
        } catch (NotSupportedException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (TransportException e) {
            Throwable cause = e.getCause();
            if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
                log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
            } else if (e instanceof RemoteRepositoryException && e.getMessage().endsWith("failed to lock")) {
                // The RemoteRepositoryException message contains both URI and reason
                // for this intermediate failure.
                log.error("Cannot replicate to " + e.getMessage());
            } else {
                log.error("Cannot replicate to " + uri, e);
            }
            // The remote push operation should be retried.
            pool.reschedule(this);
        } catch (IOException e) {
            log.error("Cannot replicate to " + uri, e);
        } catch (RuntimeException e) {
            log.error("Unexpected error during replication to " + uri, e);
        } catch (Error e) {
            log.error("Unexpected error during replication to " + uri, e);
        } finally {
            if (git != null) {
                git.close();
            }
        }
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; Local repository error: " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        // Tried to replicate to a remote via anonymous git:// but the repository
        // does not exist.  In this case NoRemoteRepositoryException is not
        // raised.
        final String msg = e.getMessage();
        if (msg.contains("access denied")) {
            createRepository();
        } else {
            log.error("Cannot replicate " + projectName + "; Remote repository error: " + msg);
        }
    } catch (NoRemoteRepositoryException e) {
        createRepository();
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else if (e instanceof LockFailureException) {
            lockRetryCount++;
            // The LockFailureException message contains both URI and reason
            // for this failure.
            log.error("Cannot replicate to " + e.getMessage());
            // The remote push operation should be retried.
            if (lockRetryCount <= maxLockRetries) {
                pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
            } else {
                log.error("Giving up after " + lockRetryCount + " of this error during replication to " + e.getMessage());
            }
        } else {
            log.error("Cannot replicate to " + uri, e);
            // The remote push operation should be retried.
            pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
        }
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    for (RemoteRefUpdate u : res.getRemoteUpdates()) {
        switch(u.getStatus()) {
            case OK:
            case UP_TO_DATE:
            case NON_EXISTING:
                break;
            case NOT_ATTEMPTED:
            case AWAITING_REPORT:
            case REJECTED_NODELETE:
            case REJECTED_NONFASTFORWARD:
            case REJECTED_REMOTE_CHANGED:
                log.error(String.format("Failed replicate of %s to %s: status %s", u.getRemoteName(), uri, u.getStatus()));
                break;
            case REJECTED_OTHER_REASON:
                if ("non-fast-forward".equals(u.getMessage())) {
                    log.error(String.format("Failed replicate of %s to %s" + ", remote rejected non-fast-forward push." + "  Check receive.denyNonFastForwards variable in config file" + " of destination repository.", u.getRemoteName(), uri));
                } else if ("failed to lock".equals(u.getMessage())) {
                    throw new RemoteRepositoryException(uri, u.getMessage());
                } else {
                    log.error(String.format("Failed replicate of %s to %s, reason: %s", u.getRemoteName(), uri, u.getMessage()));
                }
                break;
        }
    }
}
#method_after
private void runImpl() throws IOException {
    Transport tn = Transport.open(git, uri);
    PushResult res;
    try {
        res = pushVia(tn);
    } finally {
        try {
            tn.close();
        } catch (Throwable e2) {
            log.warn("Unexpected error while closing " + uri, e2);
        }
    }
    updateStates(res.getRemoteUpdates());
}
#end_block

#method_before
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#method_after
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    log.info("Push to " + uri + " references: " + todo);
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#end_block

#method_before
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            log.error("Cannot read database to replicate to " + projectName, e);
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#method_after
private List<RemoteRefUpdate> generateUpdates(Transport tn) throws IOException {
    ProjectControl pc;
    try {
        pc = pool.controlFor(projectName);
    } catch (NoSuchProjectException e) {
        return Collections.emptyList();
    }
    Map<String, Ref> local = git.getAllRefs();
    if (!pc.allRefsAreVisible()) {
        if (!pushAllRefs) {
            // If we aren't mirroring, reduce the space we need to filter
            // to only the references we will update during this operation.
            // 
            Map<String, Ref> n = Maps.newHashMap();
            for (String src : delta) {
                Ref r = local.get(src);
                if (r != null) {
                    n.put(src, r);
                }
            }
            local = n;
        }
        ReviewDb db;
        try {
            db = schema.open();
        } catch (OrmException e) {
            wrappedLog.error("Cannot read database to replicate to " + projectName, e, getStatesAsArray());
            return Collections.emptyList();
        }
        try {
            local = new VisibleRefFilter(tagCache, changeCache, git, pc, db, true).filter(local, true);
        } finally {
            db.close();
        }
    }
    return pushAllRefs ? doPushAll(tn, local) : doPushDelta(local);
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (noPerms && GitRepositoryManager.REF_CONFIG.equals(src.getName())) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushAll(Transport tn, Map<String, Ref> local) throws NotSupportedException, TransportException, IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    Map<String, Ref> remote = listRemote(tn);
    for (Ref src : local.values()) {
        if (!canPushRef(src.getName(), noPerms)) {
            continue;
        }
        RefSpec spec = matchSrc(src.getName());
        if (spec != null) {
            Ref dst = remote.get(spec.getDestination());
            if (dst == null || !src.getObjectId().equals(dst.getObjectId())) {
                // Doesn't exist yet, or isn't the same value, request to push.
                push(cmds, spec, src);
            }
        }
    }
    if (config.isMirror()) {
        for (Ref ref : remote.values()) {
            if (!Constants.HEAD.equals(ref.getName())) {
                RefSpec spec = matchDst(ref.getName());
                if (spec != null && !local.containsKey(spec.getSource())) {
                    // No longer on local side, request removal.
                    delete(cmds, spec);
                }
            }
        }
    }
    return cmds;
}
#end_block

#method_before
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && !(noPerms && GitRepositoryManager.REF_CONFIG.equals(src))) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#method_after
private List<RemoteRefUpdate> doPushDelta(Map<String, Ref> local) throws IOException {
    List<RemoteRefUpdate> cmds = Lists.newArrayList();
    boolean noPerms = !pool.isReplicatePermissions();
    for (String src : delta) {
        RefSpec spec = matchSrc(src);
        if (spec != null) {
            // If the ref still exists locally, send it, otherwise delete it.
            Ref srcRef = local.get(src);
            if (srcRef != null && canPushRef(src, noPerms)) {
                push(cmds, spec, srcRef);
            } else if (config.isMirror()) {
                delete(cmds, spec);
            }
        }
    }
    return cmds;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadGitChecks(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.isDraft() && (!receiveConfig.allowDrafts || projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH))) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload drafts");
        return;
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    RevWalk walk = rp.getRevWalk();
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    }
    // 
    try {
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().all();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    ResultSet<Account> accounts = db.accounts().iterateAllEntities();
    for (Account account : accounts) {
        String out = new StringBuilder().append(account.getId().toString()).append(" |").append(Strings.isNullOrEmpty(account.getFullName()) ? "" : " " + account.getFullName()).append(" |").append(Strings.isNullOrEmpty(account.getPreferredEmail()) ? "" : " " + account.getPreferredEmail()).toString();
        stdout.println(out);
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (doBind(meta.mode())) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    if (meta.runsAt().isSupported(slaveMode)) {
        bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
    }
}
#end_block

#method_before
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        HorizontalPanel p = new HorizontalPanel();
        p.setStyleName(Gerrit.RESOURCES.css().pluginName());
        p.add(new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (plugin.adminUrl() != null) {
            Anchor adminScreenAcnhcor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()), Gerrit.selfRedirect(plugin.adminUrl()));
            adminScreenAcnhcor.setTitle(Util.C.pluginAdminToolTip());
            p.add(adminScreenAcnhcor);
        }
        table.setWidget(row, 1, p);
    }
    table.setText(row, 2, plugin.version());
    table.setText(row, 3, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#method_after
void populate(final int row, final PluginInfo plugin) {
    if (plugin.disabled() || plugin.indexUrl() == null) {
        table.setText(row, 1, plugin.name());
    } else {
        table.setWidget(row, 1, new Anchor(plugin.name(), Gerrit.selfRedirect(plugin.indexUrl()), "_blank"));
        if (new ExtensionScreen(plugin.name() + "/settings").isFound()) {
            InlineHyperlink adminScreenLink = new InlineHyperlink();
            adminScreenLink.setHTML(new ImageResourceRenderer().render(Gerrit.RESOURCES.gear()));
            adminScreenLink.setTargetHistoryToken("/x/" + plugin.name() + "/settings");
            adminScreenLink.setTitle(Util.C.pluginSettingsToolTip());
            table.setWidget(row, 2, adminScreenLink);
        }
    }
    table.setText(row, 3, plugin.version());
    table.setText(row, 4, plugin.disabled() ? Util.C.pluginDisabled() : Util.C.pluginEnabled());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 4, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, plugin);
}
#end_block

#method_before
@Override
public ChangeDescription get(EnumSet<ListChangesOption> options) throws RestApiException {
    try {
        // TODO(davido): respect options in mapping
        return info2Description(changeJson.addOptions(options).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return new ChangeInfoMapper(s).map(changeJson.addOptions(s).format(change));
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeDescription c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#method_after
@Test
public void get() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = gApi.changes().id(triplet).get(EnumSet.noneOf(ListChangesOption.class));
    assertEquals(triplet, c.id);
    assertEquals("p", c.project);
    assertEquals("master", c.branch);
    assertEquals(ChangeStatus.NEW, c.status);
    assertEquals("test commit", c.subject);
    assertEquals(true, c.mergeable);
    assertEquals(r.getChangeId(), c.changeId);
    assertEquals(c.created, c.updated);
}
#end_block

#method_before
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id("p~master~" + r.getChangeId()).revert();
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName) {
    return getFromGerritConfig(pluginName, false);
}
#end_block

#method_before
public PluginConfig getFromGerritConfig(String pluginName) {
    return new PluginConfig(pluginName, getGerritConfig());
}
#method_after
public PluginConfig getFromGerritConfig(String pluginName, boolean refresh) {
    if (refresh && cfgSnapshot.isModified(site.gerrit_config)) {
        cfgSnapshot = FileSnapshot.save(site.gerrit_config);
        cfg = cfgProvider.get();
    }
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.user.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return Integer.compare(a._number(), b._number());
        }
    });
}
#method_after
public static void sortRevisionInfoByNumber(JsArray<RevisionInfo> list) {
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return a._number() - b._number();
        }
    });
}
#end_block

#method_before
private static void dispatchHistoryHooks(String token) {
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    ApiGlue.fireEvent("history", token);
}
#method_after
private static void dispatchHistoryHooks(String token) {
    ApiGlue.fireEvent("history", token);
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, token);
}
#end_block

#method_before
private static void addExtensionLink(final LinkMenuBar m, final TopMenuItem item) {
    final Anchor atag = anchor(item.getName(), item.getUrl());
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#method_after
private static void addExtensionLink(LinkMenuBar m, TopMenuItem item) {
    Anchor atag = anchor(item.getName(), selfRedirect(item.getUrl()));
    atag.setTarget(item.getTarget());
    if (item.getId() != null) {
        atag.getElement().setAttribute("id", item.getId());
    }
    m.add(atag);
}
#end_block

#method_before
void render(int context, DiffInfo diff) {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    JsArray<Region> regions = diff.content();
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common()) {
            int len = (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = commentManager.splitSkips(context, skips);
    if (!skips.isEmpty()) {
        CodeMirror cmA = host.getCmFromSide(DisplaySide.A);
        CodeMirror cmB = host.getCmFromSide(DisplaySide.B);
        skipBars = new HashSet<>();
        for (SkippedLine skip : skips) {
            SkipBar barA = newSkipBar(cmA, DisplaySide.A, skip);
            SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip);
            SkipBar.link(barA, barB);
            skipBars.add(barA);
            skipBars.add(barB);
            if (skip.getStartA() == 0 || skip.getStartB() == 0) {
                barA.upArrow.setVisible(false);
                barB.upArrow.setVisible(false);
                line0 = barB;
            } else if (skip.getStartA() + skip.getSize() == lineA || skip.getStartB() + skip.getSize() == lineB) {
                barA.downArrow.setVisible(false);
                barB.downArrow.setVisible(false);
            }
        }
    }
}
#method_after
void render(int context, DiffInfo diff) {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    JsArray<Region> regions = diff.content();
    List<SkippedLine> skips = new ArrayList<>();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null || current.common() || current.skip() > 0) {
            int len = current.skip() > 0 ? current.skip() : (current.ab() != null ? current.ab() : current.b()).length();
            if (i == 0 && len > context + 1) {
                skips.add(new SkippedLine(0, 0, len - context));
            } else if (i == regions.length() - 1 && len > context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - context));
            } else if (len > 2 * context + 1) {
                skips.add(new SkippedLine(lineA + context, lineB + context, len - 2 * context));
            }
            lineA += len;
            lineB += len;
        } else {
            lineA += current.a() != null ? current.a().length() : 0;
            lineB += current.b() != null ? current.b().length() : 0;
        }
    }
    skips = commentManager.splitSkips(context, skips);
    if (!skips.isEmpty()) {
        CodeMirror cmA = host.getCmFromSide(DisplaySide.A);
        CodeMirror cmB = host.getCmFromSide(DisplaySide.B);
        skipBars = new HashSet<>();
        for (SkippedLine skip : skips) {
            SkipBar barA = newSkipBar(cmA, DisplaySide.A, skip);
            SkipBar barB = newSkipBar(cmB, DisplaySide.B, skip);
            SkipBar.link(barA, barB);
            skipBars.add(barA);
            skipBars.add(barB);
            if (skip.getStartA() == 0 || skip.getStartB() == 0) {
                barA.upArrow.setVisible(false);
                barB.upArrow.setVisible(false);
                line0 = barB;
            } else if (skip.getStartA() + skip.getSize() == lineA || skip.getStartB() + skip.getSize() == lineB) {
                barA.downArrow.setVisible(false);
                barB.downArrow.setVisible(false);
            }
        }
    }
}
#end_block

#method_before
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<com.google.gwt.dom.client.Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#method_after
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitSubject) {
    // TODO Replace ActionDialog with a nicer looking display.
    b.setEnabled(false);
    new ActionDialog(b, false, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

        {
            sendButton.setText(Util.C.buttonRevertChangeSend());
            message.setText(Util.M.revertChangeDefaultMessage(commitSubject, revision));
        }

        @Override
        public void onSend() {
            ChangeApi.revert(id.get(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    detail(id).get(cb);
}
#end_block

#method_before
public static void detail(int id, AsyncCallback<ChangeInfo> cb) {
    call(id, "detail").get(cb);
}
#method_after
public static void detail(int id, EnumSet<ListChangesOption> options, AsyncCallback<ChangeInfo> cb) {
    RestApi call = detail(id);
    if (!options.isEmpty()) {
        ChangeList.addOptions(call, options);
    }
    call.get(cb);
}
#end_block

#method_before
private static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#method_after
public static RestApi change(int id) {
    // TODO Switch to triplet project~branch~id format in URI.
    return new RestApi("/changes/").id(String.valueOf(id));
}
#end_block

#method_before
public final void init() {
    if (labels0() != null) {
        labels0().copyKeysIntoChildren("_name");
    }
}
#method_after
public final void init() {
    if (all_labels() != null) {
        all_labels().copyKeysIntoChildren("_name");
    }
}
#end_block

#method_before
public final Set<String> labels() {
    return labels0().keySet();
}
#method_after
public final Set<String> labels() {
    return all_labels().keySet();
}
#end_block

#method_before
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    Gerrit.display(PageLinks.toChange2(id));
                    hide();
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final Change.Id id, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(id.get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
public static String toChange2(final Change.Id c) {
    return "/c2/" + c + "/";
}
#method_after
public static String toChange2(Change.Id c, String p) {
    return "/c2/" + c + "/" + p;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        String s = skip(token);
        if (s.endsWith("/")) {
            s = s.substring(0, s.length() - 1);
        }
        Change.Id id = Change.Id.parse(s);
        Gerrit.display(token, new ChangeScreen2(id));
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/c2/", token)) {
        change2(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ChangeApi.detail(changeId.get(), EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#end_block

#method_before
@UiHandler("starIcon")
void onToggleStar(ClickEvent e) {
    boolean newState = !starred;
    StarredChanges.toggleStar(changeId, newState);
    renderStar(newState);
}
#method_after
@UiHandler("star")
void onToggleStar(ValueChangeEvent<Boolean> e) {
    StarredChanges.toggleStar(changeId, e.getValue());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    CallbackGroup group = new CallbackGroup();
    DiffApi.list(changeId.get(), info.current_revision(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> files) {
            renderFiles(files);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, group);
    loadCommit(rev, group);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
    if (info.status().isOpen() && rev.name().equals(info.current_revision())) {
        loadSubmitAction(rev);
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    accountCache = new HashMap<String, AccountInfo>();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = renderLabels(info);
    renderStar(info.starred());
    renderOwner(info);
    renderActionTextDate(info);
    renderStandardActions(info, canSubmit);
    renderCommitInfo(info);
    renderHistory(info);
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    topicText.setInnerText(info.topic());
    idText.setInnerText(info.change_id());
    // submit_type?
    submitTypeText.setInnerText("Merge If Necessary");
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean canSubmit = labels.set(info);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision, canSubmit);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    boolean hasConflict = Gerrit.getConfig().testChangeMerge() && !info.mergeable();
    setVisible(notMergeable, hasConflict);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    reply.setVisible(replyAction != null);
    if (canSubmit && !hasConflict && actions.isSubmitEnabled()) {
        statusText.setInnerText(Util.C.readyToSubmit());
    } else if (canSubmit && hasConflict) {
        statusText.setInnerText(Util.C.mergeConflict());
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    ownerText.setInnerText(info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName());
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if (value.matches(Util.M.pluginProjectInheritedListValue(".*"))) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.name)) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.name));
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case LIST:
                                if (!projectConfigEntry.getPermittedValues().contains(v.value)) {
                                    throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.value, v.name));
                                }
                            case STRING:
                                cfg.setString(v.name, v.value);
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.name));
                                continue;
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config paramter '%s' of plugin '%s' is invalid: %s", v.value, v.name, pluginName, ex.getMessage()));
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config paramter '%s' of plugin '%s' does not exist.", v.name, pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.getKey(), Boolean.parseBoolean(v.getValue()));
                                break;
                            case INT:
                                cfg.setInt(v.getKey(), Integer.parseInt(v.getValue()));
                                break;
                            case LONG:
                                cfg.setLong(v.getKey(), Long.parseLong(v.getValue()));
                                break;
                            case LIST:
                                if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                    throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                }
                            case STRING:
                                cfg.setString(v.getKey(), v.getValue());
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                    }
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    textBox.setValue(param.value());
    g.add(getDisplayName(param), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.name)) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.name));
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case STRING:
                                cfg.setString(v.name, v.value);
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.name));
                                continue;
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config paramter '%s' of plugin '%s' is invalid: %s", v.value, v.name, pluginName, ex.getMessage()));
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config paramter '%s' of plugin '%s' does not exist.", v.name, pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case INT:
                                cfg.setInt(v.getKey(), Integer.parseInt(v.getValue()));
                                break;
                            case LONG:
                                cfg.setLong(v.getKey(), Long.parseLong(v.getValue()));
                                break;
                            case STRING:
                                cfg.setString(v.getKey(), v.getValue());
                                break;
                            default:
                                log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                    }
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    textBox.setValue(param.value());
    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    textBox.setValue(param.value());
    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!v.name.matches("^[a-zA-Z0-9]*[a-zA-Z0-9-]*$")) {
                    log.warn("The name of the parameter '" + v.name + "' of the plugin '" + pluginName + "' is invalid.");
                    continue;
                }
                if (v.value == null) {
                    cfg.unset(v.name);
                } else {
                    try {
                        switch(projectConfigEntry.getType()) {
                            case BOOLEAN:
                                cfg.setBoolean(v.name, Boolean.parseBoolean(v.value));
                                break;
                            case INT:
                                cfg.setInt(v.name, Integer.parseInt(v.value));
                                break;
                            case LONG:
                                cfg.setLong(v.name, Long.parseLong(v.value));
                                break;
                            case STRING:
                            case LIST:
                            default:
                                cfg.setString(v.name, v.value);
                        }
                    } catch (NumberFormatException ex) {
                        throw new BadRequestException("The value '" + v.value + "' of config paramter '" + v.name + "' of plugin '" + pluginName + "' is invalid: " + ex.getMessage());
                    }
                }
            } else {
                throw new BadRequestException("The config paramter '" + v.name + "' of plugin '" + pluginName + "' does not exist.");
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                if (v.getValue() != null) {
                    cfg.setString(v.getKey(), v.getValue());
                } else {
                    cfg.unset(v.getKey());
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    NativeMap<JsArray<ConfigValueInput>> configValues = NativeMap.create().cast();
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        JsArray<ConfigValueInput> values = JsArray.createArray().cast();
        configValues.put(e.getKey(), values);
        for (Entry<String, String> e2 : e.getValue().entrySet()) {
            ConfigValueInput i = ConfigValueInput.create();
            i.setName(e2.getKey());
            i.setValue(e2.getValue());
            values.push(i);
        }
    }
    setPluginConfigValuesRaw(configValues);
}
#method_after
final void setPluginConfigValues(Map<String, Map<String, String>> pluginConfigValues) {
    if (!pluginConfigValues.isEmpty()) {
        NativeMap<StringMap> configValues = NativeMap.create().cast();
        for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
            StringMap values = StringMap.create();
            configValues.put(e.getKey(), values);
            for (Entry<String, String> e2 : e.getValue().entrySet()) {
                values.put(e2.getKey(), e2.getValue());
            }
        }
        setPluginConfigValuesRaw(configValues);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, Widget> widgetMap : pluginConfigWidgets.values()) {
            for (Widget widget : widgetMap.values()) {
                ((FocusWidget) widget).setEnabled(isOwner);
            }
        }
    }
}
#method_after
private void enableForm(boolean isOwner) {
    submitType.setEnabled(isOwner);
    state.setEnabled(isOwner);
    contentMerge.setEnabled(isOwner);
    descTxt.setEnabled(isOwner);
    contributorAgreements.setEnabled(isOwner);
    signedOffBy.setEnabled(isOwner);
    requireChangeID.setEnabled(isOwner);
    maxObjectSizeLimit.setEnabled(isOwner);
    if (pluginConfigWidgets != null) {
        for (Map<String, FocusWidget> widgetMap : pluginConfigWidgets.values()) {
            for (FocusWidget widget : widgetMap.values()) {
                widget.setEnabled(isOwner);
            }
        }
    }
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, Widget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, Widget> widgetMap = new HashMap<String, Widget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                NpTextBox textBox = new NpTextBox();
                if (param.inheritable()) {
                    textBox.setValue(param.configuredValue());
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(textBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    textBox.setValue(param.value());
                    g.add(param.displayName() != null ? param.displayName() : param.name(), textBox);
                }
                saveEnabler.listenTo(textBox);
                widgetMap.put(param.name(), textBox);
            } else if ("BOOLEAN".equals(param.type())) {
                CheckBox checkbox = new CheckBox();
                checkbox.setValue(Boolean.parseBoolean(param.value()));
                g.add(param.displayName() != null ? param.displayName() : param.name(), checkbox);
                saveEnabler.listenTo(checkbox);
                widgetMap.put(param.name(), checkbox);
            } else if ("LIST".equals(param.type())) {
                ListBox listBox = new ListBox();
                if (param.inheritable()) {
                    listBox.addItem(Util.C.inheritListValue());
                    if (param.configuredValue() == null) {
                        listBox.setSelectedIndex(0);
                    }
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.configuredValue())) {
                            listBox.setSelectedIndex(i + 1);
                        }
                    }
                    Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
                    inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
                    HorizontalPanel p = new HorizontalPanel();
                    p.add(listBox);
                    p.add(inheritedLabel);
                    g.add(param.displayName() != null ? param.displayName() : param.name(), p);
                } else {
                    for (int i = 0; i < param.supportedValues().length(); i++) {
                        String sv = param.supportedValues().get(i);
                        listBox.addItem(sv);
                        if (sv.equals(param.value())) {
                            listBox.setSelectedIndex(i);
                        }
                    }
                    g.add(param.displayName() != null ? param.displayName() : param.name(), listBox);
                }
                saveEnabler.listenTo(listBox);
                widgetMap.put(param.name(), listBox);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param);
            } else {
                continue;
            }
            widgetMap.put(param.name(), w);
        }
    }
    enableForm();
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, Widget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, Widget> e2 : e.getValue().entrySet()) {
            Widget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if ("INHERIT".equals(value)) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private Map<String, Map<String, String>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, String>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        if (s.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String value = s[1];
        s = s[0].split("\\.");
        if (s.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String pluginName = s[0];
        String paramName = s[1];
        Map<String, String> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#method_after
private Map<String, Map<String, String>> parsePluginConfigValues(List<String> pluginConfigValues) throws UnloggedFailure {
    Map<String, Map<String, String>> m = new HashMap<>();
    for (String pluginConfigValue : pluginConfigValues) {
        String[] s = pluginConfigValue.split("=");
        String[] s2 = s[0].split("\\.");
        if (s.length != 2 || s2.length != 2) {
            throw new UnloggedFailure(1, "Invalid plugin config value '" + pluginConfigValue + "', expected format '<plugin-name>.<parameter-name>=<value>'");
        }
        String value = s[1];
        String pluginName = s2[0];
        String paramName = s2[1];
        Map<String, String> l = m.get(pluginName);
        if (l == null) {
            l = new HashMap<>();
            m.put(pluginName, l);
        }
        l.put(paramName, value);
    }
    return m;
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if (value == null) {
                                if (oldValue != null) {
                                    if (!configEntry.isEditable(projectControl.getProjectState())) {
                                        reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                    }
                                    configEntry.onUpdate(cfg, null);
                                }
                            } else {
                                if (!value.equals(oldValue)) {
                                    if (!configEntry.isEditable(projectControl.getProjectState())) {
                                        reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                    }
                                    switch(configEntry.getType()) {
                                        case BOOLEAN:
                                            configEntry.onUpdate(cfg, Boolean.parseBoolean(value));
                                            break;
                                        case INT:
                                            configEntry.onUpdate(cfg, Integer.parseInt(value));
                                            break;
                                        case LONG:
                                            configEntry.onUpdate(cfg, Long.parseLong(value));
                                            break;
                                        case LIST:
                                            if (!configEntry.getPermittedValues().contains(value)) {
                                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                                            }
                                        case STRING:
                                        default:
                                            configEntry.onUpdate(cfg, value);
                                    }
                                }
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        HookResult result = hooks.doRefUpdateHook(project, cmd.getRefName(), currentUser.getAccount(), cmd.getOldId(), cmd.getNewId());
        if (result != null) {
            final String message = result.toString().trim();
            if (result.getExitValue() != 0) {
                reject(cmd, message);
                continue;
            }
            rp.sendMessage(message);
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseMagicBranch(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                        Project.NameKey newParent = cfg.getProject().getParent(allProjectsName);
                        Project.NameKey oldParent = project.getParent(allProjectsName);
                        if (oldParent == null) {
                            // update of the 'All-Projects' project
                            if (newParent != null) {
                                reject(cmd, "invalid project configuration: root project cannot have parent");
                                continue;
                            }
                        } else {
                            if (!oldParent.equals(newParent) && !currentUser.getCapabilities().canAdministrateServer()) {
                                reject(cmd, "invalid project configuration: only Gerrit admin can set parent");
                                continue;
                            }
                            if (projectCache.get(newParent) == null) {
                                reject(cmd, "invalid project configuration: parent does not exist");
                                continue;
                            }
                        }
                        for (Entry<ProjectConfigEntry> e : pluginConfigEntries) {
                            PluginConfig pluginCfg = cfg.getPluginConfig(e.getPluginName());
                            ProjectConfigEntry configEntry = e.getProvider().get();
                            String value = pluginCfg.getString(e.getExportName());
                            String oldValue = projectControl.getProjectState().getConfig().getPluginConfig(e.getPluginName()).getString(e.getExportName());
                            if ((value == null ? oldValue != null : !value.equals(oldValue)) && !configEntry.isEditable(projectControl.getProjectState())) {
                                reject(cmd, String.format("invalid project configuration: Not allowed to set parameter" + " '%s' of plugin '%s' on project '%s'.", e.getExportName(), e.getPluginName(), project.getName()));
                                continue;
                            }
                            if (ProjectConfigEntry.Type.LIST.equals(configEntry.getType()) && value != null && !configEntry.getPermittedValues().contains(value)) {
                                reject(cmd, String.format("invalid project configuration: The value '%s' is " + "not permitted for parameter '%s' of plugin '%s'.", value, e.getExportName(), e.getPluginName()));
                            }
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> oldChangeApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        SetMultimap<ReviewerState, Account.Id> reviewers = ApprovalsUtil.getReviewers(oldChangeApprovals);
        MailRecipients oldRecipients = getRecipientsFromReviewers(reviewers);
        approvalsUtil.copyLabels(db, labelTypes, oldChangeApprovals, priorPatchSet, newPatchSet, changeKind);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : Natives.keys(info.pluginConfigParameters())) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        for (ConfigParameterInfo param : Natives.asList(info.pluginConfigParameter(pluginName))) {
            FocusWidget w;
            if ("STRING".equals(param.type()) || "INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#method_after
private void initPluginOptions(ConfigInfo info) {
    pluginOptionsPanel.clear();
    pluginConfigWidgets = new HashMap<String, Map<String, FocusWidget>>();
    for (String pluginName : info.pluginConfig().keySet()) {
        Map<String, FocusWidget> widgetMap = new HashMap<String, FocusWidget>();
        pluginConfigWidgets.put(pluginName, widgetMap);
        LabeledWidgetsGrid g = new LabeledWidgetsGrid();
        g.addHeader(new SmallHeading(Util.M.pluginProjectOptionsTitle(pluginName)));
        pluginOptionsPanel.add(g);
        NativeMap<ConfigParameterInfo> pluginConfig = info.pluginConfig(pluginName);
        pluginConfig.copyKeysIntoChildren("name");
        for (ConfigParameterInfo param : Natives.asList(pluginConfig.values())) {
            FocusWidget w;
            if ("STRING".equals(param.type())) {
                w = renderTextBox(g, param, false);
            } else if ("INT".equals(param.type()) || "LONG".equals(param.type())) {
                w = renderTextBox(g, param, true);
            } else if ("BOOLEAN".equals(param.type())) {
                w = renderCheckBox(g, param);
            } else if ("LIST".equals(param.type()) && param.permittedValues() != null) {
                w = renderListBox(g, param);
            } else {
                continue;
            }
            if (param.editable()) {
                widgetMap.put(param.name(), w);
            } else {
                w.setEnabled(false);
            }
        }
    }
    enableForm();
}
#end_block

#method_before
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    NpTextBox textBox = new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#method_after
private TextBox renderTextBox(LabeledWidgetsGrid g, ConfigParameterInfo param, boolean numbersOnly) {
    NpTextBox textBox = numbersOnly ? new NpIntTextBox() : new NpTextBox();
    if (param.inheritable()) {
        textBox.setValue(param.configuredValue());
        Label inheritedLabel = new Label(Util.M.pluginProjectInheritedValue(param.inheritedValue()));
        inheritedLabel.setStyleName(Gerrit.RESOURCES.css().pluginProjectConfigInheritedValue());
        HorizontalPanel p = new HorizontalPanel();
        p.add(textBox);
        p.add(inheritedLabel);
        g.add(getDisplayName(param), p);
    } else {
        textBox.setValue(param.value());
        g.add(getDisplayName(param), textBox);
    }
    saveEnabler.listenTo(textBox);
    return textBox;
}
#end_block

#method_before
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox();
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(getDisplayName(param), checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#method_after
private CheckBox renderCheckBox(LabeledWidgetsGrid g, ConfigParameterInfo param) {
    CheckBox checkBox = new CheckBox(getDisplayName(param));
    checkBox.setValue(Boolean.parseBoolean(param.value()));
    g.add(null, checkBox);
    saveEnabler.listenTo(checkBox);
    return checkBox;
}
#end_block

#method_before
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                String value = listBox.getValue(listBox.getSelectedIndex());
                if (value.matches(Util.M.pluginProjectInheritedListValue(".*"))) {
                    value = null;
                }
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#method_after
private Map<String, Map<String, String>> getPluginConfigValues() {
    Map<String, Map<String, String>> pluginConfigValues = new HashMap<String, Map<String, String>>(pluginConfigWidgets.size());
    for (Entry<String, Map<String, FocusWidget>> e : pluginConfigWidgets.entrySet()) {
        Map<String, String> values = new HashMap<String, String>(e.getValue().size());
        pluginConfigValues.put(e.getKey(), values);
        for (Entry<String, FocusWidget> e2 : e.getValue().entrySet()) {
            FocusWidget widget = e2.getValue();
            if (widget instanceof TextBox) {
                values.put(e2.getKey(), ((TextBox) widget).getValue().trim());
            } else if (widget instanceof CheckBox) {
                values.put(e2.getKey(), Boolean.toString(((CheckBox) widget).getValue()));
            } else if (widget instanceof ListBox) {
                ListBox listBox = (ListBox) widget;
                // the inherited value is at index 0,
                // if it is selected no value should be set on this project
                String value = listBox.getSelectedIndex() > 0 ? listBox.getValue(listBox.getSelectedIndex()) : null;
                values.put(e2.getKey(), value);
            }
        }
    }
    return pluginConfigValues;
}
#end_block

#method_before
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, List<ConfigValueInput>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, List<ConfigValueInput>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (ConfigValueInput v : e.getValue()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.name);
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.name)) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.name));
                    continue;
                }
                String oldValue = cfg.getString(v.name);
                if (v.value == null) {
                    if (oldValue != null) {
                        if (!projectConfigEntry.isEditable(projectState)) {
                            throw new BadRequestException(String.format("Not allowed to set parameter '%s' of plugin '%s' on project '%s'.", v.name, pluginName, projectState.getProject().getName()));
                        }
                        cfg.unset(v.name);
                        projectConfigEntry.onUpdate(projectConfig, null);
                    }
                } else {
                    if (!v.value.equals(oldValue)) {
                        if (!projectConfigEntry.isEditable(projectState)) {
                            throw new BadRequestException(String.format("Not allowed to set parameter '%s' of plugin '%s' on project '%s'.", v.name, pluginName, projectState.getProject().getName()));
                        }
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.value);
                                    cfg.setBoolean(v.name, newBooleanValue);
                                    projectConfigEntry.onUpdate(projectConfig, newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.value);
                                    cfg.setInt(v.name, newIntValue);
                                    projectConfigEntry.onUpdate(projectConfig, newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.value);
                                    cfg.setLong(v.name, newLongValue);
                                    projectConfigEntry.onUpdate(projectConfig, newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.value)) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.value, v.name));
                                    }
                                case STRING:
                                    cfg.setString(v.name, v.value);
                                    projectConfigEntry.onUpdate(projectConfig, v.value);
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.name));
                                    continue;
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config paramter '%s' of plugin '%s' is invalid: %s", v.value, v.name, pluginName, ex.getMessage()));
                        }
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config paramter '%s' of plugin '%s' does not exist.", v.name, pluginName));
            }
        }
    }
}
#method_after
private void setPluginConfigValues(ProjectState projectState, ProjectConfig projectConfig, Map<String, Map<String, String>> pluginConfigValues) throws BadRequestException {
    for (Entry<String, Map<String, String>> e : pluginConfigValues.entrySet()) {
        String pluginName = e.getKey();
        PluginConfig cfg = projectConfig.getPluginConfig(pluginName);
        for (Entry<String, String> v : e.getValue().entrySet()) {
            ProjectConfigEntry projectConfigEntry = pluginConfigEntries.get(pluginName, v.getKey());
            if (projectConfigEntry != null) {
                if (!isValidParameterName(v.getKey())) {
                    log.warn(String.format("Parameter name '%s' must match '^[a-zA-Z0-9]+[a-zA-Z0-9-]*$'", v.getKey()));
                    continue;
                }
                String oldValue = cfg.getString(v.getKey());
                if (v.getValue() != null) {
                    if (!v.getValue().equals(oldValue)) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        try {
                            switch(projectConfigEntry.getType()) {
                                case BOOLEAN:
                                    boolean newBooleanValue = Boolean.parseBoolean(v.getValue());
                                    cfg.setBoolean(v.getKey(), newBooleanValue);
                                    break;
                                case INT:
                                    int newIntValue = Integer.parseInt(v.getValue());
                                    cfg.setInt(v.getKey(), newIntValue);
                                    break;
                                case LONG:
                                    long newLongValue = Long.parseLong(v.getValue());
                                    cfg.setLong(v.getKey(), newLongValue);
                                    break;
                                case LIST:
                                    if (!projectConfigEntry.getPermittedValues().contains(v.getValue())) {
                                        throw new BadRequestException(String.format("The value '%s' is not permitted for parameter '%s' of plugin '" + pluginName + "'", v.getValue(), v.getKey()));
                                    }
                                case STRING:
                                    cfg.setString(v.getKey(), v.getValue());
                                    break;
                                default:
                                    log.warn(String.format("The type '%s' of parameter '%s' is not supported.", projectConfigEntry.getType().name(), v.getKey()));
                            }
                        } catch (NumberFormatException ex) {
                            throw new BadRequestException(String.format("The value '%s' of config parameter '%s' of plugin '%s' is invalid: %s", v.getValue(), v.getKey(), pluginName, ex.getMessage()));
                        }
                    }
                } else {
                    if (oldValue != null) {
                        validateProjectConfigEntryIsEditable(projectConfigEntry, projectState, e.getKey(), pluginName);
                        cfg.unset(v.getKey());
                    }
                }
            } else {
                throw new BadRequestException(String.format("The config parameter '%s' of plugin '%s' does not exist.", v.getKey(), pluginName));
            }
        }
    }
}
#end_block

#method_before
public void onUpdate(ProjectConfig projectConfig, long newValue) {
}
#method_after
public void onUpdate(Project.NameKey project, String oldValue, String newValue) {
}
#end_block

#method_before
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.onProjectCreated(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#method_after
@Override
public Response<ProjectInfo> apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ResourceConflictException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = input.submitType;
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validMaxObjectSizeLimit(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    for (ProjectCreationValidationListener l : projectCreationValidationListeners) {
        try {
            l.validateNewProject(args);
        } catch (ValidationException e) {
            throw new ResourceConflictException(e.getMessage(), e);
        }
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
@Override
protected void run() throws Failure, OrmException {
    try {
        CreateGroupArgs args = new CreateGroupArgs();
        args.setGroupName(groupName);
        args.groupDescription = groupDescription;
        args.visibleToAll = visibleToAll;
        args.ownerGroupId = ownerGroupId;
        args.initialMembers = initialMembers;
        args.initialGroups = initialGroups;
        for (GroupCreationValidationListener l : groupCreationValidationListeners) {
            try {
                l.validate(args);
            } catch (ValidationException e) {
                die(e);
            }
        }
        performCreateGroupFactory.create(args).createGroup();
    } catch (PermissionDeniedException e) {
        throw die(e);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#method_after
@Override
protected void run() throws Failure, OrmException {
    try {
        CreateGroupArgs args = new CreateGroupArgs();
        args.setGroupName(groupName);
        args.groupDescription = groupDescription;
        args.visibleToAll = visibleToAll;
        args.ownerGroupId = ownerGroupId;
        args.initialMembers = initialMembers;
        args.initialGroups = initialGroups;
        for (GroupCreationValidationListener l : groupCreationValidationListeners) {
            try {
                l.validateNewGroup(args);
            } catch (ValidationException e) {
                die(e);
            }
        }
        performCreateGroupFactory.create(args).createGroup();
    } catch (PermissionDeniedException e) {
        throw die(e);
    } catch (NameAlreadyUsedException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(TopLevelResource resource, Input input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    AccountGroup group;
    try {
        CreateGroupArgs args = new CreateGroupArgs();
        args.setGroupName(name);
        args.groupDescription = Strings.emptyToNull(input.description);
        args.visibleToAll = Objects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
        args.ownerGroupId = ownerId;
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
        for (GroupCreationValidationListener l : groupCreationValidationListeners) {
            try {
                l.validate(args);
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
        group = op.create(args).createGroup();
    } catch (PermissionDeniedException e) {
        throw new AuthException(e.getMessage());
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return json.format(GroupDescriptions.forAccountGroup(group));
}
#method_after
@Override
public GroupInfo apply(TopLevelResource resource, Input input) throws AuthException, BadRequestException, UnprocessableEntityException, ResourceConflictException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    AccountGroup.Id ownerId = owner(input);
    AccountGroup group;
    try {
        CreateGroupArgs args = new CreateGroupArgs();
        args.setGroupName(name);
        args.groupDescription = Strings.emptyToNull(input.description);
        args.visibleToAll = Objects.firstNonNull(input.visibleToAll, defaultVisibleToAll);
        args.ownerGroupId = ownerId;
        args.initialMembers = ownerId == null ? Collections.singleton(self.get().getAccountId()) : Collections.<Account.Id>emptySet();
        for (GroupCreationValidationListener l : groupCreationValidationListeners) {
            try {
                l.validateNewGroup(args);
            } catch (ValidationException e) {
                throw new ResourceConflictException(e.getMessage(), e);
            }
        }
        group = op.create(args).createGroup();
    } catch (PermissionDeniedException e) {
        throw new AuthException(e.getMessage());
    } catch (NameAlreadyUsedException e) {
        throw new ResourceConflictException(e.getMessage());
    }
    return json.format(GroupDescriptions.forAccountGroup(group));
}
#end_block

#method_before
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<com.google.gwt.dom.client.Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#method_after
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#end_block

#method_before
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    com.google.gwt.dom.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#method_after
private static PatchSetsBox getRevisionBox(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof PatchSetsBox) {
            return (PatchSetsBox) l;
        }
    }
    return null;
}
#end_block

#method_before
private static MyTable getMyTable(NativeEvent event) {
    com.google.gwt.dom.client.Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof MyTable) {
            return (MyTable) l;
        }
    }
    return null;
}
#method_after
private static MyTable getMyTable(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof MyTable) {
            return (MyTable) l;
        }
    }
    return null;
}
#end_block

#method_before
static ChangeScreen2 get(NativeEvent in) {
    com.google.gwt.dom.client.Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#method_after
static ChangeScreen2 get(NativeEvent in) {
    Element e = in.getEventTarget().cast();
    for (e = DOM.getParent(e); e != null; e = DOM.getParent(e)) {
        EventListener l = DOM.getEventListener(e);
        if (l instanceof ChangeScreen2) {
            return (ChangeScreen2) l;
        }
    }
    return null;
}
#end_block

#method_before
public static com.google.gwt.dom.client.Element parse(SafeHtml html) {
    com.google.gwt.dom.client.Element e = DOM.createDiv();
    setInnerHTML(e, html);
    return DOM.getFirstChild(e);
}
#method_after
public static Element parse(SafeHtml html) {
    Element e = DOM.createDiv();
    setInnerHTML(e, html);
    return DOM.getFirstChild(e);
}
#end_block

#method_before
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        log.error("Cannot replicate " + projectName + "; " + e.getMessage());
    } catch (NoRemoteRepositoryException e) {
        if (pool.isCreateMissingRepos()) {
            try {
                createRepository();
                log.warn("Missing repository created; retry replication to " + uri);
                pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING);
            } catch (IOException ioe) {
                wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
            }
        } else {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        }
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else {
            log.error("Cannot replicate to " + uri, e);
        }
        // The remote push operation should be retried.
        pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#method_after
private void runPushOperation() {
    // 
    if (!pool.requestRunway(this)) {
        if (!canceled) {
            log.info("Rescheduling replication to " + uri + " to avoid collision with an in-flight push.");
            pool.reschedule(this, Destination.RetryReason.COLLISION);
        }
        return;
    }
    try {
        git = gitManager.openRepository(projectName);
        runImpl();
    } catch (RepositoryNotFoundException e) {
        wrappedLog.error("Cannot replicate " + projectName + "; " + e.getMessage(), getStatesAsArray());
    } catch (RemoteRepositoryException e) {
        log.error("Cannot replicate " + projectName + "; " + e.getMessage());
    } catch (NoRemoteRepositoryException e) {
        if (pool.isCreateMissingRepos()) {
            try {
                createRepository();
                log.warn("Missing repository created; retry replication to " + uri);
                pool.reschedule(this, Destination.RetryReason.REPOSITORY_MISSING);
            } catch (IOException ioe) {
                wrappedLog.error("Cannot replicate to " + uri + "; failed to create missing repository", ioe, getStatesAsArray());
            }
        } else {
            wrappedLog.error("Cannot replicate to " + uri + "; repository not found", getStatesAsArray());
        }
    } catch (NotSupportedException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (TransportException e) {
        Throwable cause = e.getCause();
        if (cause instanceof JSchException && cause.getMessage().startsWith("UnknownHostKey:")) {
            log.error("Cannot replicate to " + uri + ": " + cause.getMessage());
        } else {
            log.error("Cannot replicate to " + uri, e);
        }
        // The remote push operation should be retried.
        pool.reschedule(this, Destination.RetryReason.TRANSPORT_ERROR);
    } catch (IOException e) {
        wrappedLog.error("Cannot replicate to " + uri, e, getStatesAsArray());
    } catch (RuntimeException e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } catch (Error e) {
        wrappedLog.error("Unexpected error during replication to " + uri, e, getStatesAsArray());
    } finally {
        if (git != null) {
            git.close();
        }
        pool.notifyFinished(this);
    }
}
#end_block

#method_before
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            @SuppressWarnings("unchecked")
            Enumeration<String> headerNames = request.getHeaderNames();
            while (headerNames.hasMoreElements()) {
                String name = headerNames.nextElement();
                @SuppressWarnings("unchecked")
                List<String> values = Collections.list(request.getHeaders(name));
                headers.log(logHeaders, name + ": " + values.get(0));
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            Collection<String> names = response.getHeaderNames();
            for (String name : names) {
                headers.log(logHeaders, name + ": " + response.getHeader(name));
            }
        }
    }
}
#method_after
public void log(Request request, Response response) {
    int status = response.getStatus();
    if (status < 0) {
        // Copied from NCSARequestLog
        status = 404;
    }
    TreeLogger.Type logStatus, logHeaders;
    if (status >= 500) {
        logStatus = TreeLogger.ERROR;
        logHeaders = TreeLogger.INFO;
    } else if (status >= 400) {
        logStatus = TreeLogger.WARN;
        logHeaders = TreeLogger.INFO;
    } else {
        logStatus = TreeLogger.INFO;
        logHeaders = TreeLogger.DEBUG;
    }
    String userString = request.getRemoteUser();
    if (userString == null) {
        userString = "";
    } else {
        userString += "@";
    }
    String bytesString = "";
    if (response.getContentCount() > 0) {
        bytesString = " " + response.getContentCount() + " bytes";
    }
    if (logger.isLoggable(logStatus)) {
        TreeLogger branch = logger.branch(logStatus, String.valueOf(status) + " - " + request.getMethod() + ' ' + request.getUri() + " (" + userString + request.getRemoteHost() + ')' + bytesString);
        if (branch.isLoggable(logHeaders)) {
            // Request headers
            TreeLogger headers = branch.branch(logHeaders, "Request headers");
            for (HttpField f : request.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
            // Response headers
            headers = branch.branch(logHeaders, "Response headers");
            for (HttpField f : response.getHttpFields()) {
                headers.log(logHeaders, f.getName() + ": " + f.getValue());
            }
        }
    }
}
#end_block

#method_before
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    AbstractConnector connector = getConnector();
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    Server server = new Server();
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#method_after
@Override
public ServletContainer start(TreeLogger logger, int port, File warDir) throws Exception {
    TreeLogger branch = logger.branch(TreeLogger.INFO, "Starting Jetty on port " + port, null);
    checkStartParams(branch, port, warDir);
    // Setup our branch logger during startup.
    Log.setLog(new JettyTreeLogger(branch));
    // Turn off XML validation.
    System.setProperty("org.mortbay.xml.XmlParser.Validating", "false");
    Server server = new Server();
    HttpConfiguration config = defaultConfig();
    ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(config));
    if (bindAddress != null) {
        connector.setHost(bindAddress);
    }
    connector.setPort(port);
    // Don't share ports with an existing process.
    connector.setReuseAddress(false);
    // Linux keeps the port blocked after shutdown if we don't disable this.
    connector.setSoLingerTime(0);
    server.addConnector(connector);
    File top;
    String root = System.getProperty("gerrit.source_root");
    if (root != null) {
        top = new File(root);
    } else {
        // Under Maven warDir is "$top/gerrit-gwtui/target/gwt-hosted-mode"
        top = warDir.getParentFile().getParentFile().getParentFile();
    }
    File app = new File(top, "gerrit-war/src/main/webapp");
    File webxml = new File(app, "WEB-INF/web.xml");
    // Jetty won't start unless this directory exists.
    if (!warDir.exists() && !warDir.mkdirs())
        logger.branch(TreeLogger.ERROR, "Cannot create " + warDir, null);
    // Create a new web app in the war directory.
    // 
    WebAppContext wac = new MyWebAppContext(warDir.getAbsolutePath(), "/");
    wac.setDescriptor(webxml.getAbsolutePath());
    RequestLogHandler logHandler = new RequestLogHandler();
    logHandler.setRequestLog(new JettyRequestLogger(logger));
    logHandler.setHandler(wac);
    server.setHandler(logHandler);
    server.start();
    server.setStopAtShutdown(true);
    // Now that we're started, log to the top level logger.
    Log.setLog(new JettyTreeLogger(logger));
    return new JettyServletContainer(logger, server, wac, connector.getLocalPort(), warDir);
}
#end_block

#method_before
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        URL url = ConfigAnnotationParser.class.getResource(CONFIG_DIR + name);
        if (url != null) {
            cfg.fromText(Resources.toString(url, Charsets.UTF_8));
        }
    }
    return cfg;
}
#method_after
static Config parseFromSystemProperty() throws ConfigInvalidException, IOException {
    Config cfg = new Config();
    String name = System.getProperty(CONFIG_PKG + "BaseConfig");
    if (!Strings.isNullOrEmpty(name)) {
        String resource = CONFIG_DIR + name + ".config";
        URL url = checkNotNull(ConfigAnnotationParser.class.getResource(resource), "test config resource not found: %s", resource);
        cfg.fromText(Resources.toString(url, Charsets.UTF_8));
    }
    return cfg;
}
#end_block

#method_before
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parse(cfg, c);
    }
    return cfg;
}
#method_after
static Config parse(Config base, GerritConfigs annotation) {
    if (annotation == null) {
        return null;
    }
    Config cfg = new Config(base);
    for (GerritConfig c : annotation.value()) {
        parseAnnotation(cfg, c);
    }
    return cfg;
}
#end_block

#method_before
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            LOG.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            LOG.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#method_after
private void reloadIfNeeded() {
    if (isAutoReload() && currentConfig.getCfgPath().lastModified() > currentConfigTs) {
        try {
            ReplicationFileBasedConfig newConfig = loadConfig();
            newConfig.startup(workQueue);
            int discarded = currentConfig.shutdown();
            this.currentConfig = newConfig;
            this.currentConfigTs = currentConfig.getCfgPath().lastModified();
            log.info("Configuration reloaded: " + currentConfig.getDestinations().size() + " destinations, " + discarded + " replication events discarded");
        } catch (Exception e) {
            log.error("Cannot reload replication configuration: keeping existing settings", e);
            return;
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("No " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Empty " + config.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations() throws ConfigInvalidException, IOException {
    if (!config.getFile().exists()) {
        log.warn("Config file " + config.getFile() + "does not exist; not replicating");
        return Collections.emptyList();
    }
    if (config.getFile().length() == 0) {
        log.info("Config file " + config.getFile() + " is empty; not replicating");
        return Collections.emptyList();
    }
    try {
        config.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", config.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", config.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = config.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(config)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        Destination destination = new Destination(injector, c, config, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend);
        if (!destination.isSingleProjectMatch()) {
            for (URIish u : c.getURIs()) {
                if (u.getPath() == null || !u.getPath().contains("${name}")) {
                    throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, config.getFile()));
                }
            }
        }
        dest.add(destination);
    }
    return dest.build();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(SecureCredentialsFactory.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
}
#end_block

#method_before
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        StringBuilder msgBuf = new StringBuilder().append("Topic edited.").append("\n\n").append("Old topic: " + (oldTopicName.isEmpty() ? "[empty]" : oldTopicName)).append("\n\n").append("New topic: " + (newTopicName.isEmpty() ? "[removed]" : newTopicName));
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#method_after
@Override
public Response<String> apply(ChangeResource req, Input input) throws AuthException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to " + newTopicName;
        } else if (newTopicName.isEmpty()) {
            summary = "Topic " + oldTopicName + " removed";
        } else {
            summary = String.format("Topic changed from %s to %s", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change.getId());
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.<String>none() : Response.ok(newTopicName);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalsUtil.copyLabels(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    ChangeUpdate update = updateFactory.create(change, newPatchSet.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet.getId());
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(change);
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    f.checkedGet();
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalsUtil.copyLabels(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change c = ctl.getChange();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), c.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(c.getProject(), ru);
    final PatchSet.Id currentPatchSetId = c.currentPatchSetId();
    ChangeUpdate update = updateFactory.create(c, patchSet.getCreatedOn(), (IdentifiedUser) ctl.getCurrentUser());
    db.changes().beginTransaction(c.getId());
    try {
        if (!db.changes().get(c.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", c.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        SetMultimap<ReviewerState, Account.Id> oldReviewers = sendMail ? approvalsUtil.getReviewers(db, ctl.getNotes()) : null;
        updatedChange = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", c.getId()));
        }
        if (messageIsForChange()) {
            insertMessage(db);
        }
        if (copyLabels) {
            approvalCopier.copy(db, ctl, patchSet.getId());
        }
        db.commit();
        update.commit();
        if (!messageIsForChange()) {
            insertMessage(db);
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers.get(ReviewerState.REVIEWER));
                cm.addExtraCC(oldReviewers.get(ReviewerState.CC));
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> f = mergeabilityChecker.updateAndIndexAsync(updatedChange);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
    }
    f.checkedGet();
    return updatedChange;
}
#end_block

#method_before
private static PatchSetApproval copy(PatchSetApproval src, PatchSet.Id psId) {
    if (src.getKey().getParentKey().equals(psId)) {
        return src;
    }
    return new PatchSetApproval(psId, src);
}
#method_after
public void copy(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    db.patchSetApprovals().insert(getForPatchSet(db, ctl, psId));
}
#end_block

#method_before
List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Change.Id cid = cd.change().getId();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        Map<Integer, PatchSet> patchSets = getPatchSets(cd);
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            for (int i = psId.get() - 1; i >= 1; i--) {
                PatchSet.Id prior = new PatchSet.Id(cid, i);
                PatchSet priorPs = patchSets.get(i);
                if (priorPs == null) {
                    throw new OrmException("missing patch set " + prior);
                }
                List<PatchSetApproval> priorApprovals = all.get(prior);
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
private List<PatchSetApproval> getForPatchSet(ReviewDb db, ChangeControl ctl, PatchSet.Id psId) throws OrmException {
    ChangeData cd = changeDataFactory.create(db, ctl);
    try {
        ProjectState project = projectCache.checkedGet(cd.change().getDest().getParentKey());
        ListMultimap<PatchSet.Id, PatchSetApproval> all = cd.allApprovalsMap();
        Table<String, Account.Id, PatchSetApproval> byUser = HashBasedTable.create();
        for (PatchSetApproval psa : all.get(psId)) {
            byUser.put(psa.getLabel(), psa.getAccountId(), psa);
        }
        TreeMap<Integer, PatchSet> patchSets = getPatchSets(cd);
        NavigableSet<Integer> allPsIds = patchSets.navigableKeySet();
        PatchSet currPs = patchSets.get(psId.get());
        if (currPs == null) {
            throw new OrmException("missing patch set " + psId);
        }
        Repository repo = repoManager.openRepository(project.getProject().getNameKey());
        try {
            // Walk patch sets strictly less than psId in descending order.
            for (PatchSet priorPs : patchSets.descendingMap().tailMap(psId.get(), false).values()) {
                List<PatchSetApproval> priorApprovals = all.get(priorPs.getId());
                if (priorApprovals.isEmpty()) {
                    continue;
                }
                ChangeKind kind = changeKindCache.getChangeKind(project, repo, ObjectId.fromString(priorPs.getRevision().get()), ObjectId.fromString(currPs.getRevision().get()));
                for (PatchSetApproval psa : priorApprovals) {
                    if (!byUser.contains(psa.getLabel(), psa.getAccountId()) && canCopy(project, psa, psId, allPsIds, kind)) {
                        byUser.put(psa.getLabel(), psa.getAccountId(), copy(psa, psId));
                    }
                }
            }
            return labelNormalizer.normalize(ctl, byUser.values());
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
private static Map<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    Map<Integer, PatchSet> result = Maps.newHashMapWithExpectedSize(patchSets.size());
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#method_after
private static TreeMap<Integer, PatchSet> getPatchSets(ChangeData cd) throws OrmException {
    Collection<PatchSet> patchSets = cd.patches();
    TreeMap<Integer, PatchSet> result = Maps.newTreeMap();
    for (PatchSet ps : patchSets) {
        result.put(ps.getId().get(), ps);
    }
    return result;
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, ChangeKind kind) throws OrmException {
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa)) {
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) throws OrmException {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equal(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE);
}
#end_block

#method_before
@Override
protected void configure() {
    super.configure();
    install(ThreadLocalRequestContext.module());
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(QueryDocumentationExecutor.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCache.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    cfgInjector = createCfgInjector();
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    limitThreads();
    if (version == null) {
        version = ChangeSchemas.getLatest().getVersion();
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    index = sysInjector.getInstance(IndexCollection.class).getSearchIndex();
    index.markReady(false);
    index.deleteAll();
    int result = indexAll();
    index.markReady(true);
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    // modules.add(new LogFileCompressor.Module());
    // modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new MergeabilityChecksExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModuleBase.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(NoSshKeyCache.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return CanonicalWebUrlProvider.class;
        }
    });
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(CurrentUser.class).toProvider(new Provider<CurrentUser>() {

                @Override
                public CurrentUser get() {
                    return null;
                }
            });
            bind(IdentifiedUser.class).toProvider(new Provider<IdentifiedUser>() {

                @Override
                public IdentifiedUser get() {
                    return null;
                }
            });
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(version, threads, outputBase);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(false, threads, outputBase);
            break;
        default:
            throw new IllegalStateException("unsupported index.type");
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new FactoryModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
            factory(ChangeData.Factory.class);
            factory(ProjectState.Factory.class);
            bind(new TypeLiteral<List<CommentLinkInfo>>() {
            }).toProvider(CommentLinkProvider.class).in(SINGLETON);
            bind(CurrentUser.class).toProvider(Providers.<CurrentUser>of(null));
            bind(String.class).annotatedWith(CanonicalWebUrl.class).toProvider(CanonicalWebUrlProvider.class);
            factory(IncludingGroupMembership.Factory.class);
            bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
            DynamicSet.setOf(binder(), GroupBackend.class);
            bind(InternalGroupBackend.class).in(SINGLETON);
            DynamicSet.bind(binder(), GroupBackend.class).to(SystemGroupBackend.class);
            DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
            factory(InternalUser.Factory.class);
            factory(PatchSetInserter.Factory.class);
            bind(ChangeHooks.class).to(DisabledChangeHooks.class);
            bind(ReplacePatchSetSender.Factory.class).toProvider(Providers.<ReplacePatchSetSender.Factory>of(null));
            factory(CapabilityControl.Factory.class);
            factory(MergeUtil.Factory.class);
            DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
            DynamicSet.setOf(binder(), CommitValidationListener.class);
            factory(CommitValidators.Factory.class);
        }
    });
    modules.add(AccountCacheImpl.module());
    modules.add(AccountByEmailCacheImpl.module());
    modules.add(ChangeKindCache.module());
    modules.add(GroupCacheImpl.module());
    modules.add(GroupIncludeCacheImpl.module());
    modules.add(ProjectCacheImpl.module());
    modules.add(SectionSortCache.module());
    modules.add(new AccessControlModule());
    modules.add(new GitModule());
    modules.add(new PrologModule());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
        }

        @Provides
        @Singleton
        @MergeabilityChecksExecutor
        public WorkQueue.Executor createMergeabilityChecksExecutor(WorkQueue queues) {
            return queues.createQueue(1, "MergeabilityChecks");
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(GitRepositoryManager.REF_CONFIG)) {
        executor.submit(new RefUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    String ref = event.getRefName();
    if (ref.startsWith(Constants.R_HEADS) || ref.equals(RefNames.REFS_CONFIG)) {
        executor.submit(new BranchUpdateTask(schemaFactory, new Project.NameKey(event.getProjectName()), ref));
    }
    if (ref.equals(RefNames.REFS_CONFIG)) {
        Project.NameKey p = new Project.NameKey(event.getProjectName());
        try {
            ProjectConfig oldCfg = parseConfig(p, event.getOldObjectId());
            ProjectConfig newCfg = parseConfig(p, event.getNewObjectId());
            if (recheckMerges(oldCfg, newCfg)) {
                try {
                    new ProjectUpdateTask(schemaFactory, p, true).call();
                } catch (Exception e) {
                    String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
                    log.error(msg, e);
                    Throwables.propagateIfPossible(e);
                    throw new RuntimeException(msg, e);
                }
            }
        } catch (ConfigInvalidException | IOException e) {
            String msg = "Failed to update mergeability flags for project " + p.get() + " on update of " + RefNames.REFS_CONFIG;
            log.error(msg, e);
            throw new RuntimeException(msg, e);
        }
    }
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return updateAsync(change, false);
}
#end_block

#method_before
public CheckedFuture<Boolean, IOException> updateAsync(Change change) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change)), MAPPER);
}
#method_after
private CheckedFuture<Boolean, IOException> updateAsync(Change change, boolean force) {
    return Futures.makeChecked(executor.submit(new ChangeUpdateTask(schemaFactory, change, force)), MAPPER);
}
#end_block

#method_before
public CheckedFuture<?, IOException> updateAndIndexAsync(final Change change) {
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(change);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#method_after
public CheckedFuture<?, IOException> updateAndIndexAsync(Change change) {
    final Change.Id id = change.getId();
    return Futures.makeChecked(Futures.transform(updateAsync(change), new AsyncFunction<Boolean, Object>() {

        @SuppressWarnings("unchecked")
        @Override
        public ListenableFuture<Object> apply(Boolean indexUpdated) throws Exception {
            if (!indexUpdated) {
                return (ListenableFuture<Object>) indexer.indexAsync(id);
            }
            return Futures.immediateFuture(null);
        }
    }), MAPPER);
}
#end_block

#method_before
public boolean update(Change change) throws IOException {
    try {
        return new ChangeUpdateTask(schemaFactory, change).call();
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#method_after
public void update(Project.NameKey project) throws IOException {
    try {
        for (CheckedFuture<?, IOException> f : new ProjectUpdateTask(schemaFactory, project, false).call()) {
            f.checkedGet();
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw MAPPER.apply(e);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        MergeableInfo info = mergeable.get().apply(new RevisionResource(new ChangeResource(changeControlFactory.controlFor(change, context.getCurrentUser())), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#method_after
@Override
public Boolean call() throws Exception {
    mergeabilityCheckQueue.updatingMergeabilityFlag(change, force);
    RequestContext context = new RequestContext() {

        @Override
        public CurrentUser getCurrentUser() {
            return identifiedUserFactory.create(change.getOwner());
        }

        @Override
        public Provider<ReviewDb> getReviewDbProvider() {
            return new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    if (reviewDb == null) {
                        try {
                            reviewDb = schemaFactory.open();
                        } catch (OrmException e) {
                            throw new ProvisionException("Cannot open ReviewDb", e);
                        }
                    }
                    return reviewDb;
                }
            };
        }
    };
    RequestContext old = tl.setContext(context);
    ReviewDb db = context.getReviewDbProvider().get();
    try {
        PatchSet ps = db.patchSets().get(change.currentPatchSetId());
        Mergeable m = mergeable.get();
        m.setForce(force);
        ChangeControl control = changeControlFactory.controlFor(change.getId(), context.getCurrentUser());
        MergeableInfo info = m.apply(new RevisionResource(new ChangeResource(control), ps));
        return change.isMergeable() != info.mergeable;
    } catch (ResourceConflictException e) {
        // change is closed
        return false;
    } finally {
        tl.setContext(old);
        if (reviewDb != null) {
            reviewDb.close();
            reviewDb = null;
        }
    }
}
#end_block

#method_before
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
        // TODO(davido): include indexing of mergeable field in MPM above
        for (Project.NameKey project : projects) {
            List<CheckedFuture<?, IOException>> f = checker.reindexProject(project);
            for (CheckedFuture<?, IOException> checkedFuture : f) {
                checkedFuture.checkedGet();
            }
        }
    } catch (ExecutionException | IOException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#method_after
public Result indexAll(ChangeIndex index, Iterable<Project.NameKey> projects, int numProjects, int numChanges, OutputStream progressOut, OutputStream verboseOut) {
    if (progressOut == null) {
        progressOut = NullOutputStream.INSTANCE;
    }
    PrintWriter verboseWriter = verboseOut != null ? new PrintWriter(verboseOut) : null;
    Stopwatch sw = Stopwatch.createStarted();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(progressOut, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", numProjects >= 0 ? numProjects : MultiProgressMonitor.UNKNOWN);
    final Task doneTask = mpm.beginSubTask(null, numChanges >= 0 ? numChanges : MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    final List<ListenableFuture<?>> futures = Lists.newArrayList();
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        try {
            mergeabilityChecker.update(project);
        } catch (IOException e) {
            log.error("Error in mergeability checker", e);
            ok.set(false);
        }
        final ListenableFuture<?> future = executor.submit(reindexProject(indexerFactory.create(index), project, doneTask, failedTask, verboseWriter));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    fail(project, e);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    try {
        mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

            @Override
            public ListenableFuture<Void> apply(List<?> input) {
                mpm.end();
                return Futures.immediateFuture(null);
            }
        }));
    } catch (ExecutionException e) {
        log.error("Error in batch indexer", e);
        ok.set(false);
    }
    return new Result(sw, ok.get(), doneTask.getCount(), failedTask.getCount());
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = null;
            ReviewDb db = null;
            try {
                repo = repoManager.openRepository(project);
                Map<String, Ref> refs = repo.getRefDatabase().getRefs(ALL);
                db = schemaFactory.open();
                for (Change c : db.changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), changeDataFactory.create(db, c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } catch (RepositoryNotFoundException rnfe) {
                log.error(rnfe.getMessage());
            } finally {
                if (db != null) {
                    db.close();
                }
                if (repo != null) {
                    repo.close();
                }
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#method_after
@Before
public void setUp() throws Exception {
    user = accounts.user();
    admin = accounts.admin();
    initSsh(admin);
    project = new Project.NameKey("p");
    session = new RestSession(server, user);
    SshSession sshSession = new SshSession(server, admin);
    try {
        createProject(sshSession, project.get());
        git = cloneProject(sshSession.getUrl() + "/" + project.get());
        db = reviewDbProvider.open();
        atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), user.getId())));
    } finally {
        sshSession.close();
    }
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    grant(cfg, Permission.forLabel("Code-Review"), -2, 2, anonymousUsers, "refs/heads/*");
    grant(cfg, Permission.SUBMIT, anonymousUsers, "refs/heads/*");
    codeReview = checkNotNull(cfg.getLabelSections().get("Code-Review"));
    codeReview.setCopyMinScore(false);
    codeReview.setCopyMaxScore(false);
    codeReview.setCopyAllScoresOnTrivialRebase(false);
    codeReview.setCopyAllScoresIfNoCodeChange(false);
    saveProjectConfig(cfg);
}
#end_block

#method_before
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    SubmitInput input = new SubmitInput();
    input.waitForMerge = true;
    revision(r).submit(input);
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#method_after
private void merge(PushOneCommit.Result r) throws Exception {
    review(r, 2);
    revision(r).submit();
    Repository repo = repoManager.openRepository(project);
    try {
        assertEquals(r.getCommitId(), repo.getRef("refs/heads/master").getObjectId());
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    // TODO(cranger): pass infinity
    final int height = getCodeMirrorHeight();
    operation(new Runnable() {

        @Override
        public void run() {
            cmA.setHeight(height);
            cmB.setHeight(height);
            cmA.refresh();
            cmB.refresh();
        }
    });
    diffTable.sidePanel.adjustGutters(cmB);
    if (startLine == 0 && diff.meta_b() != null) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            startSide = d.getSide();
            startLine = d.getStart() + 1;
        }
    }
    if (startSide != null && startLine > 0) {
        int line = startLine - 1;
        CodeMirror cm = getCmFromSide(startSide);
        if (cm.lineAtHeight(height - 20) < line) {
            cm.scrollToY(cm.heightAtLine(line, "local") - 0.5 * height);
        }
        cm.setCursor(LineCharacter.create(line));
        cm.focus();
    } else {
        cmA.setCursor(LineCharacter.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    final int height = getCodeMirrorHeight();
    operation(new Runnable() {

        @Override
        public void run() {
            cmA.setHeight(height);
            cmB.setHeight(height);
            cmA.refresh();
            cmB.refresh();
        }
    });
    diffTable.sidePanel.adjustGutters(cmB);
    if (startLine == 0 && diff.meta_b() != null) {
        DiffChunkInfo d = chunkManager.getFirst();
        if (d != null) {
            startSide = d.getSide();
            startLine = d.getStart() + 1;
        }
    }
    if (startSide != null && startLine > 0) {
        int line = startLine - 1;
        CodeMirror cm = getCmFromSide(startSide);
        if (cm.lineAtHeight(height - 20) < line) {
            cm.scrollToY(cm.heightAtLine(line, "local") - 0.5 * height);
        }
        cm.setCursor(LineCharacter.create(line));
        cm.focus();
    } else {
        cmA.setCursor(LineCharacter.create(0));
        cmA.focus();
    }
    if (Gerrit.isSignedIn() && prefs.autoReview()) {
        header.autoReview();
    }
    prefetchNextFile();
}
#end_block

#method_before
private static boolean onOpen(NativeEvent e, String token) {
    if (link.handleAsClick(e.<Event>cast())) {
        Gerrit.display(token);
        e.preventDefault();
        return false;
    }
    return true;
}
#method_after
private static boolean onOpen(NativeEvent evt, Element e) {
    if (LINK.handleAsClick(evt.<Event>cast())) {
        Gerrit.display(e.getAttribute("href").substring(1));
        evt.preventDefault();
        return false;
    }
    return true;
}
#end_block

#method_before
void setMaxHeight(int height) {
    maxHeight = height;
    if (view != null) {
        view.setHeight(height + "px");
        view.movePointerTo(view.selectedRow);
    }
}
#method_after
void setMaxHeight(int height) {
    maxHeight = height;
    if (view != null) {
        view.setHeight(height + "px");
        view.movePointerTo(view.selectedRow, true);
    }
}
#end_block

#method_before
private boolean computeConnected() {
    if (connected == null) {
        return false;
    }
    // the connections.
    if (!connected.contains(revision)) {
        while (connectedPos >= 0) {
            CommitInfo c = changes.get(connectedPos).commit();
            connected.add(c.commit());
            if (longRunning(--connectedPos)) {
                return true;
            }
            if (c.commit().equals(revision)) {
                break;
            }
        }
    }
    while (connectedPos >= 0) {
        CommitInfo c = changes.get(connectedPos).commit();
        for (int j = 0; j < c.parents().length(); j++) {
            if (connected.contains(c.parents().get(j).commit())) {
                connected.add(c.commit());
                break;
            }
        }
        if (longRunning(--connectedPos)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean computeConnected() {
    // the connections.
    if (!connected.contains(revision)) {
        while (connectedPos >= 0) {
            CommitInfo c = changes.get(connectedPos).commit();
            connected.add(c.commit());
            if (longRunning(--connectedPos)) {
                return true;
            }
            if (c.commit().equals(revision)) {
                break;
            }
        }
    }
    while (connectedPos >= 0) {
        CommitInfo c = changes.get(connectedPos).commit();
        for (int j = 0; j < c.parents().length(); j++) {
            if (connected.contains(c.parents().get(j).commit())) {
                connected.add(c.commit());
                break;
            }
        }
        if (longRunning(--connectedPos)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public boolean execute() {
    if (navList != view) {
        return false;
    }
    boolean attachedNow = panel.isAttached();
    if (!attached && attachedNow) {
        // Remember that we have been attached at least once. If
        // later we find we aren't attached we should stop running.
        attached = true;
    } else if (attached && !attachedNow) {
        // Don't continue to render.
        return false;
    }
    start = System.currentTimeMillis();
    if (computeConnected()) {
        return true;
    }
    int select = 0;
    while (row < changes.length()) {
        ChangeAndCommit info = changes.get(row);
        String commit = info.commit().commit();
        rows.add(new RowSafeHtml(info, connected != null && !connected.contains(commit)));
        if (revision.equals(commit)) {
            select = row;
        }
        if (longRunning(++row)) {
            return true;
        }
    }
    navList.rows = rows;
    navList.movePointerTo(select);
    return false;
}
#method_after
public boolean execute() {
    if (navList != view || !panel.isAttached()) {
        // Don't continue to render.
        return false;
    }
    start = System.currentTimeMillis();
    if (connected != null && computeConnected()) {
        return true;
    }
    int select = 0;
    while (row < changes.length()) {
        ChangeAndCommit info = changes.get(row);
        String commit = info.commit().commit();
        rows.add(new RowSafeHtml(info, connected != null && !connected.contains(commit)));
        if (revision.equals(commit)) {
            select = row;
        }
        if (longRunning(++row)) {
            return true;
        }
    }
    navList.rows = rows;
    navList.movePointerTo(select, true);
    return false;
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openSpan().addStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN + "(event,\"" + url.substring(1) + "\")");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && (!info.has_change_number() || !info.has_revision_number())) {
        sb.addStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        sb.append('\u25CF');
    } else if (connected) {
        sb.addStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.has_current_revision_number() && info.has_revision_number() && info._current_revision_number() != info._revision_number()) {
        sb.addStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        sb.append('\u25CF');
    } else {
        sb.addStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && (!info.has_change_number() || !info.has_revision_number())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.has_current_revision_number() && info.has_revision_number() && info._current_revision_number() != info._revision_number()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        sb.append('\u25CF');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
private void ensureRowMeasurements() {
    if (rowHeight == 0) {
        SafeHtmlBuilder sb = new SafeHtmlBuilder();
        renderRow(sb, 0);
        surrogate.setInnerSafeHtml(sb);
        getContainerElement().appendChild(surrogate);
        rowHeight = surrogate.getOffsetHeight();
        rowWidth = surrogate.getOffsetWidth();
        getContainerElement().removeChild(surrogate);
        getContainerElement().getStyle().setHeight(rowHeight * rows.size(), Style.Unit.PX);
    }
}
#method_after
private void ensureRowMeasurements() {
    if (rowHeight == 0) {
        surrogate.setInnerSafeHtml(rows.get(0));
        getContainerElement().appendChild(surrogate);
        rowHeight = surrogate.getOffsetHeight();
        rowWidth = surrogate.getOffsetWidth();
        getContainerElement().removeChild(surrogate);
        getContainerElement().getStyle().setHeight(rowHeight * rows.size(), Style.Unit.PX);
    }
}
#end_block

#method_before
public void movePointerTo(int row) {
    int lastSelectedRow = selectedRow;
    selectedRow = row;
    if (rows != null) {
        ensureRowMeasurements();
        // Position the selected row in the middle.
        int pos = Math.max(rowHeight * selectedRow - maxHeight / 2, 0);
        setVerticalScrollPosition(pos);
        render(lastSelectedRow);
        render(selectedRow);
        render();
    }
}
#method_after
public void movePointerTo(int row, boolean scroll) {
    if (rows != null && 0 <= row && row < rows.size()) {
        renderSelected(selectedRow, false);
        selectedRow = row;
        if (scroll) {
            // Position the selected row in the middle.
            ensureRowMeasurements();
            int pos = Math.max(rowHeight * selectedRow - maxHeight / 2, 0);
            setVerticalScrollPosition(pos);
            render();
        }
        renderSelected(selectedRow, true);
    }
}
#end_block

#method_before
private void render() {
    if (rows == null) {
        return;
    }
    int currChildren = body.getChildCount();
    int vpos = getVerticalScrollPosition();
    if (currChildren > 0 && top <= vpos && vpos <= bottom) {
        return;
    }
    int currStart = startRow;
    int currEnd = startRow + currChildren;
    ensureRowMeasurements();
    int page = maxHeight / rowHeight;
    int start = Math.max(vpos / rowHeight - 5, 0);
    int end = Math.min(vpos / rowHeight + page + 5, rows.size());
    if (end <= currStart) {
        renderRange(start, end, true, true);
    } else if (start < currStart) {
        renderRange(start, currStart, false, true);
    } else if (start >= currEnd) {
        renderRange(start, end, true, false);
    } else if (end > currEnd) {
        renderRange(currEnd, end, false, false);
    }
    if (currEnd == 0) {
        // Account for the scroll bars
        int width = body.getOffsetWidth();
        if (rowWidth > width) {
            int w = 2 * rowWidth - width;
            setWidth(w + "px");
        }
        body.getStyle().clearVisibility();
    }
}
#method_after
private void render() {
    if (rows == null) {
        return;
    }
    int currChildren = body.getChildCount();
    int vpos = getVerticalScrollPosition();
    if (currChildren > 0 && top <= vpos && vpos <= bottom) {
        return;
    }
    int currStart = startRow;
    int currEnd = startRow + currChildren;
    ensureRowMeasurements();
    int page = maxHeight / rowHeight;
    int start = Math.max(vpos / rowHeight - 5, 0);
    int end = Math.min(vpos / rowHeight + page + 5, rows.size());
    if (end <= currStart) {
        renderRange(start, end, true, true);
    } else if (start < currStart) {
        renderRange(start, currStart, false, true);
    } else if (start >= currEnd) {
        renderRange(start, end, true, false);
    } else if (end > currEnd) {
        renderRange(currEnd, end, false, false);
    }
    renderSelected(selectedRow, true);
    if (currEnd == 0) {
        // Account for the scroll bars
        int width = body.getOffsetWidth();
        if (rowWidth > width) {
            int w = 2 * rowWidth - width;
            setWidth(w + "px");
        }
        body.getStyle().clearVisibility();
    }
}
#end_block

#method_before
private void renderRange(int start, int end, boolean removeAll, boolean insertFirst) {
    if (insertFirst || removeAll) {
        startRow = start;
        top = start * rowHeight;
    }
    if (!insertFirst || removeAll) {
        bottom = (end - 2) * rowHeight - maxHeight;
    }
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    for (int i = start; i < end; i++) {
        renderRow(sb, i);
    }
    if (removeAll) {
        body.setInnerSafeHtml(sb);
        body.getStyle().setTop(top, Style.Unit.PX);
    } else {
        surrogate.setInnerSafeHtml(sb);
        for (int cnt = surrogate.getChildCount(); cnt > 0; cnt--) {
            fragment.appendChild(surrogate.getFirstChild());
        }
        if (insertFirst) {
            body.insertFirst(fragment);
            body.getStyle().setTop(top, Style.Unit.PX);
        } else {
            body.appendChild(fragment);
        }
    }
}
#method_after
private void renderRange(int start, int end, boolean removeAll, boolean insertFirst) {
    if (insertFirst || removeAll) {
        startRow = start;
        top = start * rowHeight;
    }
    if (!insertFirst || removeAll) {
        bottom = (end - 2) * rowHeight - maxHeight;
    }
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    for (int i = start; i < end; i++) {
        sb.append(rows.get(i));
    }
    if (removeAll) {
        body.setInnerSafeHtml(sb);
        body.getStyle().setTop(top, Style.Unit.PX);
    } else {
        surrogate.setInnerSafeHtml(sb);
        for (int cnt = surrogate.getChildCount(); cnt > 0; cnt--) {
            fragment.appendChild(surrogate.getFirstChild());
        }
        if (insertFirst) {
            body.insertFirst(fragment);
            body.getStyle().setTop(top, Style.Unit.PX);
        } else {
            body.appendChild(fragment);
        }
    }
}
#end_block

#method_before
@Override
public void onClick(ClickEvent event) {
    Integer row = getRow(event.getNativeEvent().<Element>cast());
    if (row != null) {
        movePointerTo(row);
        event.stopPropagation();
    }
}
#method_after
@Override
public void onClick(ClickEvent event) {
    Element row = getRow(event.getNativeEvent().getEventTarget().<Element>cast());
    if (row != null) {
        movePointerTo(startRow + DOM.getChildIndex(body, row), false);
        event.stopPropagation();
    }
}
#end_block

#method_before
@Override
public void onDoubleClick(DoubleClickEvent event) {
    Integer row = getRow(event.getNativeEvent().<Element>cast());
    if (row != null) {
        movePointerTo(row);
        onOpenRow(row);
        event.stopPropagation();
    }
}
#method_after
@Override
public void onDoubleClick(DoubleClickEvent event) {
    Element row = getRow(event.getNativeEvent().getEventTarget().<Element>cast());
    if (row != null) {
        movePointerTo(startRow + DOM.getChildIndex(body, row), false);
        onOpenRow(row);
        event.stopPropagation();
    }
}
#end_block

#method_before
private Integer getRow(Element e) {
    while (e != null) {
        Element next = DOM.getParent(e);
        if (body == next) {
            try {
                return Integer.parseInt(e.getAttribute("gerritrow"));
            } catch (NumberFormatException ex) {
                return null;
            }
        }
        e = next;
    }
    return null;
}
#method_after
private Element getRow(Element e) {
    for (Element prev = e; e != null; prev = e) {
        if ((e = DOM.getParent(e)) == body) {
            return prev;
        }
    }
    return null;
}
#end_block

#method_before
private Integer getRow(Element e) {
    while (e != null) {
        Element next = DOM.getParent(e);
        if (body == next) {
            try {
                return Integer.parseInt(e.getAttribute("gerritrow"));
            } catch (NumberFormatException ex) {
                return null;
            }
        }
        e = next;
    }
    return null;
}
#method_after
private Element getRow(int row) {
    if (startRow <= row && row < startRow + body.getChildCount()) {
        return body.getChild(row - startRow).cast();
    }
    return null;
}
#end_block

#method_before
private void onOpenRow(int row) {
    if (!(rows != null && 0 <= row && row < rows.size())) {
        return;
    }
    // Find the first HREF of the anchor of the select row (if any)
    surrogate.setInnerSafeHtml(rows.get(row));
    getContainerElement().appendChild(surrogate);
    NodeList<com.google.gwt.dom.client.Element> nodes = surrogate.getElementsByTagName("a");
    for (int i = 0; i < nodes.getLength(); i++) {
        AnchorElement anchor = nodes.getItem(i).cast();
        String url = anchor.getHref();
        if (url != null && !url.isEmpty()) {
            if (url.startsWith("#")) {
                Gerrit.display(url.substring(1));
            } else {
                Window.Location.assign(url);
            }
            break;
        }
    }
    getContainerElement().removeChild(surrogate);
}
#method_after
private void onOpenRow(Element row) {
    // Find the first HREF of the anchor of the select row (if any)
    if (row != null) {
        NodeList<com.google.gwt.dom.client.Element> nodes = row.getElementsByTagName(AnchorElement.TAG);
        for (int i = 0; i < nodes.getLength(); i++) {
            String url = nodes.getItem(i).getAttribute("href");
            if (!url.isEmpty()) {
                if (url.startsWith("#")) {
                    Gerrit.display(url.substring(1));
                } else {
                    Window.Location.assign(url);
                }
                break;
            }
        }
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    String sub = commit.subject();
    String msg = commit.message();
    if (msg.startsWith(sub)) {
        msg = msg.substring(sub.length());
        if (msg.length() > 0 && msg.charAt(0) == '\n') {
            msg = msg.substring(1);
        }
    }
    commitName.setText("Commit-Id: " + revision);
    commitName.setPreviewText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(msg).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    String sub = commit.subject();
    String msg = commit.message();
    if (msg.startsWith(sub)) {
        msg = msg.substring(sub.length());
        if (msg.length() > 0 && msg.charAt(0) == '\n') {
            msg = msg.substring(1);
        }
    }
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(msg).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#end_block

#method_before
private static ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return new ChangeData(new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = new ChangeData(change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#method_after
private ChangeData toChangeData(Document doc) {
    BytesRef cb = doc.getBinaryValue(CHANGE_FIELD);
    if (cb == null) {
        int id = doc.getField(ID_FIELD).numericValue().intValue();
        return changeDataFactory.create(db.get(), new Change.Id(id));
    }
    Change change = ChangeProtoField.CODEC.decode(cb.bytes, cb.offset, cb.length);
    ChangeData cd = changeDataFactory.create(db.get(), change);
    BytesRef[] approvalsBytes = doc.getBinaryValues(APPROVAL_FIELD);
    if (approvalsBytes != null) {
        List<PatchSetApproval> approvals = Lists.newArrayListWithCapacity(approvalsBytes.length);
        for (BytesRef ab : approvalsBytes) {
            approvals.add(PatchSetApprovalProtoField.CODEC.decode(ab.bytes, ab.offset, ab.length));
        }
        cd.setCurrentApprovals(approvals);
    }
    return cd;
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    NIOFSDirectory directory = new NIOFSDirectory(tmpdir);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    zipDir(tmpdir, "", zip);
    zip.close();
}
#end_block

#method_before
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        if (initStep instanceof PostInitStep) {
            ((PostInitStep) initStep).postRun();
        }
    }
}
#method_after
private void postInitPlugins() throws Exception {
    for (InitStep initStep : pluginLoader.getInitSteps()) {
        initStep.postRun();
    }
}
#end_block

#method_before
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (!(step instanceof PostInitStep)) {
            continue;
        }
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        ((PostInitStep) step).postRun();
    }
}
#method_after
public void postRun() throws Exception {
    for (InitStep step : steps) {
        if (step instanceof InitPlugins && flags.skipPlugins) {
            continue;
        }
        step.postRun();
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    try {
        ProjectResource projectResource = new ProjectResource(project);
        CreateBranch.Input input = new CreateBranch.Input();
        input.ref = ref;
        input.revision = revision;
        createBranchFactory.create(ref).apply(projectResource, input);
    } catch (IOException e) {
        throw new RestApiException("Cannot create branch", e);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    try {
        BranchInput in = new BranchInput();
        in.revision = revision;
        gApi.projects().name(project.getProject().getNameKey().get()).branch(name).create(in);
    } catch (RestApiException e) {
        throw new UnloggedFailure(1, "fatal: " + e.getMessage(), e);
    }
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugUrl = getConfig().getReportBugUrl();
    final String reportBugTitle = getConfig().getReportBugText();
    if (reportBugUrl != null) {
        Anchor a = new Anchor(reportBugTitle == null ? C.reportBug() : reportBugTitle, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    if (Strings.isNullOrEmpty(config.getReportBugText())) {
        config.setReportBugText(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setNewFeatures(cfg.getBoolean("gerrit", "enableNewFeatures", true));
    final String reportBugUrl = cfg.getString("gerrit", null, "reportBugUrl");
    config.setReportBugUrl(reportBugUrl != null ? reportBugUrl : "http://code.google.com/p/gerrit/issues/list");
    config.setReportBugText(cfg.getString("gerrit", null, "reportBugText"));
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
public void setReportBugText(String u) {
    reportBugText = u;
}
#method_after
public void setReportBugText(String t) {
    reportBugText = t;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    final PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#method_after
@SuppressWarnings("deprecation")
private final PGPEncryptedDataGenerator cpk() throws NoSuchProviderException, PGPException {
    PGPEncryptedDataGenerator cpk = new PGPEncryptedDataGenerator(PGPEncryptedData.CAST5, true, prng, "BC");
    cpk.addMethod(dest);
    return cpk;
}
#end_block

#method_before
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginsName, "association", ItsAssociationPolicy.OPTIONAL);
}
#method_after
private ItsAssociationPolicy getItsAssociationPolicy() {
    return gerritConfig.getEnum("commentLink", pluginName, "association", ItsAssociationPolicy.OPTIONAL);
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + "/plugins/";
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, base + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#method_after
@Override
public void service(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    List<String> parts = Lists.newArrayList(Splitter.on('/').limit(3).omitEmptyStrings().split(Strings.nullToEmpty(req.getPathInfo())));
    if (isApiCall(req, parts)) {
        managerApi.service(req, res);
        return;
    }
    String name = parts.get(0);
    final PluginHolder holder = plugins.get(name);
    if (holder == null) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    WrappedRequest wr = new WrappedRequest(req, (isAuthorizedCall(req) ? authorizedBase : base) + name);
    FilterChain chain = new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException {
            onDefault(holder, (HttpServletRequest) req, (HttpServletResponse) res);
        }
    };
    if (holder.filter != null) {
        holder.filter.doFilter(wr, res, chain);
    } else {
        chain.doFilter(wr, res);
    }
}
#end_block

#method_before
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar == null) {
            String jsFileName = file.replaceFirst("static/", "");
            sendJsPlugin(jsFileName, key, req, res);
        } else {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void onDefault(PluginHolder holder, HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!"GET".equals(req.getMethod()) && !"HEAD".equals(req.getMethod())) {
        CacheHeaders.setNotCacheable(res);
        res.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED);
        return;
    }
    String uri = req.getRequestURI();
    String ctx = req.getContextPath();
    if (uri.length() <= ctx.length()) {
        Resource.NOT_FOUND.send(req, res);
        return;
    }
    String file = uri.substring(ctx.length() + 1);
    ResourceKey key = new ResourceKey(holder.plugin, file);
    Resource rsc = resourceCache.getIfPresent(key);
    if (rsc != null) {
        rsc.send(req, res);
        return;
    }
    if ("".equals(file)) {
        res.sendRedirect(uri + holder.docPrefix + "index.html");
        return;
    }
    if (file.startsWith(holder.staticPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        if (jar != null) {
            JarEntry entry = jar.getJarEntry(file);
            if (exists(entry)) {
                sendResource(jar, entry, key, res);
            } else {
                resourceCache.put(key, Resource.NOT_FOUND);
                Resource.NOT_FOUND.send(req, res);
            }
        } else {
            sendJsPlugin(holder.plugin, key, req, res);
        }
    } else if (file.equals(holder.docPrefix.substring(0, holder.docPrefix.length() - 1))) {
        res.sendRedirect(uri + "/index.html");
    } else if (file.startsWith(holder.docPrefix) && file.endsWith("/")) {
        res.sendRedirect(uri + "index.html");
    } else if (file.startsWith(holder.docPrefix)) {
        JarFile jar = holder.plugin.getJarFile();
        JarEntry entry = jar.getJarEntry(file);
        if (!exists(entry)) {
            entry = findSource(jar, file);
        }
        if (!exists(entry) && file.endsWith("/index.html")) {
            String pfx = file.substring(0, file.length() - "index.html".length());
            sendAutoIndex(jar, pfx, holder.plugin.getName(), key, res);
        } else if (exists(entry) && entry.getName().endsWith(".md")) {
            sendMarkdownAsHtml(jar, entry, holder.plugin.getName(), key, res);
        } else if (exists(entry)) {
            sendResource(jar, entry, key, res);
        } else {
            resourceCache.put(key, Resource.NOT_FOUND);
            Resource.NOT_FOUND.send(req, res);
        }
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            if (name.substring(prefix.length()).startsWith("cmd-")) {
                cmds.add(entry);
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (!docs.isEmpty()) {
        md.append("## Documentation ##\n");
        for (JarEntry entry : docs) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(0, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(0, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    if (!cmds.isEmpty()) {
        md.append("## Commands ##\n");
        for (JarEntry entry : cmds) {
            String rsrc = entry.getName().substring(prefix.length());
            String title;
            if (rsrc.endsWith(".html")) {
                title = rsrc.substring(4, rsrc.length() - 5).replace('-', ' ');
            } else if (rsrc.endsWith(".md")) {
                title = extractTitleFromMarkdown(jar, entry);
                if (Strings.isNullOrEmpty(title)) {
                    title = rsrc.substring(4, rsrc.length() - 3).replace('-', ' ');
                }
                rsrc = rsrc.substring(0, rsrc.length() - 3) + ".html";
            } else {
                title = rsrc.substring(4).replace('-', ' ');
            }
            md.append(String.format("* [%s](%s)\n", title, rsrc));
        }
        md.append("\n");
    }
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#method_after
private void sendAutoIndex(JarFile jar, String prefix, String pluginName, ResourceKey cacheKey, HttpServletResponse res) throws IOException {
    List<JarEntry> cmds = Lists.newArrayList();
    List<JarEntry> servlets = Lists.newArrayList();
    List<JarEntry> restApis = Lists.newArrayList();
    List<JarEntry> docs = Lists.newArrayList();
    JarEntry about = null;
    Enumeration<JarEntry> entries = jar.entries();
    while (entries.hasMoreElements()) {
        JarEntry entry = entries.nextElement();
        String name = entry.getName();
        long size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && 0 < size && size <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    Collections.sort(docs, new Comparator<JarEntry>() {

        @Override
        public int compare(JarEntry a, JarEntry b) {
            return a.getName().compareTo(b.getName());
        }
    });
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, jar.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(jar.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(jar, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(jar, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(jar, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(jar, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res);
}
#end_block

#method_before
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        InputStream in = jar.getInputStream(entry);
        writeToResponse(res, in);
    }
}
#method_after
private void sendResource(JarFile jar, JarEntry entry, ResourceKey key, HttpServletResponse res) throws IOException {
    byte[] data = null;
    if (entry.getSize() <= SMALL_RESOURCE) {
        data = readWholeEntry(jar, entry);
    }
    String contentType = null;
    String charEnc = null;
    Attributes atts = entry.getAttributes();
    if (atts != null) {
        contentType = Strings.emptyToNull(atts.getValue("Content-Type"));
        charEnc = Strings.emptyToNull(atts.getValue("Character-Encoding"));
    }
    if (contentType == null) {
        contentType = mimeUtil.getMimeType(entry.getName(), data).toString();
        if ("application/octet-stream".equals(contentType) && entry.getName().endsWith(".js")) {
            contentType = "application/javascript";
        }
    }
    long time = entry.getTime();
    if (0 < time) {
        res.setDateHeader("Last-Modified", time);
    }
    res.setHeader("Content-Length", Long.toString(entry.getSize()));
    res.setContentType(contentType);
    if (charEnc != null) {
        res.setCharacterEncoding(charEnc);
    }
    if (data != null) {
        resourceCache.put(key, new SmallResource(data).setContentType(contentType).setCharacterEncoding(charEnc).setLastModified(time));
        res.getOutputStream().write(data);
    } else {
        writeToResponse(res, jar.getInputStream(entry));
    }
}
#end_block

#method_before
private void sendJsPlugin(String jsFileName, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File jsFile = new File(pluginsDir, jsFileName);
    if (jsFile.exists()) {
        res.setHeader("Content-Length", Long.toString(jsFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(jsFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#method_after
private void sendJsPlugin(Plugin plugin, ResourceKey key, HttpServletRequest req, HttpServletResponse res) throws IOException {
    File pluginFile = plugin.getSrcFile();
    if (req.getPathInfo().equals(getJsPluginPath(plugin)) && pluginFile.exists()) {
        res.setHeader("Content-Length", Long.toString(pluginFile.length()));
        res.setContentType("application/javascript");
        writeToResponse(res, new FileInputStream(pluginFile));
    } else {
        resourceCache.put(key, Resource.NOT_FOUND);
        Resource.NOT_FOUND.send(req, res);
    }
}
#end_block

#method_before
@Override
public String getServletPath() {
    return ((HttpServletRequest) getRequest()).getRequestURI().substring(contextPath.length());
}
#method_after
@Override
public String getServletPath() {
    return getRequestURI().substring(contextPath.length());
}
#end_block

#method_before
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.add(httpInjector);
    manager.start();
}
#method_after
@Override
public void start(PluginGuiceEnvironment env) throws Exception {
    manager = new LifecycleManager();
    String fileName = getSrcFile().getName();
    httpInjector = Guice.createInjector(new StandaloneJsPluginModule(getName(), fileName));
    manager.start();
}
#end_block

#method_before
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
    }
}
#method_after
@Override
void stop(PluginGuiceEnvironment env) {
    if (manager != null) {
        manager.stop();
        httpInjector = null;
    }
}
#end_block

#method_before
@Override
boolean canReload() {
    return false;
}
#method_after
@Override
boolean canReload() {
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    bind(WebUiPlugin.class).annotatedWith(UniqueAnnotations.create()).toInstance(new JavaScriptPlugin(fileName));
}
#method_after
@Override
protected void configure() {
    bind(String.class).annotatedWith(PluginName.class).toInstance(pluginName);
    DynamicSet.bind(binder(), WebUiPlugin.class).toInstance(new JavaScriptPlugin(fileName));
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!(name.endsWith(".jar") || name.endsWith(".js"))) {
        throw new ParserInitializationException("Can only install files with '.jar' and '.js' extension");
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", name));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!(fileName.endsWith(".jar") || fileName.endsWith(".js"))) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    String fileExtension = getExtension(fileName);
    File dst = new File(pluginsDir, name + fileExtension);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#method_after
public static File storeInTemp(String pluginName, InputStream in, SitePaths sitePaths) throws IOException {
    if (!sitePaths.tmp_dir.exists()) {
        sitePaths.tmp_dir.mkdirs();
    }
    return asTemp(in, tempNameFor(pluginName), ".jar", sitePaths.tmp_dir);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> plugins = scanJarsInPluginsDirectory();
    stopRemovedPlugins(plugins);
    dropRemovedDisabledPlugins(plugins);
    for (File plugin : plugins) {
        if (plugin.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(plugin);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(plugin)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(plugin)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, plugin, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", name));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (Map.Entry<String, File> entry : activePlugins.entrySet()) {
        String name = entry.getKey();
        File jar = entry.getValue();
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        cleanupHandle.cleanup();
    }
    return toCleanup.size();
}
#method_after
synchronized int processPendingCleanups() {
    Iterator<Plugin> iterator = toCleanup.iterator();
    while (iterator.hasNext()) {
        Plugin plugin = iterator.next();
        iterator.remove();
        CleanupHandle cleanupHandle = cleanupHandles.remove(plugin);
        if (cleanupHandle != null) {
            cleanupHandle.cleanup();
        }
    }
    return toCleanup.size();
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
public static String nameOf(File plugin) {
    return nameOf(plugin.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(File file) {
    return getExtension(file.getName());
}
#end_block

#method_before
private static String getExtension(File file) {
    String name = file.getName();
    int ext = name.lastIndexOf(".");
    return 0 < ext ? name.substring(ext, name.length()) : "";
}
#method_after
private static String getExtension(String name) {
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(ext) : "";
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcPlugin);
    String extension = getExtension(srcPlugin);
    try {
        tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
    } finally {
        in.close();
    }
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new RuntimeException("Unsupported plugin type");
    }
}
#method_after
private Plugin loadPlugin(String name, File srcPlugin, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    String pluginName = srcPlugin.getName();
    if (isJarPlugin(pluginName)) {
        File tmp;
        FileInputStream in = new FileInputStream(srcPlugin);
        String extension = getExtension(srcPlugin);
        try {
            tmp = asTemp(in, tempNameFor(name), extension, tmpDir);
        } finally {
            in.close();
        }
        return loadJarPlugin(name, srcPlugin, snapshot, tmp);
    } else if (isJsPlugin(pluginName)) {
        return loadJsPlugin(name, srcPlugin, snapshot);
    } else {
        throw new InvalidPluginException(String.format("Unsupported plugin type: ", srcPlugin.getName()));
    }
}
#end_block

#method_before
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadJarPlugin(String name, File srcJar, FileSnapshot snapshot, File tmp) throws IOException, InvalidPluginException, MalformedURLException, ClassNotFoundException {
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        List<URL> urls = new ArrayList<>(2);
        String overlay = System.getProperty("gerrit.plugin-classes");
        if (overlay != null) {
            File classes = new File(new File(new File(overlay), name), "main");
            if (classes.isDirectory()) {
                log.info(String.format("plugin %s: including %s", name, classes.getPath()));
                urls.add(classes.toURI().toURL());
            }
        }
        urls.add(tmp.toURI().toURL());
        ClassLoader pluginLoader = new URLClassLoader(urls.toArray(new URL[urls.size()]), parentFor(type));
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        String url = String.format("%s/plugins/%s/", CharMatcher.is('/').trimTrailingFrom(urlProvider.get()), name);
        Plugin plugin = new JarPlugin(name, url, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (isJarPlugin(n) || isJsPlugin(n)) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
private boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#method_after
private static boolean isJarPlugin(String name) {
    return isPlugin(name, "jar");
}
#end_block

#method_before
private boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#method_after
private static boolean isJsPlugin(String name) {
    return isPlugin(name, "js");
}
#end_block

#method_before
private boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#method_after
private static boolean isPlugin(String fileName, String ext) {
    String fullExt = "." + ext;
    return fileName.endsWith(fullExt) || fileName.endsWith(fullExt + ".disabled");
}
#end_block

#method_before
public <T extends TaskInfo> List<T> getTaskInfos(TaskInfo.Factory<T> factory) {
    final List<T> taskInfos = new ArrayList<T>();
    for (final Executor exe : queues) {
        for (final Task<?> task : exe.getTasks()) {
            T info = factory.getTaskInfo(task);
            taskInfos.add(info);
        }
    }
    return taskInfos;
}
#method_after
public <T> List<T> getTaskInfos(TaskInfoFactory<T> factory) {
    List<T> taskInfos = Lists.newArrayList();
    for (Executor exe : queues) {
        for (Task<?> task : exe.getTasks()) {
            taskInfos.add(factory.getTaskInfo(task));
        }
    }
    return taskInfos;
}
#end_block

#method_before
@Override
protected void run() {
    final List<QueueTaskInfo> pending = getSortedTaskInfoList();
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    stdout.print(// 
    String.format(// 
    "%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean viewAll = currentUser.getCapabilities().canViewQueue();
    for (final QueueTaskInfo taskInfo : pending) {
        final long delay = taskInfo.getDelay();
        final Task.State state = taskInfo.getTaskState();
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!viewAll) {
            projectName = taskInfo.getProjectNameKey();
            remoteName = taskInfo.getRemoteName();
            hasCustomizedPrint = taskInfo.hasCustomizedPrint();
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(currentUser).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (viewAll || (!hasCustomizedPrint && regularUserCanSee)) {
            stdout.print(String.format(// 
            "%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", taskInfo.getTaskString(taskNameWidth)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            stdout.print(// 
            String.format(// 
            "%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", remoteName));
        }
    }
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    if (viewAll) {
        numberOfPendingTasks = pending.size();
    }
    stdout.print("  " + numberOfPendingTasks + " tasks\n");
}
#method_after
@Override
protected void run() {
    taskNameWidth = wide ? Integer.MAX_VALUE : columns - 8 - 12 - 8 - 4;
    final List<QueueTaskInfo> pending = getSortedTaskInfoList();
    stdout.print(String.format("%-8s %-12s %-8s %s\n", "Task", "State", "", "Command"));
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    int numberOfPendingTasks = 0;
    final long now = System.currentTimeMillis();
    final boolean viewAll = currentUser.getCapabilities().canViewQueue();
    for (final QueueTaskInfo taskInfo : pending) {
        final long delay = taskInfo.delayMillis;
        final Task.State state = taskInfo.state;
        final String start;
        switch(state) {
            case DONE:
            case CANCELLED:
            case RUNNING:
            case READY:
                start = format(state);
                break;
            default:
                start = time(now, delay);
                break;
        }
        boolean regularUserCanSee = false;
        boolean hasCustomizedPrint = true;
        // If the user is not administrator, check if has rights to see
        // the Task
        Project.NameKey projectName = null;
        String remoteName = null;
        if (!viewAll) {
            projectName = taskInfo.getProjectNameKey();
            remoteName = taskInfo.getRemoteName();
            hasCustomizedPrint = taskInfo.hasCustomizedPrint();
            ProjectState e = null;
            if (projectName != null) {
                e = projectCache.get(projectName);
            }
            regularUserCanSee = e != null && e.controlFor(currentUser).isVisible();
            if (regularUserCanSee) {
                numberOfPendingTasks++;
            }
        }
        // Shows information about tasks depending on the user rights
        if (viewAll || (!hasCustomizedPrint && regularUserCanSee)) {
            stdout.print(String.format("%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", taskInfo.getTaskString(taskNameWidth)));
        } else if (regularUserCanSee) {
            if (remoteName == null) {
                remoteName = projectName.get();
            } else {
                remoteName = remoteName + "/" + projectName;
            }
            stdout.print(String.format("%8s %-12s %-8s %s\n", id(taskInfo.getTaskId()), start, "", remoteName));
        }
    }
    stdout.print("----------------------------------------------" + "--------------------------------\n");
    if (viewAll) {
        numberOfPendingTasks = pending.size();
    }
    stdout.print("  " + numberOfPendingTasks + " tasks\n");
}
#end_block

#method_before
private List<QueueTaskInfo> getSortedTaskInfoList() {
    final List<QueueTaskInfo> taskInfos = workQueue.getTaskInfos(new TaskInfo.Factory<QueueTaskInfo>() {

        @Override
        public QueueTaskInfo getTaskInfo(Task task) {
            return new QueueTaskInfo(task);
        }
    });
    Collections.sort(taskInfos, new Comparator<QueueTaskInfo>() {

        @Override
        public int compare(QueueTaskInfo aTaskInfo, QueueTaskInfo bTaskInfo) {
            final Task.State aState = aTaskInfo.getTaskState();
            final Task.State bState = bTaskInfo.getTaskState();
            if (aState != bState) {
                return aState.ordinal() - bState.ordinal();
            }
            final long aDelay = aTaskInfo.getDelay();
            final long bDelay = bTaskInfo.getDelay();
            if (aDelay < bDelay) {
                return -1;
            } else if (aDelay > bDelay) {
                return 1;
            }
            return aTaskInfo.getTaskString(taskNameWidth).compareTo(bTaskInfo.getTaskString(taskNameWidth));
        }
    });
    return taskInfos;
}
#method_after
private List<QueueTaskInfo> getSortedTaskInfoList() {
    final List<QueueTaskInfo> taskInfos = workQueue.getTaskInfos(new TaskInfoFactory<QueueTaskInfo>() {

        @Override
        public QueueTaskInfo getTaskInfo(Task<?> task) {
            return new QueueTaskInfo(task);
        }
    });
    Collections.sort(taskInfos, new Comparator<QueueTaskInfo>() {

        @Override
        public int compare(QueueTaskInfo a, QueueTaskInfo b) {
            if (a.state != b.state) {
                return a.state.ordinal() - b.state.ordinal();
            }
            int cmp = Long.signum(a.delayMillis - b.delayMillis);
            if (cmp != 0) {
                return cmp;
            }
            return a.getTaskString(taskNameWidth).compareTo(b.getTaskString(taskNameWidth));
        }
    });
    return taskInfos;
}
#end_block

#method_before
public String getRemoteName() {
    if (task instanceof ProjectTask) {
        return ((ProjectTask<?>) task).getRemoteName();
    } else {
        return null;
    }
}
#method_after
String getRemoteName() {
    if (task instanceof ProjectTask) {
        return ((ProjectTask<?>) task).getRemoteName();
    }
    return null;
}
#end_block

#method_before
public NameKey getProjectNameKey() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).getProjectNameKey();
    } else {
        return null;
    }
}
#method_after
Project.NameKey getProjectNameKey() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).getProjectNameKey();
    }
    return null;
}
#end_block

#method_before
public boolean hasCustomizedPrint() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).hasCustomizedPrint();
    } else {
        return false;
    }
}
#method_after
boolean hasCustomizedPrint() {
    if (task instanceof ProjectTask<?>) {
        return ((ProjectTask<?>) task).hasCustomizedPrint();
    }
    return false;
}
#end_block

#method_before
public int getTaskId() {
    return task.getTaskId();
}
#method_after
int getTaskId() {
    return task.getTaskId();
}
#end_block

#method_before
public String getTaskString(int maxLength) {
    String s = task.toString();
    if (s.length() < maxLength) {
        return s;
    } else {
        return s.substring(0, maxLength);
    }
}
#method_after
String getTaskString(int maxLength) {
    String s = task.toString();
    return s.length() < maxLength ? s : s.substring(0, maxLength);
}
#end_block

#method_before
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    StringBuilder msg = new StringBuilder();
    msg.append("Remove the following approvals:\n\n");
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                msg.append("* ").append(a.getLabel()).append(" ").append(a.getValue()).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        db.commit();
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getChange().getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        db.changeMessages().insert(Collections.singleton(changeMessage));
    } finally {
        db.rollback();
    }
    indexer.index(rsrc.getChange());
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
                if (a.getValue() != 0) {
                    if (msg.length() == 0) {
                        msg.append("Removed the following approvals:\n\n");
                    }
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(rsrc.getChange().getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), rsrc.getChange().currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(rsrc.getChange());
    return Response.none();
}
#end_block

#method_before
private PatchSet parsePatchSet(final String patchIdentity) throws UnloggedFailure, OrmException {
    // 
    if (patchIdentity.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(patchIdentity);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        final Set<PatchSet> matches = new HashSet<PatchSet>();
        for (final PatchSet ps : patches) {
            final Change change = db.changes().get(ps.getId().getParentKey());
            if (inProject(change) && inBranch(change)) {
                matches.add(ps);
            }
        }
        switch(matches.size()) {
            case 1:
                return matches.iterator().next();
            case 0:
                throw error("\"" + patchIdentity + "\" no such patch set");
            default:
                throw error("\"" + patchIdentity + "\" matches multiple patch sets");
        }
    }
    // 
    if (patchIdentity.matches("^[1-9][0-9]*,[1-9][0-9]*$")) {
        final PatchSet.Id patchSetId;
        try {
            patchSetId = PatchSet.Id.parse(patchIdentity);
        } catch (IllegalArgumentException e) {
            throw error("\"" + patchIdentity + "\" is not a valid patch set");
        }
        final PatchSet patchSet = db.patchSets().get(patchSetId);
        if (patchSet == null) {
            throw error("\"" + patchIdentity + "\" no such patch set");
        }
        if (projectControl != null || branch != null) {
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (projectControl != null) {
                if (!inProject(change)) {
                    throw error("change " + change.getId() + " not in project " + projectControl.getProject().getName());
                }
            }
            if (branch != null) {
                if (!inBranch(change)) {
                    throw error("change " + change.getId() + " not in branch " + change.getDest().toString());
                }
            }
        }
        return patchSet;
    }
    throw error("\"" + patchIdentity + "\" is not a valid patch set");
}
#method_after
private PatchSet parsePatchSet(final String patchIdentity) throws UnloggedFailure, OrmException {
    // 
    if (patchIdentity.matches("^([0-9a-fA-F]{4," + RevId.LEN + "})$")) {
        final RevId id = new RevId(patchIdentity);
        final ResultSet<PatchSet> patches;
        if (id.isComplete()) {
            patches = db.patchSets().byRevision(id);
        } else {
            patches = db.patchSets().byRevisionRange(id, id.max());
        }
        final Set<PatchSet> matches = new HashSet<PatchSet>();
        for (final PatchSet ps : patches) {
            final Change change = db.changes().get(ps.getId().getParentKey());
            if (inProject(change) && inBranch(change)) {
                matches.add(ps);
            }
        }
        switch(matches.size()) {
            case 1:
                return matches.iterator().next();
            case 0:
                throw error("\"" + patchIdentity + "\" no such patch set");
            default:
                throw error("\"" + patchIdentity + "\" matches multiple patch sets");
        }
    }
    // 
    if (patchIdentity.matches("^[1-9][0-9]*,[1-9][0-9]*$")) {
        final PatchSet.Id patchSetId;
        try {
            patchSetId = PatchSet.Id.parse(patchIdentity);
        } catch (IllegalArgumentException e) {
            throw error("\"" + patchIdentity + "\" is not a valid patch set");
        }
        final PatchSet patchSet = db.patchSets().get(patchSetId);
        if (patchSet == null) {
            throw error("\"" + patchIdentity + "\" no such patch set");
        }
        if (projectControl != null || branch != null) {
            final Change change = db.changes().get(patchSetId.getParentKey());
            if (!inProject(change)) {
                throw error("change " + change.getId() + " not in project " + projectControl.getProject().getName());
            }
            if (!inBranch(change)) {
                throw error("change " + change.getId() + " not in branch " + change.getDest().get());
            }
        }
        return patchSet;
    }
    throw error("\"" + patchIdentity + "\" is not a valid patch set");
}
#end_block

#method_before
private boolean inBranch(final Change change) {
    if (branch == null) {
        return true;
    }
    return change.getDest().toString().equals(branch);
}
#method_after
private boolean inBranch(final Change change) {
    if (branch == null) {
        // No --branch option, so they want every branch.
        return true;
    }
    return change.getDest().get().equals(branch);
}
#end_block

#method_before
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
            }
            if (reader != null) {
                reader.release();
            }
        }
    } finally {
        repo.close();
    }
}
#method_after
private void save(PersonIdent ident, String msg) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#method_after
@Override
protected void configure() {
    bind(SitePaths.class);
    bind(InitFlags.class);
    bind(Libraries.class);
    bind(LibraryDownloader.class);
    factory(Section.Factory.class);
    // Steps are executed in the order listed here.
    // 
    step().to(UpgradeFrom2_0_x.class);
    step().to(InitGitManager.class);
    if (standalone) {
        step().to(InitDatabase.class);
    }
    step().to(InitIndex.class);
    step().to(InitAuth.class);
    step().to(InitLabels.class);
    step().to(InitSendEmail.class);
    if (standalone) {
        step().to(InitContainer.class);
    }
    step().to(InitSshd.class);
    step().to(InitHttpd.class);
    step().to(InitCache.class);
    if (standalone) {
        step().to(InitPlugins.class);
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    ui.header("Review Labels");
    boolean enabled = ui.yesno(false, "Install Verified label");
    Config cfg = allProjectsConfig.load();
    if (enabled) {
        cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
        cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
        allProjectsConfig.save("Review Label Initialization");
    }
}
#method_after
@Override
public void run() throws Exception {
    Config cfg = allProjectsConfig.load();
    if (!cfg.getSubsections(KEY_LABEL).contains(LABEL_VERIFIED)) {
        ui.header("Review Labels");
        boolean enabled = ui.yesno(false, "Install Verified label");
        if (enabled) {
            cfg.setString(KEY_LABEL, LABEL_VERIFIED, KEY_FUNCTION, "MaxWithBlock");
            cfg.setStringList(KEY_LABEL, LABEL_VERIFIED, KEY_VALUE, Arrays.asList(new String[] { "-1 Fails", " 0 No score", "+1 Verified" }));
            allProjectsConfig.save("Review Label Initialization");
        }
    }
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser().isIdentifiedUser()) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            return isOwner() || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#method_after
public List<PermissionRange> getLabelRanges(boolean isChangeOwner) {
    List<PermissionRange> r = new ArrayList<PermissionRange>();
    for (Map.Entry<String, List<PermissionRule>> e : relevant.getDeclaredPermissions()) {
        if (Permission.isLabel(e.getKey())) {
            int min = 0;
            int max = 0;
            for (PermissionRule rule : e.getValue()) {
                if (projectControl.match(rule, isChangeOwner)) {
                    min = Math.min(min, rule.getMin());
                    max = Math.max(max, rule.getMax());
                }
            }
            if (min != 0 || max != 0) {
                r.add(new PermissionRange(e.getKey(), min, max));
            }
        }
    }
    return r;
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    return getRange(permission, false);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission, boolean isChangeOwner) {
    if (Permission.hasRange(permission)) {
        return toRange(permission, access(permission, isChangeOwner));
    }
    return null;
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName) {
    return access(permissionName, false);
}
#end_block

#method_before
private List<PermissionRule> access(String permissionName) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0))) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#method_after
private List<PermissionRule> access(String permissionName, boolean isChangeOwner) {
    List<PermissionRule> rules = effective.get(permissionName);
    if (rules != null) {
        return rules;
    }
    rules = relevant.getPermission(permissionName);
    if (rules.isEmpty()) {
        effective.put(permissionName, rules);
        return rules;
    }
    if (rules.size() == 1) {
        if (!projectControl.match(rules.get(0), isChangeOwner)) {
            rules = Collections.emptyList();
        }
        effective.put(permissionName, rules);
        return rules;
    }
    List<PermissionRule> mine = new ArrayList<PermissionRule>(rules.size());
    for (PermissionRule rule : rules) {
        if (projectControl.match(rule, isChangeOwner)) {
            mine.add(rule);
        }
    }
    if (mine.isEmpty()) {
        mine = Collections.emptyList();
    }
    effective.put(permissionName, mine);
    return mine;
}
#end_block

#method_before
public ChangeControl validateFor(Change.Id id, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(id, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#end_block

#method_before
public LabelTypes getLabelTypes() {
    return getProjectControl().getLabelTypes();
}
#method_after
public LabelTypes getLabelTypes() {
    String destBranch = getChange().getDest().get();
    List<LabelType> all = getProjectControl().getLabelTypes().getLabelTypes();
    List<LabelType> r = Lists.newArrayListWithCapacity(all.size());
    for (LabelType l : all) {
        List<String> refs = l.getRefPatterns();
        if (refs == null) {
            r.add(l);
        } else {
            for (String refPattern : refs) {
                if (RefConfigSection.isValid(refPattern) && match(destBranch, refPattern)) {
                    r.add(l);
                    break;
                }
            }
        }
    }
    return new LabelTypes(r);
}
#end_block

#method_before
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges();
}
#method_after
public List<PermissionRange> getLabelRanges() {
    return getRefControl().getLabelRanges(isOwner());
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    List<PermissionRule> rules = getRefControl().getRules(permission);
    if (isOwner() && rulesContainGroup(rules, AccountGroup.CHANGE_OWNERS)) {
        return getRefControl().getLabelRange(permission);
    } else {
        return getRefControl().getRange(permission);
    }
}
#method_after
public PermissionRange getRange(String permission) {
    return getRefControl().getRange(permission, isOwner());
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord, e.getMessage());
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private void appliedBy(SubmitRecord.Label label, Term status) {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        }
    }
}
#method_after
private void appliedBy(SubmitRecord.Label label, Term status) throws UserTermExpected {
    if (status.isStructure() && status.arity() == 1) {
        Term who = status.arg(0);
        if (isUser(who)) {
            label.appliedBy = new Account.Id(((IntegerTerm) who.arg(0)).intValue());
        } else {
            throw new UserTermExpected(label);
        }
    }
}
#end_block

#method_before
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owners"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#method_after
@Test
public void systemGroupsCreated_ssh() throws JSchException, IOException {
    SshSession session = new SshSession(server, admin);
    String result = session.exec("gerrit ls-groups");
    assertTrue(result.contains("Administrators"));
    assertTrue(result.contains("Anonymous Users"));
    assertTrue(result.contains("Change Owner"));
    assertTrue(result.contains("Non-Interactive Users"));
    assertTrue(result.contains("Project Owners"));
    assertTrue(result.contains("Registered Users"));
    session.close();
}
#end_block

#method_before
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owners"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#method_after
@Test
public void systemGroupsCreated_rest() throws IOException {
    RestSession session = new RestSession(server, admin);
    RestResponse r = session.get("/groups/");
    Gson gson = new Gson();
    Map<String, GroupInfo> result = gson.fromJson(r.getReader(), new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
    Set<String> names = result.keySet();
    assertTrue(names.contains("Administrators"));
    assertTrue(names.contains("Anonymous Users"));
    assertTrue(names.contains("Change Owner"));
    assertTrue(names.contains("Non-Interactive Users"));
    assertTrue(names.contains("Project Owners"));
    assertTrue(names.contains("Registered Users"));
}
#end_block

#method_before
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owners"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#method_after
@Test
public void systemGroupsCreated_internals() throws OrmException {
    ReviewDb db = reviewDbProvider.open();
    try {
        Set<String> names = Sets.newHashSet();
        for (AccountGroup g : db.accountGroups().all()) {
            names.add(g.getName());
        }
        assertTrue(names.contains("Administrators"));
        assertTrue(names.contains("Anonymous Users"));
        assertTrue(names.contains("Change Owner"));
        assertTrue(names.contains("Non-Interactive Users"));
        assertTrue(names.contains("Project Owners"));
        assertTrue(names.contains("Registered Users"));
    } finally {
        db.close();
    }
}
#end_block

#method_before
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwners = newGroup(c, "Change Owners", AccountGroup.CHANGE_OWNERS);
    changeOwners.setDescription("The owners of a change");
    changeOwners.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwners)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#method_after
private SystemConfig initSystemConfig(final ReviewDb c) throws OrmException {
    admin = newGroup(c, "Administrators", null);
    admin.setDescription("Gerrit Site Administrators");
    admin.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(admin));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(admin)));
    anonymous = newGroup(c, "Anonymous Users", AccountGroup.ANONYMOUS_USERS);
    anonymous.setDescription("Any user, signed-in or not");
    anonymous.setOwnerGroupUUID(admin.getGroupUUID());
    anonymous.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(anonymous));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(anonymous)));
    registered = newGroup(c, "Registered Users", AccountGroup.REGISTERED_USERS);
    registered.setDescription("Any signed-in user");
    registered.setOwnerGroupUUID(admin.getGroupUUID());
    registered.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(registered));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(registered)));
    batch = newGroup(c, "Non-Interactive Users", null);
    batch.setDescription("Users who perform batch actions on Gerrit");
    batch.setOwnerGroupUUID(admin.getGroupUUID());
    batch.setType(AccountGroup.Type.INTERNAL);
    c.accountGroups().insert(Collections.singleton(batch));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(batch)));
    owners = newGroup(c, "Project Owners", AccountGroup.PROJECT_OWNERS);
    owners.setDescription("Any owner of the project");
    owners.setOwnerGroupUUID(admin.getGroupUUID());
    owners.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(owners));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(owners)));
    changeOwner = newGroup(c, "Change Owner", AccountGroup.CHANGE_OWNER);
    changeOwner.setDescription("The owner of a change");
    changeOwner.setOwnerGroupUUID(admin.getGroupUUID());
    changeOwner.setType(AccountGroup.Type.SYSTEM);
    c.accountGroups().insert(Collections.singleton(changeOwner));
    c.accountGroupNames().insert(Collections.singleton(new AccountGroupName(changeOwner)));
    final SystemConfig s = SystemConfig.create();
    try {
        s.sitePath = site_path.getCanonicalPath();
    } catch (IOException e) {
        s.sitePath = site_path.getAbsolutePath();
    }
    c.systemConfig().insert(Collections.singleton(s));
    return s;
}
#end_block

#method_before
public void save(String pluginName, String message) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                PersonIdent ident = new PersonIdent(pluginName, pluginName + "@gerrit");
                String msg = "Update from plugin " + pluginName + ": " + message;
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
            }
            if (reader != null) {
                reader.release();
            }
        }
    } finally {
        repo.close();
    }
}
#method_after
public void save(String pluginName, String message) throws IOException {
    Repository repo = new FileRepository(path);
    try {
        inserter = repo.newObjectInserter();
        reader = repo.newObjectReader();
        try {
            RevWalk rw = new RevWalk(reader);
            try {
                RevTree srcTree = revision != null ? rw.parseTree(revision) : null;
                newTree = readTree(srcTree);
                saveConfig(ProjectConfig.PROJECT_CONFIG, cfg);
                ObjectId res = newTree.writeTree(inserter);
                if (res.equals(srcTree)) {
                    // If there are no changes to the content, don't create the commit.
                    return;
                }
                PersonIdent ident = new PersonIdent(pluginName, pluginName + "@gerrit");
                String msg = "Update from plugin " + pluginName + ": " + message;
                CommitBuilder commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(msg);
                commit.setTreeId(res);
                if (revision != null) {
                    commit.addParentId(revision);
                }
                ObjectId newRevision = inserter.insert(commit);
                updateRef(repo, ident, newRevision, "commit: " + msg);
                revision = newRevision;
            } finally {
                rw.release();
            }
        } finally {
            if (inserter != null) {
                inserter.release();
                inserter = null;
            }
            if (reader != null) {
                reader.release();
                reader = null;
            }
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    bind(Commands.key(parent, meta.name(), description(meta))).to(clazz);
}
#method_after
protected void command(final CommandName parent, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    bind(Commands.key(parent, meta.name(), meta.description())).to(clazz);
}
#end_block

#method_before
protected void alias(final CommandName parent, final String name, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    bind(Commands.key(parent, name, description(meta))).to(clazz);
}
#method_after
protected void alias(final CommandName parent, final String name, final Class<? extends BaseCommand> clazz) {
    CommandMetaData meta = clazz.getAnnotation(CommandMetaData.class);
    if (meta == null) {
        throw new IllegalStateException("no CommandMetaData annotation found");
    }
    bind(Commands.key(parent, name, meta.description())).to(clazz);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    save();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    save(null);
}
#end_block

#method_before
void save() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
void save(CallbackGroup group) {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            parent.updateUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, group == null ? cb : group.add(cb));
    } else {
        CommentApi.updateDraft(psId, original.id(), input, group == null ? cb : group.add(cb));
    }
    getCm().focus();
}
#end_block

#method_before
@UiHandler("editArea")
void onKeyDown(KeyDownEvent e) {
    if ((e.isControlKeyDown() || e.isMetaKeyDown()) && !e.isAltKeyDown() && !e.isShiftKeyDown()) {
        switch(e.getNativeKeyCode()) {
            case 's':
            case 'S':
                e.preventDefault();
                save();
                return;
        }
    } else if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE && !isDirty()) {
        if (isNew()) {
            removeUI();
            return;
        } else {
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCm().focus();
            return;
        }
    }
    expandTimer.schedule(250);
}
#method_after
@UiHandler("editArea")
void onKeyDown(KeyDownEvent e) {
    if ((e.isControlKeyDown() || e.isMetaKeyDown()) && !e.isAltKeyDown() && !e.isShiftKeyDown()) {
        switch(e.getNativeKeyCode()) {
            case 's':
            case 'S':
                e.preventDefault();
                save(null);
                return;
        }
    } else if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE && !isDirty()) {
        if (isNew()) {
            removeUI();
            return;
        } else {
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCm().focus();
            return;
        }
    }
    expandTimer.schedule(250);
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    saveAllDrafts();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    saveAllDrafts(null);
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
void updateUnsaved(DraftBox box, boolean isEdit) {
    if (isEdit) {
        unsaved.add(box);
    } else {
        unsaved.remove(box);
    }
}
#method_after
void updateUnsaved(DraftBox box, boolean isUnsaved) {
    if (isUnsaved) {
        unsaved.add(box);
    } else {
        unsaved.remove(box);
    }
}
#end_block

#method_before
private void saveAllDrafts() {
    for (DraftBox box : unsaved) {
        box.save();
    }
    unsaved.clear();
}
#method_after
private void saveAllDrafts(CallbackGroup cb) {
    for (DraftBox box : unsaved) {
        box.save(cb);
    }
}
#end_block

#method_before
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            saveAllDrafts();
            String b = base != null ? String.valueOf(base.get()) : null;
            String rev = String.valueOf(revision.get());
            Gerrit.display(PageLinks.toChange(changeId, rev), new ChangeScreen2(changeId, b, rev, openReplyBox));
        }
    };
}
#method_after
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            if (unsaved.isEmpty()) {
                goUpToChange(openReplyBox);
            } else {
                CallbackGroup group = new CallbackGroup();
                saveAllDrafts(group);
                group.addFinal(new GerritCallback<Void>() {

                    @Override
                    public void onSuccess(Void result) {
                        goUpToChange(openReplyBox);
                    }
                }).onSuccess(null);
            }
        }
    };
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    });
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(!Gerrit.getConfig().testChangeDisableSubmit() || changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled();
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (canSubmit) {
                if (status == Change.Status.NEW) {
                    statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
            }
            setVisible(notMergeable, !changeInfo.mergeable());
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setTestChangeMerge(cfg.getBoolean("changeMerge", "test", false));
    config.setTestChangeDisableSubmit(cfg.getBoolean("changeMerge", "disableSubmit", true));
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#method_after
private GerritConfig create() throws MalformedURLException {
    final GerritConfig config = new GerritConfig();
    switch(authConfig.getAuthType()) {
        case LDAP:
        case LDAP_BIND:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            break;
        case CUSTOM_EXTENSION:
            config.setRegisterUrl(cfg.getString("auth", null, "registerurl"));
            config.setRegisterText(cfg.getString("auth", null, "registertext"));
            config.setEditFullNameUrl(cfg.getString("auth", null, "editFullNameUrl"));
            config.setHttpPasswordUrl(cfg.getString("auth", null, "httpPasswordUrl"));
            break;
        case HTTP:
        case HTTP_LDAP:
            config.setLoginUrl(cfg.getString("auth", null, "loginurl"));
            config.setLoginText(cfg.getString("auth", null, "logintext"));
            break;
        case CLIENT_SSL_CERT_LDAP:
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
        case OPENID:
        case OPENID_SSO:
            break;
    }
    config.setSwitchAccountUrl(cfg.getString("auth", null, "switchAccountUrl"));
    config.setUseContributorAgreements(cfg.getBoolean("auth", "contributoragreements", false));
    config.setGitDaemonUrl(cfg.getString("gerrit", null, "canonicalgiturl"));
    config.setGitHttpUrl(cfg.getString("gerrit", null, "gitHttpUrl"));
    config.setUseContactInfo(contactStore != null && contactStore.isEnabled());
    config.setDownloadSchemes(downloadConfig.getDownloadSchemes());
    config.setDownloadCommands(downloadConfig.getDownloadCommands());
    config.setAuthType(authConfig.getAuthType());
    config.setWildProject(wildProject);
    config.setDocumentationAvailable(servletContext.getResource("/Documentation/index.html") != null);
    config.setAnonymousCowardName(anonymousCowardName);
    config.setSuggestFrom(cfg.getInt("suggest", "from", 0));
    config.setChangeUpdateDelay((int) ConfigUtil.getTimeUnit(cfg, "change", null, "updateDelay", 30, TimeUnit.SECONDS));
    config.setChangeScreen(cfg.getEnum("gerrit", null, "changeScreen", AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2));
    config.setIndex(indexCollection.getSearchIndex() != null);
    config.setLargeChangeSize(cfg.getInt("change", "largeChange", 500));
    config.setReportBugUrl(cfg.getString("gerrit", null, "reportBugUrl"));
    if (config.getReportBugUrl() == null) {
        config.setReportBugUrl("http://code.google.com/p/gerrit/issues/list");
    } else if (config.getReportBugUrl().isEmpty()) {
        config.setReportBugUrl(null);
    }
    config.setGitBasicAuth(authConfig.isGitBasicAuth());
    final Set<Account.FieldName> fields = new HashSet<Account.FieldName>();
    for (final Account.FieldName n : Account.FieldName.values()) {
        if (realm.allowsEdit(n)) {
            fields.add(n);
        }
    }
    if (emailSender != null && emailSender.isEnabled() && realm.allowsEdit(Account.FieldName.REGISTER_NEW_EMAIL)) {
        fields.add(Account.FieldName.REGISTER_NEW_EMAIL);
    }
    config.setEditableAccountFields(fields);
    if (gitWebConfig.getUrl() != null) {
        config.setGitwebLink(new GitwebConfig(gitWebConfig.getUrl(), gitWebConfig.getGitWebType()));
    }
    if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
        config.setSshdAddress(sshInfo.getHostKeys().get(0).getHost());
    }
    return config;
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    box.setVisible(true);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() : skip.getStartB();
    int markEnd = markStart + size - 1;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    Configuration markerConfig = Configuration.create().set("collapsed", true).set("inclusiveLeft", true).set("inclusiveRight", true);
    Configuration lineWidgetConfig = Configuration.create().set("coverGutter", true).set("noHScroll", true);
    if (markStart == 0) {
        bar.setWidget(addLineWidget(cm, markEnd + 1, bar, lineWidgetConfig.set("above", true)));
    } else {
        bar.setWidget(addLineWidget(cm, markStart - 1, bar, lineWidgetConfig));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart, 0), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveBase(info, base);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    loadDiff(b, rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            if (Gerrit.getConfig().testChangeMerge()) {
                if (canSubmit) {
                    actions.setSubmitEnabled(changeInfo.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(changeInfo.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !changeInfo.mergeable());
            }
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadSubmitType(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = -1;
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null) {
            if (base.equals(String.valueOf(r._number()))) {
                selectedIdx = i;
            }
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    if (base != null) {
        diffBase.setSelectedIndex(selectedIdx - 1);
    } else {
        diffBase.setSelectedIndex(diffBase.getItemCount() - 1);
    }
}
#method_after
private void renderDiffBaseListBox(ChangeInfo info) {
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    int selectedIdx = list.length();
    for (int i = list.length() - 1; i >= 0; i--) {
        RevisionInfo r = list.get(i);
        diffBase.addItem(r._number() + ": " + r.name().substring(0, 6), r.name());
        if (r.name().equals(revision)) {
            SelectElement.as(diffBase.getElement()).getOptions().getItem(diffBase.getItemCount() - 1).setDisabled(true);
        }
        if (base != null && base.equals(String.valueOf(r._number()))) {
            selectedIdx = diffBase.getItemCount() - 1;
        }
    }
    RevisionInfo rev = info.revisions().get(revision);
    JsArray<CommitInfo> parents = rev.commit().parents();
    diffBase.addItem(parents.length() > 1 ? Util.C.autoMerge() : Util.C.baseDiffItem(), "");
    diffBase.setSelectedIndex(selectedIdx);
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    Set<Ref> tags = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
    Set<Ref> branches = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
    Set<Ref> allTagsAndBranches = new HashSet<Ref>();
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    Set<Ref> allMatchingTagsAndBranches = includedIn(repo, rw, commit, allTagsAndBranches, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#method_after
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    return new IncludedInResolver(repo, rw, commit).resolve();
}
#end_block

#method_before
public static boolean includedInOne(final Repository repo, final RevWalk rw, final RevCommit commit, final Set<Ref> tipRefs) throws IOException {
    return !includedIn(repo, rw, commit, tipRefs, 1).isEmpty();
}
#method_after
public static boolean includedInOne(final Repository repo, final RevWalk rw, final RevCommit commit, final Collection<Ref> refs) throws IOException {
    return new IncludedInResolver(repo, rw, commit).includedInOne(refs);
}
#end_block

#method_before
public static IncludedInDetail resolve(final Repository repo, final RevWalk rw, final RevCommit commit) throws IOException {
    Set<Ref> tags = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
    Set<Ref> branches = new HashSet<Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
    Set<Ref> allTagsAndBranches = new HashSet<Ref>();
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    Set<Ref> allMatchingTagsAndBranches = includedIn(repo, rw, commit, allTagsAndBranches, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#method_after
private IncludedInDetail resolve() throws IOException {
    RefDatabase refDb = repo.getRefDatabase();
    Collection<Ref> tags = refDb.getRefs(Constants.R_TAGS).values();
    Collection<Ref> branches = refDb.getRefs(Constants.R_HEADS).values();
    List<Ref> allTagsAndBranches = Lists.newArrayListWithCapacity(tags.size() + branches.size());
    allTagsAndBranches.addAll(tags);
    allTagsAndBranches.addAll(branches);
    parseCommits(allTagsAndBranches);
    Set<String> allMatchingTagsAndBranches = includedIn(tipsByCommitTime, 0);
    IncludedInDetail detail = new IncludedInDetail();
    detail.setBranches(getMatchingRefNames(allMatchingTagsAndBranches, branches));
    detail.setTags(getMatchingRefNames(allMatchingTagsAndBranches, tags));
    return detail;
}
#end_block

#method_before
private static Set<Ref> includedIn(final Repository repo, final RevWalk rw, final RevCommit target, final Set<Ref> tipRefs, int limit) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    Set<Ref> result = new HashSet<Ref>();
    Map<RevCommit, Set<Ref>> tipsAndCommits = parseCommits(repo, rw, tipRefs);
    List<RevCommit> tips = new ArrayList<RevCommit>(tipsAndCommits.keySet());
    Collections.sort(tips, new Comparator<RevCommit>() {

        @Override
        public int compare(RevCommit c1, RevCommit c2) {
            return c1.getCommitTime() - c2.getCommitTime();
        }
    });
    Set<RevCommit> targetReachableFrom = new HashSet<RevCommit>();
    targetReachableFrom.add(target);
    for (RevCommit tip : tips) {
        boolean commitFound = false;
        rw.resetRetain(RevFlag.UNINTERESTING);
        rw.markStart(tip);
        for (RevCommit commit : rw) {
            if (targetReachableFrom.contains(commit)) {
                commitFound = true;
                targetReachableFrom.add(tip);
                result.addAll(tipsAndCommits.get(tip));
                break;
            }
        }
        if (0 < limit && limit < result.size()) {
            break;
        }
        if (!commitFound) {
            rw.markUninteresting(tip);
        }
    }
    return result;
}
#method_after
private Set<String> includedIn(final Collection<RevCommit> tips, int limit) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    Set<String> result = Sets.newHashSet();
    for (RevCommit tip : tips) {
        boolean commitFound = false;
        rw.resetRetain(RevFlag.UNINTERESTING, containsTarget);
        rw.markStart(tip);
        for (RevCommit commit : rw) {
            if (commit.equals(target) || commit.has(containsTarget)) {
                commitFound = true;
                tip.add(containsTarget);
                result.addAll(commitToRef.get(tip));
                break;
            }
        }
        if (!commitFound) {
            rw.markUninteresting(tip);
        } else if (0 < limit && limit < result.size()) {
            break;
        }
    }
    return result;
}
#end_block

#method_before
private static List<String> getMatchingRefNames(Set<Ref> matchingRefs, Set<Ref> allRefs) {
    List<String> refNames = new ArrayList<String>();
    for (Ref matchingRef : matchingRefs) {
        if (allRefs.contains(matchingRef)) {
            refNames.add(Repository.shortenRefName(matchingRef.getName()));
        }
    }
    return refNames;
}
#method_after
private static List<String> getMatchingRefNames(Set<String> matchingRefs, Collection<Ref> allRefs) {
    List<String> refNames = Lists.newArrayListWithCapacity(matchingRefs.size());
    for (Ref r : allRefs) {
        if (matchingRefs.contains(r.getName())) {
            refNames.add(Repository.shortenRefName(r.getName()));
        }
    }
    return refNames;
}
#end_block

#method_before
private static Map<RevCommit, Set<Ref>> parseCommits(final Repository repo, final RevWalk rw, final Set<Ref> refs) throws IOException {
    Map<RevCommit, Set<Ref>> result = new HashMap<RevCommit, Set<Ref>>();
    for (Ref ref : refs) {
        final RevCommit commit;
        try {
            commit = rw.parseCommit(ref.getObjectId());
        } catch (IncorrectObjectTypeException notCommit) {
            // 
            continue;
        } catch (MissingObjectException notHere) {
            // Log the problem with this branch, but keep processing.
            // 
            log.warn("Reference " + ref.getName() + " in " + repo.getDirectory() + " points to dangling object " + ref.getObjectId());
            continue;
        }
        Set<Ref> relatedRefs = result.get(commit);
        if (relatedRefs == null) {
            relatedRefs = new HashSet<Ref>();
            result.put(commit, relatedRefs);
        }
        relatedRefs.add(ref);
    }
    return result;
}
#method_after
private void parseCommits(final Collection<Ref> refs) throws IOException {
    if (commitToRef != null) {
        return;
    }
    commitToRef = LinkedListMultimap.create();
    for (Ref ref : refs) {
        final RevCommit commit;
        try {
            commit = rw.parseCommit(ref.getObjectId());
        } catch (IncorrectObjectTypeException notCommit) {
            // 
            continue;
        } catch (MissingObjectException notHere) {
            // Log the problem with this branch, but keep processing.
            // 
            log.warn("Reference " + ref.getName() + " in " + repo.getDirectory() + " points to dangling object " + ref.getObjectId());
            continue;
        }
        commitToRef.put(commit, ref.getName());
    }
    tipsByCommitTime = Lists.newArrayList(commitToRef.keySet());
    sortOlderFirst(tipsByCommitTime);
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            Map<String, Ref> allRefs = Maps.newHashMap();
            allRefs.putAll(refDb.getRefs(Constants.R_HEADS));
            allRefs.putAll(refDb.getRefs(Constants.R_TAGS));
            Set<Ref> canReadRefs = Sets.newHashSet();
            for (Entry<String, Ref> entry : allRefs.entrySet()) {
                if (controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    canReadRefs.add(entry.getValue());
                }
            }
            return !canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#method_after
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    if (controlForRef("refs/*").canPerform(Permission.READ)) {
        return true;
    }
    Project.NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            RefDatabase refDb = repo.getRefDatabase();
            List<Ref> allRefs = Lists.newLinkedList();
            allRefs.addAll(refDb.getRefs(Constants.R_HEADS).values());
            allRefs.addAll(refDb.getRefs(Constants.R_TAGS).values());
            List<Ref> canReadRefs = Lists.newLinkedList();
            for (Ref r : allRefs) {
                if (controlForRef(r.getName()).canPerform(Permission.READ)) {
                    canReadRefs.add(r);
                }
            }
            if (!canReadRefs.isEmpty() && IncludedInResolver.includedInOne(repo, rw, commit, canReadRefs)) {
                return true;
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_SIZE, Gerrit.RESOURCES.css().cSIZE());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    for (int i = BASE_COLUMNS; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    table.setWidget(row, C_SIZE, getSizeWidget(c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (Gerrit.getConfig().testChangeMerge() && !c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
        table.getCellFormatter().addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().notMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    CellFormatter fmt = table.getCellFormatter();
    for (int idx = 0; idx < labelNames.size(); idx++) {
        String name = labelNames.get(idx);
        int col = BASE_COLUMNS + idx;
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
        if (revision == null) {
            // the current revision is not visible to the calling user (maybe it is
            // a draft?) or the change is corrupt, take the last revision that
            // was returned, if no revision was returned display an error
            JsArray<RevisionInfo> revisions = info.revisions().values();
            if (revisions.length() > 0) {
                RevisionInfo.sortRevisionInfoByNumber(revisions);
                revision = revisions.get(revisions.length() - 1).name();
            } else {
                new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
            }
        }
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    return info.revision(revision);
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    if (revision == null) {
        revision = info.current_revision();
    } else if (!info.revisions().containsKey(revision)) {
        JsArray<RevisionInfo> list = info.revisions().values();
        for (int i = 0; i < list.length(); i++) {
            RevisionInfo r = list.get(i);
            if (revision.equals(String.valueOf(r._number()))) {
                revision = r.name();
                break;
            }
        }
    }
    RevisionInfo rev = revision != null ? info.revision(revision) : null;
    if (rev != null) {
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    loadChangeInfo(true, new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, null);
        }
    });
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, fg && revision != null ? ListChangesOption.ALL_REVISIONS : ListChangesOption.CURRENT_REVISION));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CURRENT_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            reload.reload();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'K', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (revision != null) {
                JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
                RevisionInfo.sortRevisionInfoByNumber(revisions);
                boolean found = false;
                for (RevisionInfo r : Natives.asList(revisions)) {
                    if (revision.equals(r.name())) {
                        found = true;
                        continue;
                    }
                    if (found) {
                        Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), r._number())));
                        break;
                    }
                }
            }
        }
    });
    keysNavigation.add(new KeyCommand(0, 'J', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            if (revision == null) {
                revision = changeInfo.current_revision();
                if (changeInfo.revision(revision)._number() == 1) {
                    return;
                }
                loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                    @Override
                    public void onSuccess(ChangeInfo info) {
                        goToPreviousPatchSet(info);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                    }
                });
            } else {
                goToPreviousPatchSet(changeInfo);
            }
        }

        private void goToPreviousPatchSet(ChangeInfo info) {
            if (changeInfo.revision(revision)._number() == 1) {
                return;
            }
            JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(revisions);
            RevisionInfo prevRev = null;
            for (RevisionInfo r : Natives.asList(revisions)) {
                if (revision.equals(r.name())) {
                    if (prevRev != null) {
                        Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), prevRev._number())));
                    }
                    break;
                }
                prevRev = r;
            }
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysNavigation.add(new KeyCommand(0, 'n', Util.C.keyNextPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(1);
        }
    }, new KeyCommand(0, 'p', Util.C.keyPreviousPatchSet()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            gotoSibling(-1);
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    keysAction.add(new KeyCommand(0, 'x', Util.C.keyExpandAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onExpandAll(null);
        }
    });
    keysAction.add(new KeyCommand(0, 'z', Util.C.keyCollapseAllMessages()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            onCollapseAll(null);
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
    related.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#end_block

#method_before
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
private void onReply() {
    if (Gerrit.isSignedIn()) {
        replyAction.onReply(null);
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(rev, myLastReply(info), group);
    loadCommit(rev, group);
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.add(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
    group.done();
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    CallbackGroup group = new CallbackGroup();
    loadDiff(info.revisions().get(base), rev, myLastReply(info), group);
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
        }
    }));
}
#end_block

#method_before
private void loadDiff(final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#method_after
private void loadDiff(final RevisionInfo base, final RevisionInfo rev, final Timestamp myLastReply, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> comments = loadComments(rev, group);
    final List<NativeMap<JsArray<CommentInfo>>> drafts = loadDrafts(rev, group);
    DiffApi.list(changeId.get(), base != null ? base.name() : null, rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(base != null ? new PatchSet.Id(changeId, base._number()) : null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m, myLastReply, comments.get(0), drafts.get(0));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderActionTextDate(info);
    renderHistory(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (msg != null) {
                message.setText(msg.replaceAll("\\n", "\\\n" + "> "));
            }
            message.setFocus(true);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            Window.scrollTo(0, 0);
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
void onReply(String msg) {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (replyBox == null) {
        replyBox = new ReplyBox(psId, revision, allLabels, permittedLabels, msg);
        allLabels = null;
        permittedLabels = null;
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    if (style != null) {
        p.setStyleName(style.replyBox());
    } else {
        p.setStyleName(style2.replyBox());
    }
    p.addAutoHidePartner(replyButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(replyBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#method_after
void onReply(MessageInfo msg) {
    if (popup != null) {
        popup.hide();
        return;
    }
    if (replyBox == null) {
        replyBox = new ReplyBox(psId, revision, allLabels, permittedLabels);
        allLabels = null;
        permittedLabels = null;
    }
    if (msg != null) {
        replyBox.replyTo(msg);
    }
    final PluginSafePopupPanel p = new PluginSafePopupPanel(true);
    p.setStyleName(style.replyBox());
    p.addAutoHidePartner(replyButton.getElement());
    p.addCloseHandler(new CloseHandler<PopupPanel>() {

        @Override
        public void onClose(CloseEvent<PopupPanel> event) {
            if (popup == p) {
                popup = null;
            }
        }
    });
    p.add(replyBox);
    p.showRelativeTo(replyButton);
    GlobalKey.dialog(p);
    popup = p;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            reload.reload();
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    Resources.I.style().ensureInjected();
    star.setVisible(Gerrit.isSignedIn());
    labels.init(style, statusText);
    reviewers.init(style, reviewersText);
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', Util.C.upToChangeList()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.displayLastChangeList();
        }
    });
    keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadChange()) {

        @Override
        public void onKeyPress(final KeyPressEvent event) {
            Gerrit.display(PageLinks.toChange(changeId));
        }
    });
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new KeyCommand(0, 'a', Util.C.keyPublishComments()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (Gerrit.isSignedIn()) {
                onReply(null);
            } else {
                Gerrit.doSignIn(getToken());
            }
        }
    });
    if (Gerrit.isSignedIn()) {
        keysAction.add(new KeyCommand(0, 's', Util.C.changeTableStar()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                star.setValue(!star.getValue(), true);
            }
        });
        keysAction.add(new KeyCommand(0, 'c', Util.C.keyAddReviewers()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                reviewers.onOpenForm();
            }
        });
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    commit.onShowView();
    related.setMaxHeight(commit.getElement().getParentElement().getOffsetHeight());
    if (openReplyBox) {
        onReply();
    } else {
        String prior = Gerrit.getPriorView();
        if (prior != null && prior.startsWith("/c/")) {
            scrollToPath(prior.substring(3));
        }
    }
    startPoller();
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<NativeMap<JsArray<CommentInfo>>>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderActionTextDate(info);
    renderHistory(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, null, reply, null);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderCommitSubject(info);
    renderOwner(info);
    renderActionTextDate(info);
    initIncludedInAction(info);
    initRevisionsAction(info, revision);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                Gerrit.display(PageLinks.toChange(changeId));
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isAttached()) {
        add(updateAvailable);
    }
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    onReply();
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    if (Gerrit.isSignedIn()) {
        history.replyTo(info);
    } else {
        Gerrit.doSignIn(com.google.gwt.user.client.History.getToken());
    }
}
#end_block

#method_before
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    if (Gerrit.isSignedIn()) {
        UIObject.setVisible(buttons, open);
    }
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
}
#method_after
void setOpen(boolean open) {
    if (open && info._revisionNumber() > 0) {
        if (commentList == null) {
            history.load(info._revisionNumber());
        } else if (!commentList.isEmpty()) {
            renderComments(commentList);
            commentList = Collections.emptyList();
        }
    }
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    comments.setVisible(open && comments.getWidgetCount() > 0);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("projects", null, "newProjectsSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(Objects.firstNonNull(createProjectArgs.submitType, cfg.getEnum("repository", "*", "defaultSubmitType", SubmitType.MERGE_IF_NECESSARY)));
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        newProject.setMaxObjectSizeLimit(createProjectArgs.maxObjectSizeLimit);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        config.commit(md);
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
}
#end_block

#method_before
void set(final ChangeInfo info, final String revision) {
    if (info.status().isOpen()) {
        setForOpenChange(info, revision);
    }
    StringBuilder cherryPicksQuery = new StringBuilder();
    cherryPicksQuery.append(" project:").append(info.project());
    cherryPicksQuery.append(" change:").append(info.change_id());
    cherryPicksQuery.append(" -change:").append(info.legacy_id().get());
    ChangeList.query(cherryPicksQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

        @Override
        public void onSuccess(ChangeList result) {
            if (result.length() > 0) {
                getTab().setTitle(Resources.M.cherryPicks(result.length()));
                getTab().setChanges(info.project(), revision, convertChangeList(result));
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.cherryPicks(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (cherryPicksTab == null) {
                cherryPicksTab = createTab(Resources.C.cherryPicks(), Resources.C.cherryPicksTooltip());
                cherryPicksTab.setShowBranches(true);
            }
            return cherryPicksTab;
        }
    });
    if (info.topic() != null && !"".equals(info.topic())) {
        StringBuilder topicQuery = new StringBuilder();
        topicQuery.append("status:open");
        topicQuery.append(" project:").append(info.project());
        topicQuery.append(" branch:").append(info.branch());
        topicQuery.append(" topic:\"").append(info.topic()).append("\"");
        ChangeList.query(topicQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                if (result.length() > 0) {
                    getTab().setTitle(Resources.M.sameTopic(result.length()));
                    getTab().setChanges(info.project(), revision, convertChangeList(result));
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.sameTopic(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (sameTopicTab == null) {
                    sameTopicTab = createTab(Resources.C.sameTopic(), Resources.C.sameTopicTooltip());
                }
                return sameTopicTab;
            }
        });
    }
}
#method_after
void set(final ChangeInfo info, final String revision) {
    if (info.status().isOpen()) {
        setForOpenChange(info, revision);
    }
    StringBuilder cherryPicksQuery = new StringBuilder();
    cherryPicksQuery.append(op("project", info.project()));
    cherryPicksQuery.append(" ").append(op("change", info.change_id()));
    cherryPicksQuery.append(" ").append(op("-change", info.legacy_id().get()));
    ChangeList.query(cherryPicksQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

        @Override
        public void onSuccess(ChangeList result) {
            if (result.length() > 0) {
                getTab().setTitle(Resources.M.cherryPicks(result.length()));
                getTab().setChanges(info.project(), revision, convertChangeList(result));
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.cherryPicks(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (cherryPicksTab == null) {
                cherryPicksTab = createTab(Resources.C.cherryPicks(), Resources.C.cherryPicksTooltip());
                cherryPicksTab.setShowBranches(true);
            }
            return cherryPicksTab;
        }
    });
    if (info.topic() != null && !"".equals(info.topic())) {
        StringBuilder topicQuery = new StringBuilder();
        topicQuery.append("status:open");
        topicQuery.append(" ").append(op("project", info.project()));
        topicQuery.append(" ").append(op("branch", info.branch()));
        topicQuery.append(" ").append(op("topic", info.topic()));
        ChangeList.query(topicQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                if (result.length() > 0) {
                    getTab().setTitle(Resources.M.sameTopic(result.length()));
                    getTab().setChanges(info.project(), revision, convertChangeList(result));
                }
            }

            @Override
            public void onFailure(Throwable err) {
                getTab().setTitle(Resources.M.sameTopic(Resources.C.notAvailable()));
                getTab().setError(err.getMessage());
            }

            private RelatedChangesTab getTab() {
                if (sameTopicTab == null) {
                    sameTopicTab = createTab(Resources.C.sameTopic(), Resources.C.sameTopicTooltip());
                }
                return sameTopicTab;
            }
        });
    }
}
#end_block

#method_before
private void setForOpenChange(final ChangeInfo info, final String revision) {
    relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(result.changes().length()));
            relatedChangesTab.setChanges(info.project(), revision, result.changes());
        }

        @Override
        public void onFailure(Throwable err) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            relatedChangesTab.setError(err.getMessage());
        }
    });
    StringBuilder conflictsQuery = new StringBuilder();
    conflictsQuery.append("status:open");
    conflictsQuery.append(" conflicts:").append(info.legacy_id().get());
    conflictsQuery.append(" -age:1month");
    ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

        @Override
        public void onSuccess(ChangeList result) {
            if (result.length() > 0) {
                getTab().setTitle(Resources.M.conflictingChanges(result.length()));
                getTab().setChanges(info.project(), revision, convertChangeList(result));
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (conflictingChangesTab == null) {
                conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
            }
            return conflictingChangesTab;
        }
    });
}
#method_after
private void setForOpenChange(final ChangeInfo info, final String revision) {
    relatedChangesTab = createTab(Resources.C.relatedChanges(), Resources.C.relatedChangesTooltip());
    ChangeApi.revision(info.legacy_id().get(), revision).view("related").get(new AsyncCallback<RelatedInfo>() {

        @Override
        public void onSuccess(RelatedInfo result) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(result.changes().length()));
            relatedChangesTab.setChanges(info.project(), revision, result.changes());
        }

        @Override
        public void onFailure(Throwable err) {
            relatedChangesTab.setTitle(Resources.M.relatedChanges(Resources.C.notAvailable()));
            relatedChangesTab.setError(err.getMessage());
        }
    });
    StringBuilder conflictsQuery = new StringBuilder();
    conflictsQuery.append("status:open");
    conflictsQuery.append(" ").append(op("conflicts", info.legacy_id().get()));
    conflictsQuery.append(" -age:1month");
    ChangeList.query(conflictsQuery.toString(), EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT), new AsyncCallback<ChangeList>() {

        @Override
        public void onSuccess(ChangeList result) {
            if (result.length() > 0) {
                getTab().setTitle(Resources.M.conflictingChanges(result.length()));
                getTab().setChanges(info.project(), revision, convertChangeList(result));
            }
        }

        @Override
        public void onFailure(Throwable err) {
            getTab().setTitle(Resources.M.conflictingChanges(Resources.C.notAvailable()));
            getTab().setError(err.getMessage());
        }

        private RelatedChangesTab getTab() {
            if (conflictingChangesTab == null) {
                conflictingChangesTab = createTab(Resources.C.conflictingChanges(), Resources.C.conflictingChangesTooltip());
            }
            return conflictingChangesTab;
        }
    });
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve()).submit();
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).current().review(approve());
    gApi.changes().id("p~master~" + r.getChangeId()).current().submit();
}
#end_block

#method_before
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in).current().review(approve()).submit();
}
#method_after
@Test
public void cherryPick() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    CherryPickInput in = new CherryPickInput();
    in.destination = "foo";
    in.message = "it goes to stable branch";
    gApi.projects().name(project.get()).branch(in.destination).create(new BranchInput());
    ChangeApi cApi = gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).cherryPick(in);
    cApi.current().review(approve());
    cApi.current().submit();
}
#end_block

#method_before
@Override
public RevisionApi review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
        return this;
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#method_after
@Override
public void review(ReviewInput in) throws RestApiException {
    try {
        review.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot post review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot post review", e);
    }
}
#end_block

#method_before
@Override
public void rebase() throws RestApiException {
    try {
        rebase.get().apply(revision, null);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#method_after
@Override
public ChangeApi rebase() throws RestApiException {
    try {
        return changes.id(rebase.get().apply(revision, null)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot rebase ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot rebase ps", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick ps", e);
    }
}
#method_after
@Override
public ChangeApi cherryPick(CherryPickInput in) throws RestApiException {
    try {
        return changes.id(cherryPick.get().apply(revision, in)._number);
    } catch (OrmException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (EmailException e) {
        throw new RestApiException("Cannot cherry pick", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot cherry pick", e);
    }
}
#end_block

#method_before
@Override
public void start() {
    for (Destination cfg : configs.getDestinations()) {
        cfg.start(workQueue);
    }
    running = true;
}
#method_after
@Override
public void start() {
    for (Destination cfg : config.getDestinations()) {
        cfg.start(workQueue);
    }
    running = true;
}
#end_block

#method_before
@Override
public void stop() {
    running = false;
    int discarded = 0;
    for (Destination cfg : configs.getDestinations()) {
        discarded += cfg.shutdown();
    }
    if (discarded > 0) {
        log.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#method_after
@Override
public void stop() {
    running = false;
    int discarded = 0;
    for (Destination cfg : config.getDestinations()) {
        discarded += cfg.shutdown();
    }
    if (discarded > 0) {
        log.warn(String.format("Cancelled %d replication events during shutdown", discarded));
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : configs.getDestinations()) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch, ReplicationState state) {
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    for (Destination cfg : config.getDestinations()) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri, state);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (GitReferenceUpdatedListener.Update u : event.getUpdates()) {
        for (Destination cfg : configs.getDestinations()) {
            if (cfg.wouldPushProject(project) && cfg.wouldPushRef(u.getRefName())) {
                for (URIish uri : cfg.getURIs(project, null)) {
                    cfg.schedule(project, u.getRefName(), uri, state);
                }
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(changeHooks, database));
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations()) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs.getDestinations()) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get(), config.isSingleProjectMatch());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    for (URIish uri : getURIs(new Project.NameKey(event.getProjectName()), false)) {
        createProject(uri, event.getHeadName());
    }
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error(String.format("Failed to create repository %s", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        log.error(String.format("Failed to create repository %s", uri.getPath()), e);
    }
}
#end_block

#method_before
private static void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + "&& cd " + quotedPath + "&& git init --bare" + "&& git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    OutputStream errStream = newErrorBufferStream();
    try {
        RemoteSession ssh = connect(uri);
        Process proc = ssh.exec(cmd, 0);
        proc.getOutputStream().close();
        StreamCopyThread out = new StreamCopyThread(proc.getInputStream(), errStream);
        StreamCopyThread err = new StreamCopyThread(proc.getErrorStream(), errStream);
        out.start();
        err.start();
        try {
            proc.waitFor();
            out.halt();
            err.halt();
        } catch (InterruptedException interrupted) {
        // Don't wait, drop out immediately.
        }
        ssh.disconnect();
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#method_after
private static void createRemoteSsh(URIish uri, String head) {
    String quotedPath = QuotedString.BOURNE.quote(uri.getPath());
    String cmd = "mkdir -p " + quotedPath + " && cd " + quotedPath + " && git init --bare";
    if (head != null) {
        cmd = cmd + " && git symbolic-ref HEAD " + QuotedString.BOURNE.quote(head);
    }
    OutputStream errStream = newErrorBufferStream();
    try {
        executeRemotSsh(uri, cmd, errStream);
    } catch (IOException e) {
        log.error(String.format("Error creating remote repository at %s:\n" + "  Exception: %s\n" + "  Command: %s\n" + "  Output: %s", uri, e, cmd, errStream), e);
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, BranchInput input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new BranchInput();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(ProjectApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Projects.class).to(ProjectsImpl.class);
    factory(BranchApiImpl.Factory.class);
    factory(ProjectApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    ProjectApi pApi = gApi.projects().forName(project.get());
    BranchInput in = new BranchInput();
    in.ref = "foo";
    pApi.createBranch(in);
}
#method_after
@Test
public void createBranch() throws GitAPIException, IOException, RestApiException {
    gApi.projects().name(project.get()).branch("foo").create(new BranchInput());
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (isDuplicate(msg)) {
        return;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, final boolean makeNew) {
    if (makeNew) {
        try {
            db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        c.setStatus(Change.Status.NEW);
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
        } catch (OrmConcurrencyException err) {
        } catch (OrmException err) {
            log.warn("Cannot update change status", err);
        }
    } else {
        try {
            ChangeUtil.touch(c, db);
        } catch (OrmException err) {
            log.warn("Cannot update change timestamp", err);
        }
    }
    if (isDuplicate(msg)) {
        return;
    }
    try {
        db.changeMessages().insert(Collections.singleton(msg));
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    Element element = context.getElement().getFirstChildElement();
    while (element.getPropertyInt("value") != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        element = element.getNextSiblingElement();
    }
    if (element.getPropertyInt("value") == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        if (enableSmallFileFeatures) {
            element.removeAttribute("disabled");
        } else {
            element.setAttribute("disabled", "disabled");
            if (AccountDiffPreference.CONTEXT_CHOICES[context.getSelectedIndex()] == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
                for (int i = 0; i < AccountDiffPreference.CONTEXT_CHOICES.length; i++) {
                    if (AccountDiffPreference.CONTEXT_CHOICES[i] == PatchScreen.LARGE_FILE_CONTEXT) {
                        context.setSelectedIndex(i);
                        break;
                    }
                }
            }
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#method_after
public void setEnableSmallFileFeatures(final boolean on) {
    enableSmallFileFeatures = on;
    if (enableSmallFileFeatures) {
        syntaxHighlighting.setValue(getValue().isSyntaxHighlighting());
    } else {
        syntaxHighlighting.setValue(false);
    }
    NodeList<OptionElement> options = context.getElement().<SelectElement>cast().getOptions();
    // WHOLE_FILE_CONTEXT is the last option in the list.
    int lastIndex = options.getLength() - 1;
    OptionElement currOption = options.getItem(lastIndex);
    if (enableSmallFileFeatures) {
        currOption.setDisabled(false);
    } else {
        currOption.setDisabled(true);
        if (context.getSelectedIndex() == lastIndex) {
            // Select the next longest context from WHOLE_FILE_CONTEXT
            context.setSelectedIndex(lastIndex - 1);
        }
    }
    toggleEnabledStatus(save.isEnabled());
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> r = Lists.newArrayList();
    for (final Change c : changes) {
        List<Predicate<ChangeData>> r2 = Lists.newArrayList();
        for (String file : (new ChangeData(c)).currentFilePaths(db, plc)) {
            r2.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> r3 = Lists.newArrayList();
        r3.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        r3.add(or(r2));
        r3.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        ObjectInserter inserter = repo.newObjectInserter();
                        try {
                            RevWalk rw = new RevWalk(repo) {

                                @Override
                                protected RevCommit createCommit(final AnyObjectId id) {
                                    return new CodeReviewCommit(id);
                                }
                            };
                            try {
                                RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                                CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(new ChangeData(c).currentPatchSet(db).getRevision().get()));
                                SubmitStrategy strategy = submitStrategyFactory.create(getSubmitType(object), db.get(), repo, rw, inserter, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                                CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(ObjectId.fromString(object.currentPatchSet(db).getRevision().get()));
                                otherCommit.add(canMergeFlag);
                                return !strategy.dryRun(commit, otherCommit);
                            } catch (MergeException e) {
                                throw new IllegalStateException();
                            } catch (NoSuchProjectException e) {
                                throw new IllegalStateException();
                            } finally {
                                rw.release();
                            }
                        } finally {
                            inserter.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(c, identifiedUserFactory.create(c.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (final Ref r : repo.getAllRefs().values()) {
                        if (r.getName().startsWith(Constants.R_HEADS) || r.getName().startsWith(Constants.R_TAGS)) {
                            try {
                                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                            } catch (IncorrectObjectTypeException iote) {
                            // Not a commit? Skip over it.
                            }
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        r.add(and(r3));
    }
    return r;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Provider<ReviewDb> db, final PatchListCache plc, final SubmitStrategyFactory submitStrategyFactory, final ChangeControl.GenericFactory changeControlFactory, final IdentifiedUser.GenericFactory identifiedUserFactory, final GitRepositoryManager repoManager, final ProjectCache projectCache, final ConflictsCache conflictsCache, final String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, projectCache);
        List<String> files = new ChangeData(c).currentFilePaths(db, plc);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsFilePredicate(db, plc, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(db, c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(db, c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(db, c.getDest().get()));
        predicatesForOneChange.add(or(filePredicates));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change(db);
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(otherChange, object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet(db).getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try {
                    Repository repo = repoManager.openRepository(otherChange.getProject());
                    try {
                        RevWalk rw = new RevWalk(repo) {

                            @Override
                            protected RevCommit createCommit(AnyObjectId id) {
                                return new CodeReviewCommit(id);
                            }
                        };
                        try {
                            RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                            CodeReviewCommit commit = (CodeReviewCommit) rw.parseCommit(changeDataCache.getTestAgainst());
                            SubmitStrategy strategy = submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest());
                            CodeReviewCommit otherCommit = (CodeReviewCommit) rw.parseCommit(other);
                            otherCommit.add(canMergeFlag);
                            conflicts = !strategy.dryRun(commit, otherCommit);
                            conflictsCache.put(conflictsKey, conflicts);
                            return conflicts;
                        } catch (MergeException e) {
                            throw new IllegalStateException(e);
                        } catch (NoSuchProjectException e) {
                            throw new IllegalStateException(e);
                        } finally {
                            rw.release();
                        }
                    } finally {
                        repo.close();
                    }
                } catch (IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(Change change, ChangeData cd) throws OrmException {
                try {
                    final SubmitTypeRecord r = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner())).getSubmitTypeRecord(db.get(), cd.currentPatchSet(db), cd);
                    if (r.status != SubmitTypeRecord.Status.OK) {
                        return null;
                    }
                    return r.type;
                } catch (NoSuchChangeException e) {
                    return null;
                }
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws MergeException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new MergeException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#method_after
@SuppressWarnings("unchecked")
public static boolean hasLimit(Predicate<ChangeData> p) {
    return find(p, IntPredicate.class, FIELD_LIMIT) != null;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#method_after
@SuppressWarnings("unchecked")
public static int getLimit(Predicate<ChangeData> p) {
    return ((IntPredicate<?>) find(p, IntPredicate.class, FIELD_LIMIT)).intValue();
}
#end_block

#method_before
public boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#method_after
public static boolean hasSortKey(Predicate<ChangeData> p) {
    return find(p, SortKeyPredicate.class, "sortkey_after") != null || find(p, SortKeyPredicate.class, "sortkey_before") != null;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for comment:" + value);
    }
    return new CommentPredicate(args.dbProvider, args.index, value);
}
#method_after
@Operator
public Predicate<ChangeData> comment(String value) throws QueryParseException {
    ChangeIndex index = requireIndex(FIELD_COMMENT, value);
    return new CommentPredicate(args.dbProvider, index, value);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for " + FIELD_CONFLICTS + ":" + value);
    }
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, value, parseChange(value));
}
#method_after
@Operator
public Predicate<ChangeData> conflicts(String value) throws OrmException, QueryParseException {
    requireIndex(FIELD_CONFLICTS, value);
    return new ConflictsPredicate(args.dbProvider, args.patchListCache, args.submitStrategyFactory, args.changeControlGenericFactory, args.userFactory, args.repoManager, args.projectCache, args.conflictsCache, value, parseChange(value));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (!allowFileRegex) {
            requireIndex(FIELD_FILE, file);
        }
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    } else {
        requireIndex(FIELD_FILE, file);
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    if (args.index == ChangeIndex.DISABLED) {
        throw error("secondary index must be enabled for message:" + text);
    }
    return new MessagePredicate(args.dbProvider, args.index, text);
}
#method_after
@Operator
public Predicate<ChangeData> message(String text) throws QueryParseException {
    ChangeIndex index = args.indexes.getSearchIndex();
    if (index == null) {
        return new LegacyMessagePredicate(args.dbProvider, args.repoManager, text);
    }
    return new MessagePredicate(args.dbProvider, index, text);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser.isIdentifiedUser() && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
public Predicate<ChangeData> limit(int limit) {
    return new IntPredicate<ChangeData>(FIELD_LIMIT, limit) {

        @Override
        public boolean match(ChangeData object) {
            return true;
        }

        @Override
        public int getCost() {
            return 0;
        }
    };
}
#method_after
public Predicate<ChangeData> limit(int limit) {
    return new LimitPredicate(limit);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_after(String sortKey) {
    return new SortKeyPredicate.After(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(args.dbProvider, sortKey);
}
#method_after
@Operator
public Predicate<ChangeData> sortkey_before(String sortKey) {
    return new SortKeyPredicate.Before(BasicChangeRewrites.schema(args.indexes), args.dbProvider, sortKey);
}
#end_block

#method_before
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        Change.Key b = a.max();
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, b).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#method_after
private List<Change> parseChange(String value) throws OrmException, QueryParseException {
    if (PAT_LEGACY_ID.matcher(value).matches()) {
        return Collections.singletonList(args.dbProvider.get().changes().get(Change.Id.parse(value)));
    } else if (PAT_CHANGE_ID.matcher(value).matches()) {
        Change.Key a = new Change.Key(parseChangeId(value));
        List<Change> changes = args.dbProvider.get().changes().byKeyRange(a, a.max()).toList();
        if (changes.isEmpty()) {
            throw error("Change " + value + " not found");
        }
        return changes;
    }
    throw error("Change " + value + " not found");
}
#end_block

#method_before
private Account.Id self() {
    if (currentUser instanceof IdentifiedUser) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#method_after
private Account.Id self() {
    if (currentUser.isIdentifiedUser()) {
        return ((IdentifiedUser) currentUser).getAccountId();
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(dbProvider, cut), a);
}
#method_after
@SuppressWarnings("unchecked")
@NoCostComputation
@Rewrite("sortkey_before:z A=(age:*)")
public Predicate<ChangeData> r00_ageToSortKey(@Named("A") AgePredicate a) {
    String cut = ChangeUtil.sortKey(a.getCut(), Integer.MAX_VALUE);
    return and(new SortKeyPredicate.Before(schema(indexes), dbProvider, cut), a);
}
#end_block

#method_before
public static boolean isExpected(int statusCode) {
    switch(statusCode) {
        case SC_UNAVAILABLE:
        // Bad Request
        case 400:
        // Unauthorized
        case 401:
        // Forbidden
        case 403:
        // Not Found
        case 404:
        // Method Not Allowed
        case 405:
        // Conflict
        case 409:
        // Precondition Failed
        case 412:
        case // Too Many Requests (RFC 6585)
        429:
            return true;
        default:
            // local proxy server errors outside of our control.
            return false;
    }
}
#method_after
public static boolean isExpected(int statusCode) {
    switch(statusCode) {
        case SC_UNAVAILABLE:
        // Bad Request
        case 400:
        // Unauthorized
        case 401:
        // Forbidden
        case 403:
        // Not Found
        case 404:
        // Method Not Allowed
        case 405:
        // Conflict
        case 409:
        // Precondition Failed
        case 412:
        // Unprocessable Entity
        case 422:
        case // Too Many Requests (RFC 6585)
        429:
            return true;
        default:
            // local proxy server errors outside of our control.
            return false;
    }
}
#end_block

#method_before
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(null);
        RpcStatus.INSTANCE.onRpcComplete();
    } else if (200 <= status && status < 300) {
        T data;
        if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
            res.getText();
        } else if (isJsonBody(res)) {
            try {
                // javac generics bug
                data = RestApi.<T>cast(parseJson(res));
            } catch (JSONException e) {
                RpcStatus.INSTANCE.onRpcComplete();
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else {
            RpcStatus.INSTANCE.onRpcComplete();
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        cb.onSuccess(data);
        RpcStatus.INSTANCE.onRpcComplete();
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        RpcStatus.INSTANCE.onRpcComplete();
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#method_after
@Override
public void onResponseReceived(Request req, Response res) {
    int status = res.getStatusCode();
    if (status == Response.SC_NO_CONTENT) {
        cb.onSuccess(null);
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else if (200 <= status && status < 300) {
        T data;
        if (isTextBody(res)) {
            data = NativeString.wrap(res.getText()).cast();
        } else if (isJsonBody(res)) {
            try {
                // javac generics bug
                data = RestApi.<T>cast(parseJson(res));
            } catch (JSONException e) {
                if (!background) {
                    RpcStatus.INSTANCE.onRpcComplete();
                }
                cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Invalid JSON: " + e.getMessage()));
                return;
            }
        } else {
            if (!background) {
                RpcStatus.INSTANCE.onRpcComplete();
            }
            cb.onFailure(new StatusCodeException(SC_BAD_RESPONSE, "Expected " + JSON_TYPE + " or " + TEXT_TYPE + "; received Content-Type: " + res.getHeader("Content-Type")));
            return;
        }
        cb.onSuccess(data);
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
    } else {
        String msg;
        if (isTextBody(res)) {
            msg = res.getText().trim();
        } else if (isJsonBody(res)) {
            JSONValue v;
            try {
                v = parseJson(res);
            } catch (JSONException e) {
                v = null;
            }
            if (v != null && v.isString() != null) {
                msg = v.isString().stringValue();
            } else {
                msg = trimJsonMagic(res.getText()).trim();
            }
        } else {
            msg = res.getStatusText();
        }
        if (!background) {
            RpcStatus.INSTANCE.onRpcComplete();
        }
        cb.onFailure(new StatusCodeException(status, msg));
    }
}
#end_block

#method_before
@Override
public void onError(Request req, Throwable err) {
    RpcStatus.INSTANCE.onRpcComplete();
    if (err.getMessage().contains("XmlHttpRequest.status")) {
        cb.onFailure(new StatusCodeException(SC_UNAVAILABLE, RpcConstants.C.errorServerUnavailable()));
    } else {
        cb.onFailure(new StatusCodeException(SC_BAD_TRANSPORT, err.getMessage()));
    }
}
#method_after
@Override
public void onError(Request req, Throwable err) {
    if (!background) {
        RpcStatus.INSTANCE.onRpcComplete();
    }
    if (err.getMessage().contains("XmlHttpRequest.status")) {
        cb.onFailure(new StatusCodeException(SC_UNAVAILABLE, RpcConstants.C.errorServerUnavailable()));
    } else {
        cb.onFailure(new StatusCodeException(SC_BAD_TRANSPORT, err.getMessage()));
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
private <T extends JavaScriptObject> void send(Method method, AsyncCallback<T> cb) {
    HttpCallback<T> httpCallback = new HttpCallback<T>(cb);
    try {
        RpcStatus.INSTANCE.onRpcStart();
        request(method).sendRequest(null, httpCallback);
    } catch (RequestException e) {
        httpCallback.onError(null, e);
    }
}
#method_after
private <T extends JavaScriptObject> void send(Method method, AsyncCallback<T> cb) {
    HttpCallback<T> httpCallback = new HttpCallback<T>(background, cb);
    try {
        if (!background) {
            RpcStatus.INSTANCE.onRpcStart();
        }
        request(method).sendRequest(null, httpCallback);
    } catch (RequestException e) {
        httpCallback.onError(null, e);
    }
}
#end_block

#method_before
public <T extends JavaScriptObject> void post(JavaScriptObject content, AsyncCallback<T> cb) {
    sendJSON(POST, content, cb);
}
#method_after
public <T extends JavaScriptObject> void post(String content, AsyncCallback<T> cb) {
    sendRaw(POST, content, cb);
}
#end_block

#method_before
public <T extends JavaScriptObject> void put(JavaScriptObject content, AsyncCallback<T> cb) {
    sendJSON(PUT, content, cb);
}
#method_after
public <T extends JavaScriptObject> void put(String content, AsyncCallback<T> cb) {
    sendRaw(PUT, content, cb);
}
#end_block

#method_before
private <T extends JavaScriptObject> void sendJSON(Method method, JavaScriptObject content, AsyncCallback<T> cb) {
    HttpCallback<T> httpCallback = new HttpCallback<T>(cb);
    try {
        RpcStatus.INSTANCE.onRpcStart();
        String body = new JSONObject(content).toString();
        RequestBuilder req = request(method);
        req.setHeader("Content-Type", JSON_UTF8);
        req.sendRequest(body, httpCallback);
    } catch (RequestException e) {
        httpCallback.onError(null, e);
    }
}
#method_after
private <T extends JavaScriptObject> void sendJSON(Method method, JavaScriptObject content, AsyncCallback<T> cb) {
    HttpCallback<T> httpCallback = new HttpCallback<T>(background, cb);
    try {
        if (!background) {
            RpcStatus.INSTANCE.onRpcStart();
        }
        String body = new JSONObject(content).toString();
        RequestBuilder req = request(method);
        req.setHeader("Content-Type", JSON_UTF8);
        req.sendRequest(body, httpCallback);
    } catch (RequestException e) {
        httpCallback.onError(null, e);
    }
}
#end_block

#method_before
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(defaultConfig(requestHeaderSize)));
        } else if ("https".equals(u.getScheme())) {
            HttpConfiguration config = defaultConfig(requestHeaderSize);
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            HttpConfiguration config = defaultConfig(requestHeaderSize);
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(config));
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            HttpConfiguration config = defaultConfig(requestHeaderSize);
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(config));
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#method_after
private Connector[] listen(Server server, Config cfg) {
    // OpenID and certain web-based single-sign-on products can cause
    // some very long headers, especially in the Referer header. We
    // need to use a larger default header size to ensure we have
    // the space required.
    // 
    final int requestHeaderSize = cfg.getInt("httpd", "requestheadersize", 16386);
    final URI[] listenUrls = listenURLs(cfg);
    final boolean reuseAddress = cfg.getBoolean("httpd", "reuseaddress", true);
    final int acceptors = cfg.getInt("httpd", "acceptorThreads", 2);
    final AuthType authType = ConfigUtil.getEnum(cfg, "auth", null, "type", AuthType.OPENID);
    reverseProxy = isReverseProxied(listenUrls);
    final Connector[] connectors = new Connector[listenUrls.length];
    for (int idx = 0; idx < listenUrls.length; idx++) {
        final URI u = listenUrls[idx];
        final int defaultPort;
        final ServerConnector c;
        HttpConfiguration config = defaultConfig(requestHeaderSize);
        if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType) && !"https".equals(u.getScheme())) {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "' when auth.type = '" + AuthType.CLIENT_SSL_CERT_LDAP.name() + "'; only 'https' is supported");
        }
        if ("http".equals(u.getScheme())) {
            defaultPort = 80;
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(config));
        } else if ("https".equals(u.getScheme())) {
            SslContextFactory ssl = new SslContextFactory();
            final File keystore = getFile(cfg, "sslkeystore", "etc/keystore");
            String password = cfg.getString("httpd", null, "sslkeypassword");
            if (password == null) {
                password = "gerrit";
            }
            ssl.setKeyStorePath(keystore.getAbsolutePath());
            ssl.setTrustStorePath(keystore.getAbsolutePath());
            ssl.setKeyStorePassword(password);
            ssl.setTrustStorePassword(password);
            if (AuthType.CLIENT_SSL_CERT_LDAP.equals(authType)) {
                ssl.setNeedClientAuth(true);
                File crl = getFile(cfg, "sslcrl", "etc/crl.pem");
                if (crl.exists()) {
                    ssl.setCrlPath(crl.getAbsolutePath());
                    ssl.setValidatePeerCerts(true);
                }
            }
            defaultPort = 443;
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new SslConnectionFactory(ssl, "http/1.1"), new HttpConnectionFactory(config));
        } else if ("proxy-http".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(config));
        } else if ("proxy-https".equals(u.getScheme())) {
            defaultPort = 8080;
            config.addCustomizer(new ForwardedRequestCustomizer());
            config.addCustomizer(new SecureRequestCustomizer());
            c = new ServerConnector(server, null, null, null, 0, acceptors, new HttpConnectionFactory(config));
        } else {
            throw new IllegalArgumentException("Protocol '" + u.getScheme() + "' " + " not supported in httpd.listenurl '" + u + "';" + " only 'http', 'https', 'proxy-http, 'proxy-https'" + " are supported");
        }
        try {
            if (u.getHost() == null && (// 
            u.getAuthority().equals("*") || u.getAuthority().startsWith("*:"))) {
                // Bind to all local addresses. Port wasn't parsed right by URI
                // due to the illegal host of "*" so replace with a legal name
                // and parse the URI.
                // 
                final URI r = new URI(u.toString().replace('*', 'A')).parseServerAuthority();
                c.setHost(null);
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            } else {
                final URI r = u.parseServerAuthority();
                c.setHost(r.getHost());
                c.setPort(0 < r.getPort() ? r.getPort() : defaultPort);
            }
        } catch (URISyntaxException e) {
            throw new IllegalArgumentException("Invalid httpd.listenurl " + u, e);
        }
        c.setReuseAddress(reuseAddress);
        connectors[idx] = c;
    }
    return connectors;
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProjectName(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getConfig().getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(value != null && editing && !value.getOwnerOf().isEmpty());
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing && value.canChangeParent());
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    final GitwebLink c = Gerrit.getGitwebLink();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), "refs/meta/config"), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#end_block

#method_before
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getProjectName());
}
#method_after
@Override
public void flush() {
    List<AccessSection> src = local.getList();
    List<AccessSection> keep = new ArrayList<AccessSection>(src.size());
    for (int i = 0; i < src.size(); i++) {
        AccessSectionEditor e = (AccessSectionEditor) localContainer.getWidget(i);
        if (!e.isDeleted() && !src.get(i).getPermissions().isEmpty()) {
            keep.add(src.get(i));
        }
    }
    value.setLocal(keep);
    value.setInheritsFrom(parentProjectBox.getParentProjectName());
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupCache)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (AccessSection.isAccessSection(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    detail.setRevision(config.getRevision().name());
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
        detail.setInheritsFrom(null);
    } else if (config.getProject().getParent() != null) {
        detail.setInheritsFrom(config.getProject().getParent());
    } else {
        detail.setInheritsFrom(allProjectsName);
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            config.commit(md);
            projectCache.evict(config.getProject());
            pc = open();
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (metaConfigControl.isVisible()) {
                local.add(section);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setCanUpload(pc.isOwner() || (metaConfigControl.isVisible() && metaConfigControl.canUpload()));
    detail.setCanChangeParent(pc.getCurrentUser().getCapabilities().canAdministrateServer());
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    detail.setLabelTypes(pc.getLabelTypes());
    return detail;
}
#end_block

#method_before
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    ObjectId base = ObjectId.fromString(baseRevision);
    changeProjectAccessFactory.create(projectName, base, sections, parentProjectName, msg).to(cb);
}
#method_after
@Override
public void changeProjectAccess(Project.NameKey projectName, String baseRevision, String msg, List<AccessSection> sections, Project.NameKey parentProjectName, AsyncCallback<ProjectAccess> cb) {
    changeProjectAccessFactory.create(projectName, getBase(baseRevision), sections, parentProjectName, msg).to(cb);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    Util.PROJECT_SVC.projectAccess(getProjectKey(), new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addFinal(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty());
    edit.setEnabled(!access.getOwnerOf().isEmpty());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent event) {
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    accessEditor.setEditing(true);
    driver.edit(access);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent event) {
    resetEditors();
    edit.setEnabled(false);
    cancel1.setVisible(true);
    UIObject.setVisible(commitTools, true);
    commit.setVisible(!access.getOwnerOf().isEmpty());
    review.setVisible(access.canUpload());
    accessEditor.setEditing(true);
    driver.edit(access);
}
#end_block

#method_before
@UiHandler("commit")
void onCommit(ClickEvent event) {
    ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess access) {
            enable(true);
            commitMessage.setText("");
            displayReadOnly(access);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            super.onFailure(caught);
        }
    });
}
#method_after
@UiHandler("commit")
void onCommit(ClickEvent event) {
    final ProjectAccess access = driver.flush();
    if (driver.hasErrors()) {
        Window.alert(Util.C.errorsMustBeFixed());
        return;
    }
    String message = commitMessage.getText().trim();
    if ("".equals(message)) {
        message = null;
    }
    enable(false);
    // 
    Util.PROJECT_SVC.changeProjectAccess(// 
    getProjectKey(), // 
    access.getRevision(), // 
    message, // 
    access.getLocal(), // 
    access.getInheritsFrom(), new GerritCallback<ProjectAccess>() {

        @Override
        public void onSuccess(ProjectAccess newAccess) {
            enable(true);
            commitMessage.setText("");
            error.clear();
            final Set<String> diffs = getDiffs(access, newAccess);
            if (diffs.isEmpty()) {
                displayReadOnly(newAccess);
            } else {
                error.add(new Label(Gerrit.C.projectAccessError()));
                for (final String diff : diffs) {
                    error.add(new Label(diff));
                }
                if (access.canUpload()) {
                    error.add(new Label(Gerrit.C.projectAccessProposeForReviewHint()));
                }
            }
        }

        private Set<String> getDiffs(ProjectAccess wantedAccess, ProjectAccess newAccess) {
            final List<AccessSection> wantedSections = mergeSections(removeEmptyPermissionsAndSections(wantedAccess.getLocal()));
            final HashSet<AccessSection> same = new HashSet<AccessSection>(wantedSections);
            final HashSet<AccessSection> different = new HashSet<AccessSection>(wantedSections.size() + newAccess.getLocal().size());
            different.addAll(wantedSections);
            different.addAll(newAccess.getLocal());
            same.retainAll(newAccess.getLocal());
            different.removeAll(same);
            final Set<String> differentNames = new HashSet<String>();
            for (final AccessSection s : different) {
                differentNames.add(s.getName());
            }
            return differentNames;
        }

        @Override
        public void onFailure(Throwable caught) {
            error.clear();
            enable(true);
            if (caught instanceof RemoteJsonException && caught.getMessage().startsWith(UpdateParentFailedException.MESSAGE)) {
                new ErrorDialog(Gerrit.M.parentUpdateFailed(caught.getMessage().substring(UpdateParentFailedException.MESSAGE.length() + 1))).center();
            } else {
                super.onFailure(caught);
            }
        }
    });
}
#end_block

#method_before
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#method_after
private void enable(boolean enabled) {
    commitMessage.setEnabled(enabled);
    commit.setEnabled(enabled ? !access.getOwnerOf().isEmpty() : false);
    review.setEnabled(enabled ? access.canUpload() : false);
    cancel1.setEnabled(enabled);
    cancel2.setEnabled(enabled);
}
#end_block

#method_before
public void setCanChangeParent(final boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#method_after
public void setCanChangeParent(boolean canChangeParent) {
    this.canChangeParent = canChangeParent;
}
#end_block

#method_before
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#method_after
public void testHeadRefReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/heads/master", "someHost", RefPushResult.SUCCEEDED);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicatedEventEquals.eqEvent(expectedEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#method_after
public void testChangeRefReplicated() throws URISyntaxException, OrmException {
    Change expectedChange = new Change(null, null, null, null, null);
    reset(changeAccessMock);
    expect(changeAccessMock.get(anyObject(Change.Id.class))).andReturn(expectedChange);
    replay(changeAccessMock);
    reset(changeHooksMock);
    RefReplicatedEvent expectedEvent = new RefReplicatedEvent("someProject", "refs/changes/1/1/1", "someHost", RefPushResult.FAILED);
    changeHooksMock.postEvent(eq(expectedChange), RefReplicatedEventEquals.eqEvent(expectedEvent), anyObject(ReviewDb.class));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToOneNode("someProject", "refs/changes/1/1/1", new URIish("git://someHost/someProject.git"), RefPushResult.FAILED);
    verify(changeHooksMock);
}
#end_block

#method_before
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), anyObject(RefReplicatedEvent.class));
    expectLastCall().times(5);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onOneNodeReplicated("someProject", "refs/heads/master", new URIish("git://someHost/someProject.git"), RefPushResult.SUCCEEDED);
    gitUpdateProcessing.onAllNodesReplicated(5);
    verify(changeHooksMock);
}
#method_after
public void testOnAllNodesReplicated() throws URISyntaxException {
    reset(changeHooksMock);
    RefReplicationDoneEvent expectedDoneEvent = new RefReplicationDoneEvent("someProject", "refs/heads/master", 5);
    changeHooksMock.postEvent(anyObject(Branch.NameKey.class), RefReplicationDoneEventEquals.eqEvent(expectedDoneEvent));
    expectLastCall().once();
    replay(changeHooksMock);
    gitUpdateProcessing.onRefReplicatedToAllNodes("someProject", "refs/heads/master", 5);
    verify(changeHooksMock);
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!checkObjectsEquals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!checkObjectsEquals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicatedEvent)) {
        return false;
    }
    RefReplicatedEvent actualRefReplicatedEvent = (RefReplicatedEvent) actual;
    if (!equals(expected.project, actualRefReplicatedEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedEvent.ref)) {
        return false;
    }
    if (!equals(expected.targetNode, actualRefReplicatedEvent.targetNode)) {
        return false;
    }
    if (!equals(expected.status, actualRefReplicatedEvent.status)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!checkObjectsEquals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!checkObjectsEquals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean matches(Object actual) {
    if (!(actual instanceof RefReplicationDoneEvent)) {
        return false;
    }
    RefReplicationDoneEvent actualRefReplicatedDoneEvent = (RefReplicationDoneEvent) actual;
    if (!equals(expected.project, actualRefReplicatedDoneEvent.project)) {
        return false;
    }
    if (!equals(expected.ref, actualRefReplicatedDoneEvent.ref)) {
        return false;
    }
    if (expected.nodesCount != actualRefReplicatedDoneEvent.nodesCount) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(ReplicationType.GIT_UPDATED, injector);
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(changeHooks, database));
    if (!running) {
        wrappedLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (refName.startsWith("refs/changes") || refName.startsWith("refs/cache-automerge")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#method_after
public boolean canReadCommit(RevWalk rw, RevCommit commit) {
    NameKey projName = state.getProject().getNameKey();
    try {
        Repository repo = repoManager.openRepository(projName);
        try {
            for (Entry<String, Ref> entry : repo.getAllRefs().entrySet()) {
                String refName = entry.getKey();
                if (!refName.startsWith("refs/heads") && !refName.startsWith("refs/tags")) {
                    continue;
                }
                RevCommit tip;
                try {
                    tip = rw.parseCommit(entry.getValue().getObjectId());
                } catch (IncorrectObjectTypeException e) {
                    continue;
                }
                if (rw.isMergedInto(commit, tip) && controlForRef(entry.getKey()).canPerform(Permission.READ)) {
                    return true;
                }
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projName.get());
        log.error(msg, e);
    }
    return controlForRef("refs/*").canPerform(Permission.READ);
}
#end_block

#method_before
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        PatchList patchList = null;
        if (repo != null) {
            try {
                patchList = getPatchList();
            } catch (PatchListNotAvailableException e) {
                patchList = null;
            }
        }
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            if (!pk.equals(currentFileKey)) {
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message\n");
                } else {
                    cmts.append(makeChangeLink(pk));
                    cmts.append("\n");
                    cmts.append("File ");
                    cmts.append(pk.getFileName());
                    cmts.append(":\n\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.get());
                    } catch (IOException e) {
                        log.warn(String.format("Cannot load %s from %s in %s", pk.getFileName(), patchList.getNewId().name(), projectState.getProject().getName()), e);
                        currentFileData = null;
                    }
                }
            }
            if (currentFileData != null) {
                appendComment(cmts, lines, currentFileData, c);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#method_after
public String getInlineComments(int lines) {
    StringBuilder cmts = new StringBuilder();
    final Repository repo = getRepository();
    try {
        PatchList patchList = null;
        if (repo != null) {
            try {
                patchList = getPatchList();
            } catch (PatchListNotAvailableException e) {
                patchList = null;
            }
        }
        Patch.Key currentFileKey = null;
        PatchFile currentFileData = null;
        for (final PatchLineComment c : inlineComments) {
            final Patch.Key pk = c.getKey().getParentKey();
            if (!pk.equals(currentFileKey)) {
                String link = makeLink(pk);
                if (link != null) {
                    cmts.append(link).append('\n');
                }
                if (Patch.COMMIT_MSG.equals(pk.get())) {
                    cmts.append("Commit Message:\n\n");
                } else {
                    cmts.append("File ").append(pk.get()).append(":\n\n");
                }
                currentFileKey = pk;
                if (patchList != null) {
                    try {
                        currentFileData = new PatchFile(repo, patchList, pk.get());
                    } catch (IOException e) {
                        log.warn(String.format("Cannot load %s from %s in %s", pk.getFileName(), patchList.getNewId().name(), projectState.getProject().getName()), e);
                        currentFileData = null;
                    }
                }
            }
            if (currentFileData != null) {
                appendComment(cmts, lines, currentFileData, c);
            }
            cmts.append("\n\n");
        }
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    return cmts.toString();
}
#end_block

#method_before
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, PatchLineComment comment) {
    int lineNbr = comment.getLine();
    short side = comment.getSide();
    int maxLines;
    try {
        maxLines = currentFileData.getLineCount(side);
    } catch (Throwable e) {
        maxLines = lineNbr;
    }
    final int startLine = Math.max(1, lineNbr - contextLines + 1);
    final int stopLine = Math.min(maxLines, lineNbr + contextLines);
    for (int line = startLine; line <= lineNbr; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
    appendParentSnippet(out, comment, db.get().patchComments());
    out.append(comment.getMessage().trim()).append('\n');
    for (int line = lineNbr + 1; line < stopLine; ++line) {
        appendFileLine(out, currentFileData, side, line);
    }
}
#method_after
private void appendComment(StringBuilder out, int contextLines, PatchFile currentFileData, PatchLineComment comment) {
    short side = comment.getSide();
    CommentRange range = comment.getRange();
    if (range != null) {
        String prefix = String.format("Line %d: ", range.getStartLine());
        out.append(prefix);
        for (int n = range.getStartLine(); n <= range.getEndLine(); n++) {
            out.append(n == range.getStartLine() ? prefix : Strings.padStart(": ", prefix.length(), ' '));
            try {
                String s = currentFileData.getLine(side, n);
                if (n == range.getStartLine() && n == range.getEndLine()) {
                    s = s.substring(Math.min(range.getStartCharacter(), s.length()), Math.min(range.getEndCharacter(), s.length()));
                } else if (n == range.getStartLine()) {
                    s = s.substring(Math.min(range.getStartCharacter(), s.length()));
                } else if (n == range.getEndLine()) {
                    s = s.substring(0, Math.min(range.getEndCharacter(), s.length()));
                }
                out.append(s);
            } catch (Throwable e) {
            // Don't quote the line if we can't safely convert it.
            }
            out.append('\n');
        }
        appendQuotedParent(out, comment);
        out.append(comment.getMessage().trim()).append('\n');
    } else {
        int lineNbr = comment.getLine();
        int maxLines;
        try {
            maxLines = currentFileData.getLineCount(side);
        } catch (Throwable e) {
            maxLines = lineNbr;
        }
        final int startLine = Math.max(1, lineNbr - contextLines + 1);
        final int stopLine = Math.min(maxLines, lineNbr + contextLines);
        for (int line = startLine; line <= lineNbr; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
        appendQuotedParent(out, comment);
        out.append(comment.getMessage().trim()).append('\n');
        for (int line = lineNbr + 1; line < stopLine; ++line) {
            appendFileLine(out, currentFileData, side, line);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(approve());
}
#method_after
@Test
public void reviewId() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).current().review(approve());
}
#end_block

#method_before
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).revision(r.getCommit().name());
    rApi.review(approve());
    rApi.submit(new SubmitInput());
}
#method_after
@Test
public void submit() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    RevisionApi rApi = gApi.changes().id("p~master~" + r.getChangeId()).current();
    rApi.review(approve());
    rApi.submit();
}
#end_block

#method_before
private static ReviewInput approve() {
    ReviewInput in = new ReviewInput();
    in.message = "Looks good!";
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    return in;
}
#method_after
private static ReviewInput approve() {
    return new ReviewInput().message("Looks good!").label("Code-Review", 2);
}
#end_block

#method_before
@Override
public void submit(SubmitInput in) throws RestApiException {
    try {
        submit.get().apply(revision, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot submit change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot submit change", e);
    }
}
#method_after
@Override
public void submit() throws RestApiException {
    SubmitInput in = new SubmitInput();
    in.waitForMerge = true;
    submit(in);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(admin.getId())));
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.admin();
    initSsh(admin);
    Project.NameKey project = new Project.NameKey("p");
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    db = reviewDbProvider.open();
    atrScope.set(atrScope.newContext(reviewDbProvider, sshSession, identifiedUserFactory.create(Providers.of(db), admin.getId())));
}
#end_block

#method_before
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
}
#method_after
@Test
public void abandon() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
}
#end_block

#method_before
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon(new AbandonInput());
    gApi.changes().id("p~master~" + r.getChangeId()).restore(new RestoreInput());
}
#method_after
@Test
public void restore() throws GitAPIException, IOException, RestApiException {
    PushOneCommit.Result r = createChange();
    gApi.changes().id("p~master~" + r.getChangeId()).abandon();
    gApi.changes().id("p~master~" + r.getChangeId()).restore();
}
#end_block

#method_before
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            SubmitInput input = new SubmitInput();
            input.waitForMerge = true;
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit(input);
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).deleteDraftPatchSet(new DeleteDraftPatchSetInput());
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#method_after
private void approveOne(final PatchSet patchSet) throws Exception {
    if (changeComment == null) {
        changeComment = "";
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(changeComment);
    review.labels = Maps.newTreeMap();
    review.drafts = ReviewInput.DraftHandling.PUBLISH;
    review.strictLabels = false;
    for (ApproveOption ao : optionList) {
        Short v = ao.value();
        if (v != null) {
            review.labels.put(ao.getLabelName(), v);
        }
    }
    review.labels.putAll(customLabels);
    // or restore comment.
    if (!review.labels.isEmpty() && (abandonChange || restoreChange)) {
        changeComment = null;
    }
    try {
        if (abandonChange) {
            AbandonInput input = new AbandonInput();
            input.message = changeComment;
            applyReview(patchSet, review);
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).abandon(input);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.ABANDON_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_IS_CLOSED) + "\n");
            }
        } else if (restoreChange) {
            RestoreInput input = new RestoreInput();
            input.message = changeComment;
            try {
                gApi.get().changes().id(patchSet.getId().getParentKey().get()).restore(input);
                applyReview(patchSet, review);
            } catch (AuthException e) {
                writeError("error: " + parseError(Type.RESTORE_NOT_PERMITTED) + "\n");
            } catch (ResourceConflictException e) {
                writeError("error: " + parseError(Type.CHANGE_NOT_ABANDONED) + "\n");
            }
        } else {
            applyReview(patchSet, review);
        }
        if (submitChange) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).submit();
        }
        if (publishPatchSet) {
            final ReviewResult result = publishDraftFactory.create(patchSet.getId()).call();
            handleReviewResultErrors(result);
        } else if (deleteDraftPatchSet) {
            gApi.get().changes().id(patchSet.getId().getParentKey().get()).revision(patchSet.getRevision().get()).delete();
        }
    } catch (InvalidChangeOperationException e) {
        throw error(e.getMessage());
    } catch (IllegalStateException e) {
        throw error(e.getMessage());
    } catch (AuthException e) {
        throw error(e.getMessage());
    } catch (BadRequestException e) {
        throw error(e.getMessage());
    } catch (ResourceConflictException e) {
        throw error(e.getMessage());
    } catch (RestApiException e) {
        throw error(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon() throws RestApiException {
    abandon(new AbandonInput());
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon review", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot abandon change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore() throws RestApiException {
    restore(new RestoreInput());
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore review", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore review", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.get().apply(change, in);
    } catch (OrmException e) {
        throw new RestApiException("Cannot restore change", e);
    } catch (IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
private void approve(String changeId) throws IOException {
    ReviewInput in = new ReviewInput();
    in.labels = Maps.newHashMap();
    in.labels.put("Code-Review", (short) 2);
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", in);
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#method_after
private void approve(String changeId) throws IOException {
    RestResponse r = session.post("/changes/" + changeId + "/revisions/current/review", new ReviewInput().label("Code-Review", 2));
    assertEquals(HttpStatus.SC_OK, r.getStatusCode());
    r.consume();
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, AbandonInput input) throws BadRequestException, AuthException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canAbandon()) {
        throw new AuthException("abandon not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = abandonedSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeAbandonedHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), db);
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    Object result = input.render ? json.format(change) : Response.none();
    indexFuture.checkedGet();
    return result;
}
#method_after
@Override
public Object apply(ChangeResource req, RestoreInput input) throws OrmException, IOException, AuthException, ResourceConflictException {
    ChangeControl control = req.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = req.getChange();
    if (!control.canRestore()) {
        throw new AuthException("restore not permitted");
    } else if (change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    ChangeMessage message;
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus() == Status.ABANDONED) {
                    change.setStatus(Status.NEW);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("change is " + status(db.changes().get(req.getChange().getId())));
        }
        message = newMessage(input, caller, change);
        db.changeMessages().insert(Collections.singleton(message));
        new ApprovalsUtil(db).syncChangeStatus(change);
        db.commit();
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
    try {
        ReplyToChangeSender cm = restoredSenderFactory.create(change);
        cm.setFrom(caller.getAccountId());
        cm.setChangeMessage(message);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getChangeId(), e);
    }
    hooks.doChangeRestoredHook(change, caller.getAccount(), db.patchSets().get(change.currentPatchSetId()), Strings.emptyToNull(input.message), dbProvider.get());
    ChangeInfo result = json.format(change);
    indexFuture.checkedGet();
    return result;
}
#end_block

#method_before
public static void toggleStar(final Change.Id changeId, final boolean newValue) {
    if (next == null) {
        next = new ToggleStarRequest();
    }
    next.toggle(changeId, newValue);
    fireChangeStarEvent(changeId, newValue);
    if (!busy) {
        start();
    }
}
#method_after
public static void toggleStar(final Change.Id changeId, final boolean newValue) {
    pending.put(changeId, newValue);
    fireChangeStarEvent(changeId, newValue);
    if (!busy) {
        startRequest();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    post(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    post(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    post(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(Change.Id id, CurrentUser user) throws NoSuchChangeException {
    final Change change;
    try {
        change = db.get().changes().get(id);
        if (change == null) {
            throw new NoSuchChangeException(id);
        }
    } catch (OrmException e) {
        throw new NoSuchChangeException(id, e);
    }
    return controlFor(change, user);
}
#end_block

#method_before
public boolean canPublish(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canPublish(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canPublishDrafts()) && isVisible(db);
}
#end_block

#method_before
public boolean canDeleteDraft(final ReviewDb db) throws OrmException {
    return isOwner() && isVisible(db);
}
#method_after
public boolean canDeleteDraft(final ReviewDb db) throws OrmException {
    return (isOwner() || getRefControl().canDeleteDrafts()) && isVisible(db);
}
#end_block

#method_before
public boolean isOwner() {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#method_after
public boolean isOwner() {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
        return i.getAccountId().equals(change.getOwner());
    }
    return false;
}
#end_block

#method_before
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser() instanceof IdentifiedUser) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isReviewer(ReviewDb db, @Nullable ChangeData cd) throws OrmException {
    if (getCurrentUser().isIdentifiedUser()) {
        final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
        Iterable<PatchSetApproval> results;
        if (cd != null) {
            results = cd.currentApprovals(Providers.of(db));
        } else {
            results = db.patchSetApprovals().byChange(change.getId());
        }
        for (PatchSetApproval approval : results) {
            if (user.getAccountId().equals(approval.getAccountId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(PatchSetApproval approval) {
    return canRemoveReviewer(approval.getAccountId(), approval.getValue());
}
#end_block

#method_before
public boolean canRemoveReviewer(PatchSetApproval approval) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser() instanceof IdentifiedUser) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(approval.getAccountId())) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= approval.getValue()) {
            return true;
        }
        // 
        if (// branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean canRemoveReviewer(Account.Id reviewer, int value) {
    if (getChange().getStatus().isOpen()) {
        // 
        if (getCurrentUser().isIdentifiedUser()) {
            final IdentifiedUser i = (IdentifiedUser) getCurrentUser();
            if (i.getAccountId().equals(reviewer)) {
                // can remove self
                return true;
            }
        }
        // 
        if (isOwner() && 0 <= value) {
            return true;
        }
        // owner and site admin can remove anyone
        if (// has removal permissions
        getRefControl().canRemoveReviewer() || // branch owner
        getRefControl().isOwner() || // project owner
        getProjectControl().isOwner() || getCurrentUser().getCapabilities().canAdministrateServer()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public List<SubmitRecord> getSubmitRecords(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, true);
}
#method_after
public List<SubmitRecord> getSubmitRecords(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, true, false);
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet, @Nullable ChangeData cd, boolean fastEvalLabels, boolean allowClosed) {
    if (!allowClosed && change.getStatus().isClosed()) {
        SubmitRecord rec = new SubmitRecord();
        rec.status = SubmitRecord.Status.CLOSED;
        return Collections.singletonList(rec);
    }
    if (!patchSet.getId().equals(change.currentPatchSetId())) {
        return ruleError("Patch set " + patchSet.getPatchSetId() + " is not current");
    }
    try {
        if (change.getStatus() == Change.Status.DRAFT) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft changes");
            }
        }
        if (patchSet.isDraft()) {
            if (!isDraftVisible(db, cd)) {
                return ruleError("Patch set " + patchSet.getPatchSetId() + " not found");
            } else {
                return ruleError("Cannot submit draft patch sets");
            }
        }
    } catch (OrmException err) {
        return logRuleError("Cannot read patch set " + patchSet.getId(), err);
    }
    List<Term> results = new ArrayList<Term>();
    Term submitRule;
    ProjectState projectState = getProjectControl().getProjectState();
    PrologEnvironment env;
    try {
        env = projectState.newPrologEnvironment();
    } catch (CompileException err) {
        return logRuleError("Cannot consult rules.pl for " + getProject().getName(), err);
    }
    try {
        env.set(StoredValues.REVIEW_DB, db);
        env.set(StoredValues.CHANGE, change);
        env.set(StoredValues.CHANGE_DATA, cd);
        env.set(StoredValues.PATCH_SET, patchSet);
        env.set(StoredValues.CHANGE_CONTROL, this);
        submitRule = env.once("gerrit", "locate_submit_rule", new VariableTerm());
        if (submitRule == null) {
            return logRuleError("No user:submit_rule found for " + getProject().getName());
        }
        if (fastEvalLabels) {
            env.once("gerrit", "assume_range_from_label");
        }
        try {
            for (Term[] template : env.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
                results.add(template[1]);
            }
        } catch (PrologException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        } catch (RuntimeException err) {
            return logRuleError("Exception calling " + submitRule + " on change " + change.getId() + " of " + getProject().getName(), err);
        }
        ProjectState parentState = projectState.getParentState();
        PrologEnvironment childEnv = env;
        Set<Project.NameKey> projectsSeen = new HashSet<Project.NameKey>();
        projectsSeen.add(getProject().getNameKey());
        while (parentState != null) {
            if (!projectsSeen.add(parentState.getProject().getNameKey())) {
                // parent has been seen before, stop walk up inheritance tree
                break;
            }
            PrologEnvironment parentEnv;
            try {
                parentEnv = parentState.newPrologEnvironment();
            } catch (CompileException err) {
                return logRuleError("Cannot consult rules.pl for " + parentState.getProject().getName(), err);
            }
            parentEnv.copyStoredValues(childEnv);
            Term filterRule = parentEnv.once("gerrit", "locate_submit_filter", new VariableTerm());
            if (filterRule != null) {
                try {
                    if (fastEvalLabels) {
                        env.once("gerrit", "assume_range_from_label");
                    }
                    Term resultsTerm = toListTerm(results);
                    results.clear();
                    Term[] template = parentEnv.once("gerrit", "filter_submit_results", filterRule, resultsTerm, new VariableTerm());
                    @SuppressWarnings("unchecked")
                    final List<? extends Term> termList = ((ListTerm) template[2]).toJava();
                    results.addAll(termList);
                } catch (PrologException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                } catch (RuntimeException err) {
                    return logRuleError("Exception calling " + filterRule + " on change " + change.getId() + " of " + parentState.getProject().getName(), err);
                }
            }
            parentState = parentState.getParentState();
            childEnv = parentEnv;
        }
    } finally {
        env.close();
    }
    if (results.isEmpty()) {
        // This should never occur. A well written submit rule will always produce
        // at least one result informing the caller of the labels that are
        // required for this change to be submittable. Each label will indicate
        // whether or not that is actually possible given the permissions.
        log.error("Submit rule " + submitRule + " for change " + change.getId() + " of " + getProject().getName() + " has no solution.");
        return ruleError("Project submit rule has no solution");
    }
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            try {
                if ("ok".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.OK;
                    appliedBy(lbl, status);
                } else if ("reject".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.REJECT;
                    appliedBy(lbl, status);
                } else if ("need".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.NEED;
                } else if ("may".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.MAY;
                } else if ("impossible".equals(status.name())) {
                    lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
                } else {
                    return logInvalidResult(submitRule, submitRecord);
                }
            } catch (UserTermExpected e) {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public boolean canSubmit() {
    return getRefControl().canSubmit();
}
#end_block

#method_before
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, false);
}
#method_after
public List<SubmitRecord> canSubmit(ReviewDb db, PatchSet patchSet) {
    return canSubmit(db, patchSet, null, false, false, false);
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record, String reason) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record + (reason == null ? "" : ". Reason: " + reason));
}
#end_block

#method_before
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logRuleError("Submit rule " + rule + " for change " + change.getId() + " of " + getProject().getName() + " output invalid result: " + record);
}
#method_after
private List<SubmitRecord> logInvalidResult(Term rule, Term record) {
    return logInvalidResult(rule, record, null);
}
#end_block

#method_before
private boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd);
}
#method_after
private boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd) || getRefControl().canViewDrafts();
}
#end_block

#method_before
private static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#method_after
public static Term toListTerm(List<Term> terms) {
    Term list = Prolog.Nil;
    for (int i = terms.size() - 1; i >= 0; i--) {
        list = new ListTerm(terms.get(i), list);
    }
    return list;
}
#end_block

