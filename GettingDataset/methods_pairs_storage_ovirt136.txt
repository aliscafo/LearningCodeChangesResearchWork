1064
#method_before
private String composeExistingVmsWarningMessage(List<T> existingVms) {
    final StringBuffer s = new StringBuffer();
    for (T t : existingVms) {
        if (s.length() > 0) {
            // $NON-NLS-1$
            s.append(", ");
        }
        s.append(extractNameFromEntity(t));
    }
    return s.toString();
}
#method_after
private String composeExistingVmsWarningMessage(List<T> existingVms) {
    final List<String> list = new ArrayList<String>();
    for (T t : existingVms) {
        list.add(extractNameFromEntity(t));
    }
    // $NON-NLS-1$
    return StringUtils.join(list, ", ");
}
#end_block

#method_before
private void sendWarningForNonExportableDisks(List<Disk> nonExportableDisks) {
    if (!nonExportableDisks.isEmpty()) {
        final StringBuilder s = new StringBuilder();
        for (Disk disk : nonExportableDisks) {
            if (s.length() > 0) {
                // $NON-NLS-1$
                s.append(", ");
            }
            s.append(disk.getDiskAlias());
        }
        // append warning message
        getModel().setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMTemplate(s.toString()));
    }
}
#method_after
private void sendWarningForNonExportableDisks(List<Disk> nonExportableDisks) {
    if (!nonExportableDisks.isEmpty()) {
        final List<String> list = new ArrayList<String>();
        for (Disk disk : nonExportableDisks) {
            list.add(disk.getDiskAlias());
        }
        // $NON-NLS-1$
        final String s = StringUtils.join(list, ", ");
        // append warning message
        getModel().setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMTemplate(s));
    }
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    messageHTML.appendText(message);
}
#method_after
@Override
public void setMessage(String message) {
    if (message == null) {
        return;
    }
    messagePanel.add(new Label(message));
}
#end_block

#method_before
@Override
public void edit(final UnitVmModel model) {
    Driver.driver.edit(model);
    model.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            addDiskAllocation(model);
        }
    });
    model.getStorageDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isDisksAllocationEnabled = model.getDisks() != null && !model.getDisks().isEmpty();
            disksAllocationView.setEnabled(isDisksAllocationEnabled);
            // $NON-NLS-1$ //$NON-NLS-2$
            disksAllocationLabel.getElement().getStyle().setColor(isDisksAllocationEnabled ? "black" : "grey");
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                VmMakeTemplatePopupWidget.this.setMessage(model.getMessage());
            }
        }
    });
}
#method_after
@Override
public void edit(final UnitVmModel model) {
    Driver.driver.edit(model);
    model.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            addDiskAllocation(model);
        }
    });
    model.getStorageDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isDisksAllocationEnabled = model.getDisks() != null && !model.getDisks().isEmpty();
            disksAllocationView.setEnabled(isDisksAllocationEnabled);
            // $NON-NLS-1$ //$NON-NLS-2$
            disksAllocationLabel.getElement().getStyle().setColor(isDisksAllocationEnabled ? "black" : "grey");
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            }
        }
    });
}
#end_block

#method_before
void sendWarningForNonExportableDisks(ArrayList<Disk> disks) {
    // filter non-exportable disks
    final List<Disk> nonExportableDisks = new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!disk.isAllowSnapshot()) {
            nonExportableDisks.add(disk);
        }
    }
    if (!nonExportableDisks.isEmpty()) {
        final StringBuilder s = new StringBuilder();
        for (Disk disk : nonExportableDisks) {
            if (s.length() > 0) {
                // $NON-NLS-1$
                s.append(", ");
            }
            s.append(disk.getDiskAlias());
        }
        // append warning message
        setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMSnapshot(s.toString()));
    }
}
#method_after
void sendWarningForNonExportableDisks(ArrayList<Disk> disks) {
    // filter non-exportable disks
    final List<String> list = new ArrayList<String>();
    for (Disk disk : disks) {
        if (!disk.isAllowSnapshot()) {
            list.add(disk.getDiskAlias());
        }
    }
    if (!list.isEmpty()) {
        // $NON-NLS-1$
        final String s = StringUtils.join(list, ", ");
        // append warning message
        setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVMSnapshot(s));
    }
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.GetVmDiskList(new AsyncQuery((ExportVmModel) getWindow(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> diskList = (ArrayList<Disk>) returnValue;
            final List<Disk> nonExportableDisks = new ArrayList<Disk>();
            for (Disk disk : diskList) {
                if (!disk.isAllowSnapshot()) {
                    nonExportableDisks.add(disk);
                }
            }
            if (!nonExportableDisks.isEmpty()) {
                final StringBuilder s = new StringBuilder();
                for (Disk disk : nonExportableDisks) {
                    if (s.length() > 0) {
                        // $NON-NLS-1$
                        s.append(", ");
                    }
                    s.append(disk.getDiskAlias());
                }
                // append warning message
                model.setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVM(s.toString()));
            }
        }
    }), entity.getId());
}
#method_after
@Override
protected void sendWarningForNonExportableDisks(VM entity) {
    // load VM disks and check if there is one which doesn't allow snapshot
    AsyncDataProvider.GetVmDiskList(new AsyncQuery((ExportVmModel) getWindow(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final ExportVmModel model = (ExportVmModel) target;
            @SuppressWarnings("unchecked")
            final ArrayList<Disk> diskList = (ArrayList<Disk>) returnValue;
            // filter non-exportable disks
            final List<String> list = new ArrayList<String>();
            for (Disk disk : diskList) {
                if (!disk.isAllowSnapshot()) {
                    list.add(disk.getDiskAlias());
                }
            }
            if (!list.isEmpty()) {
                // $NON-NLS-1$
                final String s = StringUtils.join(list, ", ");
                // append warning message
                model.setMessage(ConstantsManager.getInstance().getMessages().disksWillNotBePartOfTheExportedVM(s));
            }
        }
    }), entity.getId());
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    RunOnceLoadHosts(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsAutoAssign().setEntity(true);
}
#end_block

#method_before
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#method_after
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    // set destination host if specified
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        tempVar.setDestinationVdsId(null);
    } else {
        tempVar.setDestinationVdsId(defaultHost != null ? defaultHost.getId() : null);
    }
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public void edit(final SnapshotModel model) {
    Driver.driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                VmSnapshotCreatePopupWidget.this.setMessage(model.getMessage());
            }
        }
    });
}
#method_after
@Override
public void edit(final SnapshotModel model) {
    Driver.driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            }
        }
    });
}
#end_block

#method_before
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleUserId() == null || vm.getConsoleUserId().equals(Frontend.getLoggedInUser().getUserId())) {
        command.Execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    GetRoleActionGroupsByUserIdParameters params = new GetRoleActionGroupsByUserIdParameters(vm.getConsoleUserId());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            List<ActionGroup> resultList = ((List<ActionGroup>) returnValue.getReturnValue());
            if (resultList.contains(ActionGroup.RECONNECT_TO_VM)) {
                command.Execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetRoleActionGroupsByUserId, params, query);
}
#method_after
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getLoggedInUser().getUserId().equals(vm.getConsoleUserId())) {
        command.Execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    HasAdElementReconnectPermissionParameters params = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId().getValue(), vm.getId().getValue());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            boolean returnValue = ((Boolean) ((VdcQueryReturnValue) result).getReturnValue());
            if (returnValue) {
                command.Execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, params, query);
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setParentModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        } else if (selectionContextChanged(vm)) {
            // if new data comes which has changed the selection context, (e.g. the OS type changed)
            // recalculate the default selected protocol
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#method_after
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        } else if (selectionContextChanged(vm)) {
            // if new data comes which has changed the selection context, (e.g. the OS type changed)
            // recalculate the default selected protocol
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#end_block

#method_before
@Override
protected void Connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().Debug("Connecting to Spice console...");
        if (!getspice().getIsInstalled()) {
            // $NON-NLS-1$
            getLogger().Info("Spice client is not installed.");
            getspice().Install();
            return;
        }
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            getLogger().Info("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            getspice().Install();
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!getEntity().getVmOs().isWindows() || getEntity().getSpiceDriverVersion() == null) {
            getspice().setIsWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#method_after
@Override
protected void Connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().Debug("Connecting to Spice console...");
        if (!getspice().getIsInstalled()) {
            // $NON-NLS-1$
            getLogger().Info("Spice client is not installed.");
            getspice().Install();
            return;
        }
        // Check a spice version.
        if (getConfigurator().getIsAdmin() && getspice().getCurrentVersion().compareTo(getspice().getDesiredVersion()) < 0) {
            // $NON-NLS-1$ //$NON-NLS-2$
            getLogger().Info("Spice client version is not as desired (" + getspice().getDesiredVersion() + ")");
            getspice().Install();
            return;
        }
        // Don't connect if there VM is not running on any host.
        if (getEntity().getRunOnVds() == null) {
            return;
        }
        // If it is not windows or SPICE guest agent is not installed, make sure the WAN options are disabled.
        if (!getEntity().getVmOs().isWindows() || !getEntity().getHasSpiceDriver()) {
            getspice().setIsWanOptionsEnabled(false);
        }
        UICommand setVmTicketCommand = new UICommand("setVmCommand", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void ExecuteCommand(UICommand uiCommand) {
                setVmTicket();
            }
        });
        executeCommandWithConsoleSafenessWarning(setVmTicketCommand);
    }
}
#end_block

#method_before
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
    // save console flag
    Frontend.RunAction(VdcActionType.UpdateVmConsoleData, new UpdateVmConsoleDataParameters(getEntity().getId(), null), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        // Ignore result, this tries to update vm console data
        // nothing to do with result
        }
    });
}
#method_after
private void Spice_Disconnected(Object sender, ErrorCodeEventArgs e) {
    getspice().getDisconnectedEvent().removeListener(this);
    getspice().getMenuItemSelectedEvent().removeListener(this);
    setIsConnected(false);
    UpdateActionAvailability();
    if (e.getErrorCode() > 100) {
        getErrorEvent().raise(this, e);
    }
}
#end_block

#method_before
private void ExecuteQuery(final VM vm) {
    AsyncQuery _asyncQuery0 = new AsyncQuery();
    _asyncQuery0.setModel(this);
    _asyncQuery0.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model0, Object result0) {
            SpiceConsoleModel thisSpiceConsoleModel = (SpiceConsoleModel) model0;
            VM thisVm = thisSpiceConsoleModel.getEntity();
            storage_domains isoDomain = null;
            if (result0 != null) {
                isoDomain = (storage_domains) result0;
            }
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetVdsCertificateSubjectByVmId);
            queryTypeList.add(VdcQueryType.GetCACertificate);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SSLEnabled, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.CipherSuite, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceSecureChannels, thisVm.getVdsGroupCompatibilityVersion().toString()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.EnableSpiceRootCertificateValidation, Config.DefaultConfigurationVersion));
            parametersList.add(new GetVmByVmIdParameters(thisVm.getId()));
            parametersList.add(new VdcQueryParametersBase());
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceToggleFullScreenKeys, Config.DefaultConfigurationVersion));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceReleaseCursorKeys, Config.DefaultConfigurationVersion));
            if (isoDomain != null) {
                queryTypeList.add(VdcQueryType.GetAllIsoImagesListByStoragePoolId);
                GetAllImagesListByStoragePoolIdParameters getIsoPamams = new GetAllImagesListByStoragePoolIdParameters(vm.getStoragePoolId());
                parametersList.add(getIsoPamams);
            }
            Frontend.RunMultipleQueries(queryTypeList, parametersList, thisSpiceConsoleModel);
        }
    };
    AsyncDataProvider.GetIsoDomainByDataCenterId(_asyncQuery0, vm.getStoragePoolId());
}
#method_after
private void ExecuteQuery(final VM vm) {
    AsyncQuery _asyncQuery0 = new AsyncQuery();
    _asyncQuery0.setModel(this);
    _asyncQuery0.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model0, Object result0) {
            SpiceConsoleModel thisSpiceConsoleModel = (SpiceConsoleModel) model0;
            VM thisVm = thisSpiceConsoleModel.getEntity();
            storage_domains isoDomain = null;
            if (result0 != null) {
                isoDomain = (storage_domains) result0;
            }
            ArrayList<VdcQueryType> queryTypeList = new ArrayList<VdcQueryType>();
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetVdsCertificateSubjectByVmId);
            queryTypeList.add(VdcQueryType.GetCACertificate);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            queryTypeList.add(VdcQueryType.GetConfigurationValue);
            ArrayList<VdcQueryParametersBase> parametersList = new ArrayList<VdcQueryParametersBase>();
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SSLEnabled, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.CipherSuite, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceSecureChannels, thisVm.getVdsGroupCompatibilityVersion().toString()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.EnableSpiceRootCertificateValidation, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetVmByVmIdParameters(thisVm.getId()));
            parametersList.add(new VdcQueryParametersBase());
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceToggleFullScreenKeys, AsyncDataProvider.getDefaultConfigurationVersion()));
            parametersList.add(new GetConfigurationValueParameters(ConfigurationValues.SpiceReleaseCursorKeys, AsyncDataProvider.getDefaultConfigurationVersion()));
            if (isoDomain != null) {
                queryTypeList.add(VdcQueryType.GetAllIsoImagesListByStoragePoolId);
                GetAllImagesListByStoragePoolIdParameters getIsoPamams = new GetAllImagesListByStoragePoolIdParameters(vm.getStoragePoolId());
                parametersList.add(getIsoPamams);
            }
            Frontend.RunMultipleQueries(queryTypeList, parametersList, thisSpiceConsoleModel);
        }
    };
    AsyncDataProvider.GetIsoDomainByDataCenterId(_asyncQuery0, vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#method_after
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : !getEntity().getHasSpiceDriver());
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#end_block

#method_before
public void PostSendVmTicket(VdcReturnValueBase returnValue) {
    if (returnValue == null || !returnValue.getSucceeded()) {
        return;
    }
    ticket = (String) returnValue.getActionReturnValue();
    // we attempt to perform SSO (otherwise an error will be thrown)
    if (!getConfigurator().getIsAdmin() && getEntity().getGuestAgentVersion() != null && getEntity().getStatus() == VMStatus.Up) {
        getLogger().Info(// $NON-NLS-1$
        "SpiceConsoleManager::Connect: Attempting to perform SSO on Desktop " + getEntity().getVmName());
        Frontend.RunAction(VdcActionType.VmLogon, new VmOperationParameterBase(getEntity().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                final SpiceConsoleModel spiceConsoleModel = (SpiceConsoleModel) result.getState();
                final VdcReturnValueBase logonCommandReturnValue = result.getReturnValue();
                boolean isLogonSucceeded = logonCommandReturnValue != null && logonCommandReturnValue.getSucceeded();
                if (isLogonSucceeded) {
                    spiceConsoleModel.ExecuteQuery(getEntity());
                } else {
                    if (logonCommandReturnValue != null && logonCommandReturnValue.getFault().getError() == VdcBllErrors.nonresp) {
                        UICommand okCommand = new UICommand("SpiceWithoutAgentOK", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                logSsoOnDesktopFailedAgentNonResp(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                                "");
                                spiceConsoleModel.ExecuteQuery(getEntity());
                                parentModel.setWindow(null);
                            }
                        });
                        UICommand cancelCommand = new UICommand("SpiceWithoutAgentCancel", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                parentModel.setWindow(null);
                            }
                        });
                        createConnectWithoutAgentConfirmationPopup(okCommand, cancelCommand);
                    } else {
                        logSsoOnDesktopFailed(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                        "");
                    }
                }
            }
        }, this);
    } else {
        ExecuteQuery(getEntity());
    }
}
#method_after
public void PostSendVmTicket(VdcReturnValueBase returnValue) {
    if (returnValue == null || !returnValue.getSucceeded()) {
        return;
    }
    ticket = (String) returnValue.getActionReturnValue();
    // we attempt to perform SSO (otherwise an error will be thrown)
    if (!getConfigurator().getIsAdmin() && getEntity().getHasAgent() && getEntity().getStatus() == VMStatus.Up) {
        getLogger().Info(// $NON-NLS-1$
        "SpiceConsoleManager::Connect: Attempting to perform SSO on Desktop " + getEntity().getVmName());
        Frontend.RunAction(VdcActionType.VmLogon, new VmOperationParameterBase(getEntity().getId()), new IFrontendActionAsyncCallback() {

            @Override
            public void Executed(FrontendActionAsyncResult result) {
                final SpiceConsoleModel spiceConsoleModel = (SpiceConsoleModel) result.getState();
                final VdcReturnValueBase logonCommandReturnValue = result.getReturnValue();
                boolean isLogonSucceeded = logonCommandReturnValue != null && logonCommandReturnValue.getSucceeded();
                if (isLogonSucceeded) {
                    spiceConsoleModel.ExecuteQuery(getEntity());
                } else {
                    if (logonCommandReturnValue != null && logonCommandReturnValue.getFault().getError() == VdcBllErrors.nonresp) {
                        UICommand okCommand = new UICommand("SpiceWithoutAgentOK", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                logSsoOnDesktopFailedAgentNonResp(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                                "");
                                spiceConsoleModel.ExecuteQuery(getEntity());
                                parentModel.setWindow(null);
                            }
                        });
                        UICommand cancelCommand = new UICommand("SpiceWithoutAgentCancel", new // $NON-NLS-1$
                        BaseCommandTarget() {

                            @Override
                            public void ExecuteCommand(UICommand uiCommand) {
                                parentModel.setWindow(null);
                            }
                        });
                        createConnectWithoutAgentConfirmationPopup(okCommand, cancelCommand);
                    } else {
                        logSsoOnDesktopFailed(spiceConsoleModel.getLogger(), logonCommandReturnValue != null ? logonCommandReturnValue.getDescription() : // $NON-NLS-1$
                        "");
                    }
                }
            }
        }, this);
    } else {
        ExecuteQuery(getEntity());
    }
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.setParentModel(this);
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setParentModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    RunOnceLoadHosts(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsAutoAssign().setEntity(true);
}
#end_block

#method_before
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#method_after
private void OnRunOnce() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        Cancel();
        return;
    }
    RunOnceModel model = (RunOnceModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    BootSequenceModel bootSequenceModel = model.getBootSequence();
    RunVmOnceParams tempVar = new RunVmOnceParams();
    tempVar.setVmId(vm.getId());
    tempVar.setBootSequence(bootSequenceModel.getSequence());
    tempVar.setDiskPath((Boolean) model.getAttachIso().getEntity() ? (String) model.getIsoImage().getSelectedItem() : // $NON-NLS-1$
    "");
    tempVar.setFloppyPath(model.getFloppyImagePath());
    tempVar.setKvmEnable(model.getHwAcceleration());
    tempVar.setRunAndPause((Boolean) model.getRunAndPause().getEntity());
    tempVar.setAcpiEnable(true);
    tempVar.setRunAsStateless((Boolean) model.getRunAsStateless().getEntity());
    tempVar.setReinitialize(model.getReinitialize());
    tempVar.setCustomProperties(model.getCustomPropertySheet().getEntity());
    // set destination host if specified
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        tempVar.setDestinationVdsId(null);
    } else {
        tempVar.setDestinationVdsId(defaultHost != null ? defaultHost.getId() : null);
    }
    RunVmOnceParams param = tempVar;
    // kernel params
    if (model.getKernel_path().getEntity() != null) {
        param.setkernel_url((String) model.getKernel_path().getEntity());
    }
    if (model.getKernel_parameters().getEntity() != null) {
        param.setkernel_params((String) model.getKernel_parameters().getEntity());
    }
    if (model.getInitrd_path().getEntity() != null) {
        param.setinitrd_url((String) model.getInitrd_path().getEntity());
    }
    // Sysprep params
    if (model.getSysPrepDomainName().getSelectedItem() != null) {
        param.setSysPrepDomainName(model.getSysPrepSelectedDomainName().getEntity().equals("") ? (String) // $NON-NLS-1$
        model.getSysPrepSelectedDomainName().getEntity() : (String) model.getSysPrepDomainName().getSelectedItem());
    }
    if (model.getSysPrepUserName().getEntity() != null) {
        param.setSysPrepUserName((String) model.getSysPrepUserName().getEntity());
    }
    if (model.getSysPrepPassword().getEntity() != null) {
        param.setSysPrepPassword((String) model.getSysPrepPassword().getEntity());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    param.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) model.getDisplayConsole_Spice_IsSelected().getEntity()) {
        param.setUseVnc((Boolean) model.getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    Frontend.RunAction(VdcActionType.RunVmOnce, param, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
        }
    }, this);
    Cancel();
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public void triggerPoolMonitoringJob() {
    SchedulerUtilQuartzImpl.getInstance().triggerJob(poolMonitoringJobId);
}
#method_after
@Override
@ExcludeClassInterceptors
public void triggerPoolMonitoringJob() {
    SchedulerUtilQuartzImpl.getInstance().triggerJob(poolMonitoringJobId);
}
#end_block

#method_before
protected static int getNumOfPrestartedVmsInPool(NGuid poolId) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (isPrestartedVm(vm))
                ++numOfPrestartedVmsInPool;
        }
    }
    return numOfPrestartedVmsInPool;
}
#method_after
protected static int getNumOfPrestartedVmsInPool(NGuid poolId) {
    List<VM> vmsInPool = DbFacade.getInstance().getVmDao().getAllForVmPool(poolId);
    int numOfPrestartedVmsInPool = 0;
    if (vmsInPool != null) {
        for (VM vm : vmsInPool) {
            if (vm.isStartingOrUp() && canAttachPrestartedVmToUser(vm.getId()))
                ++numOfPrestartedVmsInPool;
        }
    }
    return numOfPrestartedVmsInPool;
}
#end_block

#method_before
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new java.util.ArrayList<String>());
}
#method_after
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new ArrayList<String>());
}
#end_block

#method_before
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // check that there isn't another user already attached to this VM:
    boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>());
    // Make sure the Vm is running stateless
    returnValue = returnValue && vmIsRunningStateless(vmId);
    return returnValue;
}
#method_after
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, new ArrayList<String>()) && vmIsRunningStateless(vmId);
}
#end_block

#method_before
protected static boolean isVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean isVmFree(Guid vmId, ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean canRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#method_after
protected static boolean canRunPoolVm(Guid vmId, ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // If the quota is in use by ether VM or image - return false
    if (getQuotaDAO().isQuotaInUse(quota) && !quota.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IN_USE_BY_VM_OR_DISK);
        return false;
    }
    // Otherwise
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters() == null || (getParameters().getQuotaId() == null)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    Quota quota = getQuota();
    if (quota == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_NOT_EXIST);
        return false;
    }
    // If the quota is in use by ether VM or image - return false
    if (!QuotaEnforcementTypeEnum.DISABLED.equals(quota.getQuotaEnforcementType()) && getQuotaDAO().isQuotaInUse(quota)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IN_USE_BY_VM_OR_DISK);
        return false;
    }
    // Otherwise
    return true;
}
#end_block

#method_before
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoFileMetaData> problematicRepoFileList, FileTypeExtension fileTypeExt) {
    boolean refreshSucceeded = false;
    List<RepoFileMetaData> tempProblematicRepoFileList = new ArrayList<RepoFileMetaData>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), fileTypeExt, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id().getValue();
        if ((storagePoolIsoMap.getstatus() != null) && (storagePoolIsoMap.getstatus() == StorageDomainStatus.Active)) {
            // Try to refresh the domain of the storage pool id.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, fileTypeExt);
        } else {
            log.debugFormat("Storage domain id {0}, is not active, and there for could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, fileTypeExt, storagePoolIsoMap.getstatus());
        }
        if (!refreshSucceeded) {
            log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, fileTypeExt, storagePoolId);
            if (storagePoolIsoMap.getstatus() != StorageDomainStatus.Maintenance) {
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoFileMetaData repoFileMetaData = new RepoFileMetaData();
                repoFileMetaData.setStoragePoolId(storagePoolId);
                repoFileMetaData.setRepoDomainId(storageDomainId);
                repoFileMetaData.setFileType(fileTypeExt);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoFileMetaData);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#method_after
private boolean refreshIsoDomain(Guid storageDomainId, List<RepoFileMetaData> problematicRepoFileList, FileTypeExtension fileTypeExt) {
    boolean refreshSucceeded = false;
    List<RepoFileMetaData> tempProblematicRepoFileList = new ArrayList<RepoFileMetaData>();
    // Fetch all the Storage pools for this Iso domain Id.
    List<StoragePoolIsoMap> isoMapList = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStorage(storageDomainId);
    log.debugFormat("Fetched {0} storage pools for {1} file type, in Iso domain {2}.", isoMapList.size(), fileTypeExt, storageDomainId);
    Iterator<StoragePoolIsoMap> iter = isoMapList.iterator();
    while (iter.hasNext() && !refreshSucceeded) {
        StoragePoolIsoMap storagePoolIsoMap = iter.next();
        Guid storagePoolId = storagePoolIsoMap.getstorage_pool_id().getValue();
        StorageDomainStatus status = storagePoolIsoMap.getstatus();
        if (status != StorageDomainStatus.Active) {
            log.debugFormat("Storage domain id {0}, is not active, and therefore could not be refreshed for {1} file type (Iso domain status is {2}).", storageDomainId, fileTypeExt, status);
        } else {
            // Try to refresh the domain of the storage pool id because its status is active.
            refreshSucceeded = refreshIsoDomainFileForStoragePool(storageDomainId, storagePoolId, fileTypeExt);
            if (!refreshSucceeded) {
                log.debugFormat("Failed refreshing Storage domain id {0}, for {1} file type in storage pool id {2}.", storageDomainId, fileTypeExt, storagePoolId);
                // set a mock repository file meta data with storage domain id and storage pool id.
                RepoFileMetaData repoFileMetaData = new RepoFileMetaData();
                repoFileMetaData.setStoragePoolId(storagePoolId);
                repoFileMetaData.setRepoDomainId(storageDomainId);
                repoFileMetaData.setFileType(fileTypeExt);
                // Add the repository file to the list of problematic Iso domains.
                tempProblematicRepoFileList.add(repoFileMetaData);
            }
        }
    }
    // If refreshed was not succeeded add the problematic storage Iso domain to the list.
    if (!refreshSucceeded) {
        problematicRepoFileList.addAll(tempProblematicRepoFileList);
    }
    return refreshSucceeded;
}
#end_block

#method_before
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new java.util.ArrayList<String>());
}
#method_after
protected static boolean canAttachNonPrestartedVmToUser(Guid vm_guid) {
    return isVmFree(vm_guid, new ArrayList<String>());
}
#end_block

#method_before
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // check that there isn't another user already attached to this VM:
    boolean returnValue = !vmAssignedToUser(vmId, new java.util.ArrayList<String>());
    // Make sure the Vm is running stateless
    returnValue = returnValue && vmIsRunningStateless(vmId);
    return returnValue;
}
#method_after
protected static boolean canAttachPrestartedVmToUser(Guid vmId) {
    // and make sure the Vm is running stateless
    return !vmAssignedToUser(vmId, new ArrayList<String>()) && vmIsRunningStateless(vmId);
}
#end_block

#method_before
protected static boolean isVmFree(Guid vmId, java.util.ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#method_after
protected static boolean isVmFree(Guid vmId, ArrayList<String> messages) {
    boolean returnValue = true;
    // check that there isn't another user already attached to this VM:
    if (vmAssignedToUser(vmId, messages)) {
        returnValue = false;
    } else // check that vm can be run:
    if (!canRunPoolVm(vmId, messages)) {
        returnValue = false;
    } else // check vm images:
    {
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vmId);
        ValidationResult vmInPreviewResult = snapshotsValidator.vmNotInPreview(vmId);
        if (!vmDuringSnapshotResult.isValid()) {
            messages.add(vmDuringSnapshotResult.getMessage().name());
            returnValue = false;
        } else if (!vmInPreviewResult.isValid()) {
            messages.add(vmInPreviewResult.getMessage().name());
            returnValue = false;
        } else {
            List<Disk> disks = DbFacade.getInstance().getDiskDao().getAllForVm(vmId);
            List<DiskImage> vmImages = ImagesHandler.filterImageDisks(disks, true, true);
            Guid storageDomainId = vmImages.size() > 0 ? vmImages.get(0).getstorage_ids().get(0) : Guid.Empty;
            VM vm = DbFacade.getInstance().getVmDao().get(vmId);
            storage_pool sp = DbFacade.getInstance().getStoragePoolDao().get(vm.getStoragePoolId());
            ValidationResult spUpResult = new StoragePoolValidator(sp).isUp();
            if (!spUpResult.isValid()) {
                messages.add(spUpResult.getMessage().name());
                returnValue = false;
            }
            if (returnValue) {
                returnValue = ImagesHandler.PerformImagesChecks(messages, vm.getStoragePoolId(), storageDomainId, false, true, false, false, !Guid.Empty.equals(storageDomainId), true, disks);
            }
            if (returnValue) {
                ValidationResult vmNotLockResult = new VmValidator(vm).vmNotLocked();
                if (!vmNotLockResult.isValid()) {
                    messages.add(vmNotLockResult.getMessage().name());
                    returnValue = false;
                }
            }
        }
        if (!returnValue) {
            if (messages != null) {
                messages.add(VdcBllMessages.VAR__TYPE__DESKTOP_POOL.toString());
                messages.add(VdcBllMessages.VAR__ACTION__ATTACH_DESKTOP_TO.toString());
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
protected static boolean canRunPoolVm(Guid vmId, java.util.ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#method_after
protected static boolean canRunPoolVm(Guid vmId, ArrayList<String> messages) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    // TODO: This is done to keep consistency with VmDAO.getById.
    // It can probably be removed, but that requires some more research
    VmHandler.updateNetworkInterfacesFromDb(vm);
    RunVmParams tempVar = new RunVmParams(vmId);
    tempVar.setUseVnc(vm.getVmOs().isLinux() || vm.getVmType() == VmType.Server);
    RunVmParams runVmParams = tempVar;
    VdsSelector vdsSelector = new VdsSelector(vm, ((runVmParams.getDestinationVdsId()) != null) ? runVmParams.getDestinationVdsId() : vm.getDedicatedVmForVds(), true, new VdsFreeMemoryChecker(new NonWaitingDelayer()));
    return VmRunHandler.getInstance().canRunVm(vm, messages, runVmParams, vdsSelector, new SnapshotsValidator(), getVmPropertiesUtils());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    String fileName = "AppErrors.properties";
    File file = new File(baseDir + "/src/main/resources/bundles/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    String fileName = "AppErrors.properties";
    File file = new File(baseDir + "/src/main/resources/bundles/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
@Test
public void testkDuplicateKeys() {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.checkDuplicateKeys(file.getAbsolutePath());
}
#method_after
@Test
public void testkDuplicateKeys() throws FileNotFoundException {
    // $NON-NLS-1$
    String baseDir = System.getProperty("basedir");
    assumeNotNull(baseDir);
    // $NON-NLS-1$
    String fileName = "AppErrors.properties";
    // $NON-NLS-1$
    File file = new File(baseDir + "/src/main/resources/org/ovirt/engine/ui/frontend/" + fileName);
    DuplicateKeysCheck.assertNoDuplicateKeys(file.getAbsolutePath());
}
#end_block

#method_before
public void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, new HashMap<String, String>());
}
#method_after
public void logVolumeMessage(final GlusterVolumeEntity volume, final AuditLogType logType) {
    logAuditMessage(volume.getClusterId(), volume, null, logType, Collections.<String, String>emptyMap());
}
#end_block

#method_before
public void logServerMessage(final VDS server, final AuditLogType logType) {
    logAuditMessage(null, null, server, logType, new HashMap<String, String>());
}
#method_after
public void logServerMessage(final VDS server, final AuditLogType logType) {
    logAuditMessage(null, null, server, logType, Collections.<String, String>emptyMap());
}
#end_block

#method_before
public Map<String, Class<?>> getTypeDictionary() {
    return mTypeDict;
}
#method_after
public Map<String, Class<?>> getTypeDictionary() {
    return typeDict;
}
#end_block

#method_before
protected void buildBasicValidationTable() {
    for (String key : mVerbs.keySet()) {
        final List<ValueValidationFunction> curList = new ArrayList<ValueValidationFunction>();
        final Class<?> curType = mTypeDict.get(key);
        if (curType == java.math.BigDecimal.class) {
            curList.add(validDecimal);
        } else if (curType == Integer.class) {
            curList.add(validInteger);
        } else if (curType == Date.class) {
            curList.add(validDateTime);
        } else if (curType == TimeSpan.class) {
            curList.add(validTimeSpan);
        } else {
            curList.add(validCharacters);
        }
        final IConditionValueAutoCompleter tmp = getFieldValueAutoCompleter(key);
        if (tmp != null) {
            if (tmp.getClass() == DateEnumValueAutoCompleter.class) {
                curList.add(validateDateEnumValueByValueAC);
            } else {
                curList.add(validateFieldValueByValueAC);
            }
        }
        mValidationDict.put(key, curList);
    }
}
#method_after
protected void buildBasicValidationTable() {
    for (String key : mVerbs.keySet()) {
        final List<ValueValidationFunction> curList = new ArrayList<ValueValidationFunction>();
        final Class<?> curType = typeDict.get(key);
        if (curType == java.math.BigDecimal.class) {
            curList.add(validDecimal);
        } else if (curType == Integer.class) {
            curList.add(validInteger);
        } else if (curType == Date.class) {
            curList.add(validDateTime);
        } else if (curType == TimeSpan.class) {
            curList.add(validTimeSpan);
        } else {
            curList.add(validCharacters);
        }
        final IConditionValueAutoCompleter tmp = getFieldValueAutoCompleter(key);
        if (tmp != null) {
            if (tmp.getClass() == DateEnumValueAutoCompleter.class) {
                curList.add(validateDateEnumValueByValueAC);
            } else {
                curList.add(validateFieldValueByValueAC);
            }
        }
        validationDict.put(key, curList);
    }
}
#end_block

#method_before
public boolean validateFieldValue(String fieldName, String fieldValue) {
    if (mValidationDict.containsKey(fieldName)) {
        final List<ValueValidationFunction> validationList = mValidationDict.get(fieldName);
        for (ValueValidationFunction curValidationFunc : validationList) {
            if (!curValidationFunc.isValid(fieldName, fieldValue)) {
                return false;
            }
        }
    }
    return true;
}
#method_after
public boolean validateFieldValue(String fieldName, String fieldValue) {
    if (validationDict.containsKey(fieldName)) {
        final List<ValueValidationFunction> validationList = validationDict.get(fieldName);
        for (ValueValidationFunction curValidationFunc : validationList) {
            if (!curValidationFunc.isValid(fieldName, fieldValue)) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
public String getDbFieldName(String fieldName) {
    String retval = null;
    if (mColumnNameDict.containsKey(fieldName)) {
        retval = mColumnNameDict.get(fieldName);
    }
    return retval;
}
#method_after
public String getDbFieldName(String fieldName) {
    String retval = null;
    if (columnNameDict.containsKey(fieldName)) {
        retval = columnNameDict.get(fieldName);
    }
    return retval;
}
#end_block

#method_before
public String getSortableDbField(String fieldName) {
    if (mSortableFieldDict.containsKey(fieldName)) {
        return mSortableFieldDict.get(fieldName);
    } else {
        return getDbFieldName(fieldName);
    }
}
#method_after
public String getSortableDbField(String fieldName) {
    if (sortableFieldDict.containsKey(fieldName)) {
        return sortableFieldDict.get(fieldName);
    } else {
        return getDbFieldName(fieldName);
    }
}
#end_block

#method_before
public Class<?> getDbFieldType(String fieldName) {
    Class<?> retval = null;
    if (mTypeDict.containsKey(fieldName)) {
        retval = mTypeDict.get(fieldName);
    }
    return retval;
}
#method_after
public Class<?> getDbFieldType(String fieldName) {
    Class<?> retval = null;
    if (typeDict.containsKey(fieldName)) {
        retval = typeDict.get(fieldName);
    }
    return retval;
}
#end_block

#method_before
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (String field : mColumnNameDict.keySet()) {
        if (mTypeDict.get(field) == String.class && !mNotFreeTextSearchableFieldsList.contains(field)) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, mColumnNameDict.get(field), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#method_after
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (String field : columnNameDict.keySet()) {
        if (typeDict.get(field) == String.class && !notFreeTextSearchableFieldsList.contains(field)) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameDict.get(field), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#end_block

#method_before
@Test
public void testEncryptThreads() throws Exception {
    List<Thread> l = new LinkedList<Thread>();
    final String plain = "Test123!32@";
    final boolean[] failed = new boolean[] { false };
    for (int i = 0; i < 100; i++) {
        l.add(new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    String encrypted = EncryptionUtils.encrypt(plain, keyStoreURL, keyStorePass, certAlias);
                    String plain2 = EncryptionUtils.decrypt(encrypted, keyStoreURL, keyStorePass, certAlias);
                    if (!plain.equals(plain2)) {
                        failed[0] = true;
                        System.out.println("BAD");
                        System.out.println("plain2: " + plain2);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }));
    }
    for (Thread t : l) {
        t.start();
    }
    for (Thread t : l) {
        t.join();
    }
    assertFalse(failed[0]);
}
#method_after
@Test
public void testEncryptThreads() throws Exception {
    List<Thread> l = new LinkedList<Thread>();
    final String plain = "Test123!32@";
    final AtomicBoolean failed = new AtomicBoolean();
    for (int i = 0; i < 100; i++) {
        l.add(new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    String encrypted = EncryptionUtils.encrypt(plain, keyStoreURL, keyStorePass, certAlias);
                    String plain2 = EncryptionUtils.decrypt(encrypted, keyStoreURL, keyStorePass, certAlias);
                    if (!plain.equals(plain2)) {
                        failed.set(true);
                        System.out.println("BAD");
                        System.out.println("plain2: " + plain2);
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }));
    }
    for (Thread t : l) {
        t.start();
    }
    for (Thread t : l) {
        t.join();
    }
    assertFalse(failed.get());
}
#end_block

#method_before
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            result = encrypt(source, store.getCertificate(alias));
        }
        return result;
    } catch (Exception e) {
        log.error("Error doing the encryption", e);
        throw e;
    }
}
#method_after
public final static String encrypt(String source, String certificateFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (source.trim().length() > 0) {
            KeyStore store = EncryptionUtils.getKeyStore(certificateFile, passwd, certType);
            result = encrypt(source, store.getCertificate(alias));
        }
        return result;
    } catch (Exception e) {
        log.error("Error doing the encryption", e);
        throw e;
    }
}
#end_block

#method_before
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (!StringHelper.isNullOrEmpty(source.trim())) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            result = decrypt(source, store.getKey(alias, passwd.toCharArray()));
        }
        return result;
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
}
#method_after
public static String decrypt(String source, String keyFile, String passwd, String alias) throws Exception {
    try {
        String result = "";
        if (source.trim().length() > 0) {
            KeyStore store = EncryptionUtils.getKeyStore(keyFile, passwd, certType);
            result = decrypt(source, store.getKey(alias, passwd.toCharArray()));
        }
        return result;
    } catch (Exception e) {
        log.error("Failed to decrypt " + e.getMessage());
        log.debug("Failed to decrypt", e);
        throw e;
    }
}
#end_block

#method_before
@Before
public void setupCommand() {
    initSpyCommand();
    mockSnapshotValidator();
    mockDaos();
}
#method_after
@Before
public void setupCommand() {
    initSpyCommand();
    mockDaos();
    mockSnapshotValidator();
}
#end_block

#method_before
/**
 * Initialize Entities
 */
private void initVm(VMStatus vmStatus, NGuid runOnVds, Guid diskImageId) {
    VM vm = new VM();
    vm.setStatus(vmStatus);
    vm.setRunOnVds(runOnVds);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsListForDisk(diskImageId)).thenReturn(Collections.singletonList(vm));
    setVmInPreview(false);
}
#method_after
/**
 * Initialize Entities
 */
private void initVm(VMStatus vmStatus, NGuid runOnVds, Guid diskImageId) {
    VM vm = new VM();
    vm.setStatus(vmStatus);
    vm.setRunOnVds(runOnVds);
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    when(vmDao.getVmsListForDisk(diskImageId)).thenReturn(Collections.singletonList(vm));
}
#end_block

#method_before
private void setVmInPreview(boolean isInPreview) {
    when(snapshotDao.exists(any(Guid.class), any(SnapshotStatus.class))).thenReturn(isInPreview);
}
#method_after
private void setVmInPreview(boolean isInPreview) {
    when(snapshotDao.exists(any(Guid.class), eq(SnapshotStatus.IN_PREVIEW))).thenReturn(isInPreview);
}
#end_block

#method_before
@Override
public void edit(ImportCloneModel object) {
    if (object.getEntity() instanceof VM) {
        dialogLabelEditor.setText(constants.sameVmNameExists().replaceFirst("\\$\\{VmName\\}", // $NON-NLS-1$
        ((VM) object.getEntity()).getVmName()));
        cloneEditor.setLabel(constants.cloneImportVm());
        suffixEditor.setLabel(constants.cloneImportSuffixVm());
    } else {
        dialogLabelEditor.setText(constants.sameTemplateNameExists() + " (" + ((VmTemplate) object.getEntity()).getname() + // $NON-NLS-1$ //$NON-NLS-2$
        ")");
        cloneEditor.setLabel(constants.cloneImportTemplate());
        suffixEditor.setLabel(constants.cloneImportSuffixTemplate());
    }
    Driver.driver.edit(object);
}
#method_after
@Override
public void edit(ImportCloneModel object) {
    if (object.getEntity() instanceof VM) {
        dialogLabelEditor.setText(messages.sameVmNameExists(((VM) object.getEntity()).getVmName()));
        cloneEditor.asRadioButton().setHTML(templates.twoLinesRadioButtonLabel(constants.cloneImportVm(), constants.cloneImportVmDetails()).asString());
        suffixEditor.setLabel(constants.cloneImportSuffixVm());
    } else {
        dialogLabelEditor.setText(constants.sameTemplateNameExists() + " (" + ((VmTemplate) object.getEntity()).getname() + // $NON-NLS-1$ //$NON-NLS-2$
        ")");
        cloneEditor.setLabel(constants.cloneImportTemplate());
        suffixEditor.setLabel(constants.cloneImportSuffixTemplate());
    }
    Driver.driver.edit(object);
}
#end_block

#method_before
@Override
public String getLabel() {
    if (useRadioButtonWidgetLabel) {
        return asRadioButton().getHTML();
    } else {
        return super.getLabel();
    }
}
#method_after
@Override
public String getLabel() {
    if (useRadioButtonWidgetLabel) {
        return asRadioButton().getText();
    } else {
        return super.getLabel();
    }
}
#end_block

#method_before
@Override
public void setLabel(String label) {
    if (useRadioButtonWidgetLabel) {
        asRadioButton().setHTML(label);
    } else {
        super.setLabel(label);
    }
}
#method_after
@Override
public void setLabel(String label) {
    if (useRadioButtonWidgetLabel) {
        asRadioButton().setText(label);
    } else {
        super.setLabel(label);
    }
}
#end_block

#method_before
private boolean updateParameters() {
    for (MoveDiskParameters moveDiskParameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().getAncestor(moveDiskParameters.getImageId());
        if (diskImage == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
        }
        List<VM> allVms = getVmDAO().getVmsListForDisk(diskImage.getId());
        VM vm = !allVms.isEmpty() ? allVms.get(0) : null;
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        if (vm != null && !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        } else if (vm == null || isVmDown(vm)) {
            moveParametersList.add(moveDiskParameters);
        } else if (isVmRunning(vm)) {
            MultiValueMapUtils.addToMap(vm.getId(), createLiveMigrateDiskParameters(moveDiskParameters, vm.getId()), vmsLiveMigrateParametersMap);
        } else {
            addCanDoActionMessage(String.format("$%1$s %2$s", "VmName", vm.getVmName()));
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP);
        }
    }
    return true;
}
#method_after
private boolean updateParameters() {
    for (MoveDiskParameters moveDiskParameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().get(moveDiskParameters.getImageId());
        if (diskImage == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
        }
        List<VM> allVms = getVmDAO().getVmsListForDisk(diskImage.getId());
        VM vm = !allVms.isEmpty() ? allVms.get(0) : null;
        SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
        if (vm != null && !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
        if (vm == null || isVmDown(vm)) {
            moveParametersList.add(moveDiskParameters);
        } else if (isVmRunning(vm)) {
            MultiValueMapUtils.addToMap(vm.getId(), createLiveMigrateDiskParameters(moveDiskParameters, vm.getId()), vmsLiveMigrateParametersMap);
        } else {
            addCanDoActionMessage(String.format("$%1$s %2$s", "VmName", vm.getVmName()));
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN_OR_UP);
        }
    }
    return true;
}
#end_block

#method_before
private boolean isVmRunning(VM vm) {
    return vm.getStatus() == VMStatus.Up && vm.getRunOnVds() != null && !vm.getRunOnVds().equals(Guid.Empty);
}
#method_after
private boolean isVmRunning(VM vm) {
    return vm.getStatus().isUpOrPaused() && vm.getRunOnVds() != null && !vm.getRunOnVds().equals(Guid.Empty);
}
#end_block

#method_before
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#method_after
private boolean isQuotaValidationNeeded() {
    return oldDisk != null && newDisk != null && oldDisk instanceof DiskImage && newDisk instanceof DiskImage && DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        QuotaStorageConsumptionParameter consumptionRequest = new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
        newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes());
        QuotaStorageConsumptionParameter releaseRequest = new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
        oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes());
        if (oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId())) {
            // empty old quota
            list.add(consumptionRequest);
        } else {
            // non-empty old quota
            if (!oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
                // different new quota
                list.add(consumptionRequest);
                list.add(releaseRequest);
            }
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        boolean emptyOldQuota = oldDiskImage.getQuotaId() == null || Guid.Empty.equals(oldDiskImage.getQuotaId());
        boolean differentNewQuota = !emptyOldQuota && !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId());
        if (emptyOldQuota || differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
        if (differentNewQuota) {
            list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
            oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().getAllForHost(getParameters().getServerName()).size() > 0 || getVdsStaticDao().getAllWithIpAddress(getParameters().getServerName()).size() > 0) {
        setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        // Check if any of the server in the map is already part of some other cluster.
        if (!validateServers(serverFingerPrint.keySet())) {
            setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (AuthenticationException ae) {
        setReturnMessage(VdcBllMessages.SSH_AUTHENTICATION_FAILED.toString());
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    // Check whether the given server is already part of the cluster
    if (getVdsStaticDao().getAllForHost(getParameters().getServerName()).size() > 0 || getVdsStaticDao().getAllWithIpAddress(getParameters().getServerName()).size() > 0) {
        setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        return;
    }
    SSHClient client = null;
    try {
        client = connect(getParameters().getServerName());
        validateFingerprint(client, getParameters().getFingerprint());
        authenticate(client, ROOT, getParameters().getPassword());
        String serversXml = executeCommand(client);
        Map<String, String> serverFingerPrint = extractServers(serversXml);
        // Check if any of the server in the map is already part of some other cluster.
        if (!validateServers(serverFingerPrint.keySet())) {
            setReturnMessage(VdcBllMessages.SERVER_ALREADY_EXISTS_IN_ANOTHER_CLUSTER.toString());
        }
        getQueryReturnValue().setReturnValue(serverFingerPrint);
    } catch (AuthenticationException ae) {
        setReturnMessage(VdcBllMessages.SSH_AUTHENTICATION_FAILED.toString());
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        if (client != null) {
            client.disconnect();
        }
    }
}
#end_block

#method_before
private void setReturnMessage(String errorMessage) {
    getQueryReturnValue().setSucceeded(false);
    getQueryReturnValue().setExceptionString(errorMessage);
    return;
}
#method_after
private void setReturnMessage(String errorMessage) {
    getQueryReturnValue().setSucceeded(false);
    getQueryReturnValue().setExceptionString(errorMessage);
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        String type = (getCurrentTaskHandler().getRevertTaskType() != null ? getCurrentTaskHandler().getRevertTaskType().name() : AsyncTaskType.unknown.name());
        log.errorFormat("Reverting task {0}, handler: {1}", type, getCurrentTaskHandler().getClass().getName());
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#end_block

#method_before
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#method_after
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    if (parametersForTask.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parametersForTask.setParametersCurrentUser(getCurrentUser());
    }
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#end_block

#method_before
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.debug("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#method_after
@Override
public void rollback() {
    log.errorFormat("Transaction rolled-back for command: {0}.", CommandBase.this.getClass().getName());
    try {
        if (isQuotaDependant()) {
            rollbackQuota();
        }
    } catch (NullPointerException e) {
        log.error("RollbackQuota: failed (may be because quota is disabled)", e);
    }
    cancelTasks();
}
#end_block

#method_before
public void setContext(CommandContext context) {
    if (context == null) {
        return;
    }
    CompensationContext compensationContext = context.getCompensationContext();
    if (compensationContext != null) {
        setCompensationContext(compensationContext);
    }
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext != null) {
        setExecutionContext(executionContext);
        if (executionContext.getJob() != null) {
            if (executionContext.getJob().getOwnerId() != null) {
                DbUser user = DbFacade.getInstance().getDbUserDao().get(executionContext.getJob().getOwnerId().getValue());
                if (user != null) {
                    setUserName(user.getusername());
                }
            }
            setJobId(executionContext.getJob().getId());
        } else if (executionContext.getStep() != null) {
            setJobId(executionContext.getStep().getJobId());
        }
    }
    if (commandLock == null) {
        commandLock = context.getLock();
    }
}
#method_after
public void setContext(CommandContext context) {
    if (context == null) {
        return;
    }
    CompensationContext compensationContext = context.getCompensationContext();
    if (compensationContext != null) {
        setCompensationContext(compensationContext);
    }
    ExecutionContext executionContext = context.getExecutionContext();
    if (executionContext != null) {
        setExecutionContext(executionContext);
        if (executionContext.getJob() != null) {
            setJobId(executionContext.getJob().getId());
        } else if (executionContext.getStep() != null) {
            setJobId(executionContext.getStep().getJobId());
        }
    }
    if (commandLock == null) {
        commandLock = context.getLock();
    }
}
#end_block

#method_before
public void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    double free = limit - consumedByOthers - consumedByUser;
    switch(getType()) {
        case STORAGE:
            // $NON-NLS-1$
            String freeStorage = free == 0 ? "0" : diskSizeRenderer.render(free);
            setTitle(constants.freeStorage() + freeStorage);
            break;
        case CPU:
            setTitle(messages.quotaFreeCpus((int) free));
            break;
        case MEM:
            // $NON-NLS-1$
            String freeMem = free > 4096 ? diskSizeRenderer.render(free / 1024) : (int) free + "MB";
            setTitle(constants.freeMemory() + freeMem);
            break;
    }
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        switch(getType()) {
            case STORAGE:
                setExceeded(messages.exceedingStorage(othersConsumptionPercent + userConsumptionPercent - 100, -free));
                break;
            case CPU:
                setExceeded(messages.exceedingCpus(othersConsumptionPercent + userConsumptionPercent - 100, (int) -free));
                break;
            case MEM:
                // $NON-NLS-1$
                String freeMem = free < -4096 ? diskSizeRenderer.render(-free / 1024) : (int) -free + "MB";
                setExceeded(messages.exceedingMem(othersConsumptionPercent + userConsumptionPercent - 100, freeMem));
                break;
        }
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#method_after
public void setValues(double limit, double consumedByOthers, double consumedByUser) {
    int othersConsumptionPercent = (int) Math.round(consumedByOthers * 100 / limit);
    int userConsumptionPercent = (int) Math.round(consumedByUser * 100 / limit);
    double free = limit - consumedByOthers - consumedByUser;
    setTitleInternal(free);
    if (limit == UNLIMITED) {
        // unlimited
        setUnlimited();
    } else if (consumedByOthers + consumedByUser == 0) {
        // empty
        setZeroValue();
    } else if (consumedByOthers + consumedByUser > limit) {
        // exceeded
        switch(getType()) {
            case STORAGE:
                setExceeded(messages.exceedingStorage(othersConsumptionPercent + userConsumptionPercent - 100, -free));
                break;
            case CPU:
                setExceeded(messages.exceedingCpus(othersConsumptionPercent + userConsumptionPercent - 100, (int) -free));
                break;
            case MEM:
                // $NON-NLS-1$
                String freeMem = free < (-MB_GB_THRESHOLD * GIGA) ? diskSizeRenderer.render(-free / GIGA) : (int) -free + "MB";
                setExceeded(messages.exceedingMem(othersConsumptionPercent + userConsumptionPercent - 100, freeMem));
                break;
        }
    } else {
        percentageBarA.setStyleName(style.percentageBarA());
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarB.setVisible(true);
        setValueA(othersConsumptionPercent);
        setValueB(userConsumptionPercent);
        setBars();
    }
}
#end_block

#method_before
public void setZeroValue() {
    percentageBarA.setVisible(true);
    percentageBarA.setTitle(title);
    percentageBarA.setStyleName(style.empty());
    // $NON-NLS-1$
    percentageBarA.setWidth("99%");
    percentageLabelA.setText(ZERO);
    percentageLabelA.setStyleName(style.percentageLabelBlack());
}
#method_after
public void setZeroValue() {
    percentageBarA.setVisible(true);
    percentageBarA.setTitle(title);
    percentageBarA.setStyleName(style.empty());
    // $NON-NLS-1$
    percentageBarA.setWidth(FULL_WIDTH + "%");
    percentageLabelA.setText(ZERO);
    percentageLabelA.setStyleName(style.percentageLabelBlack());
}
#end_block

#method_before
public void setBars() {
    int fakeA = valueA;
    int fakeB = valueB;
    if (valueA != null && valueB != null && valueA + valueB >= 99) {
        double factor = (double) 98 / (valueA + valueB);
        fakeA = (int) Math.round(factor * valueA);
        fakeB = (int) Math.round(factor * valueB);
        fakeA = (fakeB == 0 ? 99 : fakeA);
        fakeB = (fakeA == 0 ? 99 : fakeB);
    }
    if (valueB != null) {
        // $NON-NLS-1$
        String percentageB = valueB + "%";
        // $NON-NLS-1$
        String fakePercentageB = fakeB + "%";
        // $NON-NLS-1$
        percentageLabelB.setText(valueB < 10 ? "" : percentageB);
        percentageLabelB.setStyleName(style.percentageLabel());
        percentageBarB.setWidth(fakePercentageB);
        percentageBarB.setVisible(valueB != 0);
        percentageBarB.setTitle(percentageB);
    }
    if (valueA != null) {
        // $NON-NLS-1$
        String percentageA = valueA + "%";
        // $NON-NLS-1$
        String fakePercentageA = fakeA + "%";
        // $NON-NLS-1$
        percentageLabelA.setText(valueA < 10 ? "" : percentageA);
        percentageLabelA.setStyleName(style.percentageLabelBlack());
        percentageBarA.setWidth(fakePercentageA);
        percentageBarA.setVisible(valueA != 0);
        percentageBarA.setTitle(percentageA);
    }
}
#method_after
public void setBars() {
    int fakeA = valueA;
    int fakeB = valueB;
    if (valueA != null && valueB != null && valueA + valueB >= FULL_WIDTH) {
        double factor = (double) (FULL_WIDTH - 1) / (valueA + valueB);
        fakeA = (int) Math.round(factor * valueA);
        fakeB = (int) Math.round(factor * valueB);
        fakeA = (fakeB == 0 ? FULL_WIDTH : fakeA);
        fakeB = (fakeA == 0 ? FULL_WIDTH : fakeB);
    }
    setBar(percentageBarA, percentageLabelA, valueA, fakeA, style.percentageLabelBlack());
    setBar(percentageBarB, percentageLabelB, valueB, fakeB, style.percentageLabel());
}
#end_block

#method_before
protected boolean MigrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), new CommandContext(createMigrateVmContext(parentContext, vm)));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                AppendCustomValue("failedVms", vm.getVmName(), ",");
                log.errorFormat("ResourceManager::vdsMaintenance - Failed migrating desktop '{0}'", vm.getVmName());
            }
        }
    }
    return succeeded;
}
#method_after
protected boolean MigrateAllVms(ExecutionContext parentContext, boolean HAOnly) {
    boolean succeeded = true;
    for (VM vm : vms) {
        // if HAOnly is true check that vm is HA (auto_startup should be true)
        if (vm.getStatus() != VMStatus.MigratingFrom && (!HAOnly || (HAOnly && vm.isAutoStartup()))) {
            VdcReturnValueBase result = Backend.getInstance().runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType()), createMigrateVmContext(parentContext, vm));
            if (!result.getCanDoAction() || !(((Boolean) result.getActionReturnValue()).booleanValue())) {
                succeeded = false;
                AppendCustomValue("failedVms", vm.getVmName(), ",");
                log.errorFormat("ResourceManager::vdsMaintenance - Failed migrating desktop '{0}'", vm.getVmName());
            }
        }
    }
    return succeeded;
}
#end_block

#method_before
protected ExecutionContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getVmName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return ctx;
}
#method_after
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    ExecutionContext ctx = new ExecutionContext();
    try {
        Map<String, String> values = new HashMap<String, String>();
        values.put(VdcObjectType.VM.name().toLowerCase(), vm.getVmName());
        values.put(VdcObjectType.VDS.name().toLowerCase(), vm.getRunOnVdsName());
        Step step = ExecutionHandler.addSubStep(getExecutionContext(), parentContext.getJob().getStep(StepEnum.EXECUTING), StepEnum.MIGRATE_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.MIGRATE_VM, values));
        ctx.setStep(step);
        ctx.setMonitored(true);
    } catch (RuntimeException e) {
        log.error("Failed to create ExecutionContext for MigrateVmCommand", e);
    }
    return new CommandContext(ctx);
}
#end_block

#method_before
@Override
protected ExecutionContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    return new ExecutionContext();
}
#method_after
@Override
protected CommandContext createMigrateVmContext(ExecutionContext parentContext, VM vm) {
    return ExecutionHandler.createInternalJobContext();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds() != null && isOvirtReInstallOrUpgrade()) {
        OVirtNodeUpgrade upgrade = null;
        try {
            T parameters = getParameters();
            upgrade = new OVirtNodeUpgrade(getVds(), parameters.getoVirtIsoFile());
            upgrade.setCorrelationId(getCorrelationId());
            log.infoFormat("Execute upgrade host {0}, {1}", getVds().getId(), getVds().getvds_name());
            upgrade.execute();
            log.infoFormat("After upgrade host {0}, {1}: success", getVds().getId(), getVds().getvds_name());
            setSucceeded(true);
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (upgrade != null) {
                upgrade.close();
            }
        }
        return;
    }
    if (getVds() != null) {
        VdsDeploy installer = null;
        try {
            log.infoFormat("Before Installation host {0}, {1}", getVds().getId(), getVds().getvds_name());
            T parameters = getParameters();
            installer = new VdsDeploy(getVds());
            installer.setCorrelationId(getCorrelationId());
            installer.setReboot(parameters.isRebootAfterInstallation());
            switch(getVds().getvds_type()) {
                case VDS:
                    installer.setUser("root");
                    installer.setPassword(parameters.getRootPassword());
                    installer.setFirewall(parameters.getOverrideFirewall());
                    break;
                case PowerClient:
                case oVirtNode:
                    if (parameters.getOverrideFirewall()) {
                        log.warnFormat("Installation of Host {0} will ignore Firewall Override option, since it is not supported for Host type {1}", getVds().getvds_name(), getVds().getvds_type().name());
                    }
                    installer.setUser("root");
                    installer.useDefaultKeyPair();
                    break;
                default:
                    throw new IllegalArgumentException(String.format("Not handled VDS type: %1$s", getVds().getvds_type()));
            }
            installer.execute();
            if (getVds().getstatus() == VDSStatus.Reboot) {
                RunSleepOnReboot();
            }
            log.infoFormat("After Installation host {0}, {1}", getVds().getvds_name(), getVds().getvds_type().name());
            setSucceeded(true);
        } catch (Exception e) {
            log.errorFormat("Host installation failed for host {0}, {1}.", getVds().getId(), getVds().getvds_name(), e);
            setSucceeded(false);
            _failureMessage = getErrorMessage(e.getMessage());
            AddCustomValue("FailedInstallMessage", _failureMessage);
        } finally {
            if (installer != null) {
                installer.close();
            }
        }
        return;
    }
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STARTED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOPPED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getmem_available() < minAvailableThreshold || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("AvailableMemory", stat.getmem_available().toString());
        logable.AddCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.AddCustomValue("Threshold", stat.getmem_available() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, stat.getmem_available() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getmem_available() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getmem_available() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if (stat.getmem_available() < minAvailableThreshold || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("AvailableMemory", stat.getmem_available().toString());
        logable.AddCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.AddCustomValue("Threshold", stat.getmem_available() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#method_after
private void checkVdsCpuThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxCpuUsedThresholdInPercentage);
    if (stat.getusage_cpu_percent() != null && stat.getusage_cpu_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedCpu", stat.getusage_cpu_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_CPU_USE);
    }
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.AddCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#end_block

#method_before
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVdsId(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.AddCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.AddCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE);
    }
}
#method_after
private void checkVdsSwapThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getswap_total() == null || stat.getswap_free() == null) {
        return;
    }
    Long swapUsedPercent = (stat.getswap_total() - stat.getswap_free()) / stat.getswap_total();
    AuditLogType valueToLog = stat.getswap_free() < minAvailableThreshold ? AuditLogType.VDS_LOW_SWAP : AuditLogType.VDS_HIGH_SWAP_USE;
    if (stat.getswap_free() < minAvailableThreshold || swapUsedPercent > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.AddCustomValue("HostName", _vds.getvds_name());
        logable.AddCustomValue("UsedSwap", swapUsedPercent.toString());
        logable.AddCustomValue("AvailableSwapMemory", stat.getswap_free().toString());
        logable.AddCustomValue("Threshold", stat.getswap_free() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && VM.isGuestUp(runningVm.getstatus())) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("vds::Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#end_block

#method_before
private void allQueriesForVms() {
    when(vmDao.getAllForVdsGroup(any(Guid.class))).thenReturn(new ArrayList<VM>());
}
#method_after
private void allQueriesForVms() {
    when(vmDao.getAllForVdsGroup(any(Guid.class))).thenReturn(Collections.<VM>emptyList());
}
#end_block

#method_before
@Override
public List<VM> getAllForVdsGroup(Guid vdsGroupId) {
    return getCallsHandler().executeReadList("GetVmsByVdsGroupId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vdsGroupId", vdsGroupId));
}
#method_after
@Override
public List<VM> getAllForVdsGroup(Guid vds_group_id) {
    return getCallsHandler().executeReadList("GetVmsByVdsGroupId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_id", vds_group_id));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        VdsActionParameters parameters = new VdsActionParameters();
        for (VDS vds : allForVdsGroup) {
            parameters.setVdsId(vds.getId());
            if (getVdsGroup().getStoragePoolId() != null) {
                VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
                if (!addVdsSpmIdReturn.getSucceeded()) {
                    setSucceeded(false);
                    getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                    return;
                }
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId().getValue());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId().getValue());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            for (VM vm : vmList) {
                // the vm cluster id is the same as the cluster.id
                if (!vm.getVdsGroupId().equals(oldGroup.getId())) {
                    continue;
                } else {
                    hasVms = true;
                }
                if (vm.getStatus() == VMStatus.Suspended) {
                    suspendedVms = true;
                } else if (vm.getStatus() != VMStatus.Down) {
                    notDownVms = true;
                }
            }
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId().getValue());
        if (oldGroup.getStoragePoolId() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // check that if name was changed, it was done to the same cluster
    if (result && !StringUtils.equals(oldGroup.getname(), getVdsGroup().getname())) {
        VDSGroup groupWithName = getVdsGroupDAO().getByName(getVdsGroup().getname());
        if (groupWithName != null && !groupWithName.getId().equals(getVdsGroup().getId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    // decreasing of compatibility version is not allowed
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        result = false;
        getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    if (result && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allForVdsGroup.isEmpty()) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getstatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            List<VM> vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            boolean sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult < 0) {
                        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_LOWER_CPU_LEVEL);
                        result = false;
                    } else if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.AddCustomValue("VdsGroup", getParameters().getVdsGroup().getname());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        storage_pool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId().getValue());
        if (oldGroup.getStoragePoolId() == null && storagePool.getstorage_pool_type() == StorageType.LOCALFS) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId().getValue()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else // selection algorithm must be set to none in localfs
            if (getVdsGroup().getselection_algorithm() != VdsSelectionAlgorithm.None) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_SELECTION_ALGORITHM_MUST_BE_SET_TO_NONE_ON_LOCAL_STORAGE.toString());
                result = false;
            } else if (VDSGroup.DEFAULT_VDS_GROUP_ID.equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (result) {
        result = validateMetrics();
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
public void activate() {
    VDS vds = null;
    try {
        // refresh vds from db in case changed while was down
        if (log.isDebugEnabled()) {
            log.debugFormat("Trying to activate host {0} , meanwhile setting status to Unassigned meanwhile", getVdsId());
        }
        vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * refresh capabilities
         */
        VDSStatus newStatus = refreshCapabilities(new AtomicBoolean(), vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("Succeeded to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
    } catch (java.lang.Exception e) {
        log.infoFormat("Failed to get VDS = {0} capabilities with error: {1}.", getVdsId(), e.getMessage());
        log.infoFormat("Failed to activate VDS = {0}", getVdsId());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
public void activate() {
    VDS vds = null;
    try {
        // refresh vds from db in case changed while was down
        log.debugFormat("Trying to activate host {0} , meanwhile setting status to Unassigned.", getVdsId());
        vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * refresh capabilities
         */
        VDSStatus newStatus = refreshCapabilities(new AtomicBoolean(), vds);
        if (log.isDebugEnabled()) {
            log.debugFormat("Succeeded to refreshCapabilities for host {0} , new status will be {1} ", getVdsId(), newStatus);
        }
    } catch (java.lang.Exception e) {
        log.infoFormat("Failed to activate VDS = {0} with error: {1}.", getVdsId(), e.getMessage());
    } finally {
        if (vds != null) {
            UpdateDynamicData(vds.getDynamicData());
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            ResourceManager.getInstance().getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getstatus() != VDSStatus.Down) {
        if (mUnrespondedAttempts.get() < Config.<Integer>GetValue(ConfigValues.VDSAttemptsToResetCount) || lastUpdate + (TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.TimeoutToResetVdsInSeconds))) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getstatus() != VDSStatus.Connecting && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getstatus() == VDSStatus.NonResponsive || vds.getstatus() == VDSStatus.Maintenance) {
            // clearNotRespondingVds();
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.errorFormat("VDS::handleNetworkException Server failed to respond, vds_id = {0}, vds_name = {1}, error = {2}", vds.getId(), vds.getvds_name(), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds);
    }
    return true;
}
#method_after
public boolean handleNetworkException(VDSNetworkException ex, VDS vds) {
    if (vds.getstatus() != VDSStatus.Down) {
        if (mUnrespondedAttempts.get() < Config.<Integer>GetValue(ConfigValues.VDSAttemptsToResetCount) || lastUpdate + (TimeUnit.SECONDS.toMillis(Config.<Integer>GetValue(ConfigValues.TimeoutToResetVdsInSeconds))) > System.currentTimeMillis()) {
            boolean result = false;
            if (vds.getstatus() != VDSStatus.Connecting && vds.getstatus() != VDSStatus.PreparingForMaintenance && vds.getstatus() != VDSStatus.NonResponsive) {
                setStatus(VDSStatus.Connecting, vds);
                result = true;
            }
            mUnrespondedAttempts.incrementAndGet();
            return result;
        }
        if (vds.getstatus() == VDSStatus.NonResponsive || vds.getstatus() == VDSStatus.Maintenance) {
            setStatus(VDSStatus.NonResponsive, vds);
            return true;
        }
        setStatus(VDSStatus.NonResponsive, vds);
        log.errorFormat("Server failed to respond, vds_id = {0}, vds_name = {1}, error = {2}", vds.getId(), vds.getvds_name(), ex.getMessage());
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
        ResourceManager.getInstance().getEventListener().vdsNotResponding(vds);
    }
    return true;
}
#end_block

#method_before
private void addModelListeners(SystemTreeModelProvider modelProvider) {
    modelProvider.getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Collapse tree on refresh
            collapseTree(display.getRootTreeNode());
            // will collapse as it should do.
            if (initialized) {
                display.getRootTreeNode().setChildOpen(0, true);
            }
            initialized = true;
        }
    });
}
#method_after
private void addModelListeners(final SystemTreeModelProvider modelProvider) {
    modelProvider.getModel().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Reset selection in the model
            SystemTreeItemModel lastSelectedItem = modelProvider.getSelectionModel().getSelectedObject();
            modelProvider.getSelectionModel().setSelected(lastSelectedItem, false);
            expandTree(display.getRootTreeNode(), ITEM_LEVEL);
        }
    });
}
#end_block

#method_before
@Override
protected CellTree createDataDisplayWidget(SystemTreeModelProvider modelProvider) {
    SystemTreeResources res = GWT.create(SystemTreeResources.class);
    display = new CellTree(modelProvider, null, res);
    display.setAnimationEnabled(true);
    display.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.BOUND_TO_SELECTION);
    return display;
}
#method_after
@Override
protected CellTree createDataDisplayWidget(SystemTreeModelProvider modelProvider) {
    SystemTreeResources res = GWT.create(SystemTreeResources.class);
    display = new CellTree(modelProvider, null, res) {

        @Override
        protected void onLoad() {
            expandTree(display.getRootTreeNode(), ITEM_LEVEL);
        }
    };
    display.setAnimationEnabled(true);
    display.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.BOUND_TO_SELECTION);
    return display;
}
#end_block

#method_before
private void expandTree(TreeNode node) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        expandTree(node.setChildOpen(i, true));
    }
}
#method_after
private void expandTree(TreeNode node) {
    expandTree(node, ALL_LEVELS);
}
#end_block

#method_before
private void expandTree(TreeNode node) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        expandTree(node.setChildOpen(i, true));
    }
}
#method_after
private void expandTree(TreeNode node, int expandUpToLevel) {
    if (node == null) {
        return;
    }
    for (int i = 0; i < node.getChildCount(); i++) {
        boolean expandNode = 0 < expandUpToLevel ? true : false;
        expandTree(node.setChildOpen(i, expandNode), expandUpToLevel - 1);
    }
}
#end_block

#method_before
private TreeNode findNode(TreeNode node, SystemTreeItemModel model) {
    TreeNode result = null;
    if (node == null) {
        return null;
    }
    int i = 0;
    while (result == null && i < node.getChildCount()) {
        if (null != model && model.equals(node.getChildValue(i))) {
            result = node.setChildOpen(i, true);
            break;
        }
        // Only check open nodes, otherwise they couldn't have been selected.
        if (node.isChildOpen(i)) {
            result = findNode(node.setChildOpen(i, true), model);
        }
        i++;
    }
    return result;
}
#method_after
private TreeNode findNode(TreeNode node, SystemTreeItemModel model) {
    TreeNode result = null;
    if (node == null) {
        return null;
    }
    int i = 0;
    while (result == null && i < node.getChildCount()) {
        if (model != null && model.equals(node.getChildValue(i))) {
            result = node.setChildOpen(i, true);
            break;
        }
        // Only check open nodes, otherwise they couldn't have been selected.
        if (node.isChildOpen(i)) {
            result = findNode(node.setChildOpen(i, true), model);
        }
        i++;
    }
    return result;
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                for (Object object : list) {
                    if (object instanceof VM) {
                        vms.add((VM) object);
                    } else if (object instanceof vm_pools) {
                        pools.add((vm_pools) object);
                    }
                }
            }
            userPortalListModel.setvms(vms);
            userPortalListModel.setpools(pools);
            userPortalListModel.OnVmAndPoolLoad();
        }
    }));
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                if (list != null) {
                    for (Object object : list) {
                        if (object instanceof VM) {
                            vms.add((VM) object);
                        } else if (object instanceof vm_pools) {
                            pools.add((vm_pools) object);
                        }
                    }
                }
            }
            userPortalListModel.setvms(vms);
            userPortalListModel.setpools(pools);
            userPortalListModel.OnVmAndPoolLoad();
        }
    }));
}
#end_block

#method_before
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#method_after
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabVisible(false);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#end_block

#method_before
public void PostVmNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    gettempVm().setVmType(model.getVmType());
    gettempVm().setVmtGuid(template.getId());
    gettempVm().setVmName(name);
    gettempVm().setVmOs((VmOsType) model.getOSType().getSelectedItem());
    gettempVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    gettempVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    gettempVm().setVmDescription((String) model.getDescription().getEntity());
    gettempVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    gettempVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    gettempVm().setVdsGroupId(newClusterID);
    gettempVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    gettempVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    gettempVm().setAutoSuspend(false);
    gettempVm().setStateless((Boolean) model.getIsStateless().getEntity());
    gettempVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    gettempVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    gettempVm().setDefaultBootSequence(model.getBootSequence());
    gettempVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    gettempVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    gettempVm().setKernelUrl((String) model.getKernel_path().getEntity());
    gettempVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    gettempVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    gettempVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    gettempVm().setPriority((Integer) prioritySelectedItem.getEntity());
    if (model.getQuota().getSelectedItem() != null) {
        gettempVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    gettempVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        gettempVm().setDedicatedVmForVds(null);
    } else {
        gettempVm().setDedicatedVmForVds(defaultHost.getId());
    }
    gettempVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
    }
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(NGuid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), NGuid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    stopProgress(result.getState());
                    cancel();
                }
            }, this);
        } else {
            setstorageDomain((storage_domains) model.getStorageDomain().getSelectedItem());
            if ((Boolean) model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result;
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : ((UnitVmModel) userPortalListModel1.getWindow()).getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            if (disk != null) {
                                templateDisk.setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                templateDisk.setvolume_format(AsyncDataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), getstorageDomain().getstorage_type()));
                            }
                        }
                        HashMap<Guid, DiskImage> dict = new HashMap<Guid, DiskImage>();
                        for (DiskImage a : templateDisks) {
                            dict.put(a.getId(), a);
                        }
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(gettempVm(), dict, getstorageDomain().getId());
                        param.setMakeCreatorExplicitOwner(true);
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendMultipleActionAsyncResult a) {
                                stopProgress(a.getState());
                                cancel();
                            }
                        }, this);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                VmManagementParametersBase param = new VmManagementParametersBase(gettempVm());
                param.setStorageDomainId(getstorageDomain().getId());
                param.setMakeCreatorExplicitOwner(true);
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(param);
                Frontend.RunMultipleAction(VdcActionType.AddVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendMultipleActionAsyncResult a) {
                        stopProgress(a.getState());
                        cancel();
                    }
                }, this);
            }
        }
    } else {
        Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            Frontend.RunAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult a) {
                            stopProgress(a.getState());
                            cancel();
                        }
                    }, this);
                }
            }, this);
        } else {
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult a) {
                    stopProgress(a.getState());
                    cancel();
                }
            }, this);
        }
    }
}
#method_after
public void PostVmNameUniqueCheck(UserPortalListModel userPortalListModel) {
    UnitVmModel model = (UnitVmModel) getWindow();
    UserPortalItemModel selectedItem = (UserPortalItemModel) userPortalListModel.getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    gettempVm().setVmType(model.getVmType());
    gettempVm().setVmtGuid(template.getId());
    gettempVm().setVmName(name);
    gettempVm().setVmOs((VmOsType) model.getOSType().getSelectedItem());
    gettempVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    gettempVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    gettempVm().setVmDescription((String) model.getDescription().getEntity());
    gettempVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    gettempVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    gettempVm().setVdsGroupId(newClusterID);
    gettempVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    gettempVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    gettempVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    gettempVm().setAutoSuspend(false);
    gettempVm().setStateless((Boolean) model.getIsStateless().getEntity());
    gettempVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    gettempVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    gettempVm().setDefaultBootSequence(model.getBootSequence());
    gettempVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    gettempVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    gettempVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    gettempVm().setKernelUrl((String) model.getKernel_path().getEntity());
    gettempVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    gettempVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    gettempVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    gettempVm().setPriority((Integer) prioritySelectedItem.getEntity());
    if (model.getQuota().getSelectedItem() != null) {
        gettempVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    gettempVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        gettempVm().setDedicatedVmForVds(null);
    } else {
        gettempVm().setDedicatedVmForVds(defaultHost.getId());
    }
    gettempVm().setMigrationSupport(MigrationSupport.MIGRATABLE);
    if ((Boolean) model.getRunVMOnSpecificHost().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.PINNED_TO_HOST);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    } else if ((Boolean) model.getDontMigrateVM().getEntity()) {
        gettempVm().setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
        gettempVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    }
    if (model.getIsNew()) {
        if (gettempVm().getVmtGuid().equals(NGuid.Empty)) {
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(gettempVm(), new ArrayList<DiskImage>(), NGuid.Empty);
            parameters.setMakeCreatorExplicitOwner(true);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    stopProgress(result.getState());
                    cancel();
                }
            }, this);
        } else {
            setstorageDomain((storage_domains) model.getStorageDomain().getSelectedItem());
            if ((Boolean) model.getProvisioning().getEntity()) {
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void OnSuccess(Object model, Object result) {
                        UserPortalListModel userPortalListModel1 = (UserPortalListModel) model;
                        ArrayList<DiskImage> templateDisks = (ArrayList<DiskImage>) result;
                        for (DiskImage templateDisk : templateDisks) {
                            DiskModel disk = null;
                            for (DiskModel a : ((UnitVmModel) userPortalListModel1.getWindow()).getDisks()) {
                                if (templateDisk.getId().equals(a.getDisk().getId())) {
                                    disk = a;
                                    break;
                                }
                            }
                            if (disk != null) {
                                templateDisk.setvolume_type((VolumeType) disk.getVolumeType().getSelectedItem());
                                templateDisk.setvolume_format(AsyncDataProvider.GetDiskVolumeFormat((VolumeType) disk.getVolumeType().getSelectedItem(), getstorageDomain().getstorage_type()));
                            }
                        }
                        HashMap<Guid, DiskImage> dict = new HashMap<Guid, DiskImage>();
                        for (DiskImage a : templateDisks) {
                            dict.put(a.getId(), a);
                        }
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(gettempVm(), dict, getstorageDomain().getId());
                        param.setMakeCreatorExplicitOwner(true);
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void Executed(FrontendMultipleActionAsyncResult a) {
                                stopProgress(a.getState());
                                cancel();
                            }
                        }, this);
                    }
                };
                AsyncDataProvider.GetTemplateDiskList(_asyncQuery, template.getId());
            } else {
                VmManagementParametersBase param = new VmManagementParametersBase(gettempVm());
                param.setStorageDomainId(getstorageDomain().getId());
                param.setMakeCreatorExplicitOwner(true);
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(param);
                Frontend.RunMultipleAction(VdcActionType.AddVm, parameters, new IFrontendMultipleActionAsyncCallback() {

                    @Override
                    public void Executed(FrontendMultipleActionAsyncResult a) {
                        stopProgress(a.getState());
                        cancel();
                    }
                }, this);
            }
        }
    } else {
        Guid oldClusterID = ((VM) selectedItem.getEntity()).getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            Frontend.RunAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(newClusterID, gettempVm().getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult result) {
                    Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                        @Override
                        public void Executed(FrontendActionAsyncResult a) {
                            stopProgress(a.getState());
                            cancel();
                        }
                    }, this);
                }
            }, this);
        } else {
            Frontend.RunAction(VdcActionType.UpdateVm, new VmManagementParametersBase(gettempVm()), new IFrontendActionAsyncCallback() {

                @Override
                public void Executed(FrontendActionAsyncResult a) {
                    stopProgress(a.getState());
                    cancel();
                }
            }, this);
        }
    }
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalBasicListModel userPortalBasicListModel = (UserPortalBasicListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                for (Object object : list) {
                    if (object instanceof VM) {
                        vms.add((VM) object);
                    } else if (object instanceof vm_pools) {
                        pools.add((vm_pools) object);
                    }
                }
            }
            userPortalBasicListModel.setvms(vms);
            userPortalBasicListModel.setpools(pools);
            userPortalBasicListModel.OnVmAndPoolLoad();
        }
    }));
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    Frontend.RunQuery(VdcQueryType.GetAllVmsAndVmPools, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            UserPortalBasicListModel userPortalBasicListModel = (UserPortalBasicListModel) model;
            ArrayList<VM> vms = new ArrayList<VM>();
            ArrayList<vm_pools> pools = new ArrayList<vm_pools>();
            VdcQueryReturnValue retValue = (VdcQueryReturnValue) returnValue;
            if (retValue != null && retValue.getSucceeded()) {
                List<Object> list = (ArrayList<Object>) retValue.getReturnValue();
                if (list != null) {
                    for (Object object : list) {
                        if (object instanceof VM) {
                            vms.add((VM) object);
                        } else if (object instanceof vm_pools) {
                            pools.add((vm_pools) object);
                        }
                    }
                }
            }
            userPortalBasicListModel.setvms(vms);
            userPortalBasicListModel.setpools(pools);
            userPortalBasicListModel.OnVmAndPoolLoad();
        }
    }));
}
#end_block

#method_before
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    if (getStorageDomainStatus() != null) {
        valid = Arrays.asList(statuses).contains(getStorageDomainStatus());
    }
    if (!valid) {
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#method_after
protected boolean checkStorageDomainStatus(final StorageDomainStatus... statuses) {
    boolean valid = false;
    StorageDomainStatus status = getStorageDomainStatus();
    if (status != null) {
        valid = Arrays.asList(statuses).contains(status);
    }
    if (!valid) {
        if (status == StorageDomainStatus.Locked) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
        }
        addStorageDomainStatusIllegalMessage();
    }
    return valid;
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setvds_name(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.sethost_name(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setport(model.getPort());
    } else {
        entity.setport(DEFAULT_VDSM_PORT);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplayAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplayAddress()) ? null : model.getDisplayAddress());
    }
    return entity;
}
#method_after
@Mapping(from = Host.class, to = VdsStatic.class)
public static VdsStatic map(Host model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    if (model.isSetId()) {
        entity.setId(new Guid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setvds_name(model.getName());
    }
    if (model.isSetCluster() && model.getCluster().isSetId()) {
        entity.setvds_group_id(new Guid(model.getCluster().getId()));
    }
    if (model.isSetAddress()) {
        entity.sethost_name(model.getAddress());
    }
    if (model.isSetPort() && model.getPort() > 0) {
        entity.setport(model.getPort());
    } else {
        entity.setport(DEFAULT_VDSM_PORT);
    }
    if (model.isSetPowerManagement()) {
        entity = map(model.getPowerManagement(), entity);
    }
    if (model.isSetStorageManager()) {
        if (model.getStorageManager().getPriority() != null) {
            entity.setVdsSpmPriority(model.getStorageManager().getPriority());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetAddress()) {
        entity.setConsoleAddress("".equals(model.getDisplay().getAddress()) ? null : model.getDisplay().getAddress());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getcpu_cores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getlibvirt_version() != null) {
        Version version = new Version();
        version.setMajor(entity.getlibvirt_version().getMajor());
        version.setMinor(entity.getlibvirt_version().getMinor());
        version.setRevision(entity.getlibvirt_version().getRevision());
        version.setBuild(entity.getlibvirt_version().getBuild());
        version.setFullVersion(entity.getlibvirt_version().getRpmName());
        model.setLibvirtVersion(version);
    }
    model.setDisplayAddress(entity.getConsoleAddress());
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getcpu_cores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getlibvirt_version() != null) {
        Version version = new Version();
        version.setMajor(entity.getlibvirt_version().getMajor());
        version.setMinor(entity.getlibvirt_version().getMinor());
        version.setRevision(entity.getlibvirt_version().getRevision());
        version.setBuild(entity.getlibvirt_version().getBuild());
        version.setFullVersion(entity.getlibvirt_version().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    return model;
}
#end_block

#method_before
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplayAddress(), transform.getDisplayAddress());
}
#method_after
@Override
protected void verify(Host model, Host transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertNotNull(transform.getCluster());
    assertEquals(model.getCluster().getId(), transform.getCluster().getId());
    assertEquals(model.getAddress(), transform.getAddress());
    assertEquals(model.getPort(), transform.getPort());
    assertEquals(model.getStorageManager().getPriority(), transform.getStorageManager().getPriority());
    assertEquals(model.getDisplay().getAddress(), transform.getDisplay().getAddress());
}
#end_block

#method_before
@Override
protected void revertTasks() {
    // Revert should be performed only for AddVmFromSnapshot at this point.
    if (getParameters().getParentCommand() == VdcActionType.AddVmFromSnapshot) {
        Guid destImageId = getParameters().getDestinationImageId();
        RemoveImageParameters removeImageParams = new RemoveImageParameters(destImageId);
        removeImageParams.setParentParameters(removeImageParams);
        removeImageParams.setParentCommand(VdcActionType.RemoveImage);
        if (getParameters().getParentCommand() == VdcActionType.ImportVm) {
            removeImageParams.setRemoveDuringExecution(false);
            removeImageParams.setRemoveFromDB(true);
        }
        removeImageParams.setEntityId(getDestinationImageId());
        // Setting the image as the monitored entity, so there will not be dependency
        VdcReturnValueBase returnValue = checkAndPerformRollbackUsingCommand(VdcActionType.RemoveImage, removeImageParams);
        if (returnValue.getSucceeded()) {
            // Starting to monitor the the tasks - RemoveImage is an internal command
            // which adds the taskId on the internal task ID list
            startPollingAsyncTasks(returnValue.getInternalTaskIdList());
        }
    } else {
        unLockImage();
    }
}
#method_after
@Override
protected void revertTasks() {
    // Revert should be performed only for AddVmFromSnapshot at this point.
    if (getParameters().getParentCommand() == VdcActionType.AddVmFromSnapshot || getParameters().getParentCommand() == VdcActionType.ImportVm) {
        Guid destImageId = getParameters().getDestinationImageId();
        RemoveImageParameters removeImageParams = new RemoveImageParameters(destImageId);
        removeImageParams.setParentParameters(removeImageParams);
        removeImageParams.setParentCommand(VdcActionType.RemoveImage);
        if (getParameters().getParentCommand() == VdcActionType.ImportVm) {
            removeImageParams.setRemoveDuringExecution(false);
            removeImageParams.setRemoveFromDB(true);
        }
        removeImageParams.setEntityId(getDestinationImageId());
        // Setting the image as the monitored entity, so there will not be dependency
        VdcReturnValueBase returnValue = checkAndPerformRollbackUsingCommand(VdcActionType.RemoveImage, removeImageParams);
        if (returnValue.getSucceeded()) {
            // Starting to monitor the the tasks - RemoveImage is an internal command
            // which adds the taskId on the internal task ID list
            startPollingAsyncTasks(returnValue.getInternalTaskIdList());
        }
    } else {
        unLockImage();
    }
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.info("Init VM Custom Properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization failed", e);
        throw new RuntimeException(e);
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
public static void EnableLoadBalancer() {
    log.info("Start scheduling to enable load balancer");
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "PerformLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), TimeUnit.MINUTES);
    log.info("Finished scheduling to enable load balancer");
}
#method_after
public static void EnableLoadBalancer() {
    log.info("Start scheduling to enable vds load balancer");
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(instance, "PerformLoadBalancing", new Class[] {}, new Object[] {}, Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), Config.<Integer>GetValue(ConfigValues.VdsLoadBalancingeIntervalInMinutes), TimeUnit.MINUTES);
    log.info("Finished scheduling to enable vds load balancer");
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        log.info("AuditLogCleanupManager::deleteAgedOutAuditLogs - entered");
        DateTime latestTimeToKeep = DateTime.getNow().AddDays(Config.<Integer>GetValue(ConfigValues.AuditLogAgingThreashold) * -1);
        DbFacade.getInstance().getAuditLogDao().removeAllBeforeDate(latestTimeToKeep);
    } catch (RuntimeException e) {
        log.error("AuditLogCleanupManager::deleteAgedOutAuditLogs() - failed with exception", e);
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    try {
        log.info("Start deleteAgedOutAuditLogs");
        DateTime latestTimeToKeep = DateTime.getNow().AddDays(Config.<Integer>GetValue(ConfigValues.AuditLogAgingThreashold) * -1);
        DbFacade.getInstance().getAuditLogDao().removeAllBeforeDate(latestTimeToKeep);
        log.info("Finished deleteAgedOutAuditLogs");
    } catch (RuntimeException e) {
        log.error("deleteAgedOutAuditLog failed with exception", e);
    }
}
#end_block

#method_before
public static void InitDictionaries() {
    log.info("Start initializing " + CpuFlagsManagerHandler.class.getSimpleName());
    _managersDictionary.clear();
    for (Version ver : Config.<HashSet<Version>>GetValue(ConfigValues.SupportedClusterLevels)) {
        _managersDictionary.put(ver, new CpuFlagsManager(ver));
    }
    log.info("Finished initializing " + CpuFlagsManagerHandler.class.getSimpleName());
}
#method_after
public static void InitDictionaries() {
    log.info("Start initializing dictionaries");
    _managersDictionary.clear();
    for (Version ver : Config.<HashSet<Version>>GetValue(ConfigValues.SupportedClusterLevels)) {
        _managersDictionary.put(ver, new CpuFlagsManager(ver));
    }
    log.info("Finished initializing dictionaries");
}
#end_block

#method_before
public void init() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!VM.isStatusDown(vm.getStatus())) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    vm.setStatus(status);
    boolean isVmStatusDown = VM.isStatusDown(status);
    if (isVmStatusDown || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmStatusDown) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    InternalSetVmStatus(vm, status, VmExitStatus.Normal, StringUtils.EMPTY);
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    vm.setStatus(status);
    boolean isVmStatusDown = VM.isStatusDown(status);
    if (isVmStatusDown || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmStatusDown) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
@OnTimerMethodAnnotation("fetchIsoDomains")
public void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoFileMetaData> repofileList = DbFacade.getInstance().getRepoFileMetaDataDao().getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    // Set count down latch to size of map for multiple threaded.
    final CountDownLatch latch = new CountDownLatch(repofileList.size());
    resetProblematicList();
    // Iterate for each storage domain.
    for (final RepoFileMetaData repoFileMetaData : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoFileMetaData.getLastRefreshed())) {
            ThreadPoolUtil.execute(new Runnable() {

                @Override
                public void run() {
                    updateCachedIsoFileListFromVdsm(repoFileMetaData, latch);
                }
            });
        } else {
            latch.countDown();
            log.debugFormat("Automatic refresh process for {0} file type in storage domain id {1} was not performed since refresh time out did not passed yet.", repoFileMetaData.getFileType(), repoFileMetaData.getRepoDomainId());
        }
    }
    try {
        latch.await();
    } catch (InterruptedException e) {
        log.error("Automatic refresh process encounter a problem.", e);
    }
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(problematicRepoFileList);
}
#method_after
@OnTimerMethodAnnotation("fetchIsoDomains")
public void fetchIsoDomains() {
    // Gets all the active Iso storage domains.
    List<RepoFileMetaData> repofileList = DbFacade.getInstance().getRepoFileMetaDataDao().getAllRepoFilesForAllStoragePools(StorageDomainType.ISO, StoragePoolStatus.Up, StorageDomainStatus.Active, VDSStatus.Up);
    resetProblematicList();
    // Iterate for each storage domain.
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final RepoFileMetaData repoFileMetaData : repofileList) {
        // from the DB.
        if (shouldRefreshIsoDomain(repoFileMetaData.getLastRefreshed())) {
            tasks.add(new Callable<Void>() {

                @Override
                public Void call() {
                    updateCachedIsoFileListFromVdsm(repoFileMetaData);
                    return null;
                }
            });
        } else {
            log.debugFormat("Automatic refresh process for {0} file type in storage domain id {1} was not performed since refresh time out did not passed yet.", repoFileMetaData.getFileType(), repoFileMetaData.getRepoDomainId());
        }
    }
    ThreadPoolUtil.invokeAll(tasks);
    // After refresh for all Iso domains finished, handle the log.
    handleErrorLog(problematicRepoFileList);
}
#end_block

#method_before
private void updateCachedIsoFileListFromVdsm(RepoFileMetaData repoFileMetaData, final CountDownLatch latch) {
    boolean isRefreshed = false;
    try {
        List<RepoFileMetaData> problematicRepoFileList = new ArrayList<RepoFileMetaData>();
        isRefreshed = refreshIsoDomain(repoFileMetaData.getRepoDomainId(), problematicRepoFileList, repoFileMetaData.getFileType());
        addRepoFileToProblematicList(problematicRepoFileList);
    } finally {
        // At any case count down the latch, and print log message.
        latch.countDown();
        log.infoFormat("Finished automatic refresh process for {0} file type with {1}, for storage domain id {2}.", repoFileMetaData.getFileType(), isRefreshed ? "success" : "failure", repoFileMetaData.getRepoDomainId());
    }
}
#method_after
private void updateCachedIsoFileListFromVdsm(RepoFileMetaData repoFileMetaData) {
    boolean isRefreshed = false;
    try {
        List<RepoFileMetaData> problematicRepoFileList = new ArrayList<RepoFileMetaData>();
        isRefreshed = refreshIsoDomain(repoFileMetaData.getRepoDomainId(), problematicRepoFileList, repoFileMetaData.getFileType());
        addRepoFileToProblematicList(problematicRepoFileList);
    } finally {
        log.infoFormat("Finished automatic refresh process for {0} file type with {1}, for storage domain id {2}.", repoFileMetaData.getFileType(), isRefreshed ? "success" : "failure", repoFileMetaData.getRepoDomainId());
    }
}
#end_block

#method_before
void initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    SchedulerUtilQuartzImpl.getInstance().scheduleACronJob(this, "onTimer", new Class<?>[] {}, new Object[] {}, Config.<String>GetValue(ConfigValues.AutoRecoverySchedule));
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    SchedulerUtilQuartzImpl.getInstance().scheduleACronJob(this, "onTimer", new Class<?>[] {}, new Object[] {}, Config.<String>GetValue(ConfigValues.AutoRecoverySchedule));
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.info("Checking autorecoverable " + logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + ": " + fail.getId());
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.info("Checking autorecoverable " + logMsg + " done");
}
#method_after
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debugFormat("Checking autorecoverable {0}", logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + " id: " + fail.getId() + getHostName(fail));
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debugFormat("Checking autorecoverable {0} done", logMsg);
}
#end_block

#method_before
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.info("Start initializing " + this.getClass().getSimpleName());
        String ranges = Config.<String>GetValue(ConfigValues.MacPoolRanges);
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.error("MAC Pool range exceeded maximum number of mac pool addressed. Please check Mac Pool configuration.");
            }
        }
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAll();
        for (VmNetworkInterface iface : interfaces) {
            addMac(iface.getMacAddress());
        }
        initialized = true;
        log.info("Finished initializing " + this.getClass().getSimpleName());
    } catch (Exception ex) {
        log.error(INIT_ERROR_MSG, ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void initialize() {
    lockObj.writeLock().lock();
    try {
        log.info("Start initializing " + getClass().getSimpleName());
        String ranges = Config.<String>GetValue(ConfigValues.MacPoolRanges);
        if (!"".equals(ranges)) {
            try {
                initRanges(ranges);
            } catch (MacPoolExceededMaxException e) {
                log.error("MAC Pool range exceeded maximum number of mac pool addressed. Please check Mac Pool configuration.");
            }
        }
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAll();
        for (VmNetworkInterface iface : interfaces) {
            forceAddMac(iface.getMacAddress());
        }
        initialized = true;
        log.info("Finished initializing " + getClass().getSimpleName());
    } catch (Exception ex) {
        log.error(INIT_ERROR_MSG, ex);
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
public String allocateNewMac() {
    String mac = null;
    log.info("MacPoolManager::allocateNewMac entered");
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to allocate new Mac address.");
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
        }
        if (availableMacs.isEmpty()) {
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
        }
        Iterator<String> my = availableMacs.iterator();
        mac = my.next();
        commitNewMac(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
    log.infoFormat("MacPoolManager::allocateNewMac allocated mac = '{0}", mac);
    return mac;
}
#method_after
public String allocateNewMac() {
    String mac = null;
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to allocate new Mac address.");
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NOT_INITIALIZED);
        }
        if (availableMacs.isEmpty()) {
            throw new VdcBLLException(VdcBllErrors.MAC_POOL_NO_MACS_LEFT);
        }
        Iterator<String> my = availableMacs.iterator();
        mac = my.next();
        commitNewMac(mac);
    } finally {
        lockObj.writeLock().unlock();
    }
    return mac;
}
#end_block

#method_before
private boolean commitNewMac(String mac) {
    availableMacs.remove(mac);
    allocatedMacs.add(mac);
    if (availableMacs.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        AuditLogDirector.log(logable, AuditLogType.MAC_POOL_EMPTY);
        return false;
    }
    return true;
}
#method_after
private boolean commitNewMac(String mac) {
    availableMacs.remove(mac);
    allocatedMacs.put(mac, 1);
    if (availableMacs.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        AuditLogDirector.log(logable, AuditLogType.MAC_POOL_EMPTY);
        return false;
    }
    return true;
}
#end_block

#method_before
public void freeMac(String mac) {
    log.infoFormat("MacPoolManager::freeMac(mac = '{0}') - entered", mac);
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free mac address " + mac + " .");
        } else {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void freeMac(String mac) {
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free mac address " + mac + " .");
        } else {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
private void internalFreeMac(String mac) {
    if (allocatedCustomMacs.contains(mac)) {
        allocatedCustomMacs.remove(mac);
    } else if (allocatedMacs.contains(mac)) {
        allocatedMacs.remove(mac);
        availableMacs.add(mac);
    }
}
#method_after
private void internalFreeMac(String mac) {
    if (allocatedMacs.containsKey(mac)) {
        removeMacFromMap(allocatedMacs, mac);
        if (!allocatedMacs.containsKey(mac)) {
            availableMacs.add(mac);
        }
    } else if (allocatedCustomMacs.containsKey(mac)) {
        removeMacFromMap(allocatedCustomMacs, mac);
    }
}
#end_block

#method_before
public boolean addMac(String mac) {
    boolean retVal = true;
    lockObj.writeLock().lock();
    try {
        if (allocatedMacs.contains(mac)) {
            retVal = false;
        } else {
            if (availableMacs.contains(mac)) {
                retVal = commitNewMac(mac);
            } else if (allocatedCustomMacs.contains(mac)) {
                retVal = false;
            } else {
                allocatedCustomMacs.add(mac);
            }
        }
    } finally {
        lockObj.writeLock().unlock();
    }
    return retVal;
}
#method_after
public boolean addMac(String mac) {
    boolean retVal = false;
    lockObj.writeLock().lock();
    try {
        if (availableMacs.contains(mac)) {
            retVal = commitNewMac(mac);
        } else if (allocatedMacs.containsKey(mac)) {
            retVal = addMacToMap(allocatedMacs, mac);
        } else {
            retVal = addMacToMap(allocatedCustomMacs, mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
    return retVal;
}
#end_block

#method_before
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.contains(mac) || allocatedCustomMacs.contains(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
public void freeMacs(List<String> macs) {
    log.info("MacPoolManager::freeMacs - entered");
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free MAC addresses.");
        }
        for (String mac : macs) {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#method_after
public void freeMacs(List<String> macs) {
    lockObj.writeLock().lock();
    try {
        if (!initialized) {
            logInitializationError("Failed to free MAC addresses.");
        }
        for (String mac : macs) {
            internalFreeMac(mac);
        }
    } finally {
        lockObj.writeLock().unlock();
    }
}
#end_block

#method_before
@Override
public void Initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.info("Initialized VDSBrokerFrontend");
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    InitHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incompleted jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.InitDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    InitHandlers();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark incomplete jobs as {0}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), Config.DefaultConfigurationVersion)).getoption_value();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#method_after
private VdcReturnValueBase notAllowToRunAction(VdcActionType actionType) {
    // Since reload of configuration values is not fully supported, we have to get this value from DB
    // and can not use the cached configuration.
    String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
    if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
        return getErrorCommandReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
    } else if (EngineWorkingMode.PREPARE.name().equalsIgnoreCase(mode)) {
        return notAllowedInPrepForMaintMode(actionType);
    }
    return null;
}
#end_block

#method_before
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), Config.DefaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#method_after
protected VdcQueryReturnValue runQueryImpl(VdcQueryType actionType, VdcQueryParametersBase parameters, boolean isPerformUserCheck) {
    if (isPerformUserCheck) {
        String sessionId = addSessionToContext(parameters);
        if (StringUtils.isEmpty(sessionId) || SessionDataContainer.getInstance().getUser(sessionId, parameters.getRefresh()) == null) {
            return getErrorQueryReturnValue(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        }
    }
    Class<CommandBase<? extends VdcActionParametersBase>> clazz = CommandsFactory.getQueryClass(actionType.name());
    if (clazz.isAnnotationPresent(DisableInMaintenanceMode.class)) {
        String mode = (DbFacade.getInstance().getVdcOptionDao().getByNameAndVersion(ConfigValues.EngineMode.name(), ConfigCommon.defaultConfigurationVersion)).getoption_value();
        if (EngineWorkingMode.MAINTENANCE.name().equalsIgnoreCase(mode)) {
            return getErrorQueryReturnValue(VdcBllMessages.ENGINE_IS_RUNNING_IN_MAINTENANCE_MODE);
        }
    }
    QueriesCommandBase<?> command = createQueryCommand(actionType, parameters);
    command.setInternalExecution(!isPerformUserCheck);
    command.Execute();
    return command.getQueryReturnValue();
}
#end_block

#method_before
/**
 * In memory tree initialized during initialization
 */
protected void init() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    tagsMapByID.clear();
    tagsMapByName.clear();
    tags root = new tags("root", null, true, ROOT_TAG_ID, "root");
    AddTagToHash(root);
    AddChildren(root);
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
/**
 * In memory tree initialized during initialization
 */
protected void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    tagsMapByID.clear();
    tagsMapByName.clear();
    tags root = new tags("root", null, true, ROOT_TAG_ID, "root");
    AddTagToHash(root);
    AddChildren(root);
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void initialize() {
    log.info("Start initializing " + this.getClass().getSimpleName());
    succeededJobTime = Config.<Integer>GetValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>GetValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>GetValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void initialize() {
    log.info("Start initializing " + getClass().getSimpleName());
    succeededJobTime = Config.<Integer>GetValue(ConfigValues.SucceededJobCleanupTimeInMinutes).intValue();
    failedJobTime = Config.<Integer>GetValue(ConfigValues.FailedJobCleanupTimeInMinutes).intValue();
    Integer cleanupFrequency = Config.<Integer>GetValue(ConfigValues.JobCleanupRateInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(this, "completed_jobs_cleanup", new Class[] {}, new Object[] {}, cleanupFrequency, cleanupFrequency, TimeUnit.MINUTES);
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public void initialize(String bundleBaseName) {
    log.info("Start initializing " + this.getClass().getSimpleName());
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
    log.info("Finished initializing " + this.getClass().getSimpleName());
}
#method_after
public void initialize(String bundleBaseName) {
    log.info("Start initializing " + getClass().getSimpleName());
    ResourceBundle bundle = ResourceBundle.getBundle(bundleBaseName);
    final int jobMessagePrefixLength = JOB_MESSAGE_PREFIX.length();
    final int stepMessagePrefixLength = STEP_MESSAGE_PREFIX.length();
    for (String key : bundle.keySet()) {
        if (key.startsWith(JOB_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), jobMessages, VdcActionType.class, jobMessagePrefixLength);
        } else if (key.startsWith(STEP_MESSAGE_PREFIX)) {
            addMessage(key, bundle.getString(key), stepMessages, StepEnum.class, stepMessagePrefixLength);
        } else {
            log.errorFormat("The message key {0} cannot be categorized since not started with {1} nor {2}", key, JOB_MESSAGE_PREFIX, STEP_MESSAGE_PREFIX);
        }
    }
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    String volumeName = getParameters().getVolumeName();
    /*
         * To get the service info, the UI will not pass the volume name, in that case
         * engine will fetch the volume name in the database.
         *
         * NFS volume name should be passed to get nfs service details, similarly
         * REPLICATE/DISTRIBUTED_REPLICATE volume name should be passed as an
         * argument to get the SHD details.
         *
         * So to get volume name from database engine will do the following steps.
         * 1. First fetch NFS + REPLICATE/DISTRIBUTED_REPLICATE volume name
         * 2. If not found then fetch the nfs volume name and then fetch
         *    REPLICATE/DISTRIBUTED_REPLICATE volume name
         * 3. The VDS query will be called twice, one with nfs volume name
         *    and another with replicate volume name, finally combine the service details.
         */
    if (!getParameters().isDetailRequired() && StringUtils.isEmpty(volumeName)) {
        VDSReturnValue nfsReturnValue = null;
        String nfsVolumeName = "";
        String replicateVolumeName = "";
        // Get Nfs + Replicated/Distributed Replicate volume name.
        volumeName = getNfsReplicateVolumeName(getParameters().getClusterId());
        if (StringUtils.isEmpty(volumeName)) {
            // Get Nfs enabled volume name
            nfsVolumeName = getNfsVolumeName(getParameters().getClusterId());
            // Get Replicated volume name
            replicateVolumeName = getReplicateVolumeName(getParameters().getClusterId());
            // If there is no volume present in the cluster, then return empty Volume Advanced Details
            if (StringUtils.isEmpty(nfsVolumeName) && StringUtils.isEmpty(replicateVolumeName)) {
                log.error("To get service details, no Nfs or Replicated volumes found in the cluster.");
                getQueryReturnValue().setReturnValue(new GlusterVolumeAdvancedDetails());
                return;
            }
            if (StringUtils.isNotEmpty(nfsVolumeName)) {
                nfsReturnValue = executeCommand(nfsVolumeName);
            }
            if (nfsReturnValue != null && StringUtils.isNotEmpty(replicateVolumeName)) {
                // Get shd status value
                VDSReturnValue shdStatusReturnValue = executeCommand(replicateVolumeName);
                GlusterVolumeAdvancedDetails volumeAdvancedDetailsForNfs = (GlusterVolumeAdvancedDetails) nfsReturnValue.getReturnValue();
                GlusterVolumeAdvancedDetails volumeAdvancedDetailsForShd = (GlusterVolumeAdvancedDetails) shdStatusReturnValue.getReturnValue();
                // combine the Nfs + Shd status
                volumeAdvancedDetailsForNfs.getServiceInfo().addAll(volumeAdvancedDetailsForShd.getServiceInfo());
                getQueryReturnValue().setReturnValue(volumeAdvancedDetailsForNfs);
            } else if (nfsReturnValue == null && StringUtils.isNotEmpty(replicateVolumeName)) {
                VDSReturnValue shdReturnValue = executeCommand(replicateVolumeName);
                getQueryReturnValue().setReturnValue(shdReturnValue.getReturnValue());
            } else if (nfsReturnValue != null && StringUtils.isEmpty(replicateVolumeName)) {
                getQueryReturnValue().setReturnValue(nfsReturnValue.getReturnValue());
            }
        }
    } else {
        VDSReturnValue returnValue = executeCommand(volumeName);
        getQueryReturnValue().setReturnValue(returnValue.getReturnValue());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    String volumeName = getParameters().getVolumeName();
    if (StringUtils.isNotEmpty(volumeName)) {
        getQueryReturnValue().setReturnValue(fetchAdvancedDetails(volumeName));
    } else {
        getQueryReturnValue().setReturnValue(getServiceInfo());
    }
}
#end_block

#method_before
private List<GlusterVolumeEntity> getReplicateAndNfsVolumes(Guid clusterId, GlusterVolumeType volumeType) {
    return getGlusterVolumeDao().getVolumesByOptionAndVolumeType(clusterId, GlusterStatus.UP, OPTION_KEY, OPTION_VALUE, volumeType);
}
#method_after
private List<GlusterVolumeEntity> getReplicateAndNfsVolumes(Guid clusterId, List<GlusterVolumeType> volumeTypes) {
    return getGlusterVolumeDao().getVolumesByStatusTypesAndOption(clusterId, GlusterStatus.UP, volumeTypes, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
}
#end_block

#method_before
private List<GlusterVolumeEntity> getNfsVolumes(Guid clusterId) {
    return getGlusterVolumeDao().getVolumesByOption(clusterId, GlusterStatus.UP, OPTION_KEY, OPTION_VALUE);
}
#method_after
private List<GlusterVolumeEntity> getNfsVolumes(Guid clusterId) {
    return getGlusterVolumeDao().getVolumesByOption(clusterId, GlusterStatus.UP, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
}
#end_block

#method_before
private List<GlusterVolumeEntity> getReplicateVolumes(Guid clusterId, GlusterVolumeType volumeType) {
    return getGlusterVolumeDao().getVolumesByVolumeType(clusterId, GlusterStatus.UP, volumeType);
}
#method_after
private List<GlusterVolumeEntity> getReplicateVolumes(Guid clusterId, List<GlusterVolumeType> volumeTypes) {
    return getGlusterVolumeDao().getVolumesByStatusAndTypes(clusterId, GlusterStatus.UP, volumeTypes);
}
#end_block

#method_before
@Test
public void testGetVolumesByOption() {
    List<GlusterVolumeEntity> volumes = dao.getVolumesByOption(CLUSTER_ID, GlusterStatus.UP, NFS_OPTION_KEY, NFS_OPTION_VALUE);
    assertTrue(volumes != null);
    assertTrue(volumes.contains(existingReplVol));
    assertTrue(volumes.get(0).isNfsEnabled());
}
#method_after
@Test
public void testGetVolumesByOption() {
    List<GlusterVolumeEntity> volumes = dao.getVolumesByOption(CLUSTER_ID, GlusterStatus.UP, OPTION_KEY_NFS_DISABLE, OPTION_VALUE_OFF);
    assertTrue(volumes != null);
    assertTrue(volumes.contains(existingReplVol));
    assertTrue(volumes.get(0).isNfsEnabled());
}
#end_block

#method_before
@Override
public void edit(final RunOnceModel object) {
    Driver.driver.edit(object);
    object.getCustomPropertySheet().getKeyValueLines().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
        }
    });
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean toShow = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(toShow);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabValid());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
}
#method_after
@Override
public void edit(final RunOnceModel object) {
    Driver.driver.edit(object);
    object.getCustomPropertySheet().getKeyValueLines().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
        }
    });
    // Update Linux options panel
    final EntityModel isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean toShow = (Boolean) isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(toShow);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = (Boolean) object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    UpdateBootSequenceListBox();
}
#end_block

#method_before
public boolean Validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    // getCustomProperties().ValidateEntity(new IValidation[] { new CustomPropertyValidation(this.getCustomPropertiesKeysList()) });
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinux_Unassign_UnknownOS() && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation;
}
#method_after
public boolean Validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    // getCustomProperties().ValidateEntity(new IValidation[] { new CustomPropertyValidation(this.getCustomPropertiesKeysList()) });
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinux_Unassign_UnknownOS() && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    if (getIsAutoAssign().getEntity() != null && (Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation;
}
#end_block

#method_before
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabValid(false);
    model.getIsAutoAssign().setEntity(true);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#method_after
private void RunOnce() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    if (selectedItem == null || selectedItem.getEntity() == null) {
        return;
    }
    VM vm = (VM) selectedItem.getEntity();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // disable Host tab
    model.setIsHostTabVisible(false);
    fillIsoList(vm);
    fillFloppyImages(vm);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    model.getCustomProperties().setEntity(vm.getCustomProperties());
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    // Update Domain list
    AsyncDataProvider.GetDomainList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue1) {
            RunOnceModel runOnceModel = (RunOnceModel) target;
            List<String> domains = (List<String>) returnValue1;
            String oldDomain = (String) runOnceModel.getSysPrepDomainName().getSelectedItem();
            if (// $NON-NLS-1$
            oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                domains.add(0, oldDomain);
            }
            runOnceModel.getSysPrepDomainName().setItems(domains);
            runOnceModel.getSysPrepDomainName().setSelectedItem((oldDomain != null) ? oldDomain : Linq.FirstOrDefault(domains));
        }
    }), true);
    // Display protocols.
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    // Boot sequence.
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model3, Object ReturnValue) {
            UserPortalListModel userPortalListModel = (UserPortalListModel) model3;
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = ((RunOnceModel) userPortalListModel.getWindow()).getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery2);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("OnRunOnce", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar3.setIsDefault(true);
    model.getCommands().add(tempVar3);
    // $NON-NLS-1$
    UICommand tempVar4 = new UICommand("Cancel", this);
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar4.setIsCancel(true);
    model.getCommands().add(tempVar4);
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            rdpConsoleModel.getErrorEvent().addListener(new ConsoleModelErrorEventListener(this));
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void RunOnceUpdateBootSequence(VM vm) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            VmListModel vmListModel = (VmListModel) model;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel.getWindow();
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = runOnceModel.getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new GetVmByVmIdParameters(vm.getId()), _asyncQuery);
}
#method_after
private void RunOnceUpdateBootSequence(VM vm) {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            VmListModel vmListModel = (VmListModel) model;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel.getWindow();
            boolean hasNics = ((ArrayList<VmNetworkInterface>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()).size() > 0;
            if (!hasNics) {
                BootSequenceModel bootSequenceModel = runOnceModel.getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().getChangeProhibitionReasons().add(// $NON-NLS-1$
                "Virtual Machine must have at least one network interface defined to boot from network.");
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), _asyncQuery);
}
#end_block

#method_before
private void RunOnceLoadHosts(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    // append just active hosts
    AsyncDataProvider.GetHostListByCluster(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final RunOnceModel model = (RunOnceModel) target;
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getstatus())) {
                    activeHosts.add(host);
                }
            }
            model.getDefaultHost().setItems(activeHosts);
        }
    }), vm.getVdsGroupName());
    // disable host tab when no active host is available
    model.setIsHostTabValid(!model.getDefaultHost().getIsEmpty());
}
#method_after
private void RunOnceLoadHosts(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    // append just active hosts
    AsyncDataProvider.GetHostListByCluster(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            final RunOnceModel model = (RunOnceModel) target;
            final List<VDS> hosts = (ArrayList<VDS>) returnValue;
            final List<VDS> activeHosts = new ArrayList<VDS>();
            for (VDS host : hosts) {
                if (VDSStatus.Up.equals(host.getstatus())) {
                    activeHosts.add(host);
                }
            }
            model.getDefaultHost().setItems(activeHosts);
            // hide host tab when no active host is available
            if (activeHosts.isEmpty()) {
                model.setIsHostTabVisible(false);
            }
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().isAutoStartup());
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    } else if (ev.equals(ConsoleModel.ErrorEventDefinition) && sender instanceof SpiceConsoleModel) {
        SpiceConsoleModel_Error(sender, (ErrorCodeEventArgs) args);
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(ChangeCDModel.ExecutedEventDefinition)) {
        changeCD(sender, args);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    return storagePool;
}
#method_after
@Override
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
@Override
public void setStoragePoolId(NGuid storagePool) {
    this.storagePool = storagePool;
}
#method_after
@Override
public void setStoragePoolId(NGuid storagePool) {
    this.storagePoolId = storagePool;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + cpu_over_commit_duration_minutes;
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + high_utilization;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + low_utilization;
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((selection_algorithm == null) ? 0 : selection_algorithm.hashCode());
    result = prime * result + ((storagePool == null) ? 0 : storagePool.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((compatVersion == null) ? 0 : compatVersion.hashCode());
    result = prime * result + ((compatibility_version == null) ? 0 : compatibility_version.hashCode());
    result = prime * result + ((cpu_name == null) ? 0 : cpu_name.hashCode());
    result = prime * result + cpu_over_commit_duration_minutes;
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + high_utilization;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + low_utilization;
    result = prime * result + max_vds_memory_over_commit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + ((migrateOnError == null) ? 0 : migrateOnError.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((selection_algorithm == null) ? 0 : selection_algorithm.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VDSGroup other = (VDSGroup) obj;
    if (compatVersion == null) {
        if (other.compatVersion != null)
            return false;
    } else if (!compatVersion.equals(other.compatVersion))
        return false;
    if (compatibility_version == null) {
        if (other.compatibility_version != null)
            return false;
    } else if (!compatibility_version.equals(other.compatibility_version))
        return false;
    if (cpu_name == null) {
        if (other.cpu_name != null)
            return false;
    } else if (!cpu_name.equals(other.cpu_name))
        return false;
    if (cpu_over_commit_duration_minutes != other.cpu_over_commit_duration_minutes)
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        if (high_utilization != other.high_utilization)
            return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (low_utilization != other.low_utilization)
        return false;
    if (max_vds_memory_over_commit != other.max_vds_memory_over_commit)
        return false;
    if (countThreadsAsCores != other.countThreadsAsCores)
        return false;
    if (migrateOnError != other.migrateOnError)
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (selection_algorithm == null) {
        if (other.selection_algorithm != null)
            return false;
    } else if (!selection_algorithm.equals(other.selection_algorithm))
        return false;
    if (storagePool == null) {
        if (other.storagePool != null)
            return false;
    } else if (!storagePool.equals(other.storagePool))
        return false;
    if (storagePoolName == null) {
        if (other.storagePoolName != null)
            return false;
    } else if (!storagePoolName.equals(other.storagePoolName))
        return false;
    if (transparentHugepages != other.transparentHugepages)
        return false;
    if (virtService != other.virtService) {
        return false;
    }
    if (glusterService != other.glusterService) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    VDSGroup other = (VDSGroup) obj;
    if (compatVersion == null) {
        if (other.compatVersion != null)
            return false;
    } else if (!compatVersion.equals(other.compatVersion))
        return false;
    if (compatibility_version == null) {
        if (other.compatibility_version != null)
            return false;
    } else if (!compatibility_version.equals(other.compatibility_version))
        return false;
    if (cpu_name == null) {
        if (other.cpu_name != null)
            return false;
    } else if (!cpu_name.equals(other.cpu_name))
        return false;
    if (cpu_over_commit_duration_minutes != other.cpu_over_commit_duration_minutes)
        return false;
    if (description == null) {
        if (other.description != null)
            return false;
    } else if (!description.equals(other.description))
        if (high_utilization != other.high_utilization)
            return false;
    if (id == null) {
        if (other.id != null)
            return false;
    } else if (!id.equals(other.id))
        return false;
    if (low_utilization != other.low_utilization)
        return false;
    if (max_vds_memory_over_commit != other.max_vds_memory_over_commit)
        return false;
    if (countThreadsAsCores != other.countThreadsAsCores)
        return false;
    if (migrateOnError != other.migrateOnError)
        return false;
    if (name == null) {
        if (other.name != null)
            return false;
    } else if (!name.equals(other.name))
        return false;
    if (selection_algorithm == null) {
        if (other.selection_algorithm != null)
            return false;
    } else if (!selection_algorithm.equals(other.selection_algorithm))
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    if (storagePoolName == null) {
        if (other.storagePoolName != null)
            return false;
    } else if (!storagePoolName.equals(other.storagePoolName))
        return false;
    if (transparentHugepages != other.transparentHugepages)
        return false;
    if (virtService != other.virtService) {
        return false;
    }
    if (glusterService != other.glusterService) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds().getstatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        setSucceeded(MigrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getstatus() == VDSStatus.NonResponsive || getVds().getstatus() == VDSStatus.Connecting || getVds().getstatus() == VDSStatus.Down) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isMigrationOnProgress()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds().getstatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        setSucceeded(MigrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getstatus() == VDSStatus.NonResponsive || getVds().getstatus() == VDSStatus.Connecting || getVds().getstatus() == VDSStatus.Down) {
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        MigrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        MigrateAllVms(getExecutionContext(), true);
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getvds_name(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isMigrationOnProgress()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getSaveToDb()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.NonOperational, getParameters().getNonOperationalReason()));
    }
    // if host failed to recover, no point in sending migrate, as it would fail.
    if (getParameters().getNonOperationalReason() != NonOperationalReason.TIMEOUT_RECOVERING_FROM_CRASH) {
        orderListOfRunningVmsOnVds(getVdsId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                // migrate vms according to cluster migrateOnError option
                switch(getVdsGroup().getMigrateOnError()) {
                    case YES:
                        MigrateAllVms(getExecutionContext());
                        break;
                    case HA_ONLY:
                        MigrateAllVms(getExecutionContext(), true);
                        break;
                }
            }
        });
    }
    if (getParameters().getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE) {
        log.errorFormat("Host '{0}' is set to Non-Operational, it is missing the following networks: '{1}'", getVds().getvds_name(), getParameters().getCustomLogValues().get("Networks"));
    }
    setSucceeded(true);
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    boolean isShouldBeLocked = getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport;
    if (isShouldBeLocked) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to ILLEGAL, as we can't tell were the task started on vdsm side or not.
        getDiskImage().setimageStatus(ImageStatus.ILLEGAL);
        lockImageWithCompensation();
    }
    // Releasing the lock for cases it was set by the parent command. The lock can be released because the image
    // status was already changed to lock.
    freeLock();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), getStorageDomainId().getValue(), getDiskImage().getId().getValue(), getDiskImage().isWipeAfterDelete(), getParameters().getForceDelete(), getStoragePool().getcompatibility_version().toString()));
    return returnValue;
}
#method_after
@Override
protected VDSReturnValue performImageVdsmOperation() {
    boolean isShouldBeLocked = getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport;
    if (isShouldBeLocked) {
        // the image status should be set to ILLEGAL, so that in case compensation runs the image status will
        // be revert to be ILLEGAL, as we can't tell whether the task started on vdsm side or not.
        getDiskImage().setimageStatus(ImageStatus.ILLEGAL);
        lockImageWithCompensation();
    }
    // Releasing the lock for cases it was set by the parent command. The lock can be released because the image
    // status was already changed to lock.
    freeLock();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(getDiskImage().getstorage_pool_id().getValue(), getStorageDomainId().getValue(), getDiskImage().getId().getValue(), getDiskImage().isWipeAfterDelete(), getParameters().getForceDelete(), getStoragePool().getcompatibility_version().toString()));
    return returnValue;
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        if (Config.<Boolean>GetValue(ConfigValues.HardwareInfoEnabled, vds.getvds_group_compatibility_version().getValue()) && Config.<Boolean>GetValue(ConfigValues.HardwareInfoEnabled, vds.getsupported_cluster_levels())) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("refreshCapabilities:GetCapabilitiesVDSCommand started method");
    MonitoringStrategy vdsMonitoringStrategy = MonitoringStrategyFactory.getMonitoringStrategyForVds(vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand vdsBrokerCommand = new GetCapabilitiesVDSCommand(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.Execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getvds_group_compatibility_version();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by vdsm.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getstatus();
        boolean isSetNonOperational = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (isSetNonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        if (isSetNonOperational && returnStatus != VDSStatus.NonOperational) {
            if (log.isDebugEnabled()) {
                log.debugFormat("refreshCapabilities:GetCapabilitiesVDSCommand vds {0} networks  not match it's cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
            }
            vds.setstatus(VDSStatus.NonOperational);
            vds.setNonOperationalReason(NonOperationalReason.NETWORK_UNREACHABLE);
            returnStatus = vds.getstatus();
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getstatus();
        vdsMonitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getstatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            UpdateDynamicData(vds.getDynamicData());
            UpdateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    this.vmManagedDeviceMap = map;
}
#method_after
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    this.managedDeviceMap = map;
}
#end_block

#method_before
public List<VmDevice> getUnmanagedDeviceList() {
    return vmUnManagedDeviceList;
}
#method_after
public List<VmDevice> getUnmanagedDeviceList() {
    return unmanagedDeviceList;
}
#end_block

#method_before
public void setUnmanagedDeviceList(List<VmDevice> list) {
    this.vmUnManagedDeviceList = list;
}
#method_after
public void setUnmanagedDeviceList(List<VmDevice> list) {
    this.unmanagedDeviceList = list;
}
#end_block

#method_before
@Deprecated
public VmOsType getOsType() {
    return getos();
}
#method_after
@Deprecated
public VmOsType getOsType() {
    return getOs();
}
#end_block

#method_before
@Deprecated
public void setOsType(VmOsType value) {
    setos(value);
}
#method_after
@Deprecated
public void setOsType(VmOsType value) {
    setOs(value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + (autosuspend ? 1231 : 1237);
    result = prime * result + cpusPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (fail_back ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + ((mOs == null) ? 0 : mOs.hashCode());
    result = prime * result + memSizeMB;
    result = prime * result + niceLevel;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timezone == null) ? 0 : timezone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vds_group_id == null) ? 0 : vds_group_id.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((dedicated_vm_for_vds == null) ? 0 : dedicated_vm_for_vds.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + (autosuspend ? 1231 : 1237);
    result = prime * result + cpusPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + ((mOs == null) ? 0 : mOs.hashCode());
    result = prime * result + memSizeMB;
    result = prime * result + niceLevel;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timezone == null) ? 0 : timezone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (failBack != other.failBack) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vdsGroupId == null) {
        if (other.vdsGroupId != null) {
            return false;
        }
    } else if (!vdsGroupId.equals(other.vdsGroupId)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicatedVmForVds == null) {
        if (other.dedicatedVmForVds != null) {
            return false;
        }
    } else {
        if (!dedicatedVmForVds.equals(other.dedicatedVmForVds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void setDataCenter(ListModel value) {
    privateDataCenter = value;
}
#method_after
private void setDataCenter(NotChangableForVmInPoolListModel value) {
    privateDataCenter = value;
}
#end_block

#method_before
private void setStorageDomain(ListModel value) {
    privateStorageDomain = value;
}
#method_after
private void setStorageDomain(NotChangableForVmInPoolListModel value) {
    privateStorageDomain = value;
}
#end_block

#method_before
private void setTemplate(ListModel value) {
    privateTemplate = value;
}
#method_after
private void setTemplate(NotChangableForVmInPoolListModel value) {
    privateTemplate = value;
}
#end_block

#method_before
private void setOSType(ListModel value) {
    privateOSType = value;
}
#method_after
private void setOSType(NotChangableForVmInPoolListModel value) {
    privateOSType = value;
}
#end_block

#method_before
private void setNumOfMonitors(ListModel value) {
    privateNumOfMonitors = value;
}
#method_after
private void setNumOfMonitors(NotChangableForVmInPoolListModel value) {
    privateNumOfMonitors = value;
}
#end_block

#method_before
private void setAllowConsoleReconnect(EntityModel value) {
    privateAllowConsoleReconnect = value;
}
#method_after
private void setAllowConsoleReconnect(NotChangableForVmInPoolEntityModel value) {
    privateAllowConsoleReconnect = value;
}
#end_block

#method_before
private void setDescription(EntityModel value) {
    privateDescription = value;
}
#method_after
private void setDescription(NotChangableForVmInPoolEntityModel value) {
    privateDescription = value;
}
#end_block

#method_before
private void setDomain(ListModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(NotChangableForVmInPoolListModel value) {
    privateDomain = value;
}
#end_block

#method_before
private void setMemSize(EntityModel value) {
    privateMemSize = value;
}
#method_after
private void setMemSize(NotChangableForVmInPoolEntityModel value) {
    privateMemSize = value;
}
#end_block

#method_before
private void setMinAllocatedMemory(EntityModel value) {
    privateMinAllocatedMemory = value;
}
#method_after
private void setMinAllocatedMemory(NotChangableForVmInPoolEntityModel value) {
    privateMinAllocatedMemory = value;
}
#end_block

#method_before
private void setQuota(ListModel value) {
    privateQuota = value;
}
#method_after
private void setQuota(NotChangableForVmInPoolListModel value) {
    privateQuota = value;
}
#end_block

#method_before
private void setCluster(ListModel value) {
    privateCluster = value;
}
#method_after
private void setCluster(NotChangableForVmInPoolListModel value) {
    privateCluster = value;
}
#end_block

#method_before
private void setUsbPolicy(ListModel value) {
    privateUsbPolicy = value;
}
#method_after
private void setUsbPolicy(NotChangableForVmInPoolListModel value) {
    privateUsbPolicy = value;
}
#end_block

#method_before
private void setTimeZone(ListModel value) {
    privateTimeZone = value;
}
#method_after
private void setTimeZone(NotChangableForVmInPoolListModel value) {
    privateTimeZone = value;
}
#end_block

#method_before
private void setNumOfSockets(ListModel value) {
    privateNumOfSockets = value;
}
#method_after
private void setNumOfSockets(NotChangableForVmInPoolListModel value) {
    privateNumOfSockets = value;
}
#end_block

#method_before
private void setTotalCPUCores(EntityModel value) {
    privateTotalCPUCores = value;
}
#method_after
private void setTotalCPUCores(NotChangableForVmInPoolEntityModel value) {
    privateTotalCPUCores = value;
}
#end_block

#method_before
private void setCoresPerSocket(ListModel value) {
    privateCoresPerSocket = value;
}
#method_after
private void setCoresPerSocket(NotChangableForVmInPoolListModel value) {
    privateCoresPerSocket = value;
}
#end_block

#method_before
private void setDefaultHost(ListModel value) {
    privateDefaultHost = value;
}
#method_after
private void setDefaultHost(NotChangableForVmInPoolListModel value) {
    privateDefaultHost = value;
}
#end_block

#method_before
private void setIsSmartcardEnabled(EntityModel value) {
    privateisSmartcardEnabled = value;
}
#method_after
private void setIsSmartcardEnabled(NotChangableForVmInPoolEntityModel value) {
    privateisSmartcardEnabled = value;
}
#end_block

#method_before
private void setIsStateless(EntityModel value) {
    privateIsStateless = value;
}
#method_after
private void setIsStateless(NotChangableForVmInPoolEntityModel value) {
    privateIsStateless = value;
}
#end_block

#method_before
private void setDisplayProtocol(ListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(NotChangableForVmInPoolListModel value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
private void setProvisioning(EntityModel value) {
    privateProvisioning = value;
}
#method_after
private void setProvisioning(NotChangableForVmInPoolEntityModel value) {
    privateProvisioning = value;
}
#end_block

#method_before
public void setProvisioningThin_IsSelected(EntityModel value) {
    privateProvisioningThin_IsSelected = value;
}
#method_after
public void setProvisioningThin_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningThin_IsSelected = value;
}
#end_block

#method_before
public void setProvisioningClone_IsSelected(EntityModel value) {
    privateProvisioningClone_IsSelected = value;
}
#method_after
public void setProvisioningClone_IsSelected(NotChangableForVmInPoolEntityModel value) {
    privateProvisioningClone_IsSelected = value;
}
#end_block

#method_before
private void setPriority(ListModel value) {
    privatePriority = value;
}
#method_after
private void setPriority(NotChangableForVmInPoolListModel value) {
    privatePriority = value;
}
#end_block

#method_before
private void setIsHighlyAvailable(EntityModel value) {
    privateIsHighlyAvailable = value;
}
#method_after
private void setIsHighlyAvailable(NotChangableForVmInPoolEntityModel value) {
    privateIsHighlyAvailable = value;
}
#end_block

#method_before
private void setFirstBootDevice(ListModel value) {
    privateFirstBootDevice = value;
}
#method_after
private void setFirstBootDevice(NotChangableForVmInPoolListModel value) {
    privateFirstBootDevice = value;
}
#end_block

#method_before
private void setSecondBootDevice(ListModel value) {
    privateSecondBootDevice = value;
}
#method_after
private void setSecondBootDevice(NotChangableForVmInPoolListModel value) {
    privateSecondBootDevice = value;
}
#end_block

#method_before
private void setCdImage(ListModel value) {
    privateCdImage = value;
}
#method_after
private void setCdImage(NotChangableForVmInPoolListModel value) {
    privateCdImage = value;
}
#end_block

#method_before
public void setCdAttached(EntityModel value) {
    cdAttached = value;
}
#method_after
public void setCdAttached(NotChangableForVmInPoolEntityModel value) {
    cdAttached = value;
}
#end_block

#method_before
private void setInitrd_path(EntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(NotChangableForVmInPoolEntityModel value) {
    privateInitrd_path = value;
}
#end_block

#method_before
private void setKernel_path(EntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(NotChangableForVmInPoolEntityModel value) {
    privateKernel_path = value;
}
#end_block

#method_before
private void setKernel_parameters(EntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(NotChangableForVmInPoolEntityModel value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
private void setCustomProperties(EntityModel value) {
    privateCustomProperties = value;
}
#method_after
private void setCustomProperties(NotChangableForVmInPoolEntityModel value) {
    privateCustomProperties = value;
}
#end_block

#method_before
public void setCustomPropertySheet(KeyValueModel customPropertySheet) {
    this.customPropertySheet = customPropertySheet;
}
#method_after
public void setCustomPropertySheet(NotChangableForVmInPoolKeyValueModel customPropertySheet) {
    this.customPropertySheet = customPropertySheet;
}
#end_block

#method_before
public void setIsAutoAssign(EntityModel value) {
    privateIsAutoAssign = value;
}
#method_after
public void setIsAutoAssign(NotChangableForVmInPoolEntityModel value) {
    privateIsAutoAssign = value;
}
#end_block

#method_before
public void setRunVMOnSpecificHost(EntityModel value) {
    privateRunVMOnSpecificHost = value;
}
#method_after
public void setRunVMOnSpecificHost(NotChangableForVmInPoolEntityModel value) {
    privateRunVMOnSpecificHost = value;
}
#end_block

#method_before
public void setDontMigrateVM(EntityModel value) {
    privateDontMigrateVM = value;
}
#method_after
public void setDontMigrateVM(NotChangableForVmInPoolEntityModel value) {
    privateDontMigrateVM = value;
}
#end_block

#method_before
private void setIsTemplatePublic(EntityModel value) {
    privateIsTemplatePublic = value;
}
#method_after
private void setIsTemplatePublic(NotChangableForVmInPoolEntityModel value) {
    privateIsTemplatePublic = value;
}
#end_block

#method_before
public void setCpuPinning(EntityModel cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#method_after
public void setCpuPinning(NotChangableForVmInPoolEntityModel cpuPinning) {
    this.cpuPinning = cpuPinning;
}
#end_block

#method_before
public void Initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.Initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getDontMigrateVM().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getRunVMOnSpecificHost().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getCdImage().setIsChangable(false);
    InitOSType();
    InitDisplayProtocol();
    InitFirstBootDevice();
    InitNumOfMonitors();
    InitAllowConsoleReconnect();
    InitMinimalVmMemSize();
    InitMaximalVmMemSize32OS();
    behavior.Initialize(SystemTreeSelectedItem);
}
#method_after
public void Initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.Initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getDontMigrateVM().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getRunVMOnSpecificHost().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getHostCpu().setEntity(false);
    getRunVMOnSpecificHost().setIsChangable(false);
    getCdImage().setIsChangable(false);
    InitOSType();
    InitDisplayProtocol();
    InitFirstBootDevice();
    InitNumOfMonitors();
    InitAllowConsoleReconnect();
    InitMinimalVmMemSize();
    InitMaximalVmMemSize32OS();
    behavior.Initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
private void RunVMOnSpecificHost_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getRunVMOnSpecificHost().getEntity() == true) {
        getDontMigrateVM().setEntity(false);
        getDontMigrateVM().setIsChangable(false);
    } else {
        getDontMigrateVM().setIsChangable(true);
    }
}
#method_after
private void RunVMOnSpecificHost_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getRunVMOnSpecificHost().getEntity() == true) {
        clearAndDisable(getDontMigrateVM());
        getHostCpu().setIsChangable(true);
    } else {
        clearAndDisable(getHostCpu());
        getDontMigrateVM().setIsChangable(true);
    }
    behavior.updateCpuPinningVisibility();
}
#end_block

#method_before
private void IsAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == true) {
        getRunVMOnSpecificHost().setEntity(false);
        getRunVMOnSpecificHost().setIsChangable(false);
    } else {
        getRunVMOnSpecificHost().setIsChangable(true);
    }
}
#method_after
private void IsAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == true) {
        clearAndDisable(getRunVMOnSpecificHost());
        clearAndDisable(getHostCpu());
    } else {
        getRunVMOnSpecificHost().setIsChangable(true);
    }
    behavior.updateCpuPinningVisibility();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS) {
        String kernelPath = (String) getKernel_path().getEntity();
        String initrdPath = (String) getInitrd_path().getEntity();
        String kernelParams = (String) getKernel_parameters().getEntity();
        String cannotStartOrEndWithWhitespaceMsg = ConstantsManager.getInstance().getConstants().trimmingSpacesInField();
        if (hasTrimmingWhitespaces(kernelPath)) {
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if (hasTrimmingWhitespaces(kernelParams)) {
            getKernel_parameters().setIsValid(false);
            getKernel_parameters().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if (hasTrimmingWhitespaces(initrdPath)) {
            getInitrd_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(cannotStartOrEndWithWhitespaceMsg);
        }
        if ((kernelParams.length() > 0 || initrdPath.length() > 0) && kernelPath.length() == 0) {
            boolean kernelParamInvalid = false;
            boolean inetdPathInvalid = false;
            if (kernelParams.length() > 0) {
                getKernel_parameters().setIsValid(false);
                kernelParamInvalid = true;
            }
            if (initrdPath.length() > 0) {
                getInitrd_path().setIsValid(false);
                inetdPathInvalid = true;
            }
            String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
            "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
            "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
            "");
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(msg);
            getKernel_parameters().getInvalidityReasons().add(msg);
            getKernel_path().getInvalidityReasons().add(msg);
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getKernel_parameters().getIsValid() && getInitrd_path().getIsValid() && behavior.Validate() && customPropertySheetValid;
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT), new I18NNameValidation() });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255), new SpecialAsciiI18NOrNoneValidation() });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS) {
        getKernel_path().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().ValidateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        String kernelPath = (String) getKernel_path().getEntity();
        String initrdPath = (String) getInitrd_path().getEntity();
        String kernelParams = (String) getKernel_parameters().getEntity();
        if ((kernelParams.length() > 0 || initrdPath.length() > 0) && kernelPath.length() == 0) {
            boolean kernelParamInvalid = false;
            boolean inetdPathInvalid = false;
            if (kernelParams.length() > 0) {
                getKernel_parameters().setIsValid(false);
                kernelParamInvalid = true;
            }
            if (initrdPath.length() > 0) {
                getInitrd_path().setIsValid(false);
                inetdPathInvalid = true;
            }
            String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
            "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
            "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
            "");
            getKernel_path().setIsValid(false);
            getInitrd_path().getInvalidityReasons().add(msg);
            getKernel_parameters().getInvalidityReasons().add(msg);
            getKernel_path().getInvalidityReasons().add(msg);
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getKernel_parameters().getIsValid() && getInitrd_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
protected void setPoolType(ListModel value) {
    poolType = value;
}
#method_after
protected void setPoolType(NotChangableForVmInPoolListModel value) {
    poolType = value;
}
#end_block

#method_before
protected void setNumOfDesktops(EntityModel value) {
    numOfDesktops = value;
}
#method_after
protected void setNumOfDesktops(NotChangableForVmInPoolEntityModel value) {
    numOfDesktops = value;
}
#end_block

#method_before
public void setAssignedVms(EntityModel value) {
    assignedVms = value;
}
#method_after
public void setAssignedVms(NotChangableForVmInPoolEntityModel value) {
    assignedVms = value;
}
#end_block

#method_before
protected void setPrestartedVms(EntityModel value) {
    prestartedVms = value;
}
#method_after
protected void setPrestartedVms(NotChangableForVmInPoolEntityModel value) {
    prestartedVms = value;
}
#end_block

#method_before
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#method_after
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setClusterPolicyModel(new ClusterPolicyModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || ((String) getGlusterHostAddress().getEntity()).trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
public boolean Validate(boolean validateStoragePool, boolean validateCpu) {
    getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().ValidateSelectedItem(new IValidation[] {});
    }
    getVersion().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = ((Boolean) getEnableOvirtService().getEntity()) || ((Boolean) getEnableGlusterService().getEntity());
    }
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (((Boolean) getIsImportGlusterConfiguration().getEntity()) && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    getGlusterHostAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? isFingerprintVerified() : true));
    return super.Validate() && getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? isFingerprintVerified() : true);
}
#method_after
public boolean Validate(boolean validateStoragePool, boolean validateCpu) {
    getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().ValidateSelectedItem(new IValidation[] {});
    }
    getVersion().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = ((Boolean) getEnableOvirtService().getEntity()) || ((Boolean) getEnableGlusterService().getEntity());
    }
    getGlusterHostAddress().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().ValidateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (((Boolean) getIsImportGlusterConfiguration().getEntity()) && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getClusterPolicyModel().Validate() && getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && ((Boolean) getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true);
}
#end_block

#method_before
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(true);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#method_after
private void applyModeCustomizations() {
    if (ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly) {
        optimizationTab.setVisible(false);
        resiliencePolicyTab.setVisible(false);
        clusterPolicyTab.setVisible(false);
        dataCenterPanel.addStyleName(style.generalTabTopDecoratorEmpty());
    }
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    object.getOverCommitTime().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setClusterPolicyModel(object);
            if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.PowerSave)) {
                policyRadioButton_powerSave.setValue(true);
            } else if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.EvenlyDistribute)) {
                policyRadioButton_evenDist.setValue(true);
            } else {
                policyRadioButton_none.setValue(true);
            }
            setSelectionAlgorithm();
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    if (object.getClusterPolicyModel().isEditClusterPolicyFirst()) {
        tabsPanel.switchTab(clusterPolicyTab);
    }
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    object.getClusterPolicyModel().getOverCommitTime().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setClusterPolicyModel(object.getClusterPolicyModel());
            if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.PowerSave)) {
                policyRadioButton_powerSave.setValue(true);
            } else if (getClusterPolicyModel().getSelectionAlgorithm().equals(VdsSelectionAlgorithm.EvenlyDistribute)) {
                policyRadioButton_evenDist.setValue(true);
            } else {
                policyRadioButton_none.setValue(true);
            }
            setSelectionAlgorithm();
        }
    });
}
#end_block

#method_before
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new ClusterGeneralModel());
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void InitDetailModels() {
    super.InitDetailModels();
    setClusterServiceModel(new ClusterServiceModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    clusterGeneralModel = new ClusterGeneralModel();
    list.add(clusterGeneralModel);
    list.add(new ClusterNetworkListModel());
    list.add(new ClusterHostListModel());
    list.add(new ClusterVmListModel());
    list.add(getClusterServiceModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.setSelectionAlgorithm(cluster.getselection_algorithm());
    clusterModel.getOverCommitTime().setEntity(cluster.getcpu_over_commit_duration_minutes());
    clusterModel.setOverCommitLowLevel(cluster.getlow_utilization());
    clusterModel.setOverCommitHighLevel(cluster.gethigh_utilization());
    clusterModel.SaveDefaultValues();
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    clusterModel.getClusterPolicyModel().setEditClusterPolicyFirst(clusterPolicyFirst);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getClusterPolicyModel().setSelectionAlgorithm(cluster.getselection_algorithm());
    clusterModel.getClusterPolicyModel().getOverCommitTime().setEntity(cluster.getcpu_over_commit_duration_minutes());
    clusterModel.getClusterPolicyModel().setOverCommitLowLevel(cluster.getlow_utilization());
    clusterModel.getClusterPolicyModel().setOverCommitHighLevel(cluster.gethigh_utilization());
    clusterModel.getClusterPolicyModel().SaveDefaultValues();
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getSelectionAlgorithm());
    if (model.getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getOverCommitHighLevel());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    cluster.setselection_algorithm(model.getClusterPolicyModel().getSelectionAlgorithm());
    if (model.getClusterPolicyModel().getOverCommitTime().getIsAvailable()) {
        cluster.setcpu_over_commit_duration_minutes(Integer.parseInt(model.getClusterPolicyModel().getOverCommitTime().getEntity().toString()));
    }
    cluster.setlow_utilization(model.getClusterPolicyModel().getOverCommitLowLevel());
    cluster.sethigh_utilization(model.getClusterPolicyModel().getOverCommitHighLevel());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        OnSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command, Object... parameters) {
    if (command == getEditCommand() && parameters.length > 0 && Boolean.TRUE.equals(parameters[0])) {
        this.clusterPolicyFirst = true;
        super.ExecuteCommand(command, parameters);
        this.clusterPolicyFirst = false;
    }
}
#end_block

#method_before
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(":");
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchStringPrefixRaw.equals(disksSearchPrefix) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchStringPrefix.equals(disksSearchPrefix + space) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().Search();
}
#method_after
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().Search();
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.ExecuteWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getvds_group_compatibility_version())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.error("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("RefreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("RefreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    VMStatus currentVmStatus = runningVm.getstatus();
    // is not MigratingFrom, it means the migration failed
    if (oldVmStatus == VMStatus.MigratingFrom && currentVmStatus != VMStatus.MigratingFrom && currentVmStatus.isRunning()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("Adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("vds::Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#method_after
private void moveVDSToMaintenanceIfNeeded() {
    if ((_vds.getstatus() == VDSStatus.PreparingForMaintenance) && monitoringStrategy.canMoveToMaintenance(_vds)) {
        _vdsManager.setStatus(VDSStatus.Maintenance, _vds);
        _saveVdsDynamic = true;
        _saveVdsStatistics = true;
        log.infoFormat("Updated vds status from 'Preparing for Maintenance' to 'Maintenance' in database,  vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
}
#end_block

#method_before
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debug("Checking autorecoverable " + logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + ": " + fail.getId());
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debug("Checking autorecoverable " + logMsg + " done");
}
#method_after
<T extends BusinessEntity<Guid>> void check(final AutoRecoverDAO<T> dao, final VdcActionType actionType, final DoWithClosure<T, VdcActionParametersBase> paramsCallback, final String logMsg) {
    if (!shouldPerformRecoveryOnType(logMsg)) {
        log.info("Autorecovering " + logMsg + " is disabled, skipping");
        return;
    }
    log.debugFormat("Checking autorecoverable {0}", logMsg);
    final List<T> fails = dao.listFailedAutorecoverables();
    final BackendInternal backend = getBackend();
    log.info("Autorecovering " + fails.size() + " " + logMsg);
    for (final T fail : fails) {
        log.info("Autorecovering " + logMsg + " id: " + fail.getId() + getHostName(fail));
        final VdcActionParametersBase actionParams = paramsCallback.doWith(fail);
        actionParams.setShouldBeLogged(true);
        backend.runInternalAction(actionType, actionParams);
    }
    log.debugFormat("Checking autorecoverable {0} done", logMsg);
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        log.errorFormat("Reverting task handler: {0}", getCurrentTaskHandler().getClass().getName());
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#end_block

#method_before
@Override
public String getValue(String value) throws GeneralSecurityException {
    /*
         * The idea of this method would normally be to decrypt and return
         * the decrypted value. Due to security reasons, we do not wish to return
         * the real value. Just an indication if we have a value in the DB or not.
         * So if there's no value we return "Empty".
         * If there's a value we try to decrypt. On success we return "Set",
         * On failure we return an error.
         */
    String returnedValue = "Empty";
    if (value != null && !value.equals("")) {
        try {
            decrypt(value);
            returnedValue = "Set";
        } catch (Exception e) {
            String msg = "Failed to decrypt the current value";
            Logger.getLogger(EngineConfig.class).debug(msg, e);
            throw new GeneralSecurityException(msg);
        }
    }
    return returnedValue;
}
#method_after
@Override
public String getValue(String value) throws GeneralSecurityException {
    /*
         * The idea of this method would normally be to decrypt and return
         * the decrypted value. Due to security reasons, we do not wish to return
         * the real value. Just an indication if we have a value in the DB or not.
         * So if there's no value we return "Empty".
         * If there's a value we try to decrypt. On success we return "Set",
         * On failure we return an error.
         */
    String returnedValue = "Empty";
    if (value != null && !value.equals("")) {
        try {
            decrypt(value);
            returnedValue = "Set";
        } catch (Exception e) {
            String msg = "Failed to decrypt the current value";
            log.error(msg, e);
            throw new GeneralSecurityException(msg);
        }
    }
    return returnedValue;
}
#end_block

#method_before
@Override
public String setValue(String value) throws GeneralSecurityException {
    String returnedValue = null;
    String password = null;
    try {
        password = extractPasswordValue(value);
        if (StringUtils.isBlank(password)) {
            return StringUtils.EMPTY;
        }
        returnedValue = encrypt(password);
    } catch (Throwable e) {
        String msg = "Failed to encrypt the current value";
        Logger.getLogger(EngineConfig.class).debug(msg, e);
        throw new GeneralSecurityException(msg);
    }
    return returnedValue;
}
#method_after
@Override
public String setValue(String value) throws GeneralSecurityException {
    String returnedValue = null;
    String password = null;
    try {
        password = extractPasswordValue(value);
        if (StringUtils.isBlank(password)) {
            return StringUtils.EMPTY;
        }
        returnedValue = encrypt(password);
    } catch (Throwable e) {
        String msg = "Failed to encrypt the current value";
        log.error(msg, e);
        throw new GeneralSecurityException(msg);
    }
    return returnedValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (!getVm().getStatus().isStatusOfRunningOrPausedVM()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((VmRunHandler.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (!getVm().isRunningOrPaused()) {
        setSucceeded(false);
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
        // An empty 'mCdImagePath' means eject CD
        if (!StringUtils.isEmpty(mCdImagePath)) {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        } else {
            addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EJECT_CD);
        }
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
    } else if ((VmRunHandler.getInstance().findActiveISODomain(getVm().getStoragePoolId()) == null) && !StringUtils.isEmpty(mCdImagePath)) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__CHANGE_CD);
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
        setSucceeded(false);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
protected boolean GetRunningOnVds() {
    // We will need the virtual machine and the status, so it is worth saving references:
    final VM vm = getVm();
    final VMStatus status = vm.getStatus();
    // there is no need to find the id of the host:
    if (!status.isStatusOfRunningOrPausedVM() && status != VMStatus.NotResponding) {
        return false;
    }
    // Find the id of the host where the machine is running:
    NGuid hostId = vm.getRunOnVds();
    if (hostId == null) {
        log.warnFormat("Strange, according to the status \"{0}\" virtual machine \"{1}\" should be running in a host but it isn't.", status, vm.getId());
        return false;
    }
    // Find the reference to the host using the id that we got before (setting
    // the host to null is required in order to make sure that the host is
    // reloaded from the database):
    setVdsId(new Guid(hostId.toString()));
    setVds(null);
    if (getVds() == null) {
        log.warnFormat("Strange, virtual machine \"{0}\" is is running in host \"{1}\" but that host can't be found.", vm.getId(), hostId);
        return false;
    }
    // a host:
    return true;
}
#method_after
protected boolean GetRunningOnVds() {
    // We will need the virtual machine and the status, so it is worth saving references:
    final VM vm = getVm();
    final VMStatus status = vm.getStatus();
    // there is no need to find the id of the host:
    if (!status.isRunningOrPaused() && status != VMStatus.NotResponding) {
        return false;
    }
    // Find the id of the host where the machine is running:
    NGuid hostId = vm.getRunOnVds();
    if (hostId == null) {
        log.warnFormat("Strange, according to the status \"{0}\" virtual machine \"{1}\" should be running in a host but it isn't.", status, vm.getId());
        return false;
    }
    // Find the reference to the host using the id that we got before (setting
    // the host to null is required in order to make sure that the host is
    // reloaded from the database):
    setVdsId(new Guid(hostId.toString()));
    setVds(null);
    if (getVds() == null) {
        log.warnFormat("Strange, virtual machine \"{0}\" is is running in host \"{1}\" but that host can't be found.", vm.getId(), hostId);
        return false;
    }
    // a host:
    return true;
}
#end_block

#method_before
@Override
protected void Perform() {
    if (getVm().getStatus().isStatusOfRunningVM()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.Pause, new PauseVDSCommandParameters(getVdsId(), getVmId())).getReturnValue());
        // Vds.pause(VmId);
        setSucceeded(true);
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#method_after
@Override
protected void Perform() {
    if (getVm().isRunning()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.Pause, new PauseVDSCommandParameters(getVdsId(), getVmId())).getReturnValue());
        // Vds.pause(VmId);
        setSucceeded(true);
    } else {
        setActionReturnValue(getVm().getStatus());
    }
}
#end_block

#method_before
public static boolean CanPauseVm(Guid vmId, java.util.ArrayList<String> message) {
    boolean retValue = true;
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else {
        if (vm.getStatus() == VMStatus.WaitForLaunch || vm.getStatus() == VMStatus.MigratingFrom || vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
        } else if (!vm.getStatus().isStatusOfRunningVM()) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.toString());
        }
    }
    if (!retValue) {
        message.add(VdcBllMessages.VAR__ACTION__PAUSE.toString());
        message.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#method_after
public static boolean CanPauseVm(Guid vmId, java.util.ArrayList<String> message) {
    boolean retValue = true;
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else {
        if (vm.getStatus() == VMStatus.WaitForLaunch || vm.getStatus() == VMStatus.MigratingFrom || vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
        } else if (!vm.isRunning()) {
            retValue = false;
            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.toString());
        }
    }
    if (!retValue) {
        message.add(VdcBllMessages.VAR__ACTION__PAUSE.toString());
        message.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else if (!getVm().getStatus().isStatusOfRunningVM() && getVm().getStatus() != VMStatus.Paused && getVm().getStatus() != VMStatus.NotResponding && getVm().getStatus() != VMStatus.Suspended) {
        if (getVm().getStatus() == VMStatus.SavingState || getVm().getStatus() == VMStatus.RestoringState) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_SAVING_RESTORING);
        } else {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else if (!getVm().isRunning() && getVm().getStatus() != VMStatus.Paused && getVm().getStatus() != VMStatus.NotResponding && getVm().getStatus() != VMStatus.Suspended) {
        if (getVm().getStatus() == VMStatus.SavingState || getVm().getStatus() == VMStatus.RestoringState) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_SAVING_RESTORING);
        } else {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
        }
    }
    return retValue;
}
#end_block

#method_before
public static boolean IsVmRunning(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm != null) {
        return vm.getStatus().isStatusOfRunningOrPausedVM() || vm.getStatus() == VMStatus.Unknown;
    }
    return false;
}
#method_after
public static boolean IsVmRunning(Guid vmId) {
    VM vm = DbFacade.getInstance().getVmDao().get(vmId);
    if (vm != null) {
        return vm.isRunningOrPaused() || vm.getStatus() == VMStatus.Unknown;
    }
    return false;
}
#end_block

#method_before
@Override
protected void ExecuteVDSCommand() {
    SetVmStatusVDSCommandParameters parameters = getParameters();
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(parameters.getVmId());
    vmDynamic.setstatus(parameters.getStatus());
    if (parameters.getStatus().isStatusOfNotRunningVM()) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        VmStatistics vmStatistics = DbFacade.getInstance().getVmStatisticsDao().get(parameters.getVmId());
        VM vm = new VM(null, vmDynamic, vmStatistics);
        ResourceManager.getInstance().InternalSetVmStatus(vm, parameters.getStatus());
        DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
        List<VmNetworkInterface> interfaces = vm.getInterfaces();
        if (interfaces != null && interfaces.size() > 0) {
            for (VmNetworkInterface ifc : interfaces) {
                VmNetworkStatistics stats = ifc.getStatistics();
                DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
            }
        }
    } else if (parameters.getStatus() == VMStatus.Unknown) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    }
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#method_after
@Override
protected void ExecuteVDSCommand() {
    SetVmStatusVDSCommandParameters parameters = getParameters();
    final VMStatus status = parameters.getStatus();
    if (status == null) {
        log.warnFormat("got request to change the status of VM whose id is {0} to null,  ignoring", parameters.getVmId());
        return;
    }
    VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(parameters.getVmId());
    vmDynamic.setstatus(status);
    if (status.isNotRunning()) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        VmStatistics vmStatistics = DbFacade.getInstance().getVmStatisticsDao().get(parameters.getVmId());
        VM vm = new VM(null, vmDynamic, vmStatistics);
        ResourceManager.getInstance().InternalSetVmStatus(vm, status);
        DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
        List<VmNetworkInterface> interfaces = vm.getInterfaces();
        if (interfaces != null && interfaces.size() > 0) {
            for (VmNetworkInterface ifc : interfaces) {
                VmNetworkStatistics stats = ifc.getStatistics();
                DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
            }
        }
    } else if (status == VMStatus.Unknown) {
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
    }
    DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
}
#end_block

#method_before
@Override
protected void Perform() {
    if (getVm().getStatus().isStatusOfRunningOrPausedVM()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeFloppy, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), mCdImagePath)).getReturnValue());
        setSucceeded(true);
    }
}
#method_after
@Override
protected void Perform() {
    if (getVm().isRunningOrPaused()) {
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeFloppy, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), mCdImagePath)).getReturnValue());
        setSucceeded(true);
    }
}
#end_block

#method_before
public boolean isDown() {
    return getStatus() == VMStatus.Down;
}
#method_after
// /////////////////////////////////////////////
// / Utility methods that check the VM state ///
// /////////////////////////////////////////////
public boolean isDown() {
    return getStatus() == VMStatus.Down;
}
#end_block

#method_before
public boolean isRunning() {
    return getStatus().isStatusOfRunningVM();
}
#method_after
public boolean isRunning() {
    return getStatus().isRunning();
}
#end_block

#method_before
public void init() {
    log.info("ResourceManager::ResourceManager::Entered");
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.getStatus().isStatusOfNotRunningVM()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
}
#method_after
public void init() {
    log.info("ResourceManager::ResourceManager::Entered");
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getstatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Cleanup all vms dynamic data. This is defencive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            // check if vm should be suspended
            if (vm.getStatus() == VMStatus.SavingState) {
                InternalSetVmStatus(vm, VMStatus.Suspended);
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
                DbFacade.getInstance().getVmStatisticsDao().update(vm.getStatisticsData());
            } else {
                if (vm.getRunOnVds() != null) {
                    MultiValueMapUtils.addToMap(vm.getRunOnVds().getValue(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
                }
                if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                    SetVmUnknown(vm);
                }
            }
        }
    }
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.Init();
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isStatusOfNotRunningVM();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
        }
    }
}
#end_block

#method_before
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VDSParametersBase> VDSCommandBase<P> CreateCommand(VDSCommandType commandType, P parameters) {
    try {
        @SuppressWarnings("unchecked")
        Class<VDSCommandBase<P>> type = (Class<VDSCommandBase<P>>) Class.forName(GetCommandTypeName(commandType));
        Constructor<VDSCommandBase<P>> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.debug("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.debug("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && runningVm.getstatus().isStatusOfGuestUp()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#method_after
private void afterMigrationFrom(VmDynamic runningVm, VM vmToUpdate) {
    VMStatus oldVmStatus = vmToUpdate.getStatus();
    if (oldVmStatus == VMStatus.MigratingFrom && runningVm.getstatus().isGuestUp()) {
        _vmsToRerun.add(runningVm.getId());
        log.infoFormat("adding VM {0} to re-run list", runningVm.getId());
        vmToUpdate.setMigratingToVds(null);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
    freeLock();
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        endSuccessfully();
    } else {
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, getCompensationContext());
        // at the moment there's no need to execute vdsm Snapshot command for diskless snapshots,
        // when support for ram snapshot will be introduced, this vdsm command should be executed
        // for diskless snapshots as well (currently executed within endSuccesfully() method.
        incrementVmGeneration();
    } else {
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
        freeLock();
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@Override
protected void Perform() {
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM state from the DB, to avoid multi requests for VM hibernation.
    setVm(null);
    if (getVm().getStatus().isStatusOfRunningVM()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getVm().getDynamicData(), getVm().getStatus());
                // Set the VM to SavingState to lock the VM,to avoid situation of multi VM hibernation.
                getVm().setStatus(VMStatus.SavingState);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
                getCompensationContext().stateChanged();
                return null;
            }
        });
        Guid image1GroupId = Guid.NewGuid();
        // this is temp code until SPM will implement the new verb that does
        // it for us:
        Guid hiberVol1 = Guid.NewGuid();
        VDSReturnValue ret1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image1GroupId, getImageSizeInBytes(), getVolumeType(), VolumeFormat.RAW, hiberVol1, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret1.getSucceeded()) {
            return;
        }
        Guid guid1 = createTask(ret1.getCreationInfo(), VdcActionType.HibernateVm, VdcObjectType.Storage, getStorageDomainId().getValue());
        getReturnValue().getTaskIdList().add(guid1);
        // second vol should be 10kb
        Guid image2GroupId = Guid.NewGuid();
        Guid hiberVol2 = Guid.NewGuid();
        VDSReturnValue ret2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image2GroupId, getMetaDataSizeInBytes(), VolumeType.Sparse, VolumeFormat.COW, hiberVol2, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret2.getSucceeded()) {
            return;
        }
        Guid guid2 = createTask(ret2.getCreationInfo(), VdcActionType.HibernateVm);
        getReturnValue().getTaskIdList().add(guid2);
        // this is the new param that should be passed to the hibernate
        // command
        getVm().setHibernationVolHandle(String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", getStorageDomainId().toString(), getVm().getStoragePoolId().toString(), image1GroupId.toString(), hiberVol1.toString(), image2GroupId.toString(), hiberVol2.toString()));
        // end of temp code
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
        getParameters().setTaskIds(new java.util.ArrayList<Guid>());
        getParameters().getTaskIds().add(guid1);
        getParameters().getTaskIds().add(guid2);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void Perform() {
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM state from the DB, to avoid multi requests for VM hibernation.
    setVm(null);
    if (getVm().isRunning()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getVm().getDynamicData(), getVm().getStatus());
                // Set the VM to SavingState to lock the VM,to avoid situation of multi VM hibernation.
                getVm().setStatus(VMStatus.SavingState);
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
                getCompensationContext().stateChanged();
                return null;
            }
        });
        Guid image1GroupId = Guid.NewGuid();
        // this is temp code until SPM will implement the new verb that does
        // it for us:
        Guid hiberVol1 = Guid.NewGuid();
        VDSReturnValue ret1 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image1GroupId, getImageSizeInBytes(), getVolumeType(), VolumeFormat.RAW, hiberVol1, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret1.getSucceeded()) {
            return;
        }
        Guid guid1 = createTask(ret1.getCreationInfo(), VdcActionType.HibernateVm, VdcObjectType.Storage, getStorageDomainId().getValue());
        getReturnValue().getTaskIdList().add(guid1);
        // second vol should be 10kb
        Guid image2GroupId = Guid.NewGuid();
        Guid hiberVol2 = Guid.NewGuid();
        VDSReturnValue ret2 = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getVm().getStoragePoolId(), getStorageDomainId().getValue(), image2GroupId, getMetaDataSizeInBytes(), VolumeType.Sparse, VolumeFormat.COW, hiberVol2, "", getStoragePool().getcompatibility_version().toString()));
        if (!ret2.getSucceeded()) {
            return;
        }
        Guid guid2 = createTask(ret2.getCreationInfo(), VdcActionType.HibernateVm);
        getReturnValue().getTaskIdList().add(guid2);
        // this is the new param that should be passed to the hibernate
        // command
        getVm().setHibernationVolHandle(String.format("%1$s,%2$s,%3$s,%4$s,%5$s,%6$s", getStorageDomainId().toString(), getVm().getStoragePoolId().toString(), image1GroupId.toString(), hiberVol1.toString(), image2GroupId.toString(), hiberVol2.toString()));
        // end of temp code
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getVdsId(), getVm().getDynamicData()));
        getParameters().setTaskIds(new java.util.ArrayList<Guid>());
        getParameters().getTaskIds().add(guid1);
        getParameters().getTaskIds().add(guid2);
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status.isStatusOfRunningVM() || status == VMStatus.RestoringState) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getVmName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                case // probably wrong xml format sent.
                PROTOCOL_ERROR:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds
            // no need to log the command because it is being logged inside
            // the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getVmName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
protected boolean canMigrateVm(@SuppressWarnings("unused") Guid vmGuid, ArrayList<String> reasons) {
    boolean retValue = true;
    VM vm = getVm();
    if (vm == null) {
        retValue = false;
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
    } else {
        // If VM is pinned to host, no migration can occur
        if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.name());
        } else if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE.toString());
        } else if (vm.getStatus() == VMStatus.MigratingFrom) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS.name());
        } else if (vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.name());
        } else if (vm.getStatus() == VMStatus.Paused) {
            retValue = false;
            reasons.add(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED.name());
        } else if (!vm.getStatus().isStatusOfQualifyToMigrateVM()) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.name());
        } else if (getDestinationVds() != null && getDestinationVds().getstatus() != VDSStatus.Up) {
            retValue = false;
            reasons.add(VdcBllMessages.VAR__HOST_STATUS__UP.name());
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.name());
        }
        retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(reasons, true);
    }
    if (!retValue) {
        reasons.add(VdcBllMessages.VAR__ACTION__MIGRATE.toString());
        reasons.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#method_after
protected boolean canMigrateVm(@SuppressWarnings("unused") Guid vmGuid, ArrayList<String> reasons) {
    boolean retValue = true;
    VM vm = getVm();
    if (vm == null) {
        retValue = false;
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.name());
    } else {
        // If VM is pinned to host, no migration can occur
        if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.name());
        } else if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE.toString());
        } else if (vm.getStatus() == VMStatus.MigratingFrom) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS.name());
        } else if (vm.getStatus() == VMStatus.NotResponding) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.name());
        } else if (vm.getStatus() == VMStatus.Paused) {
            retValue = false;
            reasons.add(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED.name());
        } else if (!vm.isQualifyToMigrate()) {
            retValue = false;
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING.name());
        } else if (getDestinationVds() != null && getDestinationVds().getstatus() != VDSStatus.Up) {
            retValue = false;
            reasons.add(VdcBllMessages.VAR__HOST_STATUS__UP.name());
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.name());
        }
        retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && getVdsSelector().canFindVdsToRunOn(reasons, true);
    }
    if (!retValue) {
        reasons.add(VdcBllMessages.VAR__ACTION__MIGRATE.toString());
        reasons.add(VdcBllMessages.VAR__TYPE__VM.toString());
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    restoreSnapshotAndRemoveObsoleteSnapshots();
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    // The snapshot being restored to
    Snapshot targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(targetSnapshot);
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getimageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    List<Guid> deletedDisksIds = new ArrayList<Guid>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#method_after
protected void deleteOrphanedImages() {
    VdcReturnValueBase returnValue;
    boolean noImagesRemovedYet = getTaskIdList().isEmpty();
    Set<Guid> deletedDisksIds = new HashSet<Guid>();
    for (DiskImage image : getDiskImageDao().getImagesWithNoDisk(getVm().getId())) {
        if (!deletedDisksIds.contains(image.getId())) {
            deletedDisksIds.add(image.getId());
            returnValue = runAsyncTask(VdcActionType.RemoveImage, new RemoveImageParameters(image.getImageId()));
            if (!returnValue.getSucceeded() && noImagesRemovedYet) {
                setSucceeded(false);
                getReturnValue().setFault(returnValue.getFault());
                return;
            }
            noImagesRemovedYet = false;
        }
    }
}
#end_block

#method_before
protected void restoreSnapshotAndRemoveObsoleteSnapshots() {
    targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
        case STATELESS:
            restoreConfiguration(targetSnapshot);
            break;
        // Currently UI sends the "in preview" snapshot to restore when "Commit" is pressed.
        case REGULAR:
            if (SnapshotStatus.IN_PREVIEW == targetSnapshot.getStatus()) {
                prepareToDeletePreviewBranch();
                // Set the active snapshot's images as target images for restore, because they are what we keep.
                getParameters().setImagesList(getDiskImageDao().getAllSnapshotsForVmSnapshot(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE)));
                break;
            }
        default:
            throw new VdcBLLException(VdcBllErrors.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#method_after
protected void restoreSnapshotAndRemoveObsoleteSnapshots(Snapshot targetSnapshot) {
    switch(targetSnapshot.getType()) {
        case PREVIEW:
            getSnapshotDao().updateStatus(getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW), SnapshotStatus.OK);
        case STATELESS:
            restoreConfiguration(targetSnapshot);
            break;
        // Currently UI sends the "in preview" snapshot to restore when "Commit" is pressed.
        case REGULAR:
            if (SnapshotStatus.IN_PREVIEW == targetSnapshot.getStatus()) {
                prepareToDeletePreviewBranch();
                // Set the active snapshot's images as target images for restore, because they are what we keep.
                getParameters().setImagesList(getDiskImageDao().getAllSnapshotsForVmSnapshot(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE)));
                break;
            }
        default:
            throw new VdcBLLException(VdcBllErrors.ENGINE, "No support for restoring to snapshot type: " + targetSnapshot.getType());
    }
}
#end_block

#method_before
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDao().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDao().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            if (!snapshotsToRemove.contains(snapshotToRemove.getValue())) {
                snapshotsToRemove.add(snapshotToRemove.getValue());
            }
            parentImage = getDiskImageDao().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#method_after
protected void prepareToDeletePreviewBranch() {
    removedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.PREVIEW);
    Guid previewedSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.REGULAR, SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(previewedSnapshotId, SnapshotStatus.OK);
    snapshotsToRemove.add(removedSnapshotId);
    List<DiskImage> images = getDiskImageDao().getAllSnapshotsForVmSnapshot(removedSnapshotId);
    for (DiskImage image : images) {
        DiskImage parentImage = getDiskImageDao().getSnapshotById(image.getParentId());
        NGuid snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        while (parentImage != null && snapshotToRemove != null && !snapshotToRemove.equals(previewedSnapshotId)) {
            snapshotsToRemove.add(snapshotToRemove.getValue());
            parentImage = getDiskImageDao().getSnapshotById(parentImage.getParentId());
            snapshotToRemove = (parentImage == null) ? null : parentImage.getvm_snapshot_id();
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    super.endVmCommand();
    // if we got here, the target snapshot exists for sure
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
}
#method_after
@Override
protected void endVmCommand() {
    // if we got here, the target snapshot exists for sure
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
    super.endVmCommand();
}
#end_block

#method_before
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateCommand failed", e);
    }
    return null;
}
#method_after
private <P extends VdsIdVDSCommandParametersBase> FutureVDSCommand createFutureCommand(FutureVDSCommandType commandType, P parameters) {
    try {
        Class<FutureVDSCommand> type = (Class<FutureVDSCommand>) Class.forName(commandType.getFullyQualifiedClassName());
        Constructor<FutureVDSCommand> constructor = ReflectionUtils.findConstructor(type, parameters.getClass());
        if (constructor != null) {
            return constructor.newInstance(new Object[] { parameters });
        }
    } catch (Exception e) {
        if (e.getCause() != null) {
            log.error("CreateFutureCommand failed", e.getCause());
            throw new RuntimeException(e.getCause().getMessage(), e.getCause());
        }
        log.error("CreateFutureCommand failed", e);
    }
    return null;
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return String.valueOf(object.getvm_count());
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.runningVms(), "110px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return String.valueOf(object.getvm_count());
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.vmsCount(), "110px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#end_block

#method_before
@Override
public void debug(Object arg0) {
    log.debug(addPrefixToLogMessage(arg0));
}
#method_after
@Override
public void debug(Object arg0) {
    if (isDebugEnabled()) {
        log.debug(addPrefixToLogMessage(arg0));
    }
}
#end_block

#method_before
@Override
public void debug(Object arg0, Throwable arg1) {
    log.debug(addPrefixToLogMessage(arg0), arg1);
}
#method_after
@Override
public void debug(Object arg0, Throwable arg1) {
    if (isDebugEnabled()) {
        log.debug(addPrefixToLogMessage(arg0), arg1);
    }
}
#end_block

#method_before
@Override
public void trace(Object arg0) {
    if (log.isTraceEnabled()) {
        log.trace(arg0);
    }
}
#method_after
@Override
public void trace(Object arg0) {
    if (log.isTraceEnabled()) {
        log.trace(addPrefixToLogMessage(arg0));
    }
}
#end_block

#method_before
@Override
public Permissions list() {
    return mapCollection(getBackendCollection(queryType, queryParams));
}
#method_after
@Override
public Permissions list() {
    Set<permissions> permissions = new TreeSet<permissions>(new PermissionsComparator());
    List<permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected Permissions mapCollection(List<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        if (entity.getObjectType() != VdcObjectType.System) {
            castEveryonePermissionsToUser(entity);
            Permission permission = map(entity, getUserById(entity.getad_element_id()));
            collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
        }
    }
    return collection;
}
#method_after
protected Permissions mapCollection(Set<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        castEveryonePermissionsToUser(entity);
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#end_block

#method_before
private void castEveryonePermissionsToUser(permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(((MultilevelAdministrationByAdElementIdParameters) queryParams).getAdElementId());
    }
}
#method_after
private void castEveryonePermissionsToUser(permissions entity) {
    if (entity.getad_element_id() != null && entity.getad_element_id().equals(Guid.EVERYONE) && queryType.equals(VdcQueryType.GetPermissionsByAdElementId)) {
        entity.setad_element_id(this.targetId);
    }
}
#end_block

#method_before
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance().init();
    log.infoFormat("TagsDirector: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    log.infoFormat("JobRepositoryCleanupManager: {0}", new Date());
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    log.infoFormat("AutoRecoveryManager: {0}", new Date());
    AutoRecoveryManager.getInstance().initialize();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#method_after
@Override
public void Initialize() {
    log.infoFormat("Start time: {0}", new Date());
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    _resourceManger = new VDSBrokerFrontendImpl();
    log.infoFormat("VDSBrokerFrontend: {0}", new Date());
    CpuFlagsManagerHandler.InitDictionaries();
    log.infoFormat("CpuFlagsManager: {0}", new Date());
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    log.infoFormat("AuditLogCleanupManager: {0}", new Date());
    TagsDirector.getInstance().init();
    log.infoFormat("TagsDirector: {0}", new Date());
    IsoDomainListSyncronizer.getInstance();
    log.infoFormat("IsoDomainListSyncronizer: {0}", new Date());
    InitHandlers();
    log.infoFormat("InitHandlers: {0}", new Date());
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    log.infoFormat("ErrorTranslator: {0}", new Date());
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    log.infoFormat("VdsErrorTranslator: {0}", new Date());
    // initialize the JobRepository object and finalize non-terminated jobs
    log.infoFormat("Mark uncompleted jobs as {0}: {1}", JobExecutionStatus.UNKNOWN.name(), new Date());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    log.infoFormat("JobRepositoryCleanupManager: {0}", new Date());
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    log.infoFormat("AutoRecoveryManager: {0}", new Date());
    AutoRecoveryManager.getInstance().initialize();
    log.infoFormat("ExecutionMessageDirector: {0}", new Date());
    initExecutionMessageDirector();
    Integer sessionTimoutInterval = Config.<Integer>GetValue(ConfigValues.UserSessionTimeOutInterval);
    // negative value means session should never expire, therefore no need to clean sessions.
    if (sessionTimoutInterval > 0) {
        SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, sessionTimoutInterval, sessionTimoutInterval, TimeUnit.MINUTES);
    }
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int quotaCacheIntervalInMinutes = Config.<Integer>GetValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    try {
        File fLock = new File(Config.<String>GetValue(ConfigValues.SignLockFile));
        if (fLock.exists()) {
            if (!fLock.delete()) {
                log.error("Cleanup lockfile failed to delete the locking file.");
            }
        }
    } catch (SecurityException se) {
        log.error("Cleanup lockfile failed!", se);
    }
}
#end_block

#method_before
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#method_after
private VdcReturnValueBase runActionImpl(VdcActionType actionType, VdcActionParametersBase parameters, boolean runAsInternal, CommandContext context) {
    VdcReturnValueBase returnValue = null;
    switch(actionType) {
        case AutoLogin:
            return getErrorCommandReturnValue(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        default:
            // Evaluate and set the correlationId on the parameters, fails on invalid correlation id
            boolean hasCorrelationId = parameters == null ? false : StringUtils.isNotEmpty(parameters.getCorrelationId());
            returnValue = ExecutionHandler.evaluateCorrelationId(parameters);
            if (returnValue != null) {
                log.warnFormat("CanDoAction of action {0} failed. Reasons: {1}", actionType, StringUtils.join(returnValue.getCanDoActionMessages(), ','));
                return returnValue;
            }
            CommandBase<?> command = CommandsFactory.CreateCommand(actionType, parameters);
            command.setInternalExecution(runAsInternal);
            command.setContext(context);
            ExecutionHandler.prepareCommandForMonitoring(command, actionType, runAsInternal, hasCorrelationId);
            returnValue = command.executeAction();
            returnValue.setCorrelationId(parameters.getCorrelationId());
            returnValue.setJobId(command.getJobId());
            return returnValue;
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
    freeLock();
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        endSuccessfully();
    } else {
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeVmCommand() {
    Guid newActiveSnapshotId = Guid.NewGuid();
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
    getParameters().setSnapshotType(determineSnapshotType());
    getParameters().setInitialVmStatus(getVm().getStatus());
    getSnapshotDao().updateId(createdSnapshotId, newActiveSnapshotId);
    setActionReturnValue(createdSnapshotId);
    if (getDisksList().isEmpty()) {
        getParameters().setTaskGroupSuccess(true);
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), SnapshotStatus.OK, getParameters().getSnapshotType(), getVm(), true, getCompensationContext());
        // at the moment there's no need to execute vdsm Snapshot command for diskless snapshots,
        // when support for ram snapshot will be introduced, this vdsm command should be executed
        // for diskless snapshots as well (currently executed within endSuccesfully() method.
        incrementVmGeneration();
    } else {
        new SnapshotsManager().addSnapshot(createdSnapshotId, getParameters().getDescription(), getParameters().getSnapshotType(), getVm(), getCompensationContext());
        freeLock();
        for (DiskImage image : getDisksList()) {
            ImagesActionsParametersBase tempVar = new ImagesActionsParametersBase(image.getImageId());
            tempVar.setDescription(getParameters().getDescription());
            tempVar.setSessionId(getParameters().getSessionId());
            tempVar.setQuotaId(image.getQuotaId());
            tempVar.setVmSnapshotId(newActiveSnapshotId);
            tempVar.setEntityId(getParameters().getEntityId());
            VdcActionType parentCommand = getParameters().getParentCommand() != VdcActionType.Unknown ? getParameters().getParentCommand() : VdcActionType.CreateAllSnapshotsFromVm;
            tempVar.setParentCommand(parentCommand);
            ImagesActionsParametersBase p = tempVar;
            VdcActionParametersBase parrentParamsForTask = getParametersForTask(parentCommand, getParameters());
            p.setParentParameters(parrentParamsForTask);
            getParameters().getImagesParameters().add(p);
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.CreateSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
            } else {
                throw new VdcBLLException(vdcReturnValue.getFault().getError(), "CreateAllSnapshotsFromVmCommand::executeVmCommand: Failed to create snapshot!");
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        ProgressBarColumn<VDS> loadColumn = new ProgressBarColumn<VDS>() {

            @Override
            protected String getProgressText(VDS object) {
                int numOfActiveVMs = object.getvm_active() != null ? object.getvm_active() : 0;
                return ConstantsManager.getInstance().getMessages().numberOfVmsForHostsLoad(numOfActiveVMs);
            }

            @Override
            protected Integer getProgressValue(VDS object) {
                return object.getvm_active() != null ? Math.min(object.getvm_active(), 100) : 0;
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(loadColumn, constants.loadHost(), "80px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noHostsToDisplay());
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new HostStatusColumn<VDS>(), constants.empty(), "30px");
    TextColumnWithTooltip<VDS> nameColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameHost(), "150px");
    TextColumnWithTooltip<VDS> hostColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.gethost_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.ipHost(), "150px");
    TextColumnWithTooltip<VDS> clusterColumn = new TextColumnWithTooltip<VDS>() {

        @Override
        public String getValue(VDS object) {
            return object.getvds_group_name();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterHost(), "150px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> dcColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                return object.getstorage_pool_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dcColumn, constants.dcHost(), "150px");
    }
    TextColumnWithTooltip<VDS> statusColumn = new EnumColumn<VDS, VDSStatus>() {

        @Override
        public VDSStatus getRawValue(VDS object) {
            return object.getstatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusHost(), "100px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> vmCountColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                // $NON-NLS-1$
                return object.getvm_active() != null ? object.getvm_active().toString() : "0";
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(vmCountColumn, constants.runningVms(), "80px");
    }
    PercentColumn<VDS> memColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_mem_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memColumn, constants.memoryHost(), "60px");
    PercentColumn<VDS> cpuColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_cpu_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuHost(), "60px");
    PercentColumn<VDS> netColumn = new PercentColumn<VDS>() {

        @Override
        public Integer getProgressValue(VDS object) {
            return object.getusage_network_percent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(netColumn, constants.networkHost(), "60px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDS> spmColumn = new TextColumnWithTooltip<VDS>() {

            @Override
            public String getValue(VDS object) {
                int value = object.getVdsSpmPriority();
                int lowValue = defaultSpmPriority / 2;
                int highValue = defaultSpmPriority + (maxSpmPriority - defaultSpmPriority) / 2;
                if (object.getspm_status() != VdsSpmStatus.None) {
                    return object.getspm_status().name();
                }
                if (value == -1) {
                    return constants.spmNeverText();
                } else if (value == lowValue) {
                    return constants.spmLowText();
                } else if (value == defaultSpmPriority) {
                    return constants.spmNormalText();
                } else if (value == highValue) {
                    return constants.spmHighText();
                }
                return constants.spmCustomText();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(spmColumn, constants.spmPriorityHost(), "100px");
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.newHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.editHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.removeHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.activateHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getActivateCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.maintenanceHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.confirmRebootedHost(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getManualFenceCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.approveHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getApproveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.configureLocalStorageHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureLocalStorageCommand();
        }
    });
    List<ActionButtonDefinition<VDS>> pmSubActions = new LinkedList<ActionButtonDefinition<VDS>>();
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.restartHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRestartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.startHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    pmSubActions.add(new WebAdminButtonDefinition<VDS>(constants.stopHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.pmHost(), pmSubActions, CommandLocation.OnlyFromToolBar));
    }
    getTable().addActionButton(new WebAdminButtonDefinition<VDS>(constants.assignTagsHost()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDS>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Host", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDS>(constants.showReportHost(), resourceSubActions));
        }
    }
}
#end_block

#method_before
public OrderedMultiSelectionModel<T> getSelectionModel() {
    return selectionModel;
}
#method_after
@Override
public OrderedMultiSelectionModel<T> getSelectionModel() {
    return selectionModel;
}
#end_block

#method_before
@Override
protected List<T> getSelectedItems() {
    return new ArrayList<T>(selectionModel.getSelectedList());
}
#method_after
@Override
public List<T> getSelectedItems() {
    return selectionModel.getSelectedList();
}
#end_block

#method_before
public void setLoadingState(LoadingState state) {
    table.setLoadingState(state);
}
#method_after
@Override
public void setLoadingState(LoadingState state) {
    table.setLoadingState(state);
}
#end_block

#method_before
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "100px");
}
#method_after
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
void initTableColumns() {
    getTable().enableColumnResizing();
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noDisksToDisplay());
}
#method_after
void initTableColumns() {
    getTable().enableColumnResizing();
}
#end_block

#method_before
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#method_after
@UiHandler({ "basicViewButton", "advancedViewButton" })
void handleViewButtonClick(ClickEvent event) {
    boolean advancedViewEnabled = advancedViewButton.getValue();
    getTable().ensureColumnPresent(AdvancedViewColumns.logTypeColumn, constants.eventIdEvent(), advancedViewEnabled, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(AdvancedViewColumns.userColumn, constants.userEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.hostColumn, constants.hostEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.virtualMachineColumn, constants.vmEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.templateColumn, constants.templateEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.dataCenterColumn, constants.dcEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.storageColumn, constants.storageEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.clusterColumn, constants.clusterEvent(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.volumeColumn, constants.volumeEvent(), advancedViewEnabled && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly), // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.corrIdColumn, constants.eventCorrelationId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.originColumn, constants.eventOrigin(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(AdvancedViewColumns.customEventIdColumn, constants.eventCustomEventId(), advancedViewEnabled, // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new AuditLogSeverityColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<AuditLog> logTimeColumn = new FullDateTimeColumn<AuditLog>() {

        @Override
        protected Date getRawValue(AuditLog object) {
            return object.getlog_time();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(logTimeColumn, constants.timeEvent(), "150px");
    TextColumnWithTooltip<AuditLog> messageColumn = new TextColumnWithTooltip<AuditLog>() {

        @Override
        public String getValue(AuditLog object) {
            return object.getmessage();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(messageColumn, constants.messageEvent(), "150px");
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noEventsToDisplay());
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new AuditLogSeverityColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<AuditLog> logTimeColumn = new FullDateTimeColumn<AuditLog>() {

        @Override
        protected Date getRawValue(AuditLog object) {
            return object.getlog_time();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(logTimeColumn, constants.timeEvent(), "150px");
    TextColumnWithTooltip<AuditLog> messageColumn = new TextColumnWithTooltip<AuditLog>() {

        @Override
        public String getValue(AuditLog object) {
            return object.getmessage();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(messageColumn, constants.messageEvent(), "150px");
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "80px");
    TextColumnWithTooltip<VM> loggedInUserColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            if (object.getGuestCurUserName() == null) {
                // $NON-NLS-1$
                return "";
            }
            return String.valueOf(object.getGuestCurUserName());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(loggedInUserColumn, constants.loggedInUserVm(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newServerVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewServerCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newDesktopVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDesktopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.pauseVmImage(), resources.pauseVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            ConsoleModel defaultConsoleModel = getMainModel().getDefaultConsoleModel();
            return defaultConsoleModel != null ? defaultConsoleModel.getConnectCommand() : null;
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
    // Set the no item to display message
    getTable().setNoItemsToDisplayType(constants.noVMsToDisplay());
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newServerVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewServerCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newDesktopVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewDesktopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.pauseVmImage(), resources.pauseVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            ConsoleModel defaultConsoleModel = getMainModel().getDefaultConsoleModel();
            return defaultConsoleModel != null ? defaultConsoleModel.getConnectCommand() : null;
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void refreshVdsStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.Execute();
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    /**
     * TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
     */
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#method_after
private void refreshVdsStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vdsManager::refreshVdsStats entered, vds = {0} : {1}", _vds.getId(), _vds.getvds_name());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    vdsBrokerCommand.Execute();
    if (!vdsBrokerCommand.getVDSReturnValue().getSucceeded() && vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        VDSNetworkException ex = (VDSNetworkException) ((vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) ? vdsBrokerCommand.getVDSReturnValue().getExceptionObject() : null);
        if (ex != null) {
            if (_vdsManager.handleNetworkException(ex, _vds)) {
                _saveVdsDynamic = true;
            }
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), ExceptionUtils.getMessage(ex));
        } else {
            log.errorFormat("vds::refreshVdsStats Failed getVdsStats,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getvds_name(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    }
    // save also dynamic because vm_count data and image_check getting with
    // statistics data
    // TODO: omer- one day remove dynamic save when possible please check if vdsDynamic changed before save
    _saveVdsDynamic = true;
    _saveVdsStatistics = true;
    alertIfLowDiskSpaceOnHost();
    checkVdsInterfaces();
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debugFormat("vds::refreshVdsStats\n{0}", toString());
    }
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Recieved a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = null;
            vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getstatus() && !(vmToUpdate.getStatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getstatus() && !(vmToUpdate.getStatus() == VMStatus.SavingState && runningVm.getstatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.Execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = null;
        // _vdsManager.getVm(vm.getvm_guid());
        vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    AddVmDynamicToList(curVm.getDynamicData());
                    AddVmStatisticsToList(curVm.getStatisticsData());
                    AddVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = null;
        vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else /**
                 * check if vm is suspended and remove it from async list
                 */
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            AddVmDynamicToList(vmToRemove.getDynamicData());
            AddVmStatisticsToList(vmToRemove.getStatisticsData());
            AddVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getVmName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            addVmDynamicToList(vmToRemove.getDynamicData());
            addVmStatisticsToList(vmToRemove.getStatisticsData());
            addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getVmName()));
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#end_block

#method_before
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        /**
         * inMigration
         */
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#method_after
private boolean inMigrationTo(VmDynamic runningVm, VM vmToUpdate) {
    boolean returnValue = false;
    if (runningVm.getstatus() == VMStatus.MigratingTo) {
        // in migration
        log.infoFormat("vds::refreshVmList vm id '{0}' is migrating to vds '{1}' ignoring it in the refresh until migration is done", runningVm.getId(), _vds.getvds_name());
        returnValue = true;
    } else if ((vmToUpdate == null && runningVm.getstatus() != VMStatus.MigratingFrom)) {
        // check if the vm exists on another vds
        VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
        if (vmDynamic != null && vmDynamic.getrun_on_vds() != null && !vmDynamic.getrun_on_vds().equals(_vds.getId()) && runningVm.getstatus() != VMStatus.Up) {
            log.infoFormat("vds::refreshVmList vm id '{0}' status = {1} on vds {2} ignoring it in the refresh until migration is done", runningVm.getId(), runningVm.getstatus(), _vds.getvds_name());
            returnValue = true;
        }
    }
    return returnValue;
}
#end_block

#method_before
private void clearVm(VM vm, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
            vm.setExitStatus(VmExitStatus.Error);
            vm.setExitMessage(exitMessage);
        }
        AddVmDynamicToList(vm.getDynamicData());
        AddVmStatisticsToList(vm.getStatisticsData());
        AddVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be execute in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    if (isVmDownUnexpectedly() && getVm().isAutoStartup() && wasVmUpInitially()) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
                if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
                    performLiveSnapshot(createdSnapshotId);
                }
            } else {
                revertToActiveSnapshot(createdSnapshotId);
            }
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreate(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
@Override
public Disks list() {
    return mapCollection(getBackendCollection(SearchType.Disk));
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
public Permissions list() {
    return mapCollection(getBackendCollection(queryType, queryParams));
}
#method_after
@Override
public Permissions list() {
    Set<permissions> permissions = new TreeSet<permissions>(new PermissionsComparator());
    List<permissions> directPermissions = getBackendCollection(queryType, queryParams);
    permissions.addAll(directPermissions);
    if (queryType.equals(VdcQueryType.GetPermissionsForObject)) {
        permissions.addAll(getInheritedPermissions());
    }
    return mapCollection(permissions);
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected Permissions mapCollection(List<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        if (entity.getObjectType() != VdcObjectType.System) {
            Permission permission = map(entity, getUserById(entity.getad_element_id()));
            collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
        }
    }
    return collection;
}
#method_after
protected Permissions mapCollection(Set<permissions> entities) {
    Permissions collection = new Permissions();
    for (permissions entity : entities) {
        Permission permission = map(entity, getUserById(entity.getad_element_id()));
        collection.getPermissions().add(addLinks(permission, permission.getUser() != null ? suggestedParentType : Group.class));
    }
    return collection;
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        ad_groups group = new ad_groups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver resolver = new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            SaveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#method_after
public void Refresh() {
    try {
        refreshVdsRunTimeInfo();
    } finally {
        try {
            if (_firstStatus != _vds.getstatus() && _vds.getstatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                VdsManager.cancelRecoveryJob(_vds.getId());
                if (log.isDebugEnabled()) {
                    log.debugFormat("vds {0}-{1} firing up event.", _vds.getId(), _vds.getvds_name());
                }
                _vdsManager.setIsSetNonOperationalExecuted(!ResourceManager.getInstance().getEventListener().vdsUpEvent(_vds.getId()));
                // Check hardware capabilities in case VDS moved to up
                processHardwareCapsNeeded = true;
            }
            // save all data to db
            saveDataToDb();
        } catch (IRSErrorException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            if (log.isDebugEnabled()) {
                log.error(ExceptionUtils.getMessage(ex), ex);
            }
        } catch (RuntimeException ex) {
            logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", ex);
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    }
}
#end_block

#method_before
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    MoveVDSToMaintenanceIfNeeded();
}
#method_after
private void refreshVdsRunTimeInfo() {
    boolean isVdsUpOrGoingToMaintanance = _vds.getstatus() == VDSStatus.Up || _vds.getstatus() == VDSStatus.PreparingForMaintenance || _vds.getstatus() == VDSStatus.Error || _vds.getstatus() == VDSStatus.NonOperational;
    try {
        if (isVdsUpOrGoingToMaintanance) {
            // check if its time for statistics refresh
            if (_vdsManager.getRefreshStatistics() || _vds.getstatus() == VDSStatus.PreparingForMaintenance) {
                refreshVdsStats();
            } else {
            /**
             * TODO: Omer if vds team will not implement events to 4.2 please call here to refreshVdsStats -
             * refresh dynamic data
             */
            }
        } else {
            // refresh dynamic data
            final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
            VDSStatus refreshReturnStatus = _vdsManager.refreshCapabilities(processHardwareNeededAtomic, _vds);
            processHardwareCapsNeeded = processHardwareNeededAtomic.get();
            refreshedCapabilities = true;
            if (refreshReturnStatus != VDSStatus.NonOperational) {
                _vdsManager.setStatus(VDSStatus.Up, _vds);
            }
            _saveVdsDynamic = true;
        }
        beforeFirstRefreshTreatment(isVdsUpOrGoingToMaintanance);
        refreshVmStats();
    } catch (VDSRecoveringException e) {
        // move vds to maintenance
        if (_vds.getstatus() != VDSStatus.PreparingForMaintenance) {
            throw e;
        }
    }
    moveVDSToMaintenanceIfNeeded();
}
#end_block

#method_before
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#method_after
private void prepareGuestAgentNetworkDevicesForUpdate() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                List<VmGuestAgentInterface> vmGuestAgentInterfaces = vmInternalData.getVmGuestAgentInterfaces();
                int guestAgentNicHash = vmGuestAgentInterfaces == null ? 0 : vmGuestAgentInterfaces.hashCode();
                if (guestAgentNicHash != vmDynamic.getGuestAgentNicsHash()) {
                    vmGuestAgentNics.put(vmDynamic.getId(), vmGuestAgentInterfaces);
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        updateGuestAgentInterfacesChanges(_vmDynamicToSave.get(vm.getId()), vmGuestAgentInterfaces, guestAgentNicHash);
                    } else {
                        updateGuestAgentInterfacesChanges(vmDynamic, vmGuestAgentInterfaces, guestAgentNicHash);
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        AddVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#method_after
private void handleVmDeviceChange() {
    // Go over all the vms and detemine which ones require updating
    List<String> vmsToUpdateFromVds = new ArrayList<String>();
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vmDynamic = vmInternalData.getVmDynamic();
        if (vmDynamic != null) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                String dbHash = vm.getHash();
                if ((dbHash == null && vmDynamic.getHash() != null) || (dbHash != null) && !dbHash.equals(vmDynamic.getHash())) {
                    vmsToUpdateFromVds.add(vmDynamic.getId().toString());
                    // update new hash value
                    if (_vmDynamicToSave.containsKey(vm.getId())) {
                        _vmDynamicToSave.get(vm.getId()).setHash(vmDynamic.getHash());
                    } else {
                        addVmDynamicToList(vmDynamic);
                    }
                }
            }
        }
    }
    if (vmsToUpdateFromVds.size() > 0) {
        // If there are vms that require updating,
        // get the new info from VDSM in one call, and then update them all
        updateVmDevices(vmsToUpdateFromVds);
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Recieved a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, XmlRpcStruct device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device.getInnerMap();
        log.infoFormat(message + ": {2}", StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId, deviceInfo.toString());
    } else {
        log.infoFormat(message, StringUtils.defaultIfEmpty(deviceType, StringUtils.EMPTY), vmId);
    }
}
#end_block

#method_before
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Recieved NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#method_after
private void processVmDevices(XmlRpcStruct vm) {
    if (vm == null || vm.getItem(VdsProperties.vm_guid) == null) {
        log.errorFormat("Received NULL VM or VM id when processing VM devices, abort.");
        return;
    }
    Guid vmId = new Guid((String) vm.getItem(VdsProperties.vm_guid));
    HashSet<Guid> processedDevices = new HashSet<Guid>();
    Object[] objects = (Object[]) vm.getItem(VdsProperties.Devices);
    List<VmDevice> devices = getDbFacade().getVmDeviceDao().getVmDeviceByVmId(vmId);
    Map<VmDeviceId, VmDevice> deviceMap = new HashMap<VmDeviceId, VmDevice>();
    for (VmDevice device : devices) {
        deviceMap.put(device.getId(), device);
    }
    for (Object o : objects) {
        XmlRpcStruct device = new XmlRpcStruct((Map<String, Object>) o);
        Guid deviceId = getDeviceId(device);
        if ((device.getItem(VdsProperties.Address)) == null) {
            logDeviceInformation(vmId, device);
            continue;
        }
        VmDevice vmDevice = deviceMap.get(new VmDeviceId(deviceId, vmId));
        if (deviceId == null || vmDevice == null) {
            deviceId = addNewVmDevice(vmId, device);
        } else {
            String alias = StringUtils.defaultIfEmpty((String) device.getItem(VdsProperties.Alias), "");
            vmDevice.setAddress(((Map<String, String>) device.getItem(VdsProperties.Address)).toString());
            vmDevice.setAlias(alias);
            addVmDeviceToList(vmDevice);
        }
        processedDevices.add(deviceId);
    }
    handleRemovedDevices(vmId, processedDevices, devices);
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        // _vdsManager.getVm(vm.getvm_guid());
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                AfterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                HandleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getstatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo);
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.Execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    AddVmDynamicToList(curVm.getDynamicData());
                    AddVmStatisticsToList(curVm.getStatisticsData());
                    AddVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getmigrating_to_vds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getmigrating_to_vds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.Execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getVmName(), curVm.getmigrating_to_vds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getVmName(), curVm.getmigrating_to_vds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down);
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.AddCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.AddCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = UpdateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    AddVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                UpdateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getstatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringHelper.EqOp(runningVm.getclient_ip(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getstatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getstatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getdisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.errorFormat("VdsBroker.VdsUpdateRunTimeInfo.updateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getstatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getstatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getstatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getstatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine wht the vm has
                        // paused
                        AuditLogType logType = AuditLogType.UNASSIGNED;
                        AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                        VmPauseStatus pauseStatus = runningVm.getPauseStatus();
                        if (pauseStatus.equals(VmPauseStatus.NOERR) || pauseStatus.equals(VmPauseStatus.NONE)) {
                        // user requested pause, no log needed
                        } else if (pauseStatus == VmPauseStatus.ENOSPC) {
                            logType = AuditLogType.VM_PAUSED_ENOSPC;
                        } else if (pauseStatus == VmPauseStatus.EIO) {
                            logType = AuditLogType.VM_PAUSED_EIO;
                        } else if (pauseStatus == VmPauseStatus.EPERM) {
                            logType = AuditLogType.VM_PAUSED_EPERM;
                        } else {
                            logType = AuditLogType.VM_PAUSED_ERROR;
                        }
                        if (logType != AuditLogType.UNASSIGNED) {
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getstatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getstatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getstatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            AddVmDynamicToList(vmToRemove.getDynamicData());
            AddVmStatisticsToList(vmToRemove.getStatisticsData());
            AddVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove);
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#method_after
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            vmToRemove.setRunOnVds(vmToRemove.getmigrating_to_vds());
            log.infoFormat("Setting VM {0} {1} to status unknown", vmToRemove.getVmName(), vmToRemove.getId());
            ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, VMStatus.Unknown);
            addVmDynamicToList(vmToRemove.getDynamicData());
            addVmStatisticsToList(vmToRemove.getStatisticsData());
            addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
        } else {
            clearVm(vmToRemove);
        }
        log.infoFormat("vm {0} running in db and not running in vds - add to rerun treatment. vds {1}", vmToRemove.getVmName(), _vds.getvds_name());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
        }
    }
}
#end_block

#method_before
private void clearVm(VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
        }
        AddVmDynamicToList(vm.getDynamicData());
        AddVmStatisticsToList(vm.getStatisticsData());
        AddVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        if (vm.getStatus() != VMStatus.Suspended) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<event_notification_methods> getAllEventNotificationMethods() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<event_notification_methods> mapper = new ParameterizedRowMapper<event_notification_methods>() {

        @Override
        public event_notification_methods mapRow(ResultSet rs, int rowNum) throws SQLException {
            event_notification_methods entity = new event_notification_methods();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromevent_notification_methods", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<EventNotificationMethod> getAllEventNotificationMethods() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<EventNotificationMethod> mapper = new ParameterizedRowMapper<EventNotificationMethod>() {

        @Override
        public EventNotificationMethod mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventNotificationMethod entity = new EventNotificationMethod();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromevent_notification_methods", mapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<event_notification_methods> getEventNotificationMethodsById(int method_id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("method_id", method_id);
    ParameterizedRowMapper<event_notification_methods> mapper = new ParameterizedRowMapper<event_notification_methods>() {

        @Override
        public event_notification_methods mapRow(ResultSet rs, int rowNum) throws SQLException {
            event_notification_methods entity = new event_notification_methods();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventNotificationMethodById", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<EventNotificationMethod> getEventNotificationMethodsById(int method_id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("method_id", method_id);
    ParameterizedRowMapper<EventNotificationMethod> mapper = new ParameterizedRowMapper<EventNotificationMethod>() {

        @Override
        public EventNotificationMethod mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventNotificationMethod entity = new EventNotificationMethod();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventNotificationMethodById", mapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<event_notification_methods> getEventNotificationMethodsByType(String method_type) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("method_type", method_type);
    ParameterizedRowMapper<event_notification_methods> mapper = new ParameterizedRowMapper<event_notification_methods>() {

        @Override
        public event_notification_methods mapRow(ResultSet rs, int rowNum) throws SQLException {
            event_notification_methods entity = new event_notification_methods();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventNotificationMethodByType", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<EventNotificationMethod> getEventNotificationMethodsByType(String method_type) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("method_type", method_type);
    ParameterizedRowMapper<EventNotificationMethod> mapper = new ParameterizedRowMapper<EventNotificationMethod>() {

        @Override
        public EventNotificationMethod mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventNotificationMethod entity = new EventNotificationMethod();
            entity.setmethod_id(rs.getInt("method_id"));
            entity.setmethod_type(EventNotificationMethods.EMAIL);
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventNotificationMethodByType", mapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<EventMap> getAllEventMaps() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<EventMap> mapper = new ParameterizedRowMapper<EventMap>() {

        @Override
        public EventMap mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventMap entity = new EventMap();
            entity.setevent_up_name(rs.getString("event_up_name"));
            entity.setevent_down_name(rs.getString("event_down_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromevent_map", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<EventMap> getAllEventMaps() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    ParameterizedRowMapper<EventMap> mapper = new ParameterizedRowMapper<EventMap>() {

        @Override
        public EventMap mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventMap entity = new EventMap();
            entity.setEventUpName(rs.getString("event_up_name"));
            entity.setEventDownName(rs.getString("event_down_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetAllFromevent_map", mapper, parameterSource);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<EventMap> getEventMapByName(String event_up_name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("event_name", event_up_name);
    ParameterizedRowMapper<EventMap> mapper = new ParameterizedRowMapper<EventMap>() {

        @Override
        public EventMap mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventMap entity = new EventMap();
            entity.setevent_up_name(rs.getString("event_up_name"));
            entity.setevent_down_name(rs.getString("event_down_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventMapByName", mapper, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<EventMap> getEventMapByName(String event_up_name) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("event_name", event_up_name);
    ParameterizedRowMapper<EventMap> mapper = new ParameterizedRowMapper<EventMap>() {

        @Override
        public EventMap mapRow(ResultSet rs, int rowNum) throws SQLException {
            EventMap entity = new EventMap();
            entity.setEventUpName(rs.getString("event_up_name"));
            entity.setEventDownName(rs.getString("event_down_name"));
            return entity;
        }
    };
    return getCallsHandler().executeReadList("GetEventMapByName", mapper, parameterSource);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String event_name = getParameters().getEventSubscriber().getevent_up_name();
    int method_id = getParameters().getEventSubscriber().getmethod_id();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, event_name, method_id)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        List<event_notification_methods> event_notification_methods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(method_id));
        if (event_notification_methods.size() > 0) {
            // validate event
            List<EventMap> event_map = DbFacade.getInstance().getEventDao().getEventMapByName(event_name);
            if (event_map.size() > 0) {
                String domain = getParameters().getDomain();
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    // If an exception is thrown while trying, handle it and and fail with the relevant message
                    try {
                        user = UserCommandBase.initUser(new VdcUser(subscriberId, "", domain), getParameters().getSessionId());
                        if (user == null) {
                            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                            retValue = false;
                        } else {
                            retValue = ValidateAdd(event_notification_methods, getParameters().getEventSubscriber(), user);
                        }
                    } catch (VdcBLLException vdcBllException) {
                        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                        retValue = false;
                    }
                } else {
                    retValue = ValidateAdd(event_notification_methods, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // check if user is not already subscribed to this event with same
    // method and address
    Guid subscriberId = getParameters().getEventSubscriber().getsubscriber_id();
    String eventName = getParameters().getEventSubscriber().getevent_up_name();
    int methodId = getParameters().getEventSubscriber().getmethod_id();
    List<event_subscriber> subscriptions = DbFacade.getInstance().getEventDao().getAllForSubscriber(subscriberId);
    if (IsAlreadySubscribed(subscriptions, subscriberId, eventName, methodId)) {
        addCanDoActionMessage(VdcBllMessages.EN_ALREADY_SUBSCRIBED);
        retValue = false;
    } else {
        // get notification method
        List<EventNotificationMethod> eventNotificationMethods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(methodId));
        if (eventNotificationMethods.size() > 0) {
            // validate event
            List<EventMap> eventMap = DbFacade.getInstance().getEventDao().getEventMapByName(eventName);
            if (eventMap.size() > 0) {
                String domain = getParameters().getDomain();
                // Validate user
                DbUser user = DbFacade.getInstance().getDbUserDao().get(subscriberId);
                if (user == null) {
                    // If an exception is thrown while trying, handle it and and fail with the relevant message
                    try {
                        user = UserCommandBase.initUser(new VdcUser(subscriberId, "", domain), getParameters().getSessionId());
                        if (user == null) {
                            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                            retValue = false;
                        } else {
                            retValue = ValidateAdd(eventNotificationMethods, getParameters().getEventSubscriber(), user);
                        }
                    } catch (VdcBLLException vdcBllException) {
                        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
                        retValue = false;
                    }
                } else {
                    retValue = ValidateAdd(eventNotificationMethods, getParameters().getEventSubscriber(), user);
                }
            } else {
                addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
                retValue = false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
public List<event_notification_methods> getAllEventNotificationMethods() {
    return notificationMethodsDAO.getAll();
}
#method_after
@Override
public List<EventNotificationMethod> getAllEventNotificationMethods() {
    return notificationMethodsDAO.getAll();
}
#end_block

#method_before
@Override
public List<event_notification_methods> getEventNotificationMethodsById(int method_id) {
    return notificationMethodsDAO.getEventNotificationMethodsById(method_id);
}
#method_after
@Override
public List<EventNotificationMethod> getEventNotificationMethodsById(int method_id) {
    return notificationMethodsDAO.getEventNotificationMethodsById(method_id);
}
#end_block

#method_before
@Override
public List<event_notification_methods> getEventNotificationMethodsByType(String method_type) {
    return notificationMethodsDAO.getEventNotificationMethodsByType(method_type);
}
#method_after
@Override
public List<EventNotificationMethod> getEventNotificationMethodsByType(String method_type) {
    return notificationMethodsDAO.getEventNotificationMethodsByType(method_type);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue;
    // get notification method
    List<event_notification_methods> event_notification_methods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(getParameters().getEventSubscriber().getmethod_id()));
    if (event_notification_methods.size() > 0) {
        // validate event
        List<EventMap> event_map = DbFacade.getInstance().getEventDao().getEventMapByName(getParameters().getEventSubscriber().getevent_up_name());
        if (event_map.size() > 0) {
            // Validate user
            DbUser user = DbFacade.getInstance().getDbUserDao().get(getParameters().getEventSubscriber().getsubscriber_id());
            if (user == null) {
                addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                retValue = false;
            } else {
                retValue = ValidateRemove(event_notification_methods, getParameters().getEventSubscriber(), user);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
            retValue = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue;
    // get notification method
    List<EventNotificationMethod> event_notification_methods = (DbFacade.getInstance().getEventDao().getEventNotificationMethodsById(getParameters().getEventSubscriber().getmethod_id()));
    if (event_notification_methods.size() > 0) {
        // validate event
        List<EventMap> event_map = DbFacade.getInstance().getEventDao().getEventMapByName(getParameters().getEventSubscriber().getevent_up_name());
        if (event_map.size() > 0) {
            // Validate user
            DbUser user = DbFacade.getInstance().getDbUserDao().get(getParameters().getEventSubscriber().getsubscriber_id());
            if (user == null) {
                addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DB);
                retValue = false;
            } else {
                retValue = ValidateRemove(event_notification_methods, getParameters().getEventSubscriber(), user);
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.EN_UNSUPPORTED_NOTIFICATION_EVENT);
            retValue = false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(async_tasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(EventMap.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(LdapGroup.class).addAnnotatedClass(ActionVersionMap.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(EventMap.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(VmPoolMap.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
@Test
public void testGetAllEventNotificationMethods() {
    List<event_notification_methods> result = dao.getAllEventNotificationMethods();
    assertNotNull(result);
    assertFalse(result.isEmpty());
    assertEquals(NOTIFICATION_METHOD_COUNT, result.size());
}
#method_after
@Test
public void testGetAllEventNotificationMethods() {
    List<EventNotificationMethod> result = dao.getAllEventNotificationMethods();
    assertNotNull(result);
    assertFalse(result.isEmpty());
    assertEquals(NOTIFICATION_METHOD_COUNT, result.size());
}
#end_block

#method_before
@Test
public void testGetEventNotificationMethodsById() {
    List<event_notification_methods> result = dao.getEventNotificationMethodsById(1);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    assertEquals(1, result.size());
}
#method_after
@Test
public void testGetEventNotificationMethodsById() {
    List<EventNotificationMethod> result = dao.getEventNotificationMethodsById(1);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    assertEquals(1, result.size());
}
#end_block

#method_before
@Test
public void testGetEventNotificationMethodsByType() {
    String target = "Email";
    List<event_notification_methods> result = dao.getEventNotificationMethodsByType(target);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (event_notification_methods method : result) {
        assertEquals(EventNotificationMethods.EMAIL, method.getmethod_type());
    }
}
#method_after
@Test
public void testGetEventNotificationMethodsByType() {
    String target = "Email";
    List<EventNotificationMethod> result = dao.getEventNotificationMethodsByType(target);
    assertNotNull(result);
    assertFalse(result.isEmpty());
    for (EventNotificationMethod method : result) {
        assertEquals(EventNotificationMethods.EMAIL, method.getmethod_type());
    }
}
#end_block

#method_before
@Test
public void testGetEventMapByName() {
    List<EventMap> result = dao.getEventMapByName("TestRun");
    assertNotNull(result);
    for (EventMap mapping : result) {
        assertEquals("TestRun", mapping.getevent_up_name());
    }
}
#method_after
@Test
public void testGetEventMapByName() {
    List<EventMap> result = dao.getEventMapByName("TestRun");
    assertNotNull(result);
    for (EventMap mapping : result) {
        assertEquals("TestRun", mapping.getEventUpName());
    }
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!getParameters().isNested()) {
        return Collections.singletonMap(getVdsGroupId().toString(), LockingGroup.GLUSTER.name());
    }
    return super.getExclusiveLocks();
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!isInternalExecution()) {
        return Collections.singletonMap(getVdsGroupId().toString(), LockingGroup.GLUSTER.name());
    }
    return super.getExclusiveLocks();
}
#end_block

#method_before
protected VdcReturnValueBase runBllAction(VdcActionType actionType, GlusterParametersBase params) {
    params.setNested(true);
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(actionType, params);
    setSucceeded(returnValue.getSucceeded());
    return returnValue;
}
#method_after
protected VdcReturnValueBase runBllAction(VdcActionType actionType, VdcActionParametersBase params) {
    VdcReturnValueBase returnValue = Backend.getInstance().runInternalAction(actionType, params);
    setSucceeded(returnValue.getSucceeded());
    return returnValue;
}
#end_block

#method_before
private Response addNfsOrLocalOrPosix(VdcActionType action, StorageDomain model, storage_domain_static entity, Guid hostId) {
    storage_server_connections cnx = mapToCnx(model);
    entity.setstorage(addStorageServerConnection(cnx, hostId));
    if (action == VdcActionType.AddNFSStorageDomain) {
        storage_domains existing = getExistingStorageDomain(hostId, entity.getstorage_type(), entity.getstorage_domain_type(), cnx);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingNFSStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingNFSStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreation(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#method_after
private Response addNfsOrLocalOrPosix(VdcActionType action, StorageDomain model, StorageDomainStatic entity, Guid hostId) {
    StorageServerConnections cnx = mapToCnx(model);
    entity.setstorage(addStorageServerConnection(cnx, hostId));
    if (action == VdcActionType.AddNFSStorageDomain) {
        storage_domains existing = getExistingStorageDomain(hostId, entity.getstorage_type(), entity.getstorage_domain_type(), cnx);
        if (existing != null) {
            entity = existing.getStorageStaticData();
            action = VdcActionType.AddExistingNFSStorageDomain;
        }
    }
    if (action != VdcActionType.AddExistingNFSStorageDomain) {
        validateParameters(model, 2, "name");
    }
    return performCreate(action, getAddParams(entity, hostId), ID_RESOLVER);
}
#end_block

#method_before
private Response addSAN(StorageDomain model, StorageType storageType, storage_domain_static entity, Guid hostId) {
    boolean overrideLuns = model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
    return performCreation(VdcActionType.AddSANStorageDomain, getSanAddParams(entity, hostId, getLunIds(model.getStorage(), storageType, hostId), overrideLuns), ID_RESOLVER);
}
#method_after
private Response addSAN(StorageDomain model, StorageType storageType, StorageDomainStatic entity, Guid hostId) {
    boolean overrideLuns = model.getStorage().isSetOverrideLuns() ? model.getStorage().isOverrideLuns() : false;
    return performCreate(VdcActionType.AddSANStorageDomain, getSanAddParams(entity, hostId, getLunIds(model.getStorage(), storageType, hostId), overrideLuns), ID_RESOLVER);
}
#end_block

#method_before
private void connectStorageToHost(Guid hostId, StorageType storageType, LogicalUnit unit) {
    storage_server_connections cnx = StorageDomainHelper.getConnection(storageType, unit.getAddress(), unit.getTarget(), unit.getUsername(), unit.getPassword(), unit.getPort());
    performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(cnx, hostId));
}
#method_after
private void connectStorageToHost(Guid hostId, StorageType storageType, LogicalUnit unit) {
    StorageServerConnections cnx = StorageDomainHelper.getConnection(storageType, unit.getAddress(), unit.getTarget(), unit.getUsername(), unit.getPassword(), unit.getPort());
    performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(cnx, hostId));
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage.type");
    validateEnums(StorageDomain.class, storageDomain);
    storage_domain_static entity = mapToStatic(storageDomain);
    Guid hostId = getHostId(storageDomain);
    Response resp = null;
    switch(entity.getstorage_type()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getstorage_type(), entity, hostId);
            break;
        case NFS:
            validateParameters(storageDomain.getStorage(), "address", "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId);
            break;
        case LOCALFS:
            validateParameters(storageDomain.getStorage(), "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId);
            break;
        case POSIXFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId);
            break;
        default:
            break;
    }
    addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    return resp;
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "host.id|name", "type", "storage.type");
    validateEnums(StorageDomain.class, storageDomain);
    StorageDomainStatic entity = mapToStatic(storageDomain);
    Guid hostId = getHostId(storageDomain);
    Response resp = null;
    switch(entity.getstorage_type()) {
        case ISCSI:
        case FCP:
            resp = addSAN(storageDomain, entity.getstorage_type(), entity, hostId);
            break;
        case NFS:
            validateParameters(storageDomain.getStorage(), "address", "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddNFSStorageDomain, storageDomain, entity, hostId);
            break;
        case LOCALFS:
            validateParameters(storageDomain.getStorage(), "path");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddLocalStorageDomain, storageDomain, entity, hostId);
            break;
        case POSIXFS:
            validateParameters(storageDomain.getStorage(), "path", "vfsType");
            resp = addNfsOrLocalOrPosix(VdcActionType.AddPosixFsStorageDomain, storageDomain, entity, hostId);
            break;
        default:
            break;
    }
    addLinks(((StorageDomain) resp.getEntity()), getLinksToExclude(storageDomain));
    return resp;
}
#end_block

#method_before
protected storage_domain_static mapToStatic(StorageDomain model) {
    return getMapper(modelType, storage_domain_static.class).map(model, null);
}
#method_after
protected StorageDomainStatic mapToStatic(StorageDomain model) {
    return getMapper(modelType, StorageDomainStatic.class).map(model, null);
}
#end_block

#method_before
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    storage_server_connections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    if (cnx.getNfsRetrans() != null) {
        storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
    }
    if (cnx.getNfsTimeo() != null) {
        storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
    }
    if (cnx.getNfsVersion() != null) {
        storage.setNfsVersion(StorageDomainMapper.map(cnx.getNfsVersion(), null));
    }
}
#method_after
protected void mapNfsOrLocalOrPosix(StorageDomain model, storage_domains entity) {
    final Storage storage = model.getStorage();
    StorageServerConnections cnx = getStorageServerConnection(entity.getstorage());
    if (cnx.getconnection().contains(":")) {
        String[] parts = cnx.getconnection().split(":");
        model.getStorage().setAddress(parts[0]);
        model.getStorage().setPath(parts[1]);
    } else {
        model.getStorage().setPath(cnx.getconnection());
    }
    storage.setMountOptions(cnx.getMountOptions());
    storage.setVfsType(cnx.getVfsType());
    if (cnx.getNfsRetrans() != null) {
        storage.setNfsRetrans(cnx.getNfsRetrans().intValue());
    }
    if (cnx.getNfsTimeo() != null) {
        storage.setNfsTimeo(cnx.getNfsTimeo().intValue());
    }
    if (cnx.getNfsVersion() != null) {
        storage.setNfsVersion(StorageDomainMapper.map(cnx.getNfsVersion(), null));
    }
}
#end_block

#method_before
protected void mapVolumeGroupIscsi(StorageDomain model, storage_domains entity) {
    VolumeGroup vg = model.getStorage().getVolumeGroup();
    for (LUNs lun : getLunsByVgId(vg.getId())) {
        List<storage_server_connections> lunConnections = lun.getLunConnections();
        if (lunConnections != null) {
            for (storage_server_connections cnx : lunConnections) {
                LogicalUnit unit = map(lun);
                unit = map(cnx, unit);
                vg.getLogicalUnits().add(unit);
            }
        }
    }
}
#method_after
protected void mapVolumeGroupIscsi(StorageDomain model, storage_domains entity) {
    VolumeGroup vg = model.getStorage().getVolumeGroup();
    for (LUNs lun : getLunsByVgId(vg.getId())) {
        List<StorageServerConnections> lunConnections = lun.getLunConnections();
        if (lunConnections != null) {
            for (StorageServerConnections cnx : lunConnections) {
                LogicalUnit unit = map(lun);
                unit = map(cnx, unit);
                vg.getLogicalUnits().add(unit);
            }
        }
    }
}
#end_block

#method_before
protected org.ovirt.engine.api.model.StorageType map(StorageType type) {
    return getMapper(StorageType.class, org.ovirt.engine.api.model.StorageType.class).map(type, null);
}
#method_after
protected LogicalUnit map(StorageServerConnections cnx, LogicalUnit template) {
    return getMapper(StorageServerConnections.class, LogicalUnit.class).map(cnx, template);
}
#end_block

#method_before
protected storage_server_connections mapToCnx(StorageDomain model) {
    return getMapper(StorageDomain.class, storage_server_connections.class).map(model, null);
}
#method_after
protected StorageServerConnections mapToCnx(StorageDomain model) {
    return getMapper(StorageDomain.class, StorageServerConnections.class).map(model, null);
}
#end_block

#method_before
private String addStorageServerConnection(storage_server_connections cnx, Guid hostId) {
    return performAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(cnx, hostId), String.class);
}
#method_after
private String addStorageServerConnection(StorageServerConnections cnx, Guid hostId) {
    return performAction(VdcActionType.AddStorageServerConnection, new StorageServerConnectionParametersBase(cnx, hostId), String.class);
}
#end_block

#method_before
private storage_server_connections getStorageServerConnection(String id) {
    return getEntity(storage_server_connections.class, VdcQueryType.GetStorageServerConnectionById, new StorageServerConnectionQueryParametersBase(id), "Storage server connection: id=" + id);
}
#method_after
private StorageServerConnections getStorageServerConnection(String id) {
    return getEntity(StorageServerConnections.class, VdcQueryType.GetStorageServerConnectionById, new StorageServerConnectionQueryParametersBase(id), "Storage server connection: id=" + id);
}
#end_block

#method_before
private storage_domains getExistingStorageDomain(Guid hostId, StorageType storageType, StorageDomainType domainType, storage_server_connections cnx) {
    List<storage_domains> existing = asCollection(storage_domains.class, getEntity(ArrayList.class, VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, cnx.getconnection()), "Existing storage domains: path=" + cnx.getconnection()));
    return existing.size() != 0 ? existing.get(0) : null;
}
#method_after
private storage_domains getExistingStorageDomain(Guid hostId, StorageType storageType, StorageDomainType domainType, StorageServerConnections cnx) {
    List<storage_domains> existing = asCollection(storage_domains.class, getEntity(ArrayList.class, VdcQueryType.GetExistingStorageDomainList, new GetExistingStorageDomainListParameters(hostId, storageType, domainType, cnx.getconnection()), "Existing storage domains: path=" + cnx.getconnection()));
    return existing.size() != 0 ? existing.get(0) : null;
}
#end_block

#method_before
private StorageDomainManagementParameter getAddParams(storage_domain_static entity, Guid hostId) {
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(entity);
    params.setVdsId(hostId);
    return params;
}
#method_after
private StorageDomainManagementParameter getAddParams(StorageDomainStatic entity, Guid hostId) {
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(entity);
    params.setVdsId(hostId);
    return params;
}
#end_block

#method_before
private AddSANStorageDomainParameters getSanAddParams(storage_domain_static entity, Guid hostId, ArrayList<String> lunIds, boolean force) {
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(entity);
    params.setVdsId(hostId);
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#method_after
private AddSANStorageDomainParameters getSanAddParams(StorageDomainStatic entity, Guid hostId, ArrayList<String> lunIds, boolean force) {
    AddSANStorageDomainParameters params = new AddSANStorageDomainParameters(entity);
    params.setVdsId(hostId);
    params.setLunIds(lunIds);
    params.setForce(force);
    return params;
}
#end_block

#method_before
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "id|name");
    Guid storageDomainId;
    if (storageDomain.isSetId()) {
        storageDomainId = asGuid(storageDomain.getId());
    } else {
        storageDomainId = lookupStorageDomainIdByName(storageDomain.getName());
    }
    return performCreation(VdcActionType.AttachStorageDomainToPool, new DetachStorageDomainFromPoolParameters(storageDomainId, dataCenterId), new StorageDomainIdResolver(storageDomainId));
}
#method_after
@Override
public Response add(StorageDomain storageDomain) {
    validateParameters(storageDomain, "id|name");
    Guid storageDomainId;
    if (storageDomain.isSetId()) {
        storageDomainId = asGuid(storageDomain.getId());
    } else {
        storageDomainId = lookupStorageDomainIdByName(storageDomain.getName());
    }
    return performCreate(VdcActionType.AttachStorageDomainToPool, new DetachStorageDomainFromPoolParameters(storageDomainId, dataCenterId), new StorageDomainIdResolver(storageDomainId));
}
#end_block

#method_before
protected Groups mapDomainGroupsCollection(List<ad_groups> entities) {
    Groups collection = new Groups();
    for (ad_groups entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#method_after
protected Groups mapDomainGroupsCollection(List<LdapGroup> entities) {
    Groups collection = new Groups();
    for (LdapGroup entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected Group mapAdGroup(ad_groups entity) {
    return getMapper(ad_groups.class, Group.class).map(entity, null);
}
#method_after
protected Group mapAdGroup(LdapGroup entity) {
    return getMapper(LdapGroup.class, Group.class).map(entity, null);
}
#end_block

#method_before
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), ad_groups.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#method_after
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), LdapGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#end_block

#method_before
protected ad_groups getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<ad_groups> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (ad_groups adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#method_after
protected LdapGroup getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<LdapGroup> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (LdapGroup adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#end_block

#method_before
protected List<ad_groups> getGroupsFromDomain() {
    return asCollection(ad_groups.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#method_after
protected List<LdapGroup> getGroupsFromDomain() {
    return asCollection(LdapGroup.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#end_block

#method_before
public ad_groups lookupGroupById(Guid id) {
    return getEntity(ad_groups.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#method_after
public LdapGroup lookupGroupById(Guid id) {
    return getEntity(LdapGroup.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#end_block

#method_before
@Override
public ad_groups lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#method_after
@Override
public LdapGroup lookupEntity(Guid nullId) throws BackendFailureException {
    return lookupGroupById(this.id);
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(vm.getUsb(), lookupCluster(staticVm.getvds_group_id()));
        if (usbPolicy != null) {
            staticVm.setusb_policy(usbPolicy);
        }
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "name", "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (isCreateFromSnapshot(vm)) {
        response = createVmFromSnapshot(vm);
    } else {
        validateParameters(vm, "template.id|name");
        Guid templateId = getTemplateId(vm);
        VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
        if (namedCluster(vm)) {
            staticVm.setvds_group_id(getClusterId(vm));
        }
        staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getvds_group_id())));
        if (!isFiltered()) {
            // resolve the host's ID, because it will be needed down the line
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                staticVm.setdedicated_vm_for_vds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
            }
        } else {
            vm.setPlacementPolicy(null);
        }
        Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
        if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
            response = cloneVmFromTemplate(staticVm, vm, templateId);
        } else if (Guid.Empty.equals(templateId)) {
            response = addVmFromScratch(staticVm, vm, storageDomainId);
        } else {
            response = addVm(staticVm, vm, storageDomainId, templateId);
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
private Response cloneVmFromSnapshot(VmStatic staticVm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
private Response cloneVmFromSnapshot(VmStatic staticVm, String snapshotId, HashMap<Guid, DiskImage> images) {
    Guid sourceSnapshotId = asGuid(snapshotId);
    AddVmFromSnapshotParameters params = new AddVmFromSnapshotParameters(staticVm, sourceSnapshotId);
    params.setDiskInfoDestinationMap(images);
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVmFromSnapshot, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
private Response cloneVmFromTemplate(VmStatic staticVm, VM vm, Guid templateId) {
    AddVmFromTemplateParameters params = new AddVmFromTemplateParameters(staticVm, getDisksToClone(vm.getDisks(), templateId), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVmFromTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreation(VdcActionType.AddVm, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVm(VmStatic staticVm, VM vm, Guid storageDomainId, Guid templateId) {
    VmManagementParametersBase params = new VmManagementParametersBase(staticVm);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setStorageDomainId(storageDomainId);
    params.setDiskInfoDestinationMap(getDisksToClone(vm.getDisks(), templateId));
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    return performCreate(VdcActionType.AddVm, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    return performCreation(VdcActionType.AddVmFromScratch, params, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#method_after
protected Response addVmFromScratch(VmStatic staticVm, VM vm, Guid storageDomainId) {
    AddVmFromScratchParameters params = new AddVmFromScratchParameters(staticVm, mapDisks(vm.getDisks()), Guid.Empty);
    params.setVmPayload(getPayload(vm));
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    }
    params.setMakeCreatorExplicitOwner(shouldMakeCreatorExplicitOwner());
    params.setStorageDomainId(storageDomainId);
    return performCreate(VdcActionType.AddVmFromScratch, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class));
}
#end_block

#method_before
private void addInlineStatistics(VM vm) {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(vm.getId()));
    BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM> statisticsResource = inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, Guid.createGuidFromString(vm.getId()), query));
    Statistics statistics = statisticsResource.list();
    vm.setStatistics(statistics);
}
#method_after
private void addInlineStatistics(VM vm) {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(vm.getId()));
    BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM> statisticsResource = inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, Guid.createGuidFromString(vm.getId()), query));
    Statistics statistics = statisticsResource.list();
    vm.setStatistics(statistics);
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    model = addInlineDetails(details, model);
    if (details.contains(Detail.STATISTICS)) {
        addInlineStatistics(model);
    }
    // setPayload(model); //TODO: removed due to (potential) performance issue, but we will need to find another way to get payload information for *all* VMs, such as a designated backend query.
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setCertificateInfo(model);
    return model;
}
#end_block

#method_before
@Override
public Template update(Template incoming) {
    validateEnums(Template.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
}
#method_after
@Override
public Template update(Template incoming) {
    validateEnums(Template.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class), VdcActionType.UpdateVmTemplate, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(incoming.getUsb(), lookupCluster(updated.getvds_group_id()));
    if (usbPolicy != null) {
        updated.setusb_policy(usbPolicy);
    }
    return new UpdateVmTemplateParameters(updated);
}
#method_after
@Override
public VdcActionParametersBase getParameters(Template incoming, VmTemplate entity) {
    VmTemplate updated = getMapper(modelType, VmTemplate.class).map(incoming, entity);
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getusb_policy(), lookupCluster(updated.getvds_group_id())));
    return new UpdateVmTemplateParameters(updated);
}
#end_block

#method_before
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class), VdcActionType.UpdateVmPoolWithVms, new UpdateParametersProvider());
}
#method_after
@Override
public VmPool update(VmPool incoming) {
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class), VdcActionType.UpdateVmPoolWithVms, new UpdateParametersProvider());
}
#end_block

#method_before
public org.ovirt.engine.api.model.VM lookupEntity(Guid id) throws BackendFailureException {
    VM vm = doGetEntity(VM.class, query, getQueryParams(queryParamsClass, id), id.toString());
    org.ovirt.engine.api.model.VM model = new org.ovirt.engine.api.model.VM();
    model.setId(vm.getId().toString());
    return LinkHelper.addLinks(getUriInfo(), model);
}
#method_after
@Override
public Object lookupEntity(Object id) throws BackendFailureException {
    VM vm = doGetEntity(VM.class, query, getQueryParams(queryParamsClass, id), id.toString());
    org.ovirt.engine.api.model.VM model = new org.ovirt.engine.api.model.VM();
    model.setId(vm.getId().toString());
    return LinkHelper.addLinks(getUriInfo(), model);
}
#end_block

#method_before
@Override
protected boolean matchEntity(Q entity, Guid id) {
    return id.equals(CDROM_ID) && parentId.equals(entity.getQueryableId());
}
#method_after
@Override
protected <T> boolean matchEntity(Q entity, T id) {
    return id.equals(CDROM_ID) && parentId.equals(entity.getQueryableId());
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(map(lookupEntity(asGuid(disk.getId())))).build();
    } else {
        validateDiskForCreation(disk);
        return performCreation(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#method_after
@Override
public Response add(Disk disk) {
    validateEnums(Disk.class, disk);
    if (disk.isSetId()) {
        return Response.fromResponse(attachDiskToVm(disk)).entity(map(lookupEntity(asGuid(disk.getId())))).build();
    } else {
        validateDiskForCreation(disk);
        return performCreate(addAction, getAddParameters(map(disk), disk), getEntityIdResolver(disk.getName()));
    }
}
#end_block

#method_before
@Override
protected boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, String name) {
    return false;
}
#method_after
@Override
protected <T> boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, T id) {
    return id != null && (id.equals(entity.getId()));
}
#end_block

#method_before
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return model;
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Tag update(Tag incoming) {
    if (parent.isSetParentName(incoming)) {
        incoming.getParent().getTag().setId(parent.getParentId(incoming));
    }
    Tag existingTag = get();
    String existingTagParentId = existingTag.isSetParent() && existingTag.getParent().isSetTag() && existingTag.getParent().getTag().isSetId() ? existingTag.getParent().getTag().getId() : null;
    if (isSetParent(incoming) && !incoming.getParent().getTag().getId().equals(existingTagParentId)) {
        moveTag(asGuid(incoming.getParent().getTag().getId()));
    }
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetTagByTagId, GetTagByTagIdParameters.class), VdcActionType.UpdateTag, new UpdateParametersProvider());
}
#method_after
@Override
public Tag update(Tag incoming) {
    if (parent.isSetParentName(incoming)) {
        incoming.getParent().getTag().setId(parent.getParentId(incoming));
    }
    Tag existingTag = get();
    String existingTagParentId = existingTag.isSetParent() && existingTag.getParent().isSetTag() && existingTag.getParent().getTag().isSetId() ? existingTag.getParent().getTag().getId() : null;
    if (isSetParent(incoming) && !incoming.getParent().getTag().getId().equals(existingTagParentId)) {
        moveTag(asGuid(incoming.getParent().getTag().getId()));
    }
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetTagByTagId, GetTagByTagIdParameters.class), VdcActionType.UpdateTag, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Hosts list() {
    // Filtered users are not allowed to view hosts
    if (isFiltered()) {
        throw new WebApplicationException(Response.Status.FORBIDDEN);
    }
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return listGlusterOnly();
    } else {
        return listAll();
    }
}
#method_after
@Override
public Hosts list() {
    ApplicationMode appMode = getCurrent().get(ApplicationMode.class);
    if (appMode == ApplicationMode.GlusterOnly) {
        return listGlusterOnly();
    } else {
        return listAll();
    }
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreate(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = addStatistics(model, entity, uriInfo, httpHeaders);
    addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    return model;
}
#end_block

#method_before
public HostStorage list() {
    HostStorage ret = new HostStorage();
    for (LUNs lun : getLogicalUnits()) {
        Storage storage = map(lun);
        ArrayList<storage_server_connections> lunConnections = lun.getLunConnections();
        if (lunConnections != null && !lunConnections.isEmpty()) {
            getMapper(storage_server_connections.class, LogicalUnit.class).map(lunConnections.get(0), storage.getLogicalUnits().get(0));
        }
        ret.getStorage().add(addLinks(storage));
    }
    for (storage_domains vg : getVolumeGroups()) {
        ret.getStorage().add(addLinks(map(vg)));
    }
    return ret;
}
#method_after
public HostStorage list() {
    HostStorage ret = new HostStorage();
    for (LUNs lun : getLogicalUnits()) {
        Storage storage = map(lun);
        ArrayList<StorageServerConnections> lunConnections = lun.getLunConnections();
        if (lunConnections != null && !lunConnections.isEmpty()) {
            getMapper(StorageServerConnections.class, LogicalUnit.class).map(lunConnections.get(0), storage.getLogicalUnits().get(0));
        }
        ret.getStorage().add(addLinks(storage));
    }
    for (storage_domains vg : getVolumeGroups()) {
        ret.getStorage().add(addLinks(map(vg)));
    }
    return ret;
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreate(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
@Override
public Disks list() {
    return mapCollection(getBackendCollection(SearchType.Disk));
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        Guid clusterId = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(parentId), "id").getvds_group_id();
        Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
        if (net != null) {
            ni.setNetworkName(net.getname());
        }
    }
    return ni;
}
#method_after
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        if (device.isSetId() || device.isSetName()) {
            Guid clusterId = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(parentId), "id").getvds_group_id();
            Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
            if (net != null) {
                ni.setNetworkName(net.getName());
            }
        } else {
            ni.setNetworkName(null);
        }
    }
    return ni;
}
#end_block

#method_before
@Override
public Response add(Permit permit) {
    validateParameters(permit, "name|id");
    validateEnums(Permit.class, permit);
    ArrayList<ActionGroup> actionGroups = new ArrayList<ActionGroup>();
    actionGroups.add(map(permit));
    return performCreation(VdcActionType.AttachActionGroupsToRole, new ActionGroupsToRoleParameter(roleId, actionGroups), new PermitIdResolver(actionGroups.get(0)));
}
#method_after
@Override
public Response add(Permit permit) {
    validateParameters(permit, "name|id");
    validateEnums(Permit.class, permit);
    ArrayList<ActionGroup> actionGroups = new ArrayList<ActionGroup>();
    actionGroups.add(map(permit));
    return performCreate(VdcActionType.AttachActionGroupsToRole, new ActionGroupsToRoleParameter(roleId, actionGroups), new PermitIdResolver(actionGroups.get(0)));
}
#end_block

#method_before
@Override
public ActionGroup lookupEntity(Guid guid) {
    return actionGroup;
}
#method_after
@Override
public ActionGroup lookupEntity(Guid id) {
    return actionGroup;
}
#end_block

#method_before
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreation(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Permission permission) {
    validateParameters(permission, isPrincipalSubCollection() ? new String[] { "role.id", "dataCenter|cluster|host|storageDomain|vm|vmpool|template.id" } : new String[] { "role.id", "user|group.id" });
    permissions entity = map(permission, getPermissionsTemplate(permission));
    return performCreate(VdcActionType.AddPermission, getPrincipal(entity, permission), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        ad_groups group = new ad_groups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Override
public Response add(Role role) {
    validateParameters(role, "name", "permits.id");
    validateEnums(Role.class, role);
    return performCreation(VdcActionType.AddRoleWithActionGroups, new RoleWithActionGroupsParameters(map(role), mapPermits(role.getPermits().getPermits())), new QueryIdResolver(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class));
}
#method_after
@Override
public Response add(Role role) {
    validateParameters(role, "name", "permits.id");
    validateEnums(Role.class, role);
    return performCreate(VdcActionType.AddRoleWithActionGroups, new RoleWithActionGroupsParameters(map(role), mapPermits(role.getPermits().getPermits())), new QueryIdResolver<Guid>(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class));
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    Guid clusterId = parent.getClusterId();
    org.ovirt.engine.core.common.businessentities.Network network = parent.getClusterNetwork(clusterId, null, model.getNetwork().getName());
    String networkId = network == null ? null : network.getId().toString();
    model.getNetwork().setId(networkId);
    model.getNetwork().setName(null);
    if (entity.isPortMirroring()) {
        PortMirroring portMirroring = new PortMirroring();
        Networks networks = new Networks();
        Network net = new Network();
        net.setId(networkId);
        net.setName(network.getname());
        portMirroring.setNetworks(networks);
        portMirroring.getNetworks().getNetworks().add(net);
        model.setPortMirroring(portMirroring);
    }
    return parent.addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    parent.addReportedDevices(model, entity);
    return model;
}
#end_block

#method_before
@Override
public NIC update(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
    String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
    if (!fault && isPortMirroring) {
        Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        if (pmNetworkId != null) {
            if (networkId == null) {
                networkId = (networkName != null) ? getNetworkId(networkName) : get().getNetwork().getId();
            }
            fault = (!pmNetworkId.equals(networkId));
        } else if (pmNetworkName != null) {
            if (networkName == null) {
                if (networkId == null) {
                    networkId = get().getNetwork().getId();
                }
                pmNetworkId = getNetworkId(pmNetworkName);
                fault = (!networkId.equals(pmNetworkId));
            }
            fault = fault || (!pmNetworkName.equals(networkName));
        } else {
            fault = true;
            faultString = "Network must have name or id property for port mirroring";
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.update(device);
}
#method_after
@Override
public NIC update(NIC device) {
    validateEnums(NIC.class, device);
    if (device.isSetPortMirroring() || device.isSetNetwork()) {
        validatePortMirroring(device);
    }
    return super.update(device);
}
#end_block

#method_before
private String getNetworkId(String networkName) {
    BackendVmNicsResource parent = (BackendVmNicsResource) collection;
    Guid clusterId = parent.getClusterId();
    org.ovirt.engine.core.common.businessentities.Network n = parent.getClusterNetwork(clusterId, null, networkName);
    if (n != null) {
        return n.getId().toString();
    }
    return null;
}
#method_after
private String getNetworkId(String networkName) {
    if (networkName != null) {
        BackendVmNicsResource parent = (BackendVmNicsResource) collection;
        Guid clusterId = parent.getClusterId();
        org.ovirt.engine.core.common.businessentities.network.Network n = parent.getClusterNetwork(clusterId, null, networkName);
        if (n != null) {
            return n.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public Response activate(Action action) {
    ActivateDeactivateVmNicParameters params = new ActivateDeactivateVmNicParameters(guid, PlugAction.PLUG);
    BackendNicsResource parent = (BackendNicsResource) collection;
    params.setVmId(parent.parentId);
    return doAction(VdcActionType.ActivateDeactivateVmNic, params, action);
}
#method_after
@Override
public Response activate(Action action) {
    NIC nic = get();
    nic.setPlugged(true);
    update(nic);
    return actionSuccess(action);
}
#end_block

#method_before
@Override
public Response deactivate(Action action) {
    ActivateDeactivateVmNicParameters params = new ActivateDeactivateVmNicParameters(guid, PlugAction.UNPLUG);
    params.setVmId(((BackendNicsResource) collection).parentId);
    return doAction(VdcActionType.ActivateDeactivateVmNic, params, action);
}
#method_after
@Override
public Response deactivate(Action action) {
    NIC nic = get();
    nic.setPlugged(false);
    update(nic);
    return actionSuccess(action);
}
#end_block

#method_before
@Override
public Role update(Role role) {
    validateEnums(Role.class, role);
    return performUpdate(role, new QueryIdResolver(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class), VdcActionType.UpdateRole, new UpdateParametersProvider());
}
#method_after
@Override
public Role update(Role role) {
    validateEnums(Role.class, role);
    return performUpdate(role, new QueryIdResolver<Guid>(VdcQueryType.GetRoleById, MultilevelAdministrationByRoleIdParameters.class), VdcActionType.UpdateRole, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected Action doPopulate(Action model, List entity) {
    model.setId(asString(ids));
    if (model.isSetFault()) {
        setReason(model.getFault());
    }
    return model;
}
#method_after
@Override
protected Action doPopulate(Action model, List entity) {
    return model;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Collection<VmTemplate> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    params.setGetAll(true);
    Map<VmTemplate, DiskImageList> ret = getEntity(HashMap.class, VdcQueryType.GetTemplatesFromExportDomain, params, "Templates under storage domain id : " + storageDomainId.toString());
    return ret.keySet();
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected Collection<VmTemplate> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    Map<VmTemplate, DiskImageList> ret = getEntity(HashMap.class, VdcQueryType.GetTemplatesFromExportDomain, params, "Templates under storage domain id : " + storageDomainId.toString());
    return ret.keySet();
}
#end_block

#method_before
@Override
public Events list() {
    return mapCollection(getBackendCollection());
}
#method_after
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#end_block

#method_before
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return new BackendEventResource(id, this);
}
#method_after
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id, this));
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveExternalEvent, new RemoveExternalEventParameters(asLong(id)));
}
#end_block

#method_before
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    vm_pools entity = map(pool);
    entity.setvm_pool_type(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    return performCreation(VdcActionType.AddVmPoolWithVms, new AddVmPoolWithVmsParameters(entity, vm, size, -1), new QueryIdResolver(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class));
}
#method_after
@Override
public Response add(VmPool pool) {
    validateParameters(pool, "name", "template.id|name", "cluster.id|name");
    VmTemplate template = getVmTemplate(pool);
    if (namedTemplate(pool)) {
        pool.getTemplate().setId(template.getId().toString());
    }
    if (namedCluster(pool)) {
        pool.getCluster().setId(getClusterId(pool));
    }
    vm_pools entity = map(pool);
    entity.setvm_pool_type(VmPoolType.Automatic);
    VM vm = mapToVM(pool, template);
    int size = pool.isSetSize() ? pool.getSize() : 1;
    return performCreate(VdcActionType.AddVmPoolWithVms, new AddVmPoolWithVmsParameters(entity, vm, size, -1), new QueryIdResolver<Guid>(VdcQueryType.GetVmPoolById, GetVmPoolByIdParameters.class));
}
#end_block

#method_before
@Override
public VmPool doPopulate(VmPool pool, vm_pools entity) {
    if (pool.isSetSize() && pool.getSize() > 0) {
        VM vm = getEntity(VM.class, SearchType.VM, "Vms: pool=" + pool.getName());
        pool.setTemplate(new Template());
        pool.getTemplate().setId(vm.getVmtGuid().toString());
    }
    return pool;
}
#method_after
@Override
public VmPool doPopulate(VmPool pool, vm_pools entity) {
    return pool;
}
#end_block

#method_before
@Override
protected Collection<org.ovirt.engine.core.common.businessentities.VM> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    params.setGetAll(true);
    return getBackendCollection(VdcQueryType.GetVmsFromExportDomain, params);
}
#method_after
@Override
protected Collection<org.ovirt.engine.core.common.businessentities.VM> getEntitiesFromExportDomain() {
    GetAllFromExportDomainQueryParameters params = new GetAllFromExportDomainQueryParameters(getDataCenterId(storageDomainId), storageDomainId);
    return getBackendCollection(VdcQueryType.GetVmsFromExportDomain, params);
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    QueryIdResolver hostResolver = new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && incoming.getCluster().isSetId() && !asGuid(incoming.getCluster().getId()).equals(entity.getvds_group_id())) {
        performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(asGuid(incoming.getCluster().getId()), guid));
    }
    return performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && incoming.getCluster().isSetId() && !asGuid(incoming.getCluster().getId()).equals(entity.getvds_group_id())) {
        performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(asGuid(incoming.getCluster().getId()), guid));
    }
    return performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    storage_server_connections cnx = new storage_server_connections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    // TODO: when VSDM and Backend will support this, we will need to externalize this parameter to the user
    cnx.setportal("0");
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#method_after
@Override
public Response iscsiLogin(Action action) {
    validateParameters(action, "iscsi.address", "iscsi.target");
    StorageServerConnections cnx = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    cnx.setconnection(iscsiDetails.getAddress());
    cnx.setiqn(iscsiDetails.getTarget());
    cnx.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        cnx.setport(iscsiDetails.getPort().toString());
    } else {
        cnx.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        cnx.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        cnx.setpassword(iscsiDetails.getPassword());
    }
    // TODO: when VSDM and Backend will support this, we will need to externalize this parameter to the user
    cnx.setportal("0");
    StorageServerConnectionParametersBase connectionParms = new StorageServerConnectionParametersBase(cnx, guid);
    return doAction(VdcActionType.ConnectStorageToVds, connectionParms, action);
}
#end_block

#method_before
public Response iscsiDiscover(Action action) {
    validateParameters(action, "iscsi.address");
    List<storage_server_connections> result = getBackendCollection(storage_server_connections.class, VdcQueryType.DiscoverSendTargets, createDiscoveryQueryParams(action));
    return actionSuccess(mapTargets(action, result));
}
#method_after
public Response iscsiDiscover(Action action) {
    validateParameters(action, "iscsi.address");
    List<StorageServerConnections> result = getBackendCollection(StorageServerConnections.class, VdcQueryType.DiscoverSendTargets, createDiscoveryQueryParams(action));
    return actionSuccess(mapTargets(action, result));
}
#end_block

#method_before
private Action mapTargets(Action action, List<storage_server_connections> targets) {
    if (targets != null) {
        for (storage_server_connections cnx : targets) {
            action.getIscsiTargets().add(map(cnx).getTarget());
        }
    }
    return action;
}
#method_after
private Action mapTargets(Action action, List<StorageServerConnections> targets) {
    if (targets != null) {
        for (StorageServerConnections cnx : targets) {
            action.getIscsiTargets().add(map(cnx).getTarget());
        }
    }
    return action;
}
#end_block

#method_before
protected LogicalUnit map(storage_server_connections cnx) {
    return getMapper(storage_server_connections.class, LogicalUnit.class).map(cnx, null);
}
#method_after
protected LogicalUnit map(StorageServerConnections cnx) {
    return getMapper(StorageServerConnections.class, LogicalUnit.class).map(cnx, null);
}
#end_block

#method_before
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    storage_server_connections connectionDetails = new storage_server_connections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#method_after
private DiscoverSendTargetsQueryParameters createDiscoveryQueryParams(Action action) {
    StorageServerConnections connectionDetails = new StorageServerConnections();
    IscsiDetails iscsiDetails = action.getIscsi();
    connectionDetails.setconnection(iscsiDetails.getAddress());
    connectionDetails.setstorage_type(org.ovirt.engine.core.common.businessentities.StorageType.ISCSI);
    if (iscsiDetails.isSetPort()) {
        connectionDetails.setport(iscsiDetails.getPort().toString());
    } else {
        connectionDetails.setport(DEFAULT_ISCSI_PORT);
    }
    if (iscsiDetails.isSetUsername()) {
        connectionDetails.setuser_name(iscsiDetails.getUsername());
    }
    if (iscsiDetails.isSetPassword()) {
        connectionDetails.setpassword(iscsiDetails.getPassword());
    }
    return new DiscoverSendTargetsQueryParameters(guid, connectionDetails);
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Host, VDS>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class);
    HostStatisticalQuery query = new HostStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Host, VDS>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected Host doPopulate(Host model, VDS entity) {
    Host host = parent.addStatistics(model, entity, uriInfo, httpHeaders);
    parent.addCertificateInfo(host);
    return host;
}
#method_after
@Override
protected Host doPopulate(Host model, VDS entity) {
    return model;
}
#end_block

#method_before
@Override
protected boolean matchEntity(VmNetworkInterface entity, Guid id) {
    return id.equals(entity.getId());
}
#method_after
@Override
protected <T> boolean matchEntity(VmNetworkInterface entity, T id) {
    return id.equals(entity.getId());
}
#end_block

#method_before
@Override
public Response add(Role role) {
    validateParameters(role, "id|name");
    validateEnums(Role.class, role);
    if (!role.isSetId()) {
        org.ovirt.engine.core.common.businessentities.Role entity = getEntity(org.ovirt.engine.core.common.businessentities.Role.class, VdcQueryType.GetRoleByName, new MultilevelAdministrationByRoleNameParameters(role.getName()), role.getName());
        role.setId(entity.getId().toString());
    }
    return performCreation(VdcActionType.AddSystemPermission, new PermissionsOperationsParametes(newPermission(role.getId())), new QueryIdResolver(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#method_after
@Override
public Response add(Role role) {
    validateParameters(role, "id|name");
    validateEnums(Role.class, role);
    if (!role.isSetId()) {
        org.ovirt.engine.core.common.businessentities.Role entity = getEntity(org.ovirt.engine.core.common.businessentities.Role.class, VdcQueryType.GetRoleByName, new MultilevelAdministrationByRoleNameParameters(role.getName()), role.getName());
        role.setId(entity.getId().toString());
    }
    return performCreate(VdcActionType.AddSystemPermission, new PermissionsOperationsParametes(newPermission(role.getId())), new QueryIdResolver<Guid>(VdcQueryType.GetPermissionById, MultilevelAdministrationByPermissionIdParameters.class));
}
#end_block

#method_before
@Override
public Response add(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    if (!fault && isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (!fault && isPortMirroring) {
        org.ovirt.engine.api.model.Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
        String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
        if (pmNetworkId != null) {
            networkId = (networkId == null) ? getNetworkId(networkName) : networkId;
            fault = (!pmNetworkId.equals(networkId));
        } else if (pmNetworkName != null) {
            if (networkName == null && networkId != null) {
                pmNetworkId = getNetworkId(pmNetworkName);
                fault = (!pmNetworkId.equals(networkId));
            }
            fault = fault || (!pmNetworkName.equals(networkName));
        } else {
            fault = true;
            faultString = "Network must have name or id property for port mirroring";
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.add(device);
}
#method_after
@Override
public Response add(NIC device) {
    // TODO: this is temporary mapping between engine boolean port mirroring parameter, and REST
    // port mirroring network collection, next engine version will support the network collection
    // in port mirroring
    validateEnums(NIC.class, device);
    boolean fault = false;
    String faultString = "The port mirroring network must match the Network set on the NIC";
    boolean isPortMirroring = device.isSetPortMirroring() && device.getPortMirroring().isSetNetworks();
    boolean isPortMirroringExceeded = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() > 1;
    if (!fault && isPortMirroringExceeded) {
        fault = true;
        faultString = "Cannot set more than one network in port mirroring mode";
    }
    isPortMirroring = isPortMirroring && device.getPortMirroring().getNetworks().getNetworks().size() == 1;
    if (!fault && isPortMirroring) {
        org.ovirt.engine.api.model.Network pmNetwork = device.getPortMirroring().getNetworks().getNetworks().get(0);
        String pmNetworkId = (pmNetwork.isSetId() ? pmNetwork.getId() : null);
        String pmNetworkName = (pmNetwork.isSetName() ? pmNetwork.getName() : null);
        String networkId = (device.isSetNetwork() && device.getNetwork().isSetId()) ? device.getNetwork().getId() : null;
        String networkName = (device.isSetNetwork() && device.getNetwork().isSetName()) ? device.getNetwork().getName() : null;
        if (networkName != null || networkId != null) {
            if (pmNetworkId != null) {
                networkId = (networkId == null) ? getNetworkId(networkName) : networkId;
                fault = (!networkId.equals(pmNetworkId));
            } else if (pmNetworkName != null) {
                if (networkName == null && networkId != null) {
                    pmNetworkId = getNetworkId(pmNetworkName);
                    fault = (!networkId.equals(pmNetworkId));
                }
                fault = fault || (!pmNetworkName.equals(networkName));
            } else {
                fault = true;
                faultString = "Network must have name or id property for port mirroring";
            }
        }
    }
    if (fault) {
        Fault f = new Fault();
        f.setReason(faultString);
        Response response = Response.status(Response.Status.BAD_REQUEST).entity(f).build();
        throw new WebApplicationException(response);
    }
    return super.add(device);
}
#end_block

#method_before
private String getNetworkId(String networkName) {
    Guid clusterId = getClusterId();
    org.ovirt.engine.core.common.businessentities.Network n = getClusterNetwork(clusterId, null, networkName);
    if (n != null) {
        return n.getId().toString();
    }
    return null;
}
#method_after
private String getNetworkId(String networkName) {
    if (networkName != null) {
        Guid clusterId = getClusterId();
        org.ovirt.engine.core.common.businessentities.network.Network n = getClusterNetwork(clusterId, null, networkName);
        if (n != null) {
            return n.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        Guid clusterId = getClusterId();
        Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
        if (net != null) {
            ni.setNetworkName(net.getname());
        }
    }
    return ni;
}
#method_after
@Override
protected VmNetworkInterface setNetwork(NIC device, VmNetworkInterface ni) {
    if (device.isSetNetwork()) {
        if (device.getNetwork().isSetId() || device.getNetwork().isSetName()) {
            Guid clusterId = getClusterId();
            Network net = lookupClusterNetwork(clusterId, device.getNetwork().isSetId() ? asGuid(device.getNetwork().getId()) : null, device.getNetwork().getName());
            if (net != null) {
                ni.setNetworkName(net.getName());
            }
        } else {
            ni.setNetworkName(null);
        }
    }
    return ni;
}
#end_block

#method_before
@Override
protected Creation doPopulate(Creation model, List entity) {
    model.setId(asString(ids));
    if (model.isSetFault()) {
        setReason(model.getFault());
    }
    return model;
}
#method_after
@Override
protected Creation doPopulate(Creation model, List entity) {
    return model;
}
#end_block

#method_before
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver storageDomainResolver = new QueryIdResolver(VdcQueryType.GetStorageDomainById, StorageDomainQueryParametersBase.class);
    storage_domains entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getstorage_type();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#method_after
@Override
public StorageDomain update(StorageDomain incoming) {
    validateEnums(StorageDomain.class, incoming);
    QueryIdResolver<Guid> storageDomainResolver = new QueryIdResolver<Guid>(VdcQueryType.GetStorageDomainById, StorageDomainQueryParametersBase.class);
    storage_domains entity = getEntity(storageDomainResolver, true);
    StorageDomain model = map(entity, new StorageDomain());
    StorageType storageType = entity.getstorage_type();
    if (storageType != null) {
        switch(storageType) {
            case ISCSI:
            case FCP:
                extendStorageDomain(incoming, model, storageType);
                break;
            default:
                break;
        }
    }
    return addLinks(performUpdate(incoming, entity, model, storageDomainResolver, VdcActionType.UpdateStorageDomain, new UpdateParametersProvider()), new String[] { "templates", "vms" });
}
#end_block

#method_before
private void addLunsToStorageDomain(StorageDomain incoming, StorageType storageType, List<LogicalUnit> newLuns, boolean overrideLuns) {
    for (LogicalUnit lun : newLuns) {
        if (lun.isSetAddress() && lun.isSetTarget()) {
            storage_server_connections connection = StorageDomainHelper.getConnection(storageType, lun.getAddress(), lun.getTarget(), lun.getUsername(), lun.getPassword(), lun.getPort());
            performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(connection, getHostId(incoming)));
        }
    }
    refreshVDSM(incoming);
    ExtendSANStorageDomainParameters params = createParameters(guid, newLuns, overrideLuns);
    performAction(VdcActionType.ExtendSANStorageDomain, params);
}
#method_after
private void addLunsToStorageDomain(StorageDomain incoming, StorageType storageType, List<LogicalUnit> newLuns, boolean overrideLuns) {
    for (LogicalUnit lun : newLuns) {
        if (lun.isSetAddress() && lun.isSetTarget()) {
            StorageServerConnections connection = StorageDomainHelper.getConnection(storageType, lun.getAddress(), lun.getTarget(), lun.getUsername(), lun.getPassword(), lun.getPort());
            performAction(VdcActionType.ConnectStorageToVds, new StorageServerConnectionParametersBase(connection, getHostId(incoming)));
        }
    }
    refreshVDSM(incoming);
    ExtendSANStorageDomainParameters params = createParameters(guid, newLuns, overrideLuns);
    performAction(VdcActionType.ExtendSANStorageDomain, params);
}
#end_block

#method_before
@Override
protected StorageDomain doPopulate(StorageDomain model, storage_domains entity) {
    if (StorageDomainSharedStatus.Unattached.equals(entity.getstorage_domain_shared_status())) {
        model.setStatus(StatusUtils.create(StorageDomainStatus.UNATTACHED));
    } else {
        model.setStatus(null);
    }
    return model;
}
#method_after
@Override
protected StorageDomain doPopulate(StorageDomain model, storage_domains entity) {
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(StorageDomain incoming, storage_domains entity) {
    // save SD type before mapping
    org.ovirt.engine.core.common.businessentities.StorageDomainType currentType = entity.getStorageStaticData() == null ? null : entity.getStorageStaticData().getstorage_domain_type();
    storage_domain_static updated = getMapper(modelType, storage_domain_static.class).map(incoming, entity.getStorageStaticData());
    // if SD type was 'Master', and user gave 'Data', they are the same, this is not a real update, so exchange data back to master.
    if (currentType == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master && updated.getstorage_domain_type() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Data) {
        updated.setstorage_domain_type(org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    }
    return new StorageDomainManagementParameter(updated);
}
#method_after
@Override
public VdcActionParametersBase getParameters(StorageDomain incoming, storage_domains entity) {
    // save SD type before mapping
    org.ovirt.engine.core.common.businessentities.StorageDomainType currentType = entity.getStorageStaticData() == null ? null : entity.getStorageStaticData().getstorage_domain_type();
    StorageDomainStatic updated = getMapper(modelType, StorageDomainStatic.class).map(incoming, entity.getStorageStaticData());
    // if SD type was 'Master', and user gave 'Data', they are the same, this is not a real update, so exchange data back to master.
    if (currentType == org.ovirt.engine.core.common.businessentities.StorageDomainType.Master && updated.getstorage_domain_type() == org.ovirt.engine.core.common.businessentities.StorageDomainType.Data) {
        updated.setstorage_domain_type(org.ovirt.engine.core.common.businessentities.StorageDomainType.Master);
    }
    return new StorageDomainManagementParameter(updated);
}
#end_block

#method_before
@Override
public Response add(Tag tag) {
    validateParameters(tag, "name");
    if (isSetParentName(tag)) {
        tag.getParent().getTag().setId(getParentId(tag));
    }
    return performCreation(VdcActionType.AddTag, new TagsOperationParameters(map(tag)), new TagNameResolver(tag.getName()));
}
#method_after
@Override
public Response add(Tag tag) {
    validateParameters(tag, "name");
    if (isSetParentName(tag)) {
        tag.getParent().getTag().setId(getParentId(tag));
    }
    return performCreate(VdcActionType.AddTag, new TagsOperationParameters(map(tag)), new TagNameResolver(tag.getName()));
}
#end_block

#method_before
@Override
public tags lookupEntity(Guid id) {
    // AddTag returns nothing, lookup name instead
    assert (id == null);
    return lookupTagByName(name);
}
#method_after
@Override
public tags lookupEntity(Guid id) throws BackendFailureException {
    // AddTag returns nothing, lookup name instead
    assert (id == null);
    return lookupTagByName(name);
}
#end_block

#method_before
protected Q getEntity(EntityIdResolver entityResolver, boolean notFoundAs404) {
    try {
        return entityResolver.resolve(guid);
    } catch (Exception e) {
        return handleError(entityType, e, notFoundAs404);
    }
}
#method_after
protected <T> Q getEntity(EntityIdResolver<T> entityResolver, boolean notFoundAs404) {
    try {
        return entityResolver.resolve((T) guid);
    } catch (Exception e) {
        return handleError(entityType, e, notFoundAs404);
    }
}
#end_block

#method_before
protected R performUpdate(R incoming, EntityIdResolver entityResolver, VdcActionType update, ParametersProvider<R, Q> updateProvider) {
    // REVISIT maintain isolation across retrievals and update
    Q entity = getEntity(entityResolver, true);
    validateUpdate(incoming, map(entity));
    performAction(update, updateProvider.getParameters(incoming, entity));
    return addLinks(doPopulate(map(getEntity(entityResolver, false)), entity));
}
#method_after
protected final R performUpdate(R incoming, Q entity, R model, EntityIdResolver<Guid> entityResolver, VdcActionType update, ParametersProvider<R, Q> updateProvider) {
    entity = doUpdate(incoming, entity, model, entityResolver, update, updateProvider);
    R model2 = map(entity);
    deprecatedPopulate(model2, entity);
    return addLinks(doPopulate(model2, entity));
}
#end_block

#method_before
public Network get() {
    org.ovirt.engine.core.common.businessentities.Network entity = parent.lookupNetwork(guid);
    if (entity == null) {
        return notFound();
    }
    return addLinks(map(entity));
}
#method_after
public Network get() {
    org.ovirt.engine.core.common.businessentities.network.Network entity = parent.lookupNetwork(guid);
    if (entity == null) {
        return notFound();
    }
    return addLinks(map(entity));
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
public HostNics list() {
    HostNics ret = new HostNics();
    List<VdsNetworkInterface> ifaces = getCollection();
    List<org.ovirt.engine.core.common.businessentities.Network> clusterNetworks = getClusterNetworks();
    Map<String, String> networkIds = new HashMap<String, String>();
    for (org.ovirt.engine.core.common.businessentities.Network nwk : clusterNetworks) {
        networkIds.put(nwk.getname(), nwk.getId().toString());
    }
    for (VdsNetworkInterface iface : ifaces) {
        HostNIC hostNic = populate(map(iface, ifaces), iface);
        if (networkIds.containsKey(iface.getNetworkName())) {
            hostNic.getNetwork().setId(networkIds.get(iface.getNetworkName()));
            hostNic.getNetwork().setName(null);
        }
        ret.getHostNics().add(addLinks(hostNic));
    }
    return addActions(ret);
}
#method_after
@Override
public HostNics list() {
    HostNics ret = new HostNics();
    List<VdsNetworkInterface> ifaces = getCollection();
    List<org.ovirt.engine.core.common.businessentities.network.Network> clusterNetworks = getClusterNetworks();
    Map<String, String> networkIds = new HashMap<String, String>();
    for (org.ovirt.engine.core.common.businessentities.network.Network nwk : clusterNetworks) {
        networkIds.put(nwk.getName(), nwk.getId().toString());
    }
    for (VdsNetworkInterface iface : ifaces) {
        HostNIC hostNic = populate(map(iface, ifaces), iface);
        if (networkIds.containsKey(iface.getNetworkName())) {
            hostNic.getNetwork().setId(networkIds.get(iface.getNetworkName()));
            hostNic.getNetwork().setName(null);
        }
        ret.getHostNics().add(addLinks(hostNic));
    }
    return addActions(ret);
}
#end_block

#method_before
@SuppressWarnings("serial")
@Override
public Response add(final HostNIC nic) {
    validateParameters(nic, "name", "network.id|name", "bonding.slaves.id|name");
    validateEnums(HostNIC.class, nic);
    return performCreation(VdcActionType.AddBond, new AddBondParameters(asGuid(hostId), nic.getName(), lookupNetwork(nic.getNetwork()), lookupSlaves(nic)) {

        {
            setBondingOptions(map(nic, null).getBondOptions());
        }
    }, new HostNicResolver(nic.getName()));
}
#method_after
@SuppressWarnings("serial")
@Override
public Response add(final HostNIC nic) {
    validateParameters(nic, "name", "network.id|name", "bonding.slaves.id|name");
    validateEnums(HostNIC.class, nic);
    return performCreate(VdcActionType.AddBond, new AddBondParameters(asGuid(hostId), nic.getName(), lookupNetwork(nic.getNetwork()), lookupSlaves(nic)) {

        {
            setBondingOptions(map(nic, null).getBondOptions());
        }
    }, new HostNicResolver(nic.getName()));
}
#end_block

#method_before
public HostNIC lookupNic(String id, boolean forcePopulate) {
    List<VdsNetworkInterface> ifaces = getCollection();
    for (VdsNetworkInterface iface : ifaces) {
        if (iface.getId().toString().equals(id)) {
            HostNIC hostNic = map(iface, ifaces);
            if (forcePopulate) {
                doPopulate(hostNic, iface);
            } else {
                populate(hostNic, iface);
            }
            for (org.ovirt.engine.core.common.businessentities.Network nwk : getClusterNetworks()) {
                if (nwk.getname().equals(iface.getNetworkName())) {
                    hostNic.getNetwork().setId(nwk.getId().toString());
                    hostNic.getNetwork().setName(null);
                    break;
                }
            }
            return addLinks(hostNic);
        }
    }
    return notFound();
}
#method_after
public HostNIC lookupNic(String id, boolean forcePopulate) {
    List<VdsNetworkInterface> ifaces = getCollection();
    for (VdsNetworkInterface iface : ifaces) {
        if (iface.getId().toString().equals(id)) {
            HostNIC hostNic = map(iface, ifaces);
            if (forcePopulate) {
                deprecatedPopulate(hostNic, iface);
                doPopulate(hostNic, iface);
            } else {
                populate(hostNic, iface);
            }
            for (org.ovirt.engine.core.common.businessentities.network.Network nwk : getClusterNetworks()) {
                if (nwk.getName().equals(iface.getNetworkName())) {
                    hostNic.getNetwork().setId(nwk.getId().toString());
                    hostNic.getNetwork().setName(null);
                    break;
                }
            }
            return addLinks(hostNic);
        }
    }
    return notFound();
}
#end_block

#method_before
protected List<VdsNetworkInterface> getCollection() {
    return getBackendCollection(VdcQueryType.GetVdsInterfacesByVdsId, new GetVdsByVdsIdParameters(asGuid(hostId)));
}
#method_after
protected List<VdsNetworkInterface> getCollection() {
    return getBackendCollection(VdcQueryType.GetVdsInterfacesByVdsId, new IdQueryParameters(asGuid(hostId)));
}
#end_block

#method_before
@Override
protected VdsNetworkInterface map(HostNIC entity, VdsNetworkInterface template) {
    VdsNetworkInterface iface = super.map(entity, template);
    if (entity.isSetNetwork()) {
        org.ovirt.engine.core.common.businessentities.Network net = lookupNetwork(entity.getNetwork());
        iface.setNetworkName(net.getname());
    }
    return iface;
}
#method_after
@Override
protected VdsNetworkInterface map(HostNIC entity, VdsNetworkInterface template) {
    VdsNetworkInterface iface = super.map(entity, template);
    if (entity.isSetNetwork()) {
        org.ovirt.engine.core.common.businessentities.network.Network net = lookupNetwork(entity.getNetwork());
        iface.setNetworkName(net.getName());
    }
    return iface;
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.Network lookupNetwork(Network network) {
    String id = network.getId();
    String name = network.getName();
    for (org.ovirt.engine.core.common.businessentities.Network entity : getBackendCollection(org.ovirt.engine.core.common.businessentities.Network.class, VdcQueryType.GetAllNetworks, new GetAllNetworkQueryParamenters(Guid.Empty))) {
        if ((id != null && id.equals(entity.getId().toString())) || (name != null && name.equals(entity.getname()))) {
            return entity;
        }
    }
    return handleError(new EntityNotFoundException(id != null ? id : name), false);
}
#method_after
protected org.ovirt.engine.core.common.businessentities.network.Network lookupNetwork(Network network) {
    String id = network.getId();
    String name = network.getName();
    for (org.ovirt.engine.core.common.businessentities.network.Network entity : getBackendCollection(org.ovirt.engine.core.common.businessentities.network.Network.class, VdcQueryType.GetAllNetworks, new IdQueryParameters(Guid.Empty))) {
        if ((id != null && id.equals(entity.getId().toString())) || (name != null && name.equals(entity.getName()))) {
            return entity;
        }
    }
    return handleError(new EntityNotFoundException(id != null ? id : name), false);
}
#end_block

#method_before
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<org.ovirt.engine.core.common.businessentities.Network> getClusterNetworks() {
    VDS vds = getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(Guid.createGuidFromString(getHostId())), "Host");
    return getEntity(List.class, VdcQueryType.GetAllNetworksByClusterId, new VdsGroupQueryParamenters(vds.getvds_group_id()), "Networks");
}
#method_after
@SuppressWarnings("unchecked")
protected List<org.ovirt.engine.core.common.businessentities.network.Network> getClusterNetworks() {
    VDS vds = getEntity(VDS.class, VdcQueryType.GetVdsByVdsId, new GetVdsByVdsIdParameters(Guid.createGuidFromString(getHostId())), "Host");
    return getEntity(List.class, VdcQueryType.GetAllNetworksByClusterId, new IdQueryParameters(vds.getvds_group_id()), "Networks");
}
#end_block

#method_before
public org.ovirt.engine.core.common.businessentities.Network lookupClusterNetwork(Network net) {
    List<org.ovirt.engine.core.common.businessentities.Network> networks = getClusterNetworks();
    if (net.isSetId()) {
        for (org.ovirt.engine.core.common.businessentities.Network nwk : networks) {
            if (nwk.getId().toString().equals(net.getId()))
                return nwk;
        }
    } else {
        String networkName = net.getName();
        for (org.ovirt.engine.core.common.businessentities.Network nwk : networks) {
            if (nwk.getname().equals(networkName))
                return nwk;
        }
    }
    return notFound(org.ovirt.engine.core.common.businessentities.Network.class);
}
#method_after
public org.ovirt.engine.core.common.businessentities.network.Network lookupClusterNetwork(Network net) {
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getClusterNetworks();
    if (net.isSetId()) {
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : networks) {
            if (nwk.getId().toString().equals(net.getId()))
                return nwk;
        }
    } else {
        String networkName = net.getName();
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : networks) {
            if (nwk.getName().equals(networkName))
                return nwk;
        }
    }
    return notFound(org.ovirt.engine.core.common.businessentities.network.Network.class);
}
#end_block

#method_before
private List<String> nicsToNetworksToSync(List<HostNIC> hostNics) {
    List<String> networks = new ArrayList<String>();
    for (HostNIC nic : hostNics) {
        if (nic.isSetOverrideConfiguration() && nic.isOverrideConfiguration() && nic.isSetNetwork()) {
            org.ovirt.engine.core.common.businessentities.Network net = lookupNetwork(nic.getNetwork());
            networks.add(net.getname());
        }
    }
    return networks;
}
#method_after
private List<String> nicsToNetworksToSync(List<HostNIC> hostNics) {
    List<String> networks = new ArrayList<String>();
    for (HostNIC nic : hostNics) {
        if (nic.isSetOverrideConfiguration() && nic.isOverrideConfiguration() && nic.isSetNetwork()) {
            org.ovirt.engine.core.common.businessentities.network.Network net = lookupNetwork(nic.getNetwork());
            networks.add(net.getName());
        }
    }
    return networks;
}
#end_block

#method_before
protected boolean isPopulate() {
    List<String> populates = httpHeaders.getRequestHeader(POPULATE);
    if (populates != null && populates.size() > 0) {
        return Boolean.valueOf(populates.get(0));
    } else {
        return false;
    }
}
#method_after
protected boolean isPopulate() {
    List<String> populates = httpHeaders.getRequestHeader(POPULATE);
    if (populates != null && populates.size() > 0) {
        return Boolean.valueOf(populates.get(0)).booleanValue();
    } else {
        return false;
    }
}
#end_block

#method_before
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    return performCreation(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#method_after
protected Response doAdd(Snapshot snapshot, boolean block) {
    validateParameters(snapshot, "description");
    CreateAllSnapshotsFromVmParameters snapshotParams = new CreateAllSnapshotsFromVmParameters(parentId, snapshot.getDescription());
    return performCreate(VdcActionType.CreateAllSnapshotsFromVm, snapshotParams, new SnapshotIdResolver(), block);
}
#end_block

#method_before
@Override
public org.ovirt.engine.core.common.businessentities.Snapshot lookupEntity(Guid id) {
    return getSnapshotById(id);
}
#method_after
@Override
public org.ovirt.engine.core.common.businessentities.Snapshot lookupEntity(Guid id) throws BackendFailureException {
    return getSnapshotById(id);
}
#end_block

#method_before
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getActionParameters(network, entity);
    return performCreation(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#method_after
@Override
public Response add(Network network) {
    validateParameters(network, getRequiredAddFields());
    validateEnums(Network.class, network);
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    AddNetworkStoragePoolParameters params = getActionParameters(network, entity);
    return performCreate(addAction, params, new DataCenterNetworkIdResolver(network.getName(), params.getStoragePoolId().toString()));
}
#end_block

#method_before
@Override
public Networks list() {
    Networks networks = mapCollection(getBackendCollection(queryType, getQueryParameters()));
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#method_after
@Override
public Networks list() {
    Networks networks;
    if (isFiltered()) {
        networks = mapCollection(getBackendCollection(queryType, getQueryParameters()));
    } else {
        networks = mapCollection(getBackendCollection(SearchType.Network));
    }
    for (Network network : networks.getNetworks()) {
        network.setDisplay(null);
    }
    return networks;
}
#end_block

#method_before
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new GetAllNetworkQueryParamenters(Guid.Empty);
}
#method_after
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new IdQueryParameters(Guid.Empty);
}
#end_block

#method_before
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.Network entity) {
    if (namedDataCenter(network)) {
        entity.setstorage_pool_id(getDataCenterId(network));
    }
    return new AddNetworkStoragePoolParameters(entity.getstorage_pool_id().getValue(), entity);
}
#method_after
@Override
protected AddNetworkStoragePoolParameters getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    if (namedDataCenter(network)) {
        entity.setDataCenterId(getDataCenterId(network));
    }
    return new AddNetworkStoragePoolParameters(entity.getDataCenterId().getValue(), entity);
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
protected Group doPopulate(Group model, ad_groups entity) {
    return model;
}
#method_after
@Override
protected Group doPopulate(Group model, LdapGroup entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    validateEnumParameters(volume);
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreation(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#method_after
@Override
public Response add(GlusterVolume volume) {
    validateParameters(volume, "name", "volumeType", "bricks");
    validateEnumParameters(volume);
    GlusterVolumeEntity volumeEntity = getMapper(GlusterVolume.class, GlusterVolumeEntity.class).map(volume, null);
    volumeEntity.setClusterId(asGuid(parent.get().getId()));
    mapBricks(volume, volumeEntity);
    return performCreate(VdcActionType.CreateGlusterVolume, new CreateGlusterVolumeParameters(volumeEntity), new QueryIdResolver<Guid>(VdcQueryType.GetGlusterVolumeById, IdQueryParameters.class), true);
}
#end_block

#method_before
private Collection<DetailedLink> getLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#method_after
private Collection<DetailedLink> getLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("datacenters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks", LinkFlags.SEARCHABLE));
    links.add(createLink("roles"));
    links.add(createLink("storagedomains", LinkFlags.SEARCHABLE));
    links.add(createLink("tags"));
    links.add(createLink("templates", LinkFlags.SEARCHABLE));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    links.add(createLink("vmpools", LinkFlags.SEARCHABLE));
    links.add(createLink("vms", LinkFlags.SEARCHABLE));
    links.add(createLink("disks", LinkFlags.SEARCHABLE));
    return links;
}
#end_block

#method_before
private Collection<DetailedLink> getGlusterLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks"));
    links.add(createLink("roles"));
    links.add(createLink("tags"));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    return links;
}
#method_after
private Collection<DetailedLink> getGlusterLinks() {
    Collection<DetailedLink> links = new LinkedList<DetailedLink>();
    links.add(createLink("capabilities"));
    links.add(createLink("clusters", LinkFlags.SEARCHABLE));
    links.add(createLink("events", LinkFlags.SEARCHABLE, getEventParams()));
    links.add(createLink("hosts", LinkFlags.SEARCHABLE));
    links.add(createLink("networks", LinkFlags.SEARCHABLE));
    links.add(createLink("roles"));
    links.add(createLink("tags"));
    links.add(createLink("users", LinkFlags.SEARCHABLE));
    links.add(createLink("groups", LinkFlags.SEARCHABLE));
    links.add(createLink("domains"));
    return links;
}
#end_block

#method_before
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name", "dataCenter.name|id");
    validateEnums(Cluster.class, cluster);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreation(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#method_after
@Override
public Response add(Cluster cluster) {
    validateParameters(cluster, "name", "dataCenter.name|id");
    validateEnums(Cluster.class, cluster);
    storage_pool pool = getStoragePool(cluster, this);
    VDSGroup entity = map(cluster, map(pool));
    return performCreate(VdcActionType.AddVdsGroup, new VdsGroupOperationParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class));
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new QueryIdResolver(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, GetVmByVmIdParameters.class);
    VmStatisticalQuery query = new VmStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<VM, org.ovirt.engine.core.common.businessentities.VM>(entityType, guid, query));
}
#end_block

#method_before
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#method_after
@Override
protected Guid getStorageDomainId(Action action) {
    if (action.getStorageDomain().isSetId()) {
        return asGuid(action.getStorageDomain().getId());
    } else {
        return lookupStorageDomainIdByName(action.getStorageDomain().getName());
    }
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#method_after
@Override
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(storage_domains.class, SearchType.StorageDomain, "Storage: name=" + name).getId();
}
#end_block

#method_before
@Override
public Response ticket(Action action) {
    return doAction(VdcActionType.SetVmTicket, new SetVmTicketParameters(guid, getTicketValue(action), getTicketExpiry(action)), action);
}
#method_after
@Override
public Response ticket(Action action) {
    final Response response = doAction(VdcActionType.SetVmTicket, new SetVmTicketParameters(guid, getTicketValue(action), getTicketExpiry(action)), action);
    final Action actionResponse = (Action) response.getEntity();
    if (CreationStatus.FAILED.value().equals(actionResponse.getStatus().getState())) {
        actionResponse.getTicket().setValue(null);
        actionResponse.getTicket().setExpiry(null);
    }
    return response;
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    Set<Detail> details = DetailHelper.getDetails(getHttpHeaders());
    parent.addInlineDetails(details, model);
    addStatistics(model, entity, uriInfo, httpHeaders);
    parent.setPayload(model);
    setBallooning(model);
    setCertificateInfo(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    return model;
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(incoming.getUsb(), lookupCluster(updated.getvds_group_id()));
    if (usbPolicy != null) {
        updated.setusb_policy(usbPolicy);
    }
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        params.setVmPayload(parent.getPayload(incoming));
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VM incoming, org.ovirt.engine.core.common.businessentities.VM entity) {
    VmStatic updated = getMapper(modelType, VmStatic.class).map(incoming, entity.getStaticData());
    updated.setusb_policy(VmMapper.getUsbPolicyOnUpdate(incoming.getUsb(), entity.getUsbPolicy(), lookupCluster(updated.getvds_group_id())));
    VmManagementParametersBase params = new VmManagementParametersBase(updated);
    if (incoming.isSetPayloads()) {
        if (incoming.isSetPayloads() && incoming.getPayloads().isSetPayload()) {
            params.setVmPayload(parent.getPayload(incoming));
        } else {
            params.setClearPayload(true);
        }
    }
    if (incoming.isSetMemoryPolicy() && incoming.getMemoryPolicy().isSetBallooning()) {
        params.setBalloonEnabled(incoming.getMemoryPolicy().isBallooning());
    }
    return params;
}
#end_block

#method_before
@Override
public Response add(Network network) {
    // right now, name is mandatory (future - id alone will be enough)
    validateParameters(network, "name");
    if (!network.isSetId()) {
        network.setId(getNetworkId(network.getName(), clusterId));
    }
    org.ovirt.engine.core.common.businessentities.Network entity = map(network);
    return performCreation(addAction, getActionParameters(network, entity), new NetworkIdResolver(network.getName()));
}
#method_after
@Override
public Response add(Network network) {
    // right now, name is mandatory (future - id alone will be enough)
    validateParameters(network, "name");
    if (!network.isSetId()) {
        network.setId(getNetworkId(network.getName(), clusterId));
    }
    org.ovirt.engine.core.common.businessentities.network.Network entity = map(network);
    return performCreate(addAction, getActionParameters(network, entity), new NetworkIdResolver(network.getName()));
}
#end_block

#method_before
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new VdsGroupQueryParamenters(asGuid(clusterId));
}
#method_after
@Override
protected VdcQueryParametersBase getQueryParameters() {
    return new IdQueryParameters(asGuid(clusterId));
}
#end_block

#method_before
@Override
protected VdcActionParametersBase getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.Network entity) {
    return new AttachNetworkToVdsGroupParameter(getVDSGroup(), entity);
}
#method_after
@Override
protected VdcActionParametersBase getActionParameters(Network network, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return new AttachNetworkToVdsGroupParameter(getVDSGroup(), entity);
}
#end_block

#method_before
private String getNetworkId(String networkName, String clusterId) {
    NGuid dataCenterId = getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupById, new GetVdsGroupByIdParameters(asGuid(clusterId)), null).getStoragePoolId();
    GetAllNetworkQueryParamenters params = new GetAllNetworkQueryParamenters(asGuid(dataCenterId));
    List<org.ovirt.engine.core.common.businessentities.Network> networks = getBackendCollection(VdcQueryType.GetAllNetworks, params);
    for (org.ovirt.engine.core.common.businessentities.Network nw : networks) {
        if (nw.getname().equals(networkName)) {
            return nw.getId().toString();
        }
    }
    return null;
}
#method_after
private String getNetworkId(String networkName, String clusterId) {
    NGuid dataCenterId = getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupById, new GetVdsGroupByIdParameters(asGuid(clusterId)), null).getStoragePoolId();
    IdQueryParameters params = new IdQueryParameters(asGuid(dataCenterId));
    List<org.ovirt.engine.core.common.businessentities.network.Network> networks = getBackendCollection(VdcQueryType.GetAllNetworks, params);
    for (org.ovirt.engine.core.common.businessentities.network.Network nw : networks) {
        if (nw.getName().equals(networkName)) {
            return nw.getId().toString();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.Network entity) {
    return model;
}
#method_after
@Override
protected Network doPopulate(Network model, org.ovirt.engine.core.common.businessentities.network.Network entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(Quota quota) {
    validateParameters(quota, "name");
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreation(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver(VdcQueryType.GetQuotaByQuotaId, GetQuotaByQuotaIdQueryParameters.class));
}
#method_after
@Override
public Response add(Quota quota) {
    validateParameters(quota, "name");
    org.ovirt.engine.core.common.businessentities.Quota entity = map(quota);
    entity.setStoragePoolId(dataCenterId);
    return performCreate(VdcActionType.AddQuota, new QuotaCRUDParameters(entity), new QueryIdResolver<Guid>(VdcQueryType.GetQuotaByQuotaId, GetQuotaByQuotaIdQueryParameters.class));
}
#end_block

#method_before
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#method_after
@Override
public DataCenter update(DataCenter incoming) {
    validateEnums(DataCenter.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class), VdcActionType.UpdateStoragePool, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    Network network = findNetwork(model);
    model.getNetwork().setId(network.getId().toString());
    model.getNetwork().setName(null);
    return model;
}
#method_after
@Override
protected NIC doPopulate(NIC model, VmNetworkInterface entity) {
    return model;
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    UsbPolicy usbPolicy = UsbResourceUtils.getUsbPolicy(template.getUsb(), lookupCluster(staticVm.getvds_group_id()));
    if (usbPolicy != null) {
        staticVm.setusb_policy(usbPolicy);
    }
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreation(VdcActionType.AddVmTemplate, params, new QueryIdResolver(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(template));
    if (namedCluster(template)) {
        staticVm.setvds_group_id(getClusterId(template));
    }
    staticVm.setusb_policy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), lookupCluster(staticVm.getvds_group_id())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
protected List<AdUser> getUsersFromDomain() {
    return asCollection(AdUser.class, getEntity(ArrayList.class, SearchType.AdUser, getSearchPattern("*", getCurrentDomain())));
}
#method_after
protected List<LdapUser> getUsersFromDomain() {
    return asCollection(LdapUser.class, getEntity(ArrayList.class, SearchType.AdUser, getSearchPattern("*", getCurrentDomain())));
}
#end_block

#method_before
protected Users mapDomainUserCollection(List<AdUser> entities) {
    Users collection = new Users();
    for (AdUser entity : entities) {
        collection.getUsers().add(addLinks(modifyDomain(mapAdUser(entity)), true));
    }
    return collection;
}
#method_after
protected Users mapDomainUserCollection(List<LdapUser> entities) {
    Users collection = new Users();
    for (LdapUser entity : entities) {
        collection.getUsers().add(addLinks(modifyDomain(mapAdUser(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected VdcUser map(AdUser adUser) {
    return getMapper(AdUser.class, VdcUser.class).map(adUser, null);
}
#method_after
protected VdcUser map(LdapUser adUser) {
    return getMapper(LdapUser.class, VdcUser.class).map(adUser, null);
}
#end_block

#method_before
protected User mapAdUser(AdUser adUser) {
    return getMapper(AdUser.class, User.class).map(adUser, null);
}
#method_after
protected User mapAdUser(LdapUser adUser) {
    return getMapper(LdapUser.class, User.class).map(adUser, null);
}
#end_block

#method_before
@Override
public DbUser lookupEntity(Guid nullId) {
    return lookupUserById(id);
}
#method_after
@Override
public DbUser lookupEntity(Guid id) throws BackendFailureException {
    return lookupUserById(this.id);
}
#end_block

#method_before
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    storage_pool entity = map(dataCenter);
    return performCreation(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class));
}
#method_after
@Override
public Response add(DataCenter dataCenter) {
    validateParameters(dataCenter, "name", "storageType");
    validateEnums(DataCenter.class, dataCenter);
    validateEnum(StorageType.class, dataCenter.getStorageType().toUpperCase());
    storage_pool entity = map(dataCenter);
    return performCreate(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(entity), new QueryIdResolver<Guid>(VdcQueryType.GetStoragePoolById, StoragePoolQueryParametersBase.class));
}
#end_block

#method_before
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    GetAvailableStoragePoolVersionsParameters parameters = new GetAvailableStoragePoolVersionsParameters();
    parameters.setStoragePoolId(new Guid(model.getId()));
    model.setSupportedVersions(getMapper(List.class, SupportedVersions.class).map(getEntity(ArrayList.class, VdcQueryType.GetAvailableStoragePoolVersions, parameters, model.getId()), null));
    return model;
}
#method_after
@Override
protected DataCenter doPopulate(DataCenter model, storage_pool entity) {
    return model;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver resolver = new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
protected final R populate(R model, Q entity) {
    return (isPopulate() ? doPopulate(model, entity) : model);
}
#method_after
protected final R populate(R model, Q entity) {
    model = deprecatedPopulate(model, entity);
    return (isPopulate() ? doPopulate(model, entity) : model);
}
#end_block

#method_before
protected VdcQueryParametersBase getQueryParams(Class<? extends VdcQueryParametersBase> queryParamsClass, Guid id) {
    VdcQueryParametersBase params = null;
    try {
        params = queryParamsClass.getConstructor(Guid.class).newInstance(id);
    } catch (Exception e) {
    // trivial class construction
    }
    return params;
}
#method_after
protected <T> VdcQueryParametersBase getQueryParams(Class<? extends VdcQueryParametersBase> queryParamsClass, T id) {
    VdcQueryParametersBase params = null;
    try {
        params = queryParamsClass.getConstructor(id.getClass()).newInstance(id);
    } catch (Exception e) {
    // trivial class construction
    }
    return params;
}
#end_block

#method_before
public Q resolve(Guid id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#method_after
@Override
public Q resolve(T id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#end_block

#method_before
public Object resolve(Guid id) throws BackendFailureException {
    Object entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#method_after
public Q resolve(T id) throws BackendFailureException {
    Q entity = lookupEntity(id);
    if (entity == null) {
        throw new EntityNotFoundException(id.toString());
    }
    return entity;
}
#end_block

#method_before
public Q lookupEntity(Guid id) throws BackendFailureException {
    return doGetEntity(entityType, query, getQueryParams(queryParamsClass, id), id.toString());
}
#method_after
@Override
public Q lookupEntity(T id) throws BackendFailureException {
    return doGetEntity(entityType, query, getQueryParams(queryParamsClass, id), id.toString());
}
#end_block

#method_before
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    int stripeCount = bricks.isSetStripeCount() ? bricks.getStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(GlusterBricks bricks) {
    for (GlusterBrick brick : bricks.getGlusterBricks()) {
        validateParameters(brick, "serverId", "brickDir");
    }
    List<GlusterBrickEntity> brickEntities = mapBricks(asGuid(getVolumeId()), bricks);
    int replicaCount = bricks.isSetReplicaCount() ? bricks.getReplicaCount() : 0;
    int stripeCount = bricks.isSetStripeCount() ? bricks.getStripeCount() : 0;
    return performCreationMultiple(VdcActionType.AddBricksToGlusterVolume, new GlusterVolumeBricksActionParameters(asGuid(getVolumeId()), brickEntities, replicaCount, stripeCount), new QueryIdResolver<Guid>(VdcQueryType.GetGlusterBrickById, IdQueryParameters.class));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected GlusterBricks resolveCreatedList(VdcReturnValueBase result, EntityIdResolver entityResolver) {
    try {
        GlusterBricks bricks = new GlusterBricks();
        for (Guid id : (List<Guid>) result.getActionReturnValue()) {
            GlusterBrickEntity created = entityResolver.resolve(id);
            bricks.getGlusterBricks().add(addLinks(doPopulate(map(created), created)));
        }
        return bricks;
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
protected GlusterBricks resolveCreatedList(VdcReturnValueBase result, EntityIdResolver<Guid> entityResolver) {
    try {
        GlusterBricks bricks = new GlusterBricks();
        for (Guid id : (List<Guid>) result.getActionReturnValue()) {
            GlusterBrickEntity created = entityResolver.resolve(id);
            bricks.getGlusterBricks().add(addLinks(doPopulate(map(created), created)));
        }
        return bricks;
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#end_block

#method_before
protected Response performCreationMultiple(VdcActionType task, VdcActionParametersBase taskParams, EntityIdResolver entityResolver) {
    VdcReturnValueBase createResult;
    try {
        createResult = doAction(task, taskParams);
    } catch (Exception e) {
        return handleError(e, false);
    }
    GlusterBricks model = resolveCreatedList(createResult, entityResolver);
    Response response = null;
    if (model == null) {
        response = Response.status(ACCEPTED_STATUS).build();
    } else {
        response = Response.created(URI.create(getUriInfo().getPath())).entity(model).build();
    }
    return response;
}
#method_after
protected Response performCreationMultiple(VdcActionType task, VdcActionParametersBase taskParams, EntityIdResolver<Guid> entityResolver) {
    VdcReturnValueBase createResult;
    try {
        createResult = doAction(task, taskParams);
    } catch (Exception e) {
        return handleError(e, false);
    }
    GlusterBricks model = resolveCreatedList(createResult, entityResolver);
    Response response = null;
    if (model == null) {
        response = Response.status(ACCEPTED_STATUS).build();
    } else {
        response = Response.created(URI.create(getUriInfo().getPath())).entity(model).build();
    }
    return response;
}
#end_block

#method_before
protected R resolveCreated(VdcReturnValueBase result, EntityIdResolver entityResolver, Class<? extends BaseResource> suggestedParentType) {
    try {
        Q created = entityResolver.resolve((Guid) result.getActionReturnValue());
        return addLinks(doPopulate(map(created), created), suggestedParentType);
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#method_after
@SuppressWarnings("unchecked")
protected <T> Q resolveCreated(VdcReturnValueBase result, IResolver<T, Q> entityResolver) {
    try {
        return entityResolver.resolve((T) result.getActionReturnValue());
    } catch (Exception e) {
        // we tolerate a failure in the entity resolution
        // as the substantive action (entity creation) has
        // already succeeded
        e.printStackTrace();
        return null;
    }
}
#end_block

#method_before
@Override
public Cluster update(Cluster incoming) {
    validateEnums(Cluster.class, incoming);
    return performUpdate(incoming, new QueryIdResolver(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class), VdcActionType.UpdateVdsGroup, new UpdateParametersProvider());
}
#method_after
@Override
public Cluster update(Cluster incoming) {
    validateEnums(Cluster.class, incoming);
    return performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVdsGroupById, GetVdsGroupByIdParameters.class), VdcActionType.UpdateVdsGroup, new UpdateParametersProvider());
}
#end_block

#method_before
protected boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, Guid id) {
    return id != null && id.equals(entity.getId());
}
#method_after
protected <T> boolean matchEntity(org.ovirt.engine.core.common.businessentities.Disk entity, T id) {
    return id != null && id.equals(entity.getId());
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<HostNIC, VdsNetworkInterface>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<HostNIC, VdsNetworkInterface>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return parent.addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected HostNIC doPopulate(HostNIC model, VdsNetworkInterface entity) {
    return parent.doPopulate(model, entity);
}
#end_block

#method_before
@SuppressWarnings("serial")
@Override
public HostNIC update(HostNIC nic) {
    validateEnums(HostNIC.class, nic);
    VdsNetworkInterface originalInter = parent.lookupInterface(id);
    final VdsNetworkInterface inter = map(nic, originalInter);
    org.ovirt.engine.core.common.businessentities.Network oldNetwork = getOldNetwork(originalInter);
    org.ovirt.engine.core.common.businessentities.Network newNetwork = getNewNetwork(nic);
    UpdateNetworkToVdsParameters params = new UpdateNetworkToVdsParameters(Guid.createGuidFromString(parent.getHostId()), newNetwork != null ? newNetwork : oldNetwork, new ArrayList<VdsNetworkInterface>() {

        {
            add(inter);
        }
    });
    params.setOldNetworkName(oldNetwork != null ? oldNetwork.getname() : null);
    if (nic.isSetName() && inter.getBonded() != null && inter.getBonded()) {
        params.setBondName(nic.getName());
    }
    if (nic.isSetIp()) {
        if (nic.getIp().isSetAddress()) {
            params.setAddress(nic.getIp().getAddress());
        }
        if (nic.getIp().isSetNetmask()) {
            params.setSubnet(nic.getIp().getNetmask());
        }
        if (nic.getIp().isSetGateway()) {
            params.setGateway(nic.getIp().getGateway());
        }
    }
    if (nic.isSetBootProtocol()) {
        BootProtocol bootProtocol = BootProtocol.fromValue(nic.getBootProtocol());
        if (bootProtocol != null) {
            params.setBootProtocol(map(bootProtocol, null));
        }
    } else if (nic.isSetIp() && nic.getIp().isSetAddress() && !nic.getIp().getAddress().isEmpty()) {
        params.setBootProtocol(NetworkBootProtocol.StaticIp);
    }
    if (nic.isSetBonding() && nic.getBonding().isSetOptions()) {
        params.setBondingOptions(getBondingOptions(nic.getBonding().getOptions().getOptions()));
    }
    if (nic.isSetCheckConnectivity()) {
        params.setCheckConnectivity(nic.isCheckConnectivity());
    }
    performAction(VdcActionType.UpdateNetworkToVdsInterface, params);
    return parent.lookupNic(id, true);
}
#method_after
@SuppressWarnings("serial")
@Override
public HostNIC update(HostNIC nic) {
    validateEnums(HostNIC.class, nic);
    VdsNetworkInterface originalInter = parent.lookupInterface(id);
    final VdsNetworkInterface inter = map(nic, originalInter);
    org.ovirt.engine.core.common.businessentities.network.Network oldNetwork = getOldNetwork(originalInter);
    org.ovirt.engine.core.common.businessentities.network.Network newNetwork = getNewNetwork(nic);
    UpdateNetworkToVdsParameters params = new UpdateNetworkToVdsParameters(Guid.createGuidFromString(parent.getHostId()), newNetwork != null ? newNetwork : oldNetwork, new ArrayList<VdsNetworkInterface>() {

        {
            add(inter);
        }
    });
    params.setOldNetworkName(oldNetwork != null ? oldNetwork.getName() : null);
    if (nic.isSetName() && inter.getBonded() != null && inter.getBonded()) {
        params.setBondName(nic.getName());
    }
    if (nic.isSetIp()) {
        if (nic.getIp().isSetAddress()) {
            params.setAddress(nic.getIp().getAddress());
        }
        if (nic.getIp().isSetNetmask()) {
            params.setSubnet(nic.getIp().getNetmask());
        }
        if (nic.getIp().isSetGateway()) {
            params.setGateway(nic.getIp().getGateway());
        }
    }
    if (nic.isSetBootProtocol()) {
        BootProtocol bootProtocol = BootProtocol.fromValue(nic.getBootProtocol());
        if (bootProtocol != null) {
            params.setBootProtocol(map(bootProtocol, null));
        }
    } else if (nic.isSetIp() && nic.getIp().isSetAddress() && !nic.getIp().getAddress().isEmpty()) {
        params.setBootProtocol(NetworkBootProtocol.STATIC_IP);
    }
    if (nic.isSetBonding() && nic.getBonding().isSetOptions()) {
        params.setBondingOptions(getBondingOptions(nic.getBonding().getOptions().getOptions()));
    }
    if (nic.isSetCheckConnectivity()) {
        params.setCheckConnectivity(nic.isCheckConnectivity());
    }
    performAction(VdcActionType.UpdateNetworkToVdsInterface, params);
    return parent.lookupNic(id, true);
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network getNewNetwork(HostNIC nic) {
    org.ovirt.engine.core.common.businessentities.Network newNetwork = null;
    if (nic.isSetNetwork()) {
        newNetwork = map(nic.getNetwork(), parent.lookupClusterNetwork(nic.getNetwork()));
    }
    return newNetwork;
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network getNewNetwork(HostNIC nic) {
    org.ovirt.engine.core.common.businessentities.network.Network newNetwork = null;
    if (nic.isSetNetwork()) {
        newNetwork = map(nic.getNetwork(), parent.lookupClusterNetwork(nic.getNetwork()));
    }
    return newNetwork;
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network getOldNetwork(VdsNetworkInterface originalInter) {
    String oldNetworkName = originalInter.getNetworkName();
    if (!StringHelper.isNullOrEmpty(oldNetworkName)) {
        return lookupAtachedNetwork(originalInter.getNetworkName());
    } else {
        GetAllChildVlanInterfacesQueryParameters params = new GetAllChildVlanInterfacesQueryParameters(asGuid(originalInter.getVdsId()), originalInter);
        List<VdsNetworkInterface> vlans = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetAllChildVlanInterfaces, params);
        if (vlans != null && !vlans.isEmpty()) {
            return lookupAtachedNetwork(vlans.get(0).getNetworkName());
        } else {
            return null;
        }
    }
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network getOldNetwork(VdsNetworkInterface originalInter) {
    String oldNetworkName = originalInter.getNetworkName();
    if (!StringHelper.isNullOrEmpty(oldNetworkName)) {
        return lookupAtachedNetwork(originalInter.getNetworkName());
    } else {
        InterfaceAndIdQueryParameters params = new InterfaceAndIdQueryParameters(asGuid(originalInter.getVdsId()), originalInter);
        List<VdsNetworkInterface> vlans = getBackendCollection(VdsNetworkInterface.class, VdcQueryType.GetAllChildVlanInterfaces, params);
        if (vlans != null && !vlans.isEmpty()) {
            return lookupAtachedNetwork(vlans.get(0).getNetworkName());
        } else {
            return null;
        }
    }
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network lookupAtachedNetwork(String networkName) {
    if (!StringHelper.isNullOrEmpty(networkName)) {
        for (org.ovirt.engine.core.common.businessentities.Network nwk : parent.getClusterNetworks()) {
            if (nwk.getname().equals(networkName))
                return nwk;
        }
    }
    return null;
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network lookupAtachedNetwork(String networkName) {
    if (!StringHelper.isNullOrEmpty(networkName)) {
        for (org.ovirt.engine.core.common.businessentities.network.Network nwk : parent.getClusterNetworks()) {
            if (nwk.getName().equals(networkName))
                return nwk;
        }
    }
    return null;
}
#end_block

#method_before
private org.ovirt.engine.core.common.businessentities.Network map(Network network, org.ovirt.engine.core.common.businessentities.Network template) {
    return getMapper(Network.class, org.ovirt.engine.core.common.businessentities.Network.class).map(network, template);
}
#method_after
private org.ovirt.engine.core.common.businessentities.network.Network map(Network network, org.ovirt.engine.core.common.businessentities.network.Network template) {
    return getMapper(Network.class, org.ovirt.engine.core.common.businessentities.network.Network.class).map(network, template);
}
#end_block

#method_before
@Override
protected boolean matchEntity(VM entity, String name) {
    return false;
}
#method_after
@Override
protected <T> boolean matchEntity(VM entity, T id) {
    return (id == null || id.equals(CDROM_ID)) && parentId.equals(entity.getQueryableId());
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver resolver = new EntityIdResolver() {

        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public org.ovirt.engine.core.common.businessentities.Disk lookupEntity(Guid guid) throws BackendFailureException {
            return collection.lookupEntity(guid);
        }
    };
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return ((BackendVmDisksResource) collection).addStatistics(model, entity, uriInfo, httpHeaders);
}
#method_after
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    return ((BackendVmDisksResource) collection).doPopulate(model, entity);
}
#end_block

#method_before
@Override
public Groups list() {
    if (isFiltered()) {
        return mapDbGroupsCollection(getBackendCollection(DbUser.class, VdcQueryType.GetDbUserByUserId, new GetDbUserByUserIdParameters(getCurrent().get(VdcUser.class).getUserId())));
    } else {
        return mapDbGroupsCollection(getGroupsCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#method_after
@Override
public Groups list() {
    if (isFiltered()) {
        return mapDbGroupsCollection(getBackendCollection(DbUser.class, VdcQueryType.GetAllDbUsers, new VdcQueryParametersBase()));
    } else {
        return mapDbGroupsCollection(getGroupsCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#end_block

#method_before
@Override
public List<AuditLog> getAll() {
    return recoreds;
}
#method_after
@Override
public List<AuditLog> getAll(Guid userID, boolean isFiltered) {
    return recoreds;
}
#end_block

#method_before
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#method_after
@Override
public Events list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllEventMessages, new GetEventMessagesParameters()));
    } else {
        return mapCollection(getBackendCollection());
    }
}
#end_block

#method_before
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return new BackendEventResource(id, this);
}
#method_after
@Override
@SingleEntityResource
public EventResource getEventSubResource(String id) {
    return inject(new BackendEventResource(id, this));
}
#end_block

#method_before
@Override
protected Response performRemove(String id) {
    throw new UnsupportedOperationException();
}
#method_after
@Override
protected Response performRemove(String id) {
    return performAction(VdcActionType.RemoveExternalEvent, new RemoveExternalEventParameters(asLong(id)));
}
#end_block

#method_before
@Override
public List<AuditLog> getAll() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetAllFromAuditLog", auditLogRowMapper, parameterSource);
}
#method_after
@Override
public List<AuditLog> getAll(Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeReadList("GetAllFromAuditLog", auditLogRowMapper, parameterSource);
}
#end_block

#method_before
@Override
public void save(AuditLog event) {
    getCallsHandler().executeModification("InsertAuditLog", getSqlMapper(event).addValue("log_type_name", event.getlog_type_name()));
}
#method_after
@Override
public void save(AuditLog event) {
    if (event.isExternal()) {
        getCallsHandler().executeModification("InsertExternalAuditLog", getExternalEventSqlMapper(event));
    } else {
        getCallsHandler().executeModification("InsertAuditLog", getSqlMapper(event));
    }
}
#end_block

#method_before
@Override
public void update(AuditLog event) {
    getCallsHandler().executeModification("UpdateAuditLog", getSqlMapper(event));
}
#method_after
@Override
public void update(AuditLog event) {
    throw new UnsupportedOperationException();
}
#end_block

#method_before
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getaudit_log_id()).addValue("log_time", event.getlog_time()).addValue("log_type", event.getlog_type()).addValue("severity", event.getseverity()).addValue("message", event.getmessage()).addValue("user_id", event.getuser_id()).addValue("user_name", event.getuser_name()).addValue("vds_id", event.getvds_id()).addValue("vds_name", event.getvds_name()).addValue("vm_id", event.getvm_id()).addValue("vm_name", event.getvm_name()).addValue("vm_template_id", event.getvm_template_id()).addValue("vm_template_name", event.getvm_template_name()).addValue("storage_pool_id", event.getstorage_pool_id()).addValue("storage_pool_name", event.getstorage_pool_name()).addValue("storage_domain_id", event.getstorage_domain_id()).addValue("storage_domain_name", event.getstorage_domain_name()).addValue("vds_group_id", event.getvds_group_id()).addValue("vds_group_name", event.getvds_group_name()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName());
}
#method_after
private MapSqlParameterSource getSqlMapper(AuditLog event) {
    return getCustomMapSqlParameterSource().addValue("audit_log_id", event.getaudit_log_id()).addValue("log_time", event.getlog_time()).addValue("log_type", event.getlog_type()).addValue("log_type_name", event.getlog_type_name()).addValue("severity", event.getseverity()).addValue("message", event.getmessage()).addValue("user_id", event.getuser_id()).addValue("user_name", event.getuser_name()).addValue("vds_id", event.getvds_id()).addValue("vds_name", event.getvds_name()).addValue("vm_id", event.getvm_id()).addValue("vm_name", event.getvm_name()).addValue("vm_template_id", event.getvm_template_id()).addValue("vm_template_name", event.getvm_template_name()).addValue("storage_pool_id", event.getstorage_pool_id()).addValue("storage_pool_name", event.getstorage_pool_name()).addValue("storage_domain_id", event.getstorage_domain_id()).addValue("storage_domain_name", event.getstorage_domain_name()).addValue("vds_group_id", event.getvds_group_id()).addValue("vds_group_name", event.getvds_group_name()).addValue("correlation_id", event.getCorrelationId()).addValue("job_id", event.getJobId()).addValue("quota_id", event.getQuotaId()).addValue("quota_name", event.getQuotaName()).addValue("gluster_volume_id", event.getGlusterVolumeId()).addValue("gluster_volume_name", event.getGlusterVolumeName());
}
#end_block

#method_before
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setaudit_log_id(rs.getLong("audit_log_id"));
    entity.setlog_time(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setlog_type(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setseverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setmessage(rs.getString("message"));
    entity.setuser_id(NGuid.createGuidFromString(rs.getString("user_id")));
    entity.setuser_name(rs.getString("user_name"));
    entity.setvds_id(NGuid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setvm_id(NGuid.createGuidFromString(rs.getString("vm_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvm_template_id(NGuid.createGuidFromString(rs.getString("vm_template_id")));
    entity.setvm_template_name(rs.getString("vm_template_name"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setstorage_domain_id(NGuid.createGuidFromString(rs.getString("storage_domain_id")));
    entity.setstorage_domain_name(rs.getString("storage_domain_name"));
    entity.setvds_group_id(NGuid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(NGuid.createGuidFromString(rs.getString("job_id")));
    entity.setQuotaId(NGuid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(NGuid.createGuidFromString(rs.getString("gluster_volume_id")));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    return entity;
}
#method_after
@Override
public AuditLog mapRow(ResultSet rs, int rowNum) throws SQLException {
    AuditLog entity = new AuditLog();
    entity.setaudit_log_id(rs.getLong("audit_log_id"));
    entity.setlog_time(DbFacadeUtils.fromDate(rs.getTimestamp("log_time")));
    entity.setlog_type(AuditLogType.forValue(rs.getInt("log_type")));
    entity.setseverity(AuditLogSeverity.forValue(rs.getInt("severity")));
    entity.setmessage(rs.getString("message"));
    entity.setuser_id(NGuid.createGuidFromString(rs.getString("user_id")));
    entity.setuser_name(rs.getString("user_name"));
    entity.setvds_id(NGuid.createGuidFromString(rs.getString("vds_id")));
    entity.setvds_name(rs.getString("vds_name"));
    entity.setvm_id(NGuid.createGuidFromString(rs.getString("vm_id")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setvm_template_id(NGuid.createGuidFromString(rs.getString("vm_template_id")));
    entity.setvm_template_name(rs.getString("vm_template_name"));
    entity.setstorage_pool_id(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setstorage_domain_id(NGuid.createGuidFromString(rs.getString("storage_domain_id")));
    entity.setstorage_domain_name(rs.getString("storage_domain_name"));
    entity.setvds_group_id(NGuid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setCorrelationId(rs.getString("correlation_id"));
    entity.setJobId(NGuid.createGuidFromString(rs.getString("job_id")));
    entity.setQuotaId(NGuid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setGlusterVolumeId(NGuid.createGuidFromString(rs.getString("gluster_volume_id")));
    entity.setGlusterVolumeName(rs.getString("gluster_volume_name"));
    entity.setOrigin(rs.getString("origin"));
    entity.setCustomEventId(rs.getInt("custom_event_id"));
    entity.setEventFloodInSec(rs.getInt("event_flood_in_sec"));
    entity.setCustomData(rs.getString("custom_data"));
    entity.setDeleted(rs.getBoolean("deleted"));
    return entity;
}
#end_block

#method_before
@Override
public Response add(Host host) {
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#method_after
@Override
public Response add(Host host) {
    validateEnums(Host.class, host);
    validateParameters(host, "name", "address", "rootPassword");
    VdsStatic staticHost = getMapper(Host.class, VdsStatic.class).map(host, null);
    staticHost.setvds_group_id(getClusterId(host));
    AddVdsActionParameters addParams = new AddVdsActionParameters(staticHost, host.getRootPassword());
    if (host.isSetOverrideIptables()) {
        addParams.setOverrideFirewall(host.isOverrideIptables());
    }
    if (host.isSetRebootAfterInstallation()) {
        addParams.setRebootAfterInstallation(host.isRebootAfterInstallation());
    }
    return performCreation(VdcActionType.AddVds, addParams, new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, GetVdsByVdsIdParameters.class));
}
#end_block

#method_before
@Override
public Response performRemove(String id) {
    return performAction(VdcActionType.RemoveVds, new VdsActionParameters(asGuid(id)));
}
#method_after
@Override
public Response performRemove(String id) {
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(asGuid(id)));
}
#end_block

#method_before
@Override
public Users list() {
    if (isFiltered()) {
        return mapDbUserCollection(getBackendCollection(VdcQueryType.GetDbUserByUserId, new GetDbUserByUserIdParameters(getCurrent().get(VdcUser.class).getUserId())));
    } else {
        return mapDbUserCollection(getBackendCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#method_after
@Override
public Users list() {
    if (isFiltered()) {
        return mapDbUserCollection(getBackendCollection(VdcQueryType.GetAllDbUsers, new VdcQueryParametersBase()));
    } else {
        return mapDbUserCollection(getBackendCollection(SearchType.DBUser, getSearchPattern()));
    }
}
#end_block

#method_before
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameConatinsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    AdUser adUser = getEntity(AdUser.class, SearchType.AdUser, getSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setVdcUser(map(adUser));
    return performCreation(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#method_after
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameConatinsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    LdapUser adUser = getEntity(LdapUser.class, SearchType.AdUser, getSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setVdcUser(map(adUser));
    return performCreation(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#end_block

#method_before
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#method_after
@Override
public Response add(Disk disk) {
    validateDiskForCreation(disk);
    AddDiskParameters params = new AddDiskParameters();
    params.setDiskInfo(getMapper(Disk.class, org.ovirt.engine.core.common.businessentities.Disk.class).map(disk, null));
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        params.setStorageDomainId(Guid.createGuidFromString(disk.getStorageDomains().getStorageDomains().get(0).getId()));
    } else if (disk.isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetName()) {
        Guid storageDomainId = getStorageDomainId(disk.getStorageDomains().getStorageDomains().get(0).getName());
        if (storageDomainId == null) {
            notFound(StorageDomain.class);
        } else {
            params.setStorageDomainId(storageDomainId);
        }
    }
    return performCreation(VdcActionType.AddDisk, params, new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, GetDiskByDiskIdParameters.class));
}
#end_block

#method_before
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), "address", "target", "port");
        }
    } else {
        // Non lun disks require size
        validateParameters(disk, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#method_after
protected void validateDiskForCreation(Disk disk) {
    validateParameters(disk, 3, "format", "interface");
    if (DiskResourceUtils.isLunDisk(disk)) {
        // when creating a LUN disk, user must specify type.
        validateParameters(disk.getLunStorage(), 3, "type");
        StorageType storageType = StorageType.fromValue(disk.getLunStorage().getType());
        if (storageType != null && storageType == StorageType.ISCSI) {
            validateParameters(disk.getLunStorage().getLogicalUnits().get(0), 3, "address", "target", "port", "id");
        }
    } else if (disk.isSetLunStorage() && disk.getLunStorage().getLogicalUnits().isEmpty()) {
        // TODO: Implement nested entity existence validation infra for validateParameters()
        throw new WebFaultException(null, localize(Messages.INCOMPLETE_PARAMS_REASON), localize(Messages.INCOMPLETE_PARAMS_DETAIL_TEMPLATE, "LogicalUnit", "", "add"), Response.Status.BAD_REQUEST);
    } else {
        // Non lun disks require size
        validateParameters(disk, 3, "provisionedSize|size");
    }
    validateEnums(Disk.class, disk);
}
#end_block

#method_before
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisksByUserId, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#method_after
@Override
public Disks list() {
    if (isFiltered()) {
        return mapCollection(getBackendCollection(VdcQueryType.GetAllDisks, new VdcQueryParametersBase()));
    } else {
        return mapCollection(getBackendCollection(SearchType.Disk));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetworkDAO().update(getNetwork());
    for (VDSGroup cluster : clusters) {
        NetworkClusterHelper.setStatus(cluster.getId(), getNetwork());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetworkDAO().update(getNetwork());
    for (NetworkCluster clusterAttachment : getClusterAttachments()) {
        NetworkClusterHelper.setStatus(clusterAttachment.getClusterId(), getNetwork());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<Network> networks = getNetworkDAO().getAll();
    Network oldNetwork = getNetworkById(networks);
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(vlanIsFree(networks)) && validate(networkExists(oldNetwork)) && validate(notChangingManagementNetworkName(oldNetwork)) && validate(networkNameNotUsed(networks)) && validate(networkNotUsedByRunningVm()) && validate(networkNotAttachedToCluster(oldNetwork));
}
#method_after
@Override
protected boolean canDoAction() {
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(vlanIsFree()) && validate(networkExists()) && validate(notChangingManagementNetworkName()) && validate(networkNameNotUsed()) && validate(networkNotUsedByRunningVm()) && validate(networkNotAttachedToCluster(getOldNetwork()));
}
#end_block

#method_before
private ValidationResult networkExists(Network oldNetwork) {
    return oldNetwork == null ? new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS) : ValidationResult.VALID;
}
#method_after
private ValidationResult networkExists() {
    return getOldNetwork() == null ? new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS) : ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult networkNameNotUsed(List<Network> networks) {
    Network networkWithSameName = getOtherNetworkWithSameName(networks);
    return networkWithSameName != null ? new ValidationResult(VdcBllMessages.NETWORK_IN_USE) : ValidationResult.VALID;
}
#method_after
private ValidationResult networkNameNotUsed() {
    Network networkWithSameName = getOtherNetworkWithSameName(getNetworks());
    return networkWithSameName != null ? new ValidationResult(VdcBllMessages.NETWORK_IN_USE) : ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult networkNotUsedByRunningVm() {
    String networkName = getNetworkName();
    for (VDSGroup cluster : getVdsGroupDAO().getAllForStoragePool(getStoragePool().getId())) {
        List<VmStatic> vms = getVmStaticDAO().getAllByGroupAndNetworkName(cluster.getId(), networkName);
        if (vms.size() > 0) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
        }
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult networkNotUsedByRunningVm() {
    String networkName = getNetworkName();
    for (NetworkCluster clusterAttachment : getClusterAttachments()) {
        List<VmStatic> vms = getVmStaticDAO().getAllByGroupAndNetworkName(clusterAttachment.getClusterId(), networkName);
        if (vms.size() > 0) {
            return new ValidationResult(VdcBllMessages.NETWORK_INTERFACE_IN_USE_BY_VM);
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult notChangingManagementNetworkName(Network oldNetwork) {
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    return oldNetwork.getName().equals(managementNetwork) && !getNetworkName().equals(managementNetwork) ? new ValidationResult(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK) : ValidationResult.VALID;
}
#method_after
private ValidationResult notChangingManagementNetworkName() {
    String managementNetwork = Config.<String>GetValue(ConfigValues.ManagementNetwork);
    return getOldNetwork().getName().equals(managementNetwork) && !getNetworkName().equals(managementNetwork) ? new ValidationResult(VdcBllMessages.NETWORK_CAN_NOT_REMOVE_DEFAULT_NETWORK) : ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<Network> all = getNetworks();
    return validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(networkDoesNotExist(all)) && validate(vlanIsFree(all));
}
#method_after
@Override
protected boolean canDoAction() {
    return validate(storagePoolExists()) && validate(vmNetworkSetCorrectly()) && validate(stpForVmNetworkOnly()) && validate(mtuValid()) && validate(networkPrefixValid()) && validate(networkDoesNotExist()) && validate(vlanIsFree());
}
#end_block

#method_before
private ValidationResult networkDoesNotExist(List<Network> networks) {
    return getNetworkByName(networks) == null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_NAME_ALREADY_EXISTS);
}
#method_after
private ValidationResult networkDoesNotExist() {
    return getNetworkByName(getNetworks()) == null ? ValidationResult.VALID : new ValidationResult(VdcBllMessages.NETWORK_NAME_ALREADY_EXISTS);
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (getIsVmRunning(entity) && entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (getIsVmRunning(entity) && entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setAddress(entity.getdisplay_ip());
            Integer displayPort = entity.getdisplay();
            model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
            Integer displaySecurePort = entity.getdisplay_secure_port();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        }
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (getIsVmRunning(entity) && entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (getIsVmRunning(entity) && entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            for (String item : entity.getVmIp().split(" ")) {
                if (!item.equals("")) {
                    IP ip = new IP();
                    ip.setAddress(item.trim());
                    model.getGuestInfo().getIps().getIPs().add(ip);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        case WINDOWS_2012X64:
            return VmOsType.Windows2012x64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    Payload model = template != null ? template : new Payload();
    if (entity.getType() != null) {
        org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
        if (deviceType != null) {
            model.setType(deviceType.value());
        }
    }
    PayloadFile file = new PayloadFile();
    file.setName(entity.getFileName());
    file.setContent(entity.getContent());
    model.setFile(file);
    return model;
}
#method_after
@Mapping(from = VmPayload.class, to = Payload.class)
public static Payload map(VmPayload entity, Payload template) {
    if (entity.getType() != null || entity.getFileName() != null) {
        Payload model = template != null ? template : new Payload();
        if (entity.getType() != null) {
            org.ovirt.engine.api.model.VmDeviceType deviceType = map(entity.getType(), null);
            if (deviceType != null) {
                model.setType(deviceType.value());
            }
        }
        if (entity.getFileName() != null) {
            PayloadFile file = new PayloadFile();
            file.setName(entity.getFileName());
            file.setContent(entity.getContent());
            model.setFile(file);
        }
        return model;
    }
    return null;
}
#end_block

#method_before
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getstatus() == VMStatus.Up || entity.getstatus() == VMStatus.PoweringUp || entity.getstatus() == VMStatus.WaitForLaunch || entity.getstatus() == VMStatus.PoweredDown || entity.getstatus() == VMStatus.RebootInProgress || entity.getstatus() == VMStatus.RestoringState;
}
#method_after
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getStatus() == VMStatus.Up || entity.getStatus() == VMStatus.PoweringUp || entity.getStatus() == VMStatus.WaitForLaunch || entity.getStatus() == VMStatus.PoweredDown || entity.getStatus() == VMStatus.RebootInProgress || entity.getStatus() == VMStatus.RestoringState;
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(new Double(10L));
    statistics.setcpu_sys(new Double(20L));
    VmDynamic dynamic = new VmDynamic();
    dynamic.setstatus(VMStatus.Up);
    dynamic.setdisplay_type(to.getdefault_display_type());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setusage_mem_percent(Integer.valueOf(50));
    return ret;
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(new Double(10L));
    statistics.setcpu_sys(new Double(20L));
    VmDynamic dynamic = new VmDynamic();
    dynamic.setstatus(VMStatus.Up);
    dynamic.setboot_sequence(to.getdefault_boot_sequence());
    dynamic.setdisplay_type(to.getdefault_display_type());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setUsageMemPercent(Integer.valueOf(50));
    return ret;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getUsb().isEnabled(), transform.getUsb().isEnabled());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getDomain().getName(), transform.getDomain().getName());
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
}
#end_block

#method_before
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setstatus(VMStatus.Up);
    entity.setdisplay(5900);
    entity.setdisplay_secure_port(9999);
    VM model = VmMapper.map(entity, null);
    assertTrue(model.getDisplay().getPort() == 5900);
    assertTrue(model.getDisplay().getSecurePort() == 9999);
    entity.setdisplay(-1);
    entity.setdisplay_secure_port(-1);
    model = VmMapper.map(entity, null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#method_after
@Test
public void testDisplayPort() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    entity.setDisplay(5900);
    entity.setDisplaySecurePort(9999);
    VM model = VmMapper.map(entity, null);
    assertTrue(model.getDisplay().getPort() == 5900);
    assertTrue(model.getDisplay().getSecurePort() == 9999);
    entity.setDisplay(-1);
    entity.setDisplaySecurePort(-1);
    model = VmMapper.map(entity, null);
    assertNull(model.getDisplay().getPort());
    assertNull(model.getDisplay().getSecurePort());
}
#end_block

#method_before
@Test
public void testMapHostId() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setstatus(VMStatus.Up);
    Guid guid = NGuid.NewGuid();
    entity.setrun_on_vds(guid);
    VM model = VmMapper.map(entity, null);
    assertEquals(guid.toString(), model.getHost().getId());
}
#method_after
@Test
public void testMapHostId() {
    org.ovirt.engine.core.common.businessentities.VM entity = new org.ovirt.engine.core.common.businessentities.VM();
    entity.setStatus(VMStatus.Up);
    Guid guid = NGuid.NewGuid();
    entity.setRunOnVds(guid);
    VM model = VmMapper.map(entity, null);
    assertEquals(guid.toString(), model.getHost().getId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning
    if (returnValue) {
        VDS dedicatedVds;
        VM vmFromParams = getParameters().getVm();
        if (vmFromParams.getDedicatedVmForVds() != null && (dedicatedVds = DbFacade.getInstance().getVdsDao().get(vmFromParams.getDedicatedVmForVds())) != null) {
            VdcBllMessages returnMsg = isCpuPinningValid(vmFromParams.getCpuPinning(), getParameters().getVm().getNumOfCpus(), dedicatedVds.getcpu_cores() * dedicatedVds.getcpu_sockets() * dedicatedVds.getcpu_sockets());
            if (returnMsg != VdcBllMessages.Unassigned) {
                returnValue = false;
                addCanDoActionMessage(returnMsg);
            }
        } else {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.VM_PINNING_WITHOUT_DEDICATED_VDS);
        }
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getVmName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getiso_path());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning if the check haven't failed yet
    if (returnValue) {
        VM vmFromParams = getParameters().getVm();
        returnValue = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData());
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return returnValue && checkCpuSockets();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        freeLock();
        addVmPermission();
        if (addVmImages()) {
            copyVmDevices();
            addDiskPermissions(newDiskImages);
            addVmPayload();
            // add or remove the smartcard according to user request
            if (getVm().isSmartcardEnabled() != getVmTemplate().isSmartcardEnabled()) {
                VmDeviceUtils.updateSmartcardDevice(getVm().getId(), getVm().isSmartcardEnabled());
            }
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    if (getVm() != null) {
        removeVmInSpm(getVm().getStoragePoolId(), getVmId());
    }
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    super.endActionOnDisks();
    removeVmRelatedEntitiesFromDb();
    setSucceeded(true);
}
#end_block

#method_before
protected VmDynamicDAO getVmDynamicDao() {
    return DbFacade.getInstance().getVmDynamicDao();
}
#method_after
@Override
protected VmDynamicDAO getVmDynamicDao() {
    return DbFacade.getInstance().getVmDynamicDao();
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    // Set the VM to null, to fetch it again from the DB ,instead from the cache.
    // We want to get the VM current data that was updated to the DB.
    setVm(null);
    try {
        updateVmInSpm(getVm().getStoragePoolId(), Arrays.asList(getVm()));
    } catch (Exception e) {
    // DO nothing
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    VDS dedicatedVds;
    if (vmFromParams.getDedicatedVmForVds() != null && (dedicatedVds = DbFacade.getInstance().getVdsDao().get(vmFromParams.getDedicatedVmForVds())) != null) {
        VdcBllMessages returnMsg = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getNumOfCpus(), dedicatedVds.getcpu_cores() * dedicatedVds.getcpu_sockets());
        if (returnMsg != VdcBllMessages.Unassigned) {
            addCanDoActionMessage(returnMsg);
            return false;
        }
    } else {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_WITHOUT_DEDICATED_VDS);
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#end_block

#method_before
@Test
public void isCpuPinningValid() {
    Assert.assertTrue("null value must be accepted", VmManagementCommandBase.isCpuPinningValid(null, 0, 0) == VdcBllMessages.Unassigned);
    Assert.assertTrue("empty string must be accepted", VmManagementCommandBase.isCpuPinningValid("", 0, 0) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("intentionally invalid", 0, 0) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0", 1, 1) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^3,^2", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-8,^5,^6,^7", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#^1,^2,^3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,6-8,9-12", 10, 13) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-4,^3,9-12,^10", 10, 13) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#0_1#1", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1-2_1#1-2", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#2,3", 10, 10) == VdcBllMessages.Unassigned);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("0#1,2,3_1#1-4,^3", 10, 10) == VdcBllMessages.Unassigned);
    // validate vcpus over 9
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 12, 12) == VdcBllMessages.Unassigned);
    // negative tests
    Assert.assertTrue("random wrong text", VmManagementCommandBase.isCpuPinningValid("lorem ipsum", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("no cpu id specified, should not pass", VmManagementCommandBase.isCpuPinningValid("0", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("letter instead of vcpu ID", VmManagementCommandBase.isCpuPinningValid("A#1", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("letter instead of cpu ID", VmManagementCommandBase.isCpuPinningValid("0#B", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("A separating _ while only one vcpu pinning", VmManagementCommandBase.isCpuPinningValid("0#1_", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("Trailing _", VmManagementCommandBase.isCpuPinningValid("0#1_1#2_", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("Too many separators", VmManagementCommandBase.isCpuPinningValid("0#1__1#2", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    Assert.assertTrue("trailing junk", VmManagementCommandBase.isCpuPinningValid("0#1_1#2...", 10, 10) == VdcBllMessages.VM_PINNING_FORMAT_INVALID);
    // negative logical validation
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 4, 12) == VdcBllMessages.VM_PINNING_VCPU_DOESNT_EXIST);
    Assert.assertTrue(VmManagementCommandBase.isCpuPinningValid("10#1,2,3_11#1-4,^3", 12, 4) == VdcBllMessages.VM_PINNING_PCPU_DOESNT_EXIST);
}
#method_after
@Test
public void isCpuPinningValid() {
    VmManagementCommandBase<VmManagementParametersBase> test = spy(new VmManagementCommandBase<VmManagementParametersBase>(Guid.Empty));
    VmStatic vmStatic = new VmStatic();
    vmStatic.setnum_of_sockets(6);
    vmStatic.setcpu_per_socket(2);
    vmStatic.setdedicated_vm_for_vds(Guid.Empty);
    final VDS dedicatedVds = new VDS();
    dedicatedVds.setCpuThreads(16);
    dedicatedVds.setvds_group_compatibility_version(Version.v3_2);
    doReturn(dedicatedVds).when(test).getVds(Guid.Empty);
    Assert.assertTrue("null value must be accepted", test.isCpuPinningValid(null, vmStatic));
    Assert.assertTrue("empty string must be accepted", test.isCpuPinningValid("", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("intentionally invalid", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#0", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^3", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^3,^2", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-8,^5,^6,^7", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3", vmStatic));
    Assert.assertFalse(test.isCpuPinningValid("0#^1,^2,^3", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,6-8", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,6-8,9-12", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-4,^3,9-12,^10", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#0_1#1", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1-2_1#1-2", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3_1#2,3", vmStatic));
    Assert.assertTrue(test.isCpuPinningValid("0#1,2,3_1#1-4,^3", vmStatic));
    // validate vcpus over 9
    Assert.assertTrue(test.isCpuPinningValid("10#1,2,3_11#1-4,^3", vmStatic));
    // negative tests
    Assert.assertFalse("random wrong text", test.isCpuPinningValid("lorem ipsum", vmStatic));
    Assert.assertFalse("no cpu id specified, should not pass", test.isCpuPinningValid("0", vmStatic));
    Assert.assertFalse("letter instead of vcpu ID", test.isCpuPinningValid("A#1", vmStatic));
    Assert.assertFalse("letter instead of cpu ID", test.isCpuPinningValid("0#B", vmStatic));
    Assert.assertFalse("A separating _ while only one vcpu pinning", test.isCpuPinningValid("0#1_", vmStatic));
    Assert.assertFalse("Trailing _", test.isCpuPinningValid("0#1_1#2_", vmStatic));
    Assert.assertFalse("Too many separators", test.isCpuPinningValid("0#1__1#2", vmStatic));
    Assert.assertFalse("trailing junk", test.isCpuPinningValid("0#1_1#2...", vmStatic));
    // negative logical validation
    ArrayList<String> canDoActionMessages = test.getReturnValue().getCanDoActionMessages();
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_10#1-4,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,^1,^2", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_20#1-4,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST.toString(), canDoActionMessages.get(0));
    }
    canDoActionMessages.clear();
    Assert.assertFalse(test.isCpuPinningValid("10#1,2,3_11#1-20,^3", vmStatic));
    Assert.assertTrue(canDoActionMessages.size() > 0);
    if (canDoActionMessages.size() > 0) {
        Assert.assertEquals(VdcBllMessages.VM_PINNING_PCPU_DOES_NOT_EXIST.toString(), canDoActionMessages.get(0));
    }
    // making sure cluster < 3.2 does not get validated on pCPU as we cant tell the number for sure
    dedicatedVds.setvds_group_compatibility_version(Version.v3_1);
    Assert.assertTrue(test.isCpuPinningValid("10#1,2,3_11#1-20,^3", vmStatic));
}
#end_block

#method_before
static VdcBllMessages isCpuPinningValid(final String cpuPinning, int maxVcpus, int maxPcpus) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return VdcBllMessages.Unassigned;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        return VdcBllMessages.VM_PINNING_FORMAT_INVALID;
    }
    HashSet<Integer> vcpus = new HashSet<Integer>();
    String[] rules = cpuPinning.split("_");
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxVcpus) {
            // ERROR maps to a non existent vcpu
            return VdcBllMessages.VM_PINNING_VCPU_DOESNT_EXIST;
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more then one definition for the same vcpu
            return VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION;
        }
        TreeSet<Integer> currPcpus = parseCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return VdcBllMessages.VM_PINNING_FORMAT_INVALID;
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU;
        }
        if (currPcpus.last() >= maxPcpus * 2) {
            // ERROR maps to a non existent pcpu
            return VdcBllMessages.VM_PINNING_PCPU_DOESNT_EXIST;
        }
    }
    return VdcBllMessages.Unassigned;
}
#method_after
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<Integer>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getnum_of_cpus();
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxvCPU) {
            // ERROR maps to a non existent vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST);
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more then one definition for the same vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION);
        }
        Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return failCanDoAction(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return failCanDoAction(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU);
        }
        // can not check if no dedicated vds was configured
        if (vmStatic.getdedicated_vm_for_vds() != null) {
            VDS dedicatedVds = getVds(vmStatic.getdedicated_vm_for_vds().getValue());
            // check only from cluster version 3.2
            if (dedicatedVds != null && dedicatedVds.getvds_group_compatibility_version() != null && dedicatedVds.getvds_group_compatibility_version().compareTo(Version.v3_2) >= 0 && dedicatedVds.getCpuThreads() != null) {
                if (Collections.max(currPcpus) >= dedicatedVds.getCpuThreads()) {
                    // ERROR maps to a non existent pcpu
                    return failCanDoAction(VdcBllMessages.VM_PINNING_PCPU_DOES_NOT_EXIST);
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // the VM in Run Once scenario, in that case we need to add proper video device
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        addVideoCardAccordingToTheRequestedDisplayType(vm.getDisplayType());
    } else {
        addVideoCardsDefinedForTheVmFromDB();
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // the VM in Run Once scenario, in that case we need to add proper video device
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        addVideoCardByDisplayType(vm.getDisplayType());
    } else {
        addVideoCardsDefinedForVmInDB(vm.getId());
    }
}
#end_block

#method_before
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.InnerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringHelper.isNullOrEmpty(node.InnerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.InnerText));
            vmBase.setdefault_display_type(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#method_after
protected void readGeneralData() {
    XmlNode content = _document.SelectSingleNode("//*/Content");
    XmlNode node;
    node = content.SelectSingleNode("Description");
    if (node != null) {
        vmBase.setdescription(node.InnerText);
    }
    node = content.SelectSingleNode("Domain");
    if (node != null) {
        vmBase.setdomain(node.InnerText);
    }
    node = content.SelectSingleNode("CreationDate");
    if (node != null) {
        Date creationDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (creationDate != null) {
            vmBase.setcreation_date(creationDate);
        }
    }
    node = content.SelectSingleNode("ExportDate");
    if (node != null) {
        Date exportDate = OvfParser.UtcDateStringToLocaDate(node.InnerText);
        if (exportDate != null) {
            vmBase.setExportDate(exportDate);
        }
    }
    node = content.SelectSingleNode("IsAutoSuspend");
    if (node != null) {
        vmBase.setis_auto_suspend(Boolean.parseBoolean(node.InnerText));
    }
    node = content.SelectSingleNode("TimeZone");
    if (node != null) {
        vmBase.settime_zone(node.InnerText);
    }
    node = content.SelectSingleNode("default_boot_sequence");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setdefault_boot_sequence(BootSequence.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("initrd_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setinitrd_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_url");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_url((node.InnerText));
        }
    }
    node = content.SelectSingleNode("kernel_params");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setkernel_params((node.InnerText));
        }
    }
    node = content.SelectSingleNode("Generation");
    if (node != null) {
        vmBase.setDbGeneration(Long.parseLong(node.InnerText));
    } else {
        vmBase.setDbGeneration(1L);
    }
    // Note: the fetching of 'default display type' should happen before reading
    // the hardware section
    node = content.SelectSingleNode(getDefaultDisplayTypeStringRepresentation());
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            defaultDisplayType = DisplayType.forValue(Integer.parseInt(node.InnerText));
            vmBase.setdefault_display_type(defaultDisplayType);
        }
    }
    XmlNodeList list = content.SelectNodes("Section");
    for (XmlNode section : list) {
        String value = section.Attributes.get("xsi:type").getValue();
        if ("ovf:OperatingSystemSection_Type".equals(value)) {
            ReadOsSection(section);
        } else if ("ovf:VirtualHardwareSection_Type".equals(value)) {
            ReadHardwareSection(section);
        } else if ("ovf:SnapshotsSection_Type".equals(value)) {
            readSnapshotsSection(section);
        }
    }
    node = content.SelectSingleNode("Origin");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setorigin(OriginType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("VmType");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setvm_type(VmType.forValue(Integer.parseInt(node.InnerText)));
        }
    }
    node = content.SelectSingleNode("IsSmartcardEnabled");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setSmartcardEnabled(Boolean.parseBoolean(node.InnerText));
        }
    }
    node = content.SelectSingleNode("DeleteProtected");
    if (node != null) {
        if (!StringUtils.isEmpty(node.InnerText)) {
            vmBase.setDeleteProtected(Boolean.parseBoolean(node.InnerText));
        }
    }
    readGeneralData(content);
}
#end_block

#method_before
public static void RunQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback) {
    initQueryParamsFilter(parameters);
    dumpQueryDetails(queryType, parameters);
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async runQuery.");
    raiseQueryStartedEvent(queryType, callback.getContext());
    GenericApiGWTServiceAsync service = GenericApiGWTServiceAsync.Util.getInstance();
    service.RunQuery(queryType, parameters, new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onFailure(Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                callback.asyncCallback.OnSuccess(callback.getModel(), null);
            }
            raiseQueryCompleteEvent(queryType, callback.getContext());
        }

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from RunQuery.");
            if (!result.getSucceeded()) {
                logger.log(Level.WARNING, // $NON-NLS-1$
                "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                "]");
                if (getEventsHandler() != null) {
                    ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                    failedResult.add(result);
                    // getEventsHandler().runQueryFailed(failedResult);
                    String errorMessage = result.getExceptionString();
                    handleNotLoggedInEvent(errorMessage);
                }
                if (callback.isHandleFailure()) {
                    callback.getDel().OnSuccess(callback.getModel(), result);
                }
            } else {
                callback.setOriginalReturnValue(result);
                if (callback.getConverter() != null) {
                    callback.getDel().OnSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                } else {
                    callback.getDel().OnSuccess(callback.getModel(), result);
                }
            }
            raiseQueryCompleteEvent(queryType, callback.getContext());
        }
    });
}
#method_after
public static void RunQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback) {
    final QueryWrapper queryWrapper = new QueryWrapper(queryType, parameters, callback);
    final boolean isHandleSequentialQueries = isHandleSequentialQueries(queryWrapper);
    if (isHandleSequentialQueries) {
        if (currentRequests.get(queryWrapper.getKey()) == null) {
            currentRequests.put(queryWrapper.getKey(), queryWrapper);
        } else {
            pendingRequests.put(queryWrapper.getKey(), queryWrapper);
            return;
        }
    }
    initQueryParamsFilter(parameters);
    dumpQueryDetails(queryType, parameters);
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async runQuery.");
    raiseQueryStartedEvent(queryType, callback.getContext());
    GenericApiGWTServiceAsync service = GenericApiGWTServiceAsync.Util.getInstance();
    service.RunQuery(queryType, parameters, new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onFailure(Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.asyncCallback.OnSuccess(callback.getModel(), null);
                }
                raiseQueryCompleteEvent(queryType, callback.getContext());
            } finally {
                if (isHandleSequentialQueries) {
                    handleSequentialQueries(queryWrapper.getKey());
                }
            }
        }

        @Override
        public void onSuccess(VdcQueryReturnValue result) {
            try {
                // $NON-NLS-1$
                logger.finer("Succesful returned result from RunQuery.");
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().OnSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().OnSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().OnSuccess(callback.getModel(), result);
                    }
                }
                raiseQueryCompleteEvent(queryType, callback.getContext());
            } finally {
                if (isHandleSequentialQueries) {
                    handleSequentialQueries(queryWrapper.getKey());
                }
            }
        }

        private void handleSequentialQueries(String key) {
            currentRequests.remove(queryWrapper.getKey());
            QueryWrapper wrapper = pendingRequests.get(key);
            if (wrapper != null) {
                pendingRequests.remove(queryWrapper.getKey());
                RunQuery(wrapper.getQueryType(), wrapper.getParameters(), wrapper.getCallback());
            }
        }
    });
}
#end_block

#method_before
@Override
public void addActionVersionMap(ActionVersionMap action_version_map) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("action_type", action_version_map.getaction_type()).addValue("cluster_minimal_version", action_version_map.getcluster_minimal_version()).addValue("storage_pool_minimal_version", action_version_map.getstorage_pool_minimal_version());
    getCallsHandler().executeModification("Insertaction_version_map", parameterSource);
}
#method_after
@Override
public void addActionVersionMap(ActionVersionMap actionVersionMap) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("action_type", actionVersionMap.getaction_type()).addValue("cluster_minimal_version", actionVersionMap.getcluster_minimal_version()).addValue("storage_pool_minimal_version", actionVersionMap.getstorage_pool_minimal_version());
    getCallsHandler().executeModification("Insertaction_version_map", parameterSource);
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(ActionVersionMap.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(async_tasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(LdapGroup.class).addAnnotatedClass(ActionVersionMap.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
private List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    List<QuotaConsumptionParameter> consumptionParameters;
    // The enum markings prevent Quota dependencies unintentional inheritance.
    switch(getActionType().getQuotaDependency()) {
        case NONE:
            return null;
        case STORAGE:
            consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
            break;
        case VDS_GROUP:
            consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
            break;
        default:
            consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
            consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
            break;
    }
    return consumptionParameters;
}
#method_after
private List<QuotaConsumptionParameter> getQuotaConsumptionParameters() {
    // The enum markings prevent Quota dependencies unintentional inheritance.
    if (consumptionParameters == null) {
        switch(getActionType().getQuotaDependency()) {
            case NONE:
                return null;
            case STORAGE:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                break;
            case VDS_GROUP:
                consumptionParameters = getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters();
                break;
            default:
                consumptionParameters = getThisQuotaStorageDependent().getQuotaStorageConsumptionParameters();
                consumptionParameters.addAll(getThisQuotaVdsDependent().getQuotaVdsConsumptionParameters());
                break;
        }
    }
    return consumptionParameters;
}
#end_block

#method_before
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
            }
        }
    }
}
#method_after
public void addQuotaPermissionSubject(List<PermissionSubject> quotaPermissionList) {
    if (!isInternalExecution() && getStoragePool() != null && getStoragePool().getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        List<QuotaConsumptionParameter> consumptionParameters = getQuotaConsumptionParameters();
        if (consumptionParameters != null) {
            for (QuotaConsumptionParameter parameter : getQuotaConsumptionParameters()) {
                if (parameter.getQuotaGuid() != null && parameter.getQuotaGuid() != Guid.Empty) {
                    quotaPermissionList.add(new PermissionSubject(parameter.getQuotaGuid(), VdcObjectType.Quota, ActionGroup.CONSUME_QUOTA));
                }
            }
        }
    }
}
#end_block

#method_before
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#method_after
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
    }
    return validationResult.isValid();
}
#method_after
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#end_block

#method_before
public void OnSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if (!model.getIsNew() && !((Version) model.getVersion().getSelectedItem()).equals(((storage_pool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (((storage_pool) getSelectedItem()).getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        promptNoQuotaAvailable(model.getEntity(), this);
    } else {
        OnSaveInternal();
    }
}
#method_after
public void OnSave() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (!model.Validate()) {
        return;
    }
    if ((model.getIsNew() || model.getEntity() == null) && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        promptNoQuotaInDCMessage();
    } else if (!((Version) model.getVersion().getSelectedItem()).equals(((storage_pool) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeDataCenterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_data_center_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeDcCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else if (((storage_pool) getSelectedItem()).getQuotaEnforcementType() == QuotaEnforcementTypeEnum.DISABLED && model.getQuotaEnforceTypeListModel().getSelectedItem() != QuotaEnforcementTypeEnum.DISABLED) {
        checkForQuotaInDC(model.getEntity(), this);
    } else {
        OnSaveInternal();
    }
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(LdapGroup.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(EventNotificationMethod.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
protected boolean ValidateNotificationMethod(java.util.List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethods notificationMethod = event_notification_methods.get(0).getmethod_type();
    switch(notificationMethod) {
        case EMAIL:
            String mailAdress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getemail() : event_subscriber.getmethod_address();
            if (StringUtils.isEmpty(mailAdress) || !ValidatMailAddress(mailAdress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
protected boolean ValidateNotificationMethod(java.util.List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = true;
    EventNotificationMethods notificationMethod = eventNotificationMethods.get(0).getmethod_type();
    switch(notificationMethod) {
        case EMAIL:
            String mailAdress = (StringUtils.isEmpty(event_subscriber.getmethod_address())) ? user.getemail() : event_subscriber.getmethod_address();
            if (StringUtils.isEmpty(mailAdress) || !ValidatMailAddress(mailAdress)) {
                addCanDoActionMessage(VdcBllMessages.USER_DOES_NOT_HAVE_A_VALID_EMAIL);
                retValue = false;
            }
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.EN_UNKNOWN_NOTIFICATION_METHOD);
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
protected boolean ValidateAdd(List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    String tagName = event_subscriber.gettag_name();
    // validate notification method
    boolean retValue = ValidateNotificationMethod(event_notification_methods, event_subscriber, user);
    // validate tag name if exists
    if (retValue && StringUtils.isNotEmpty(tagName)) {
        retValue = ValidateTag(tagName);
    }
    return retValue;
}
#method_after
protected boolean ValidateAdd(List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    String tagName = event_subscriber.gettag_name();
    // validate notification method
    boolean retValue = ValidateNotificationMethod(eventNotificationMethods, event_subscriber, user);
    // validate tag name if exists
    if (retValue && StringUtils.isNotEmpty(tagName)) {
        retValue = ValidateTag(tagName);
    }
    return retValue;
}
#end_block

#method_before
protected boolean ValidateRemove(List<EventNotificationMethod> event_notification_methods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = false;
    // check if user is subscribed to the event
    List<event_subscriber> list = DbFacade.getInstance().getEventDao().getAllForSubscriber(event_subscriber.getsubscriber_id());
    if (list.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
    } else {
        if (!ValidateSubscription(list, event_subscriber)) {
            addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
        } else {
            String tagName = event_subscriber.gettag_name();
            // validate notification method
            retValue = ValidateNotificationMethod(event_notification_methods, event_subscriber, user);
            // validate tag name if exists
            if (retValue && StringUtils.isNotEmpty(tagName)) {
                retValue = ValidateTag(tagName);
            }
        }
    }
    return retValue;
}
#method_after
protected boolean ValidateRemove(List<EventNotificationMethod> eventNotificationMethods, event_subscriber event_subscriber, DbUser user) {
    boolean retValue = false;
    // check if user is subscribed to the event
    List<event_subscriber> list = DbFacade.getInstance().getEventDao().getAllForSubscriber(event_subscriber.getsubscriber_id());
    if (list.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
    } else {
        if (!ValidateSubscription(list, event_subscriber)) {
            addCanDoActionMessage(VdcBllMessages.EN_NOT_SUBSCRIBED);
        } else {
            String tagName = event_subscriber.gettag_name();
            // validate notification method
            retValue = ValidateNotificationMethod(eventNotificationMethods, event_subscriber, user);
            // validate tag name if exists
            if (retValue && StringUtils.isNotEmpty(tagName)) {
                retValue = ValidateTag(tagName);
            }
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean connectHostToPool() {
    setStoragePool(null);
    final Guid masterDomainIdFromDb = getMasterDomainIdFromDb();
    final VDS vds = getVds();
    final storage_pool storagePool = getStoragePool();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(storagePool.getId(), masterDomainIdFromDb, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(masterDomainIdFromDb, vds, storagePool);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#method_after
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid masterDomainIdFromDb, final VDS vds, final storage_pool storagePool) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    try {
        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getvds_spm_id(), masterDomainIdFromDb, storagePool.getmaster_domain_version())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.StoragePoolWrongMaster || e.getErrorCode() == VdcBllErrors.StoragePoolMasterNotFound) {
            boolean returnValue = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, new ReconstructMasterParameters(vds.getStoragePoolId(), masterDomainIdFromDb, vds.getId(), false)).getSucceeded();
            result = new EventResult(returnValue, EventType.RECONSTRUCT);
        } else {
            log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
            result.setSuccess(false);
        }
    } catch (RuntimeException exp) {
        log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
        result.setSuccess(false);
    }
    if (result.isSuccess() && result.getEventType() != EventType.RECONSTRUCT) {
        result.setSuccess(proceedVdsStats());
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    storage_pool storagePool = getStoragePoolDAO().get(storagePoolId);
    Guid masterDomainIdFromDb = getStorageDomainDAO().getMasterStorageDomainIdForPool(storagePoolId);
    try {
        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), storagePoolId, vds.getvds_spm_id(), masterDomainIdFromDb, storagePool.getmaster_domain_version())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.StoragePoolWrongMaster || e.getErrorCode() == VdcBllErrors.StoragePoolMasterNotFound) {
            boolean returnValue = Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, new ReconstructMasterParameters(vds.getStoragePoolId(), masterDomainIdFromDb, vds.getId(), false)).getSucceeded();
            result = new EventResult(returnValue, EventType.RECONSTRUCT);
        } else {
            log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
            result.setSuccess(false);
        }
    } catch (RuntimeException exp) {
        log.errorFormat("Could not connect host {0} to pool {1}", vds.getvds_name(), storagePool.getname());
        result.setSuccess(false);
    }
    if (result.isSuccess() && result.getEventType() != EventType.RECONSTRUCT) {
        result.setSuccess(proceedVdsStats());
        if (!result.isSuccess()) {
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_HOST_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (!getVdsGroup().supportsVirtService()) {
        if (getVdsGroup().supportsGlusterService()) {
            if (!_glusterPeerListSucceeded) {
                type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
            } else if (!_glusterPeerProbeSucceeded) {
                type = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
            }
        }
        return type;
    }
    if (!_connectStorageSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_SERVERS_FAILED;
    } else if (!_connectPoolSucceeded) {
        type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
    } else if (getVds().getpm_enabled() && _fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS;
    } else if (getVds().getpm_enabled() && !_fencingSucceeded) {
        type = AuditLogType.VDS_FENCE_STATUS_FAILED;
    }
    // PM alerts
    AuditLogableBase logable = new AuditLogableBase(getVds().getId());
    if (getVds().getpm_enabled()) {
        if (!_vdsProxyFound) {
            logable.AddCustomValue("Reason", AuditLogDirector.GetMessage(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST));
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        } else if (!_fenceStatusReturnValue.getIsSucceeded()) {
            logable.AddCustomValue("Reason", _fenceStatusReturnValue.getMessage());
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_TEST_FAILED);
        }
    } else {
        AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED);
    }
    return type;
}
#end_block

#method_before
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterHostAdd, new GlusterHostAddVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_HOST_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            _glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.errorFormat("Could not peer probe the gluster server {0}. Error: {1}", getVds().gethost_name(), e.getMessage());
        _glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecutor(tasks).execute();
    }
}
#end_block

#method_before
public NGuid getUserId() {
    if (mUserId.equals(Guid.Empty) && getCurrentUser() != null) {
        mUserId = getCurrentUser().getUserId();
    }
    return mUserId;
}
#method_after
public NGuid getUserId() {
    if (mUserId != null && mUserId.equals(Guid.Empty) && getCurrentUser() != null) {
        mUserId = getCurrentUser().getUserId();
    }
    return mUserId;
}
#end_block

#method_before
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getVdsGroupId();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#method_after
protected VDSGroup getVdsGroup() {
    if (mVdsGroup == null) {
        if (mVdsGroupId != null) {
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVds() != null) {
            mVdsGroupId = getVds().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVm() != null) {
            mVdsGroupId = getVm().getVdsGroupId();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        } else if (getVmTemplate() != null) {
            mVdsGroupId = getVmTemplate().getvds_group_id();
            mVdsGroup = getVdsGroupDAO().get(mVdsGroupId);
        }
    }
    return mVdsGroup;
}
#end_block

#method_before
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    storage_domain_static domainFromDb = null;
    storage_pool_iso_map domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void ProceedStorageDomain(storage_domains data, int dataMasterVersion, storage_pool storagePool) {
    storage_domains storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getstorage_domain_type() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getstorage_domain_type() == StorageDomainType.Master) || (data.getstorage_domain_type() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getstorage_name()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getstorage_pool_id().getValue(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getstorage_name(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setstorage_pool_id(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getstatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getstatus() != null && data.getstatus() == StorageDomainStatus.InActive && domainFromDb.getstorage_domain_type() == StorageDomainType.Master) {
                storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id().getValue());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintanance);
                    pool.setstatus(StoragePoolStatus.Maintanance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintanance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getstatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getavailable_disk_size() != null && data.getused_disk_size() != null) {
                int freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.AddCustomValue("DiskSpace", (data.getavailable_disk_size()).toString());
                    data.setstorage_name(domainFromDb.getstorage_name());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setstorage_name(domainFromDb.getstorage_name());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getstorage_name(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId);
            return result;
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
public void Init(VDS vds) {
    mCurrentVdsId = vds.getId();
    setmIrsPort(vds.getport());
    setmCurrentIrsHost(vds.gethost_name());
}
#method_after
public void Init(VDS vds) {
    mCurrentVdsId = vds.getId();
    setmIrsPort(vds.getport());
    privatemCurrentIrsHost = vds.gethost_name();
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    mCurrentVdsId = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = GetPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    WaitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.Problematic) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.Problematic, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getstatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getvds_spm_id();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getvds_spm_id(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getvds_name(), spmStatus.getSpmStatus().toString(), storagePool.getname());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = HandleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = HandleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getvds_name());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
public String getIsoDirectory() {
    String tempVar = getmCurrentIrsHost();
    return String.format("\\\\%1$s\\CD", ((tempVar != null) ? tempVar : gethostFromVds()));
}
#method_after
public String getIsoDirectory() {
    String tempVar = privatemCurrentIrsHost;
    return String.format("\\\\%1$s\\CD", ((tempVar != null) ? tempVar : gethostFromVds()));
}
#end_block

#method_before
private void nullifyInternalProxies() {
    if (privatemIrsProxy != null) {
        XmlRpcUtils.shutDownConnection(((IrsServerWrapper) privatemIrsProxy).getHttpClient());
    }
    setmCurrentIrsHost(null);
    privatemIrsProxy = null;
    mCurrentVdsId = null;
}
#method_after
private void nullifyInternalProxies() {
    if (privatemIrsProxy != null) {
        XmlRpcUtils.shutDownConnection(((IrsServerWrapper) privatemIrsProxy).getHttpClient());
    }
    privatemCurrentIrsHost = null;
    privatemIrsProxy = null;
    mCurrentVdsId = null;
}
#end_block

#method_before
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    storage_pool_iso_map map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#method_after
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    storage_pool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.Problematic)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                synchronized (_lockObject) {
                    updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                }
                return result;
            }
        });
    }
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            synchronized (_lockObject) {
                if (_domainsInProblem.containsKey(domainId)) {
                    log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                    result = ProcessDomainRecovery(domainId);
                }
                _timers.remove(domainId);
            }
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#end_block

#method_before
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("domain {0} was reported by all hosts in status UP as problematic. Moving the Domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
    return result;
}
#method_after
private EventResult ProcessDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getstatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getstorage_domain_type() != StorageDomainType.ImportExport && storageDomain.getstorage_domain_type() != StorageDomainType.ISO) {
            // operational.
            for (Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getstatus() != VDSStatus.Maintenance && vds.getstatus() != VDSStatus.NonOperational) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, moving the vds to status NonOperational", vds.getvds_name(), domainIdTuple);
                    ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                    clearVdsFromCache(vdsId, vds.getvds_name());
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getvds_name(), domainIdTuple, vds.getstatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getstorage_domain_type());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getstorage_domain_type() != StorageDomainType.Master) {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId);
        }
    }
    // clear from cache of _vdssInProblem and
    // _domainsInProblem
    clearDomainFromCache(domainId);
    ClearTimer(domainId);
    return result;
}
#end_block

#method_before
public void clearCache() {
    synchronized (_lockObject) {
        log.info("clearing cache for problematic entities in pool " + _storagePoolId);
        // clear lists
        _timers.clear();
        _domainsInProblem.clear();
        _vdssInProblem.clear();
    }
}
#method_after
public void clearCache() {
    log.info("clearing cache for problematic entities in pool " + _storagePoolId);
    // clear lists
    _timers.clear();
    _domainsInProblem.clear();
    _vdssInProblem.clear();
}
#end_block

#method_before
public void clearPoolTimers() {
    synchronized (_lockObject) {
        log.info("clear domain error-timers for pool " + _storagePoolId);
        for (String jobId : _timers.values()) {
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("failed deleting job " + jobId);
            }
        }
    }
}
#method_after
public void clearPoolTimers() {
    log.info("clear domain error-timers for pool " + _storagePoolId);
    for (String jobId : _timers.values()) {
        try {
            SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
        } catch (Exception e) {
            log.warn("failed deleting job " + jobId);
        }
    }
}
#end_block

#method_before
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.infoFormat("Clearing cache of pool: {0} for problematic entities of VDS: {1}.", _storagePoolId, vdsName);
    synchronized (_lockObject) {
        if (_vdssInProblem.containsKey(vdsId)) {
            for (Guid domainId : _vdssInProblem.get(vdsId)) {
                DomainRecoveredFromProblem(domainId, vdsId, vdsName);
            }
        }
    }
}
#method_after
public void clearVdsFromCache(Guid vdsId, String vdsName) {
    log.infoFormat("Clearing cache of pool: {0} for problematic entities of VDS: {1}.", _storagePoolId, vdsName);
    if (_vdssInProblem.containsKey(vdsId)) {
        for (Guid domainId : _vdssInProblem.get(vdsId)) {
            DomainRecoveredFromProblem(domainId, vdsId, vdsName);
        }
    }
}
#end_block

#method_before
private static String getDomainIdTuple(Guid domainId) {
    storage_domain_static storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#method_after
private static String getDomainIdTuple(Guid domainId) {
    StorageDomainStatic storage_domain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    if (storage_domain != null) {
        return domainId + ":" + storage_domain.getstorage_name();
    } else {
        return domainId.toString();
    }
}
#end_block

#method_before
private void startReconstruct() {
    storage_domain_static masterDomain = null;
    List<storage_domain_static> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (storage_domain_static storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId());
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getstorage_domain_type() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId());
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
@Override
public void vdsMovedToMaintanance(Guid vdsId) {
    VDS vds = DbFacade.getInstance().getVdsDao().get(vdsId);
    MaintananceVdsCommand.ProcessStorageOnVdsInactive(vds);
    ExecutionHandler.updateSpecificActionJobCompleted(vdsId, VdcActionType.MaintananceVds, true);
}
#method_after
@Override
public void vdsMovedToMaintanance(VDS vds) {
    try {
        MaintananceVdsCommand.ProcessStorageOnVdsInactive(vds);
    } finally {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintananceVds, true);
    }
}
#end_block

#method_before
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // clients, so we won't need to handle migration errors
    if (StringUtils.isNotEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.doCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()), ExecutionHandler.createInternalJobContext());
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setguest_cur_user_id(null);
        vmDynamic.setguest_cur_user_name(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#method_after
@Override
public void processOnClientIpChange(final VDS vds, final Guid vmId) {
    final VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(vmId);
    // clients, so we won't need to handle migration errors
    if (StringUtils.isNotEmpty(vmDynamic.getclient_ip())) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                RunVmCommandBase.doCompressionCheck(vds, vmDynamic);
                // Run PowerClientMigrateOnConnectCheck if configured.
                if (Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateToPowerClientOnConnect) || Config.<Boolean>GetValue(ConfigValues.PowerClientAutoMigrateFromPowerClientToVdsWhenConnectingFromRegularClient)) {
                    Backend.getInstance().runInternalAction(VdcActionType.PowerClientMigrateOnConnectCheck, new PowerClientMigrateOnConnectCheckParameters(false, vmDynamic.getId(), vmDynamic.getclient_ip(), vds.getId()), ExecutionHandler.createInternalJobContext());
                }
            }
        });
    } else // in case of empty clientIp we clear the logged in user.
    // (this happened when user close the console to spice/vnc)
    {
        vmDynamic.setConsole_current_user_name(null);
        DbFacade.getInstance().getVmDynamicDao().update(vmDynamic);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((domainId == null) ? 0 : domainId.hashCode());
    result = prime * result + ((eventType == null) ? 0 : eventType.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((domainId == null) ? 0 : domainId.hashCode());
    result = prime * result + ((eventType == null) ? 0 : eventType.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Event other = (Event) obj;
    if (domainId == null) {
        if (other.domainId != null)
            return false;
    } else if (!domainId.equals(other.domainId))
        return false;
    if (eventType != other.eventType)
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Event other = (Event) obj;
    if (domainId == null) {
        if (other.domainId != null)
            return false;
    } else if (!domainId.equals(other.domainId))
        return false;
    if (eventType != other.eventType)
        return false;
    if (storagePoolId == null) {
        if (other.storagePoolId != null)
            return false;
    } else if (!storagePoolId.equals(other.storagePoolId))
        return false;
    if (vdsId == null) {
        if (other.vdsId != null)
            return false;
    } else if (!vdsId.equals(other.vdsId))
        return false;
    return true;
}
#end_block

#method_before
@Override
public String toString() {
    return "Event [storagePoolId=" + storagePoolId + ", domainId=" + domainId + ", eventType=" + eventType + "]";
}
#method_after
@Override
public String toString() {
    return "Event [eventType=" + eventType + ", storagePoolId=" + storagePoolId + ", domainId=" + domainId + ", vdsId=" + vdsId + "]";
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static <V> Future<V> execute(FutureTask<V> command) {
    try {
        return (Future<V>) es.submit(command);
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. A submitted task was rejected");
        throw e;
    }
}
#method_after
@SuppressWarnings("unchecked")
public static <V> Future<V> execute(FutureTask<V> command) {
    try {
        return (Future<V>) es.submit(command);
    } catch (RejectedExecutionException e) {
        log.warn("The thread pool is out of limit. The submitted event was rejected");
        throw e;
    }
}
#end_block

#method_before
@Override
public void submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            task.get();
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e.getMessage());
        }
    }
}
#method_after
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e.getMessage());
        }
    }
    return null;
}
#end_block

#method_before
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECONSTRUCT:
                    log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    break;
                default:
                    task = new FutureTask<EventResult>(callable);
                    getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
                    break;
            }
        } else {
            task = new FutureTask<EventResult>(callable);
            getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueuRunnable(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#method_after
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECONSTRUCT:
                    log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    break;
                default:
                    task = new FutureTask<EventResult>(callable);
                    getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
                    break;
            }
        } else {
            task = new FutureTask<EventResult>(callable);
            getEventQueue(storagePoolId).add(new Pair<Event, FutureTask<EventResult>>(event, task));
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    storage_domains masterDomain = getNewMaster(false);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getstorage_type()).ConnectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    storage_domains masterDomain = getNewMaster(false);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getstorage_type()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in pool {1}. error {2}", vds.getId(), getStoragePool().getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in pool {1}. error {2}", vds.getId(), getStoragePool().getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecuter(tasks).execute();
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    final boolean isPerformConnectOps = !_isLastMaster && commandSucceeded;
    final boolean isPerformDisconnect = !getParameters().isInactive();
    if (isPerformConnectOps || isPerformDisconnect) {
        List<Runnable> tasks = new LinkedList<Runnable>();
        for (final VDS vds : getAllRunningVdssInPool()) {
            tasks.add(new Runnable() {

                @Override
                public void run() {
                    try {
                        if (isPerformConnectOps && connectVdsToNewMaster(vds)) {
                            try {
                                runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                            } catch (VdcBLLException ex) {
                                if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                                    VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                                    if (!returnVal.getSucceeded()) {
                                        log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                                    }
                                } else {
                                    log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                                }
                            }
                        }
                        // only if we deactivate the storage domain we want to disconnect from it.
                        if (isPerformDisconnect) {
                            StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
                        }
                    } catch (Exception e) {
                        log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                    }
                }
            });
        }
        new LatchedRunnableExecutor(tasks).execute();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            VmCommand.updateVmInSpm(getStoragePool().getId(), vmsInPool);
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded && performConnectOperations(vds)) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded && connectVdsToNewMaster(vds)) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StorageDomainStatic storage = DbFacade.getInstance().getStorageDomainStaticDao().get(getParameters().getStorageDomainId());
    if (storage.getstorage_domain_type() == StorageDomainType.ImportExport) {
        VDSReturnValue retVal = null;
        try {
            retVal = executeVerb();
        } catch (RuntimeException e) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.AddCustomValue("StorageDomainName", storage.getstorage_name());
            AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
            throw e;
        }
        buildOvfReturnValue(retVal.getReturnValue());
    } else {
        getQueryReturnValue().setReturnValue(new java.util.ArrayList<VM>());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomainStatic storage = DbFacade.getInstance().getStorageDomainStaticDao().get(getParameters().getStorageDomainId());
    if (storage.getstorage_domain_type() == StorageDomainType.ImportExport) {
        VDSReturnValue retVal = null;
        retVal = executeVerb(storage);
        buildOvfReturnValue(retVal.getReturnValue());
    } else {
        getQueryReturnValue().setReturnValue(new java.util.ArrayList<VM>());
    }
}
#end_block

#method_before
protected VDSReturnValue executeVerb() {
    GetVmsInfoVDSCommandParameters tempVar = new GetVmsInfoVDSCommandParameters(getParameters().getStoragePoolId());
    tempVar.setStorageDomainId(getParameters().getStorageDomainId());
    tempVar.setVmIdList(getParameters().getIds());
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetVmsInfo, tempVar);
    return retVal;
}
#method_after
protected VDSReturnValue executeVerb(StorageDomainStatic storage) {
    try {
        GetVmsInfoVDSCommandParameters tempVar = new GetVmsInfoVDSCommandParameters(getParameters().getStoragePoolId());
        tempVar.setStorageDomainId(getParameters().getStorageDomainId());
        tempVar.setVmIdList(getParameters().getIds());
        VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetVmsInfo, tempVar);
        return retVal;
    } catch (RuntimeException e) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.AddCustomValue("StorageDomainName", storage.getstorage_name());
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
        throw e;
    }
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.REFRESH_REPOSITORY_FILE_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    // External Events/Alerts
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_NORMAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.EXTERNAL_EVENT_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.EXTERNAL_ALERT, AuditLogSeverity.ALERT);
}
#end_block

#method_before
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        if ((message = mMessages.get(logType)) != null) {
            String resolvedMessage = resolveMessage(message, auditLogable);
            AuditLogSeverity severity = AuditLogSeverity.forValue(0);
            if (!((severity = mSeverities.get(logType)) != null)) {
                severity = AuditLogSeverity.NORMAL;
                log.infoFormat("No severity for {0} type", logType);
            }
            AuditLog auditLog;
            if (auditLogable != null) {
                AuditLog tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                auditLog = tempVar;
            } else {
                auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
            }
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        } else if (auditLogable != null) {
            log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
            defaultLog(auditLogable);
        }
    }
}
#method_after
public static void log(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    updateTimeoutLogableObject(auditLogable, logType);
    if (auditLogable == null || auditLogable.getLegal()) {
        String message = null;
        String resolvedMessage = null;
        AuditLogSeverity severity = AuditLogSeverity.forValue(0);
        if (!((severity = mSeverities.get(logType)) != null)) {
            severity = AuditLogSeverity.NORMAL;
            log.infoFormat("No severity for {0} type", logType);
        }
        AuditLog auditLog = null;
        if (auditLogable != null) {
            AuditLog tempVar = null;
            // handle external log messages invoked by plugins via the API
            if (auditLogable.isExternal()) {
                // message is sent as an argument, no need to resolve.
                resolvedMessage = message = loggerString;
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName(), auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
            } else if ((message = mMessages.get(logType)) != null) {
                // Application log message from AuditLogMessages
                resolvedMessage = resolveMessage(message, auditLogable);
                tempVar = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
            }
            if (tempVar != null) {
                tempVar.setstorage_domain_id(auditLogable.getStorageDomainId());
                tempVar.setstorage_domain_name(auditLogable.getStorageDomainName());
                tempVar.setstorage_pool_id(auditLogable.getStoragePoolId());
                tempVar.setstorage_pool_name(auditLogable.getStoragePoolName());
                tempVar.setvds_group_id(auditLogable.getVdsGroupId());
                tempVar.setvds_group_name(auditLogable.getVdsGroupName());
                tempVar.setCorrelationId(auditLogable.getCorrelationId());
                tempVar.setJobId(auditLogable.getJobId());
                tempVar.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
                tempVar.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
                tempVar.setExternal(auditLogable.isExternal());
                auditLog = tempVar;
            }
        } else {
            auditLog = new AuditLog(logType, severity, resolvedMessage, null, null, null, null, null, null, null, null);
        }
        if (auditLog != null) {
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
            if (!"".equals(loggerString)) {
                log.infoFormat(loggerString, resolvedMessage);
            }
        }
    } else if (auditLogable != null) {
        log.infoFormat("No string for {0} type. Use default Log", auditLogable.getAuditLogTypeValue());
        defaultLog(auditLogable);
    }
}
#end_block

#method_before
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    if (logType.getDuplicateEventsIntervalValue() > 0) {
        auditLogable.setEndTime(DateTime.getNow().AddSeconds(logType.getDuplicateEventsIntervalValue()));
        auditLogable.setTimeoutObjectId(ComposeObjectId(auditLogable, logType));
    }
}
#method_after
private static void updateTimeoutLogableObject(AuditLogableBase auditLogable, AuditLogType logType) {
    int duplicateEventsIntrvalValue = (auditLogable.isExternal()) ? // Min duration for External Events is 30 sec
    Math.max(auditLogable.getEventFloodInSec(), 30) : logType.getDuplicateEventsIntervalValue();
    if (duplicateEventsIntrvalValue > 0) {
        auditLogable.setEndTime(DateTime.getNow().AddSeconds(logType.getDuplicateEventsIntervalValue()));
        auditLogable.setTimeoutObjectId(ComposeObjectId(auditLogable, logType));
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing EndAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getSnapshotDao().get(getParameters().getDstSnapshotId()), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getCompensationContext());
    getVmDAO().incrementVmDbGeneration(getVm().getId());
}
#method_after
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    snapshotsManager.attempToRestoreVmConfigurationFromSnapshot(getVm(), getSnapshotDao().get(getParameters().getDstSnapshotId()), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getCompensationContext());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final Guid newActiveSnapshotId = Guid.NewGuid();
    final List<DiskImage> images = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForVmSnapshot(getParameters().getDstSnapshotId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
            getCompensationContext().snapshotEntity(previousActiveSnapshot);
            Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
            getSnapshotDao().remove(previousActiveSnapshotId);
            snapshotsManager.addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), getCompensationContext());
            snapshotsManager.addActiveSnapshot(newActiveSnapshotId, getVm(), getCompensationContext());
            snapshotsManager.removeAllIllegalDisks(previousActiveSnapshotId, getVm().getId());
            // the update is being executed in the same transaction so we can restore the vm config and end the command.
            if (!images.isEmpty()) {
                getCompensationContext().stateChanged();
            } else {
                getVmStaticDAO().incrementDbGeneration(getVm().getId());
                restoreVmConfigFromSnapshot();
            }
            return null;
        }
    });
    if (images.size() > 0) {
        VmHandler.LockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : images) {
                    ImagesContainterParametersBase tempVar = new ImagesContainterParametersBase(image.getImageId());
                    tempVar.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                    tempVar.setVmSnapshotId(newActiveSnapshotId);
                    tempVar.setEntityId(getParameters().getEntityId());
                    tempVar.setParentParameters(getParameters());
                    tempVar.setQuotaId(image.getQuotaId());
                    ImagesContainterParametersBase p = tempVar;
                    VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.TryBackToSnapshot, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                    getParameters().getImagesParameters().add(p);
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new VdcBLLException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                return null;
            }
        });
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmHandler.updateDisksFromDb(getVm());
    Collection<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, true);
    DiskImage vmDisk = LinqUtils.first(diskImages);
    boolean result = true;
    Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    result = result && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.snapshotExists(snapshot)) && validate(snapshotsValidator.snapshotNotBroken(snapshot));
    if (vmDisk != null) {
        result = result && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, false, false, true, true, true, true, getVm().getDiskMap().values());
    }
    if (result && LinqUtils.foreach(diskImages, new Function<DiskImage, Guid>() {

        @Override
        public Guid eval(DiskImage disk) {
            return disk.getvm_snapshot_id().getValue();
        }
    }).contains(getParameters().getDstSnapshotId())) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.CANNOT_PREIEW_CURRENT_IMAGE);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__PREVIEW);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    VmHandler.updateDisksFromDb(getVm());
    Collection<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, true);
    DiskImage vmDisk = LinqUtils.first(diskImages);
    boolean result = true;
    Snapshot snapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    result = result && validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotsValidator.snapshotExists(snapshot)) && validate(snapshotsValidator.snapshotNotBroken(snapshot));
    if (vmDisk != null) {
        result = result && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, false, false, true, true, true, true, getVm().getDiskMap().values());
    }
    if (result && LinqUtils.foreach(diskImages, new Function<DiskImage, Guid>() {

        @Override
        public Guid eval(DiskImage disk) {
            return disk.getvm_snapshot_id().getValue();
        }
    }).contains(getParameters().getDstSnapshotId())) {
        result = false;
        addCanDoActionMessage(VdcBllMessages.CANNOT_PREIEW_CURRENT_IMAGE);
    }
    if (!result) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__PREVIEW);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__SNAPSHOT);
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    getVmDAO().incrementVmDbGeneration(getVm().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    VM oldVm = getVm();
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    VmStatic newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setcreation_date(oldVm.getStaticData().getcreation_date());
    if (newVmStatic.getcreation_date().equals(DateTime.getMinValue())) {
        newVmStatic.setcreation_date(new Date());
    }
    UpdateVmNetworks();
    getVmStaticDAO().update(newVmStatic);
    updateVmPayload();
    VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
    setSucceeded(true);
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceType.DISK.getName());
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getVmId()), VmDeviceType.DISK, payload.getType(), payload.getSpecParams(), true, true);
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceType.DISK.getName());
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getVmId()), VmDeviceType.DISK, payload.getType(), payload.getSpecParams(), true, true);
        }
    }
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getvds_group_id().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return iface.getNetworkName().equals(n.getname());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getVdsGroupId().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return n.getName().equals(iface.getNetworkName());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getvm_name())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getvm_name(), vmFromParams.getvm_name())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getvm_name())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.getauto_startup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getos(), vmFromParams.getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getvds_group_id().equals(vmFromParams.getvds_group_id())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getdefault_display_type(), vmFromParams.getnum_of_monitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getnum_of_monitors() < vmFromParams.getnum_of_monitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getnum_of_monitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.getis_stateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getnum_of_sockets(), vmFromParams.getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getiso_path())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getusb_policy(), vmFromParams.getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!isPinningAndMigrationValid(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getVmName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getVmName(), vmFromParams.getVmName())) {
        boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(vmFromParams.getVmName())).getReturnValue();
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromParams.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(vmFromParams.getOs(), vmFromParams.getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // if number of monitors has increased, check PCI and IDE limits are ok
    if (vmFromDB.getNumOfMonitors() < vmFromParams.getNumOfMonitors()) {
        List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getVmId());
        List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
        if (!checkPciAndIdeLimit(vmFromParams.getNumOfMonitors(), interfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (!VmTemplateCommand.IsVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.CheckCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_AND_MIGRATABLE);
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    return true;
}
#end_block

#method_before
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getstatus());
}
#method_after
protected boolean areUpdatedFieldsLegal() {
    return VmHandler.mUpdateVmsStatic.IsUpdateValid(getVm().getStaticData(), getParameters().getVmStaticData(), getVm().getStatus());
}
#end_block

#method_before
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getvm_name())) {
        return Collections.singletonMap(getParameters().getVm().getvm_name(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#method_after
@Override
protected Map<String, String> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getVmName())) {
        return Collections.singletonMap(getParameters().getVm().getVmName(), LockingGroup.VM_NAME.name());
    }
    return null;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getstatus() == VMStatus.Down || getVm().getstatus() == VMStatus.Suspended || getVm().getstatus() == VMStatus.ImageIllegal || getVm().getstatus() == VMStatus.ImageLocked || getVm().getstatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() != null && !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getvmt_cpu_per_socket() * getVm().getnum_of_sockets(), getVm().getmem_size_mb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    // The cases must be persistent with the create_functions_sp
    if (getVm().getStatus() == VMStatus.Down || getVm().getStatus() == VMStatus.Suspended || getVm().getStatus() == VMStatus.ImageIllegal || getVm().getStatus() == VMStatus.ImageLocked || getVm().getStatus() == VMStatus.PoweringDown) {
        list.add(new QuotaSanityParameter(getParameters().getVmStaticData().getQuotaId(), null));
    } else {
        if (getParameters().getVmStaticData().getQuotaId() == null || getParameters().getVmStaticData().getQuotaId().equals(NGuid.Empty) || !getParameters().getVmStaticData().getQuotaId().equals(getVm().getQuotaId())) {
            list.add(new QuotaVdsGroupConsumptionParameter(getVm().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.RELEASE, getVdsGroupId(), getVm().getVmtCpuPerSocket() * getVm().getNumOfSockets(), getVm().getMemSizeMb()));
            list.add(new QuotaVdsGroupConsumptionParameter(getParameters().getVmStaticData().getQuotaId(), null, QuotaConsumptionParameter.QuotaAction.CONSUME, getParameters().getVmStaticData().getvds_group_id(), getParameters().getVmStaticData().getcpu_per_socket() * getParameters().getVmStaticData().getnum_of_sockets(), getParameters().getVmStaticData().getmem_size_mb()));
        }
    }
    return list;
}
#end_block

#method_before
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getstorage_pool_id());
        }
    }
    return super.getStoragePoolId();
}
#method_after
@Override
public NGuid getStoragePoolId() {
    if (super.getStoragePoolId() == null) {
        VM vm = getVm();
        if (vm != null) {
            setStoragePoolId(vm.getStoragePoolId());
        }
    }
    return super.getStoragePoolId();
}
#end_block

#method_before
protected void removeVmUsers() {
    List<tags_vm_map> all = getTagDao().getTagVmMapByVmIdAndDefaultTag(getVmId());
    for (tags_vm_map tagVm : all) {
        getTagDao().detachVmFromTag(tagVm.gettag_id(), getVmId());
    }
}
#method_after
protected void removeVmUsers() {
    List<TagsVmMap> all = getTagDao().getTagVmMapByVmIdAndDefaultTag(getVmId());
    for (TagsVmMap tagVm : all) {
        getTagDao().detachVmFromTag(tagVm.gettag_id(), getVmId());
    }
}
#end_block

#method_before
protected void endVmCommand() {
    endActionOnDisks();
    endActionOnVmConfiguration();
    setSucceeded(true);
}
#method_after
protected void endVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    unlockVm();
    setSucceeded(true);
}
#end_block

#method_before
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().gethibernation_vol_handle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getvds_group_compatibility_version().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#method_after
protected boolean handleHibernatedVm(VdcActionType parentCommand, boolean startPollingTasks) {
    // this is temp code until it will be implemented in SPM
    String[] strings = getVm().getHibernationVolHandle().split(",");
    List<Guid> guids = new LinkedList<Guid>();
    for (String string : strings) {
        guids.add(new Guid(string));
    }
    Guid[] imagesList = guids.toArray(new Guid[0]);
    if (imagesList.length == 6) {
        // get all vm disks in order to check post zero - if one of the
        // disks is marked with wipe_after_delete
        boolean postZero = LinqUtils.filter(getDiskDao().getAllForVm(getVm().getId()), new Predicate<Disk>() {

            @Override
            public boolean eval(Disk disk) {
                return disk.isWipeAfterDelete();
            }
        }).size() > 0;
        // delete first image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue1 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[2], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue1.getSucceeded()) {
            return false;
        }
        Guid guid1 = createTask(vdsRetValue1.getCreationInfo(), parentCommand, VdcObjectType.Storage, imagesList[0]);
        getTaskIdList().add(guid1);
        // delete second image
        // the next 'DeleteImageGroup' command should also take care of the
        // image removal:
        VDSReturnValue vdsRetValue2 = runVdsCommand(VDSCommandType.DeleteImageGroup, new DeleteImageGroupVDSCommandParameters(imagesList[1], imagesList[0], imagesList[4], postZero, false, getVm().getVdsGroupCompatibilityVersion().toString()));
        if (!vdsRetValue2.getSucceeded()) {
            if (startPollingTasks) {
                updateTasksWithActionParameters();
                AsyncTaskManager.getInstance().StartPollingTask(guid1);
            }
            return false;
        }
        Guid guid2 = createTask(vdsRetValue2.getCreationInfo(), parentCommand);
        getTaskIdList().add(guid2);
        if (startPollingTasks) {
            updateTasksWithActionParameters();
            AsyncTaskManager.getInstance().StartPollingTask(guid1);
            AsyncTaskManager.getInstance().StartPollingTask(guid2);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getvm_name();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getvm_os().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#method_after
protected boolean isVmNameValidLength(VM vm) {
    // get VM name
    String vmName = vm.getVmName();
    // get the max VM name (configuration parameter)
    int maxVmNameLengthWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthWindows);
    int maxVmNameLengthNonWindows = Config.<Integer>GetValue(ConfigValues.MaxVmNameLengthNonWindows);
    // names are allowed different lengths in Windows and non-Windows OSs,
    // consider this when setting the max length.
    int maxLength = vm.getVmOs().isWindows() ? maxVmNameLengthWindows : maxVmNameLengthNonWindows;
    // check if name is longer than allowed name
    boolean nameLengthValid = (vmName.length() <= maxLength);
    // return result
    return nameLengthValid;
}
#end_block

#method_before
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getos().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isOsSupportingHotPlug() {
    String vmOs = getVm().getOs().name();
    String[] unsupportedOSs = Config.<String>GetValue(ConfigValues.HotPlugUnsupportedOsList).split(",");
    for (String os : unsupportedOSs) {
        if (os.equalsIgnoreCase(vmOs)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getstorage_pool_id());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!CheckTemplateInStorageDomain(getVm().getstorage_pool_id(), getParameters().getStorageDomainId(), getVm().getvmt_guid())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getvmt_name()));
            return false;
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : getDisksBasedOnImage()) {
            if (images.containsKey(img.getId())) {
                // mode)
                if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        return false;
    }
    // check destination storage have free space
    int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
    if (!StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    setDescription(getVmName());
    setStoragePoolId(getVm().getStoragePoolId());
    // check that target domain exists
    StorageDomainValidator targetstorageDomainValidator = new StorageDomainValidator(getStorageDomain());
    if (!targetstorageDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // load the disks of vm from database
    VmHandler.updateDisksFromDb(getVm());
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    // check that the target and source domain are in the same storage_pool
    if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        return false;
    }
    // check if template exists only if asked for
    if (getParameters().getTemplateMustExists()) {
        if (!CheckTemplateInStorageDomain(getVm().getStoragePoolId(), getParameters().getStorageDomainId(), getVm().getVmtGuid())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_EXPORT_DOMAIN);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", getVm().getVmtName()));
            return false;
        }
    }
    Map<Guid, ? extends Disk> images = getVm().getDiskMap();
    // check that the images requested format are valid (COW+Sparse)
    if (!ImagesHandler.CheckImagesConfiguration(getParameters().getStorageDomainId(), new ArrayList<Disk>(images.values()), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getCopyCollapse()) {
        for (DiskImage img : getDisksBasedOnImage()) {
            if (images.containsKey(img.getId())) {
                // mode)
                if (((DiskImage) images.get(img.getId())).getvolume_format() == VolumeFormat.RAW && img.getvolume_format() != VolumeFormat.RAW) {
                    addCanDoActionMessage(VdcBllMessages.VM_CANNOT_EXPORT_RAW_FORMAT);
                    return false;
                }
            }
        }
    }
    // check destination storage is Export domain
    if (getStorageDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
        return false;
    }
    // check destination storage have free space
    int sizeInGB = (int) getVm().getActualDiskWithSnapshotsSize();
    if (!StorageDomainSpaceChecker.hasSpaceForRequest(getStorageDomain(), sizeInGB)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
        return false;
    }
    if (!(checkVmInStorageDomain() && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, false, true, false, false, true, true, true, true, getDisksBasedOnImage()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    VmHandler.updateDisksFromDb(vm);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    for (Disk disk : vm.getDiskMap().values()) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.setParentId(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
            DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
            diskImage.setvolume_format(diskForVolumeInfo.getvolume_format());
            diskImage.setvolume_type(diskForVolumeInfo.getvolume_type());
            VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
            if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
                DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
                diskImage.setactual_size(fromVdsm.getactual_size());
            }
            AllVmImages.add(diskImage);
        }
    }
    if (StringUtils.isEmpty(vm.getvmt_name())) {
        VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getvmt_guid());
        vm.setvmt_name(t.getname());
    }
    getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
    List<Guid> imageGroupIds = new ArrayList<Guid>();
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageGroupIds.add(disk.getId());
        }
    }
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#method_after
public boolean updateCopyVmInSpm(Guid storagePoolId, VM vm, Guid storageDomainId) {
    HashMap<Guid, KeyValuePairCompat<String, List<Guid>>> vmsAndMetaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfManager ovfManager = new OvfManager();
    ArrayList<DiskImage> AllVmImages = new ArrayList<DiskImage>();
    VmHandler.updateDisksFromDb(vm);
    List<VmNetworkInterface> interfaces = vm.getInterfaces();
    if (interfaces != null) {
        // TODO remove this when the API changes
        interfaces.clear();
        interfaces.addAll(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()));
    }
    for (Disk disk : vm.getDiskMap().values()) {
        if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
            DiskImage diskImage = (DiskImage) disk;
            diskImage.setParentId(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            diskImage.setstorage_ids(new ArrayList<Guid>(Arrays.asList(storageDomainId)));
            DiskImage diskForVolumeInfo = getDiskForVolumeInfo(diskImage);
            diskImage.setvolume_format(diskForVolumeInfo.getvolume_format());
            diskImage.setvolume_type(diskForVolumeInfo.getvolume_type());
            VDSReturnValue vdsReturnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskImage.getId(), diskImage.getImageId()));
            if (vdsReturnValue != null && vdsReturnValue.getSucceeded()) {
                DiskImage fromVdsm = (DiskImage) vdsReturnValue.getReturnValue();
                diskImage.setactual_size(fromVdsm.getactual_size());
            }
            AllVmImages.add(diskImage);
        }
    }
    if (StringUtils.isEmpty(vm.getVmtName())) {
        VmTemplate t = DbFacade.getInstance().getVmTemplateDao().get(vm.getVmtGuid());
        vm.setVmtName(t.getname());
    }
    getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    String vmMeta = ovfManager.ExportVm(vm, AllVmImages);
    List<Guid> imageGroupIds = new ArrayList<Guid>();
    for (Disk disk : vm.getDiskMap().values()) {
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            imageGroupIds.add(disk.getId());
        }
    }
    vmsAndMetaDictionary.put(vm.getId(), new KeyValuePairCompat<String, List<Guid>>(vmMeta, imageGroupIds));
    UpdateVMVDSCommandParameters tempVar = new UpdateVMVDSCommandParameters(storagePoolId, vmsAndMetaDictionary);
    tempVar.setStorageDomainId(storageDomainId);
    return Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVM, tempVar).getSucceeded();
}
#end_block

#method_before
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getstorage_pool_id(), getParameters().getStorageDomainId());
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = (ArrayList<VM>) qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getvm_name().equals(getVm().getvm_name())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#method_after
protected boolean checkVmInStorageDomain() {
    boolean retVal = true;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getVm().getStoragePoolId(), getParameters().getStorageDomainId());
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        ArrayList<VM> vms = (ArrayList<VM>) qretVal.getReturnValue();
        for (VM vm : vms) {
            if (vm.getId().equals(getVm().getId())) {
                if (!getParameters().getForceOverride()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_GUID_ALREADY_EXIST);
                    retVal = false;
                    break;
                }
            } else if (vm.getVmName().equals(getVm().getVmName())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_ALREADY_EXIST);
                retVal = false;
                break;
            }
        }
    }
    return retVal;
}
#end_block

#method_before
public static boolean CheckTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    tempVar.setGetAll(true);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BlankVmTemplateId.equals(tmplId)) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#method_after
public static boolean CheckTemplateInStorageDomain(Guid storagePoolId, Guid storageDomainId, final Guid tmplId) {
    boolean retVal = false;
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
    if (qretVal.getSucceeded()) {
        if (!VmTemplateHandler.BlankVmTemplateId.equals(tmplId)) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            VmTemplate tmpl = LinqUtils.firstOrNull(templates.keySet(), new Predicate<VmTemplate>() {

                @Override
                public boolean eval(VmTemplate vmTemplate) {
                    return vmTemplate.getId().equals(tmplId);
                }
            });
            retVal = tmpl != null;
        } else {
            retVal = true;
        }
    }
    return retVal;
}
#end_block

#method_before
protected boolean updateVmImSpm() {
    VmHandler.updateDisksFromDb(getVm());
    return OvfDataUpdater.executeUpdateVmInSpmCommand(getVm().getstorage_pool_id(), OvfDataUpdater.getVmsMetadataDictionary(getVm().getstorage_pool_id(), Arrays.asList(getVm())), getParameters().getStorageDomainId());
}
#method_after
protected boolean updateVmImSpm() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfDataUpdater.getInstance().loadVmData(getVm());
    VmHandler.updateDisksFromDb(getVm());
    OvfDataUpdater.getInstance().buildMetadataDictionaryForVm(getVm(), metaDictionary);
    return OvfDataUpdater.getInstance().executeUpdateVmInSpmCommand(getVm().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
}
#end_block

#method_before
private void endCopyCollapseOperations(VM vm) {
    vm.setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    vm.setvmt_name(null);
    Snapshot activeSnapshot = DbFacade.getInstance().getSnapshotDao().get(DbFacade.getInstance().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    updateCopyVmInSpm(getVm().getstorage_pool_id(), vm, getParameters().getStorageDomainId());
}
#method_after
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    vm.setVmtName(null);
    Snapshot activeSnapshot = DbFacade.getInstance().getSnapshotDao().get(DbFacade.getInstance().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        if (!isDiskExist(_oldDisk)) {
            return false;
        }
        List<VM> listVms = getVmDAO().getForDisk(_oldDisk.getId()).get(Boolean.TRUE);
        buidSharedLockMap(listVms);
        buidExclusiveLockMap(listVms);
        acquireLockInternal();
        // Check if all VMs are in status down.
        if (listVms != null && !listVms.isEmpty()) {
            for (VM vm : listVms) {
                if (vm.getstatus() != VMStatus.Down) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
        retValue = checkCanPerformRegularUpdate();
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist()) {
        return false;
    }
    if (!isDiskExist(oldDisk)) {
        return false;
    }
    List<VM> vmsDiskPluggedTo = getVmDAO().getForDisk(oldDisk.getId()).get(Boolean.TRUE);
    if (vmsDiskPluggedTo != null && !vmsDiskPluggedTo.isEmpty()) {
        buildSharedLockMap(vmsDiskPluggedTo);
        buildExclusiveLockMap(vmsDiskPluggedTo);
        acquireLockInternal();
        // Check if all VMs are in status down.
        for (VM vm : vmsDiskPluggedTo) {
            if (vm.getStatus() != VMStatus.Down) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
            }
        }
    }
    return checkCanPerformRegularUpdate();
}
#end_block

#method_before
private boolean checkCanPerformRegularUpdate() {
    boolean retValue = true;
    if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(_oldDisk.getId());
            }
        }));
        allVmDisks.add(getParameters().getDiskInfo());
        if (!checkPciAndIdeLimit(getVm().getnum_of_monitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            retValue = false;
        }
    }
    // Validate update boot disk.
    if (retValue && getParameters().getDiskInfo().isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(_oldDisk.getId())) {
                retValue = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                break;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    return retValue && validateShareableDisk();
}
#method_after
private boolean checkCanPerformRegularUpdate() {
    if (oldDisk.getDiskInterface() != newDisk.getDiskInterface()) {
        List<VmNetworkInterface> allVmInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getVmId());
        List<Disk> allVmDisks = getDiskDao().getAllForVm(getVmId());
        allVmDisks.removeAll(LinqUtils.filter(allVmDisks, new Predicate<Disk>() {

            @Override
            public boolean eval(Disk o) {
                return o.getId().equals(oldDisk.getId());
            }
        }));
        allVmDisks.add(newDisk);
        if (!checkPciAndIdeLimit(getVm().getNumOfMonitors(), allVmInterfaces, allVmDisks, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // Validate update boot disk.
    if (newDisk.isBoot()) {
        VmHandler.updateDisksFromDb(getVm());
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.isBoot() && !disk.getId().equals(oldDisk.getId())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                return false;
            }
        }
    }
    // Set disk alias name in the disk retrieved from the parameters.
    ImagesHandler.setDiskAlias(newDisk, getVm());
    return validateShareableDisk();
}
#end_block

#method_before
protected boolean validateShareableDisk() {
    if (DiskStorageType.LUN == _oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = getParameters().getDiskInfo().isShareable();
    boolean isDiskShareable = _oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(_oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) _oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(_oldDisk, getStoragePoolDAO().get(getVm().getstorage_pool_id()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) getParameters().getDiskInfo();
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) _oldDisk).setvm_snapshot_id(null);
    } else if (isDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(_oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) _oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#method_after
private boolean validateShareableDisk() {
    if (DiskStorageType.LUN == oldDisk.getDiskStorageType()) {
        return true;
    }
    boolean isDiskUpdatedToShareable = newDisk.isShareable();
    boolean isOldDiskShareable = oldDisk.isShareable();
    // Check if VM is not during snapshot.
    if (getSnapshotDao().exists(getVmId(), SnapshotStatus.IN_PREVIEW)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
        return false;
    }
    if (!isOldDiskShareable && isDiskUpdatedToShareable) {
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(oldDisk.getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) oldDisk).getit_guid())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
            return false;
        }
        if (!isVersionSupportedForShareable(oldDisk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
            return false;
        }
        DiskImage diskImage = (DiskImage) newDisk;
        if (!isVolumeFormatSupportedForShareable(diskImage.getvolume_format())) {
            addCanDoActionMessage(VdcBllMessages.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
            return false;
        }
        // If user want to update the disk to be shareable then update the vm snapshot id to be null.
        ((DiskImage) oldDisk).setvm_snapshot_id(null);
    } else if (isOldDiskShareable && !isDiskUpdatedToShareable) {
        if (getVmDAO().getVmsListForDisk(oldDisk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
            return false;
        }
        // If disk is not floating, then update its vm snapshot id to the active VM snapshot.
        ((DiskImage) oldDisk).setvm_snapshot_id(DbFacade.getInstance().getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE).getValue());
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (listPermissionSubjects == null) {
        listPermissionSubjects = new ArrayList<PermissionSubject>();
        Guid diskId = _oldDisk == null ? null : _oldDisk.getId();
        listPermissionSubjects.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    }
    return listPermissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (listPermissionSubjects == null) {
        listPermissionSubjects = new ArrayList<PermissionSubject>();
        Guid diskId = oldDisk == null ? null : oldDisk.getId();
        listPermissionSubjects.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.EDIT_DISK_PROPERTIES));
    }
    return listPermissionSubjects;
}
#end_block

#method_before
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            clearAddressOnInterfaceChange();
            _oldDisk.setBoot(getParameters().getDiskInfo().isBoot());
            _oldDisk.setDiskInterface(getParameters().getDiskInfo().getDiskInterface());
            _oldDisk.setPropagateErrors(getParameters().getDiskInfo().getPropagateErrors());
            _oldDisk.setWipeAfterDelete(getParameters().getDiskInfo().isWipeAfterDelete());
            _oldDisk.setDiskAlias(getParameters().getDiskInfo().getDiskAlias());
            _oldDisk.setDiskDescription(getParameters().getDiskInfo().getDiskDescription());
            _oldDisk.setShareable(getParameters().getDiskInfo().isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(_oldDisk);
            if (_oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) _oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            getVmDAO().incrementVmDbGeneration(getVm().getId());
            setSucceeded(true);
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (_oldDisk.getDiskInterface() != getParameters().getDiskInfo().getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(_oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#method_after
private void performDiskUpdate() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            clearAddressOnInterfaceChange();
            oldDisk.setBoot(newDisk.isBoot());
            oldDisk.setDiskInterface(newDisk.getDiskInterface());
            oldDisk.setPropagateErrors(newDisk.getPropagateErrors());
            oldDisk.setWipeAfterDelete(newDisk.isWipeAfterDelete());
            oldDisk.setDiskAlias(newDisk.getDiskAlias());
            oldDisk.setDiskDescription(newDisk.getDiskDescription());
            oldDisk.setShareable(newDisk.isShareable());
            DbFacade.getInstance().getBaseDiskDao().update(oldDisk);
            if (oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) oldDisk;
                diskImage.setQuotaId(getQuotaId());
                getImageDao().update(diskImage.getImage());
            }
            // update cached image
            VmHandler.updateDisksFromDb(getVm());
            // update vm device boot order
            VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
            setSucceeded(true);
            return null;
        }

        private void clearAddressOnInterfaceChange() {
            // clear the disk address if the type has changed
            if (oldDisk.getDiskInterface() != newDisk.getDiskInterface()) {
                getVmDeviceDao().clearDeviceAddress(getVmDeviceDao().get(new VmDeviceId(oldDisk.getId(), getVmId())).getDeviceId());
            }
        }
    });
}
#end_block

#method_before
@Override
public String getDiskAlias() {
    return _oldDisk.getDiskAlias();
}
#method_after
@Override
public String getDiskAlias() {
    return oldDisk.getDiskAlias();
}
#end_block

#method_before
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == _oldDisk.getDiskStorageType();
}
#method_after
private boolean isQuotaValidationNeeded() {
    return DiskStorageType.IMAGE == oldDisk.getDiskStorageType();
}
#end_block

#method_before
private Guid getQuotaId() {
    if (getParameters().getDiskInfo() != null && isQuotaValidationNeeded()) {
        return ((DiskImage) getParameters().getDiskInfo()).getQuotaId();
    }
    return null;
}
#method_after
private Guid getQuotaId() {
    if (newDisk != null && isQuotaValidationNeeded()) {
        return ((DiskImage) newDisk).getQuotaId();
    }
    return null;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) _oldDisk;
        DiskImage newDiskImage = (DiskImage) getParameters().getDiskInfo();
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    if (isQuotaValidationNeeded()) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        DiskImage newDiskImage = (DiskImage) newDisk;
        if (oldDiskImage.getQuotaId() == null || !oldDiskImage.getQuotaId().equals(newDiskImage.getQuotaId())) {
            if (oldDiskImage.getQuotaId() != null && !Guid.Empty.equals(oldDiskImage.getQuotaId())) {
                list.add(new QuotaStorageConsumptionParameter(oldDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.RELEASE, // TODO: Shared Disk?
                oldDiskImage.getstorage_ids().get(0), (double) oldDiskImage.getSizeInGigabytes()));
            }
            list.add(new QuotaStorageConsumptionParameter(newDiskImage.getQuotaId(), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, // TODO: Shared Disk?
            newDiskImage.getstorage_ids().get(0), (double) newDiskImage.getSizeInGigabytes()));
        }
    }
    return list;
}
#end_block

#method_before
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmDAO().incrementVmDbGeneration(getParameters().getVmStaticData().getId());
    }
    return ret;
}
#method_after
protected boolean ConcreteAddVmImages(Guid itGuid) {
    boolean ret = true;
    if (getVmDisks().size() > 0) {
        for (Disk diskInfo : getVmDisks()) {
            VdcReturnValueBase tmpRetValue = null;
            AddImageFromScratchParameters tempVar = new AddImageFromScratchParameters(itGuid, getParameters().getVmStaticData().getId(), (DiskImage) diskInfo);
            tempVar.setStorageDomainId(this.getStorageDomainId().getValue());
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVmFromScratch);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tmpRetValue = Backend.getInstance().runInternalAction(VdcActionType.AddImageFromScratch, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (!tmpRetValue.getSucceeded()) {
                log.error("AddVmFromScratchCommand::ConcreteAddVmImages: AddImageFromScratch Command failed.");
                ret = false;
            } else // the AddImageFromScratch task created ended successfully:
            {
                getReturnValue().getTaskIdList().addAll(tmpRetValue.getInternalTaskIdList());
            }
        }
        VmHandler.LockVm(getParameters().getVmStaticData().getId());
    } else {
        // if no disks send update vm here
        getVmStaticDao().incrementDbGeneration(getVm().getId());
    }
    return ret;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                storage_domain_static targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(StringUtils.EMPTY);
        }
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<VmNetworkInterface> interfaces = getVmTemplate().getInterfaces();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVmTemplate().getvds_group_id()));
    String networkName;
    for (VmNetworkInterface iface : interfaces) {
        if (iface.getId() == null) {
            iface.setId(Guid.NewGuid());
        }
        networkName = iface.getNetworkName();
        iface.setVmId(getVmTemplateId());
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        iDynamic.setStatistics(iStat);
        iDynamic.setId(iface.getId());
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        if (vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            iDynamic.setNetworkName(networkName);
        } else {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iDynamic.setNetworkName(null);
        }
        iDynamic.setLinked(iface.isLinked());
        iDynamic.setSpeed(iface.getSpeed());
        iDynamic.setType(iface.getType());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
        getCompensationContext().snapshotNewEntity(iDynamic);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
@Override
protected void endMoveOrCopyCommand() {
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    updateTemplateInSpm();
    setSucceeded(true);
}
#method_after
@Override
protected void endMoveOrCopyCommand() {
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
    endActionOnAllImageGroups();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    } else {
        return super.getVmId();
    }
}
#method_after
@Override
public Guid getVmId() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm().getId();
    }
    return super.getVmId();
}
#end_block

#method_before
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    } else {
        return super.getVm();
    }
}
#method_after
@Override
public VM getVm() {
    if (getParameters().isImportAsNewEntity()) {
        return getParameters().getVm();
    }
    return super.getVm();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    Map<Guid, storage_domains> domainsMap = new HashMap<Guid, storage_domains>();
    retVal = canDoAction_beforeCloneVm(retVal, canDoActionMessages, domainsMap);
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return retVal && canDoAction_afterCloneVm(retVal, canDoActionMessages, domainsMap);
}
#method_after
@Override
protected boolean canDoAction() {
    Map<Guid, storage_domains> domainsMap = new HashMap<Guid, storage_domains>();
    if (!canDoActionBeforeCloneVm(domainsMap)) {
        return false;
    }
    if (getParameters().isImportAsNewEntity()) {
        initImportClonedVm();
    }
    return canDoActionAfterCloneVm(domainsMap);
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setvm_name(getParameters().getVm().getvm_name());
    getVm().setstorage_pool_id(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setVmName(getParameters().getVm().getVmName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#end_block

#method_before
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getvmt_guid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getvmt_guid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#method_after
private boolean templateExistsOnExportDomain() {
    boolean retVal = false;
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        if (qretVal.getSucceeded()) {
            Map templates = (Map) qretVal.getReturnValue();
            for (Object template : templates.keySet()) {
                if (getParameters().getVm().getVmtGuid().equals(((VmTemplate) template).getId())) {
                    retVal = true;
                    break;
                }
            }
        }
    } else {
        retVal = true;
    }
    return retVal;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getvmt_guid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<storage_domains> domains = (List<storage_domains>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new GetStorageDomainsByVmTemplateIdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<storage_domains, Guid>() {

            @Override
            public Guid eval(storage_domains storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getstorage_pool_id() != null ? image.getstorage_pool_id().getValue() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getvm_name())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#method_after
protected boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(getVm().getVmName())).getReturnValue();
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        // vm related ops
        if (!hasSnappableDisks(vm)) {
            endVmRelatedOps();
        } else {
            processImages();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        // vm related ops
        if (vm.getImages().isEmpty()) {
            endVmRelatedOps();
        } else {
            processImages();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < list.size() - 1; i++) {
                    list.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            BaseImagesCommand.saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        }
        Snapshot snapshot = new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            BaseImagesCommand.saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            if (!getSnapshotDao().exists(getVm().getId(), snapshotId)) {
                getSnapshotDao().save(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.REGULAR, disk.getdescription(), disk.getlast_modified_date(), disk.getappList()));
            }
            DiskImageDynamic diskDynamic = new DiskImageDynamic();
            diskDynamic.setId(disk.getImageId());
            diskDynamic.setactual_size(disk.getactual_size());
            DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        }
        for (Guid id : images.keySet()) {
            List<DiskImage> list = images.get(id);
            DiskImage disk = list.get(list.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            DbFacade.getInstance().getImageDao().update(disk.getImage());
            DbFacade.getInstance().getBaseDiskDao().save(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        getSnapshotDao().update(new Snapshot(snapshotId, SnapshotStatus.OK, getVm().getId(), null, SnapshotType.ACTIVE, "Active VM snapshot", new Date(), null));
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setit_guid(VmTemplateHandler.BlankVmTemplateId);
            disk.setvm_snapshot_id(snapshotId);
            disk.setactive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolume_format(diskImageBase.getvolume_format());
                disk.setvolume_type(diskImageBase.getvolume_type());
            }
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < diskList.size() - 1; i++) {
                    diskList.get(i).setId(disk.getId());
                }
            }
            disk.setcreation_date(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            disk.setactive(false);
            saveImage(disk);
            snapshotId = disk.getvm_snapshot_id().getValue();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            snapshotId = disk.getvm_snapshot_id().getValue();
            disk.setactive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setvmt_guid(VmTemplateHandler.BlankVmTemplateId);
    }
    DbFacade.getInstance().getVmStaticDao().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#method_after
protected void addVmStatic() {
    logImportEvents();
    getVm().getStaticData().setId(getVmId());
    getVm().getStaticData().setcreation_date(new Date());
    getVm().getStaticData().setvds_group_id(getParameters().getVdsGroupId());
    getVm().getStaticData().setMinAllocatedMem(computeMinAllocatedMem());
    getVm().getStaticData().setQuotaId(getParameters().getQuotaId());
    if (getParameters().getCopyCollapse()) {
        getVm().setVmtGuid(VmTemplateHandler.BlankVmTemplateId);
    }
    getVmStaticDAO().save(getVm().getStaticData());
    getCompensationContext().snapshotNewEntity(getVm().getStaticData());
}
#end_block

#method_before
private int computeMinAllocatedMem() {
    int vmMem = getVm().getmem_size_mb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = DbFacade.getInstance().getVdsGroupDao().get(getVm().getvds_group_id());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#method_after
private int computeMinAllocatedMem() {
    int vmMem = getVm().getMemSizeMb();
    int minAllocatedMem = vmMem;
    if (getVm().getMinAllocatedMem() > 0) {
        minAllocatedMem = getVm().getMinAllocatedMem();
    } else {
        // first get cluster memory over commit value
        VDSGroup vdsGroup = getVdsGroupDAO().get(getVm().getVdsGroupId());
        if (vdsGroup != null && vdsGroup.getmax_vds_memory_over_commit() > 0) {
            minAllocatedMem = (vmMem * 100) / vdsGroup.getmax_vds_memory_over_commit();
        }
    }
    return minAllocatedMem;
}
#end_block

#method_before
private void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getvm_name();
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("FieldName", fieldName);
    logable.AddCustomValue("VmName", vmName);
    logable.AddCustomValue("FieldValue", fieldValue);
    AuditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#method_after
private static void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getvm_name();
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("FieldName", fieldName);
    logable.AddCustomValue("VmName", vmName);
    logable.AddCustomValue("FieldValue", fieldValue);
    AuditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getvds_group_id()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(StringUtils.EMPTY);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInVdsByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInVdsByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(null);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#end_block

#method_before
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getvm_name());
}
#method_after
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getVmName());
}
#end_block

#method_before
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setstatus(VMStatus.ImageLocked);
    tempVar.setvm_host("");
    tempVar.setvm_ip("");
    tempVar.setapp_list(getParameters().getVm().getDynamicData().getapp_list());
    DbFacade.getInstance().getVmDynamicDao().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#method_after
private void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setstatus(VMStatus.ImageLocked);
    tempVar.setvm_host("");
    tempVar.setvm_ip("");
    tempVar.setapp_list(getParameters().getVm().getDynamicData().getapp_list());
    getVmDynamicDAO().save(tempVar);
    getCompensationContext().snapshotNewEntity(tempVar);
}
#end_block

#method_before
private void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    DbFacade.getInstance().getVmStatisticsDao().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
    getCompensationContext().stateChanged();
}
#method_after
private void addVmStatistics() {
    VmStatistics stats = new VmStatistics();
    stats.setId(getVmId());
    getVmStatisticsDAO().save(stats);
    getCompensationContext().snapshotNewEntity(stats);
    getCompensationContext().stateChanged();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            DbFacade.getInstance().getDiskImageDynamicDao().remove(disk.getImageId());
            DbFacade.getInstance().getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                DbFacade.getInstance().getBaseDiskDao().remove(disk.getId());
            }
        }
        removeVmNetworkInterfaces();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        DbFacade.getInstance().getVmDynamicDao().remove(getVmId());
        DbFacade.getInstance().getVmStatisticsDao().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        DbFacade.getInstance().getVmStaticDao().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        for (DiskImage disk : imageList) {
            getDiskImageDynamicDAO().remove(disk.getImageId());
            getImageDao().remove(disk.getImageId());
            List<DiskImage> imagesForDisk = getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId());
            if (imagesForDisk == null || imagesForDisk.isEmpty()) {
                getBaseDiskDao().remove(disk.getId());
            }
        }
        removeVmNetworkInterfaces();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        getVmDynamicDAO().remove(getVmId());
        getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#end_block

#method_before
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        getVmDAO().incrementVmDbGeneration(getVm().getId());
        ;
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getvds_group_id(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    // special permission is needed to use custom properties
    if (getVm() != null && !StringUtils.isEmpty(getVm().getCustomProperties())) {
        permissionList.add(new PermissionSubject(getVm().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
        if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getrun_on_vds() != null) {
            performLiveSnapshot(createdSnapshotId);
        }
    } else {
        revertToActiveSnapshot(createdSnapshotId);
    }
    endActionOnDisks();
    getVmDAO().incrementVmDbGeneration(getVm().getId());
    setSucceeded(getParameters().getTaskGroupSuccess());
    getReturnValue().setEndActionTryAgain(false);
}
#method_after
@Override
protected void endVmCommand() {
    Guid createdSnapshotId = getSnapshotDao().getId(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().updateStatus(createdSnapshotId, SnapshotStatus.OK);
        if (getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isStatusUp() && getVm().getRunOnVds() != null) {
            performLiveSnapshot(createdSnapshotId);
        }
    } else {
        revertToActiveSnapshot(createdSnapshotId);
    }
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    setSucceeded(getParameters().getTaskGroupSuccess());
    getReturnValue().setEndActionTryAgain(false);
}
#end_block

#method_before
protected void performLiveSnapshot(Guid createdSnapshotId) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                List<Disk> pluggedDisks = VmRunHandler.getInstance().getPluggedDisks(getVm());
                runVdsCommand(VDSCommandType.Snapshot, new SnapshotVDSCommandParameters(getVm().getrun_on_vds().getValue(), getVm().getId(), ImagesHandler.filterImageDisks(pluggedDisks, false, true)));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        if (e.getErrorCode() == VdcBllErrors.SNAPSHOT_FAILED) {
            getParameters().setTaskGroupSuccess(false);
            log.errorFormat("Wasn't able to live snpashot due to error: {0}, rolling back.", ExceptionUtils.getMessage(e));
            revertToActiveSnapshot(createdSnapshotId);
        } else {
            throw e;
        }
    }
}
#method_after
protected void performLiveSnapshot(Guid createdSnapshotId) {
    try {
        TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                List<Disk> pluggedDisks = VmRunHandler.getInstance().getPluggedDisks(getVm());
                runVdsCommand(VDSCommandType.Snapshot, new SnapshotVDSCommandParameters(getVm().getRunOnVds().getValue(), getVm().getId(), ImagesHandler.filterImageDisks(pluggedDisks, false, true)));
                return null;
            }
        });
    } catch (VdcBLLException e) {
        if (e.getErrorCode() != VdcBllErrors.SNAPSHOT_FAILED) {
            throw e;
        }
        handleVdsLiveSnapshotFailure(e);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, true, true, true, true, true, checkVmIsDown(), true, true, disksList);
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && canDoSnapshot(getVm()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList);
    }
    return result;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()));
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false);
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), Guid.Empty, false, true, true, true, true, true, false, true, diskImages);
    setStoragePoolId(getVm().getstorage_pool_id());
    ensureDomainMap(diskImages, getParameters().getStorageDomainId());
    for (DiskImage disk : diskImages) {
        imageFromSourceDomainMap.put(disk.getId(), disk);
    }
    retValue = retValue && checkTemplateInStorageDomain(diskImages);
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getstorage_pool_id())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    return retValue && destinationHasSpace();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVm() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    } else {
        setDescription(getVmName());
    }
    retValue = retValue && validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()));
    // check that vm is down and images are ok
    // not checking storage domain, there is a check in
    // CheckTemplateInStorageDomain later
    VmHandler.updateDisksFromDb(getVm());
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false);
    retValue = retValue && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, false, true, true, true, true, true, false, true, diskImages);
    setStoragePoolId(getVm().getStoragePoolId());
    ensureDomainMap(diskImages, getParameters().getStorageDomainId());
    for (DiskImage disk : diskImages) {
        imageFromSourceDomainMap.put(disk.getId(), disk);
    }
    retValue = retValue && checkTemplateInStorageDomain(diskImages);
    if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVm().getStoragePoolId())) == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (retValue && getVm().getDiskMap().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_NO_DISKS);
        retValue = false;
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    return retValue && destinationHasSpace();
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain(List<DiskImage> diskImages) {
    boolean retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(diskImages);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getvmt_guid())) {
        List<DiskImage> imageList = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVm().getvmt_guid()), false, false);
        Map<Guid, DiskImage> templateImagesMap = new HashMap<Guid, DiskImage>();
        for (DiskImage image : imageList) {
            templateImagesMap.put(image.getImageId(), image);
        }
        for (DiskImage image : diskImages) {
            if (templateImagesMap.containsKey(image.getit_guid())) {
                if (!templateImagesMap.get(image.getit_guid()).getstorage_ids().contains(getParameters().getStorageDomainId())) {
                    retValue = false;
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
                    break;
                }
            }
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain(List<DiskImage> diskImages) {
    boolean retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(diskImages);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid())) {
        List<DiskImage> imageList = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVm().getVmtGuid()), false, false);
        Map<Guid, DiskImage> templateImagesMap = new HashMap<Guid, DiskImage>();
        for (DiskImage image : imageList) {
            templateImagesMap.put(image.getImageId(), image);
        }
        for (DiskImage image : diskImages) {
            if (templateImagesMap.containsKey(image.getit_guid())) {
                if (!templateImagesMap.get(image.getit_guid()).getstorage_ids().contains(getParameters().getStorageDomainId())) {
                    retValue = false;
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
                    break;
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VM vm = getVm();
    if (vm.getstatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // Check if vm is initializing to run or already running - if it is in
    // such state,
    // we cannot move the vm
    boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
    if (isVmDuringInit) {
        log.errorFormat("VM {0} must be down for Move VM to be successfuly executed", vm.getvm_name());
        setActionReturnValue(vm.getstatus());
        setSucceeded(false);
        return;
    }
    VmHandler.LockVm(vm.getDynamicData(), getCompensationContext());
    moveOrCopyAllImageGroups();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VM vm = getVm();
    if (vm.getStatus() != VMStatus.Down) {
        throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
    }
    // Check if vm is initializing to run or already running - if it is in
    // such state,
    // we cannot move the vm
    boolean isVmDuringInit = ((Boolean) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
    if (isVmDuringInit) {
        log.errorFormat("VM {0} must be down for Move VM to be successfuly executed", vm.getVmName());
        setActionReturnValue(vm.getStatus());
        setSucceeded(false);
        return;
    }
    VmHandler.LockVm(vm.getDynamicData(), getCompensationContext());
    moveOrCopyAllImageGroups();
    setSucceeded(true);
}
#end_block

#method_before
protected void endMoveVmCommand() {
    endActionOnAllImageGroups();
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
        getVmDAO().incrementVmDbGeneration(getVm().getId());
        ;
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#method_after
protected void endMoveVmCommand() {
    boolean vmExists = (getVm() != null);
    if (vmExists) {
        incrementDbGeneration();
    }
    endActionOnAllImageGroups();
    if (vmExists) {
        VmHandler.UnLockVm(getVm());
        VmHandler.updateDisksFromDb(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveVmCommand::EndMoveVmCommand: Vm is null - not performing full EndAction");
    }
    setSucceeded(true);
}
#end_block

#method_before
private boolean canRemoveLunDisk() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getstatus() != VMStatus.Down) {
                VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#method_after
private boolean canRemoveLunDisk() {
    if (disk.getVmEntityType() == VmEntityType.VM) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getStatus() != VMStatus.Down) {
                VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getvm_name());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveTemplateDisk() {
    boolean retValue = true;
    DiskImage diskImage = (DiskImage) disk;
    if (getVmTemplate().getstatus() == VmTemplateStatus.Locked) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (retValue && diskImage.getstorage_ids().size() == 1) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.VM_TEMPLATE_IMAGE_LAST_DOMAIN);
    }
    if (retValue) {
        List<String> problematicVmNames = new ArrayList<String>();
        List<VM> vms = DbFacade.getInstance().getVmDao().getAllWithTemplate(getVmTemplateId());
        for (VM vm : vms) {
            List<Disk> vmDisks = DbFacade.getInstance().getDiskDao().getAllForVm(vm.getId());
            for (Disk vmDisk : vmDisks) {
                if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage vmDiskImage = (DiskImage) vmDisk;
                    if (vmDiskImage.getit_guid().equals(diskImage.getImageId())) {
                        if (vmDiskImage.getstorage_ids().contains(getParameters().getStorageDomainId())) {
                            retValue = false;
                            problematicVmNames.add(vm.getVmName());
                        }
                        break;
                    }
                }
            }
        }
        if (!retValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
            addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    boolean firstTime = true;
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<Disk> diskList = Arrays.asList(disk);
    for (VM vm : listVms) {
        VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getstorage_pool_id(), getParameters().getStorageDomainId(), false, firstTime, false, false, vmDevice.getIsPlugged() && disk.isAllowSnapshot(), vmDevice.getIsPlugged(), false, firstTime, diskList)) {
            return false;
        }
        firstTime = false;
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    boolean firstTime = true;
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<Disk> diskList = Arrays.asList(disk);
    for (VM vm : listVms) {
        VmDevice vmDevice = getVmDeviceDAO().get(new VmDeviceId(disk.getId(), vm.getId()));
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !ImagesHandler.PerformImagesChecks(vm, getReturnValue().getCanDoActionMessages(), vm.getStoragePoolId(), getParameters().getStorageDomainId(), false, firstTime, false, false, vmDevice.getIsPlugged() && disk.isAllowSnapshot(), vmDevice.getIsPlugged(), false, firstTime, diskList)) {
            return false;
        }
        firstTime = false;
    }
    return true;
}
#end_block

#method_before
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    for (VM vm : listVms) {
        getVmDAO().incrementVmDbGeneration(vm.getId());
    }
    setSucceeded(true);
}
#method_after
private void endCommand() {
    List<VM> listVms = getVmsForDiskId();
    for (VM vm : listVms) {
        getVmStaticDAO().incrementDbGeneration(vm.getId());
    }
    Backend.getInstance().EndAction(VdcActionType.RemoveImage, getParameters().getImagesParameters().get(0));
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getstorage_pool_id().equals(getVdsGroup().getstorage_pool_id())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getstatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getusb_policy(), getParameters().getVm().getos(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getstorage_pool_id(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getstorage_pool_id());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null || !getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getos(), getParameters().getMasterVm().getmem_size_mb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getpriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId()))) {
        return false;
    }
    if (getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_DUPLICATE_NAME);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getstorage_ids().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getstorage_ids().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setstorage_ids(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
    for (Guid srcStorageDomainId : sourceImageDomainsImageMap.keySet()) {
        boolean checkIsValid = true;
        if (!ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), srcStorageDomainId, false, true, true, true, true, false, true, checkIsValid, sourceImageDomainsImageMap.get(srcStorageDomainId))) {
            return false;
        }
        checkIsValid = false;
    }
    Map<Guid, storage_domains> storageDomains = new HashMap<Guid, storage_domains>();
    Set<Guid> destImageDomains = getStorageGuidSet();
    destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
    for (Guid destImageDomain : destImageDomains) {
        storage_domains storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
        if (storage == null) {
            // domain is not in the same storage pool as the vm
            if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
            } else {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
            }
            return false;
        }
        if (storage.getstatus() == null || storage.getstatus() != StorageDomainStatus.Active) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
            return false;
        }
        if (storage.getstorage_domain_type() == StorageDomainType.ImportExport || storage.getstorage_domain_type() == StorageDomainType.ISO) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
            return false;
        }
        storageDomains.put(destImageDomain, storage);
    }
    // update vm snapshots for storage free space check
    ImagesHandler.fillImagesBySnapshots(getVm());
    Map<storage_domains, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
    for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
        if (!StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
            return false;
        }
    }
    return AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#method_after
protected void AddVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getmem_size_mb(), getVmTemplateName(), getParameters().getMasterVm().getnum_of_sockets(), getParameters().getMasterVm().getcpu_per_socket(), getParameters().getMasterVm().getos(), getParameters().getMasterVm().getvds_group_id(), getVmTemplateId(), getParameters().getMasterVm().getdomain(), getParameters().getMasterVm().getnum_of_monitors(), (VmTemplateStatus.Locked.getValue()), (getParameters().getMasterVm().getusb_policy().getValue()), getParameters().getMasterVm().gettime_zone(), getParameters().getMasterVm().getis_auto_suspend(), getParameters().getMasterVm().getnice_level(), getParameters().getMasterVm().getfail_back(), getParameters().getMasterVm().getdefault_boot_sequence(), getParameters().getMasterVm().getvm_type(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected()));
    getVmTemplate().setauto_startup(getParameters().getMasterVm().getauto_startup());
    getVmTemplate().setpriority(getParameters().getMasterVm().getpriority());
    getVmTemplate().setdefault_display_type(getParameters().getMasterVm().getdefault_display_type());
    getVmTemplate().setinitrd_url(getParameters().getMasterVm().getinitrd_url());
    getVmTemplate().setkernel_url(getParameters().getMasterVm().getkernel_url());
    getVmTemplate().setkernel_params(getParameters().getMasterVm().getkernel_params());
    getVmTemplate().setis_stateless(getParameters().getMasterVm().getis_stateless());
    getVmTemplate().setQuotaId(getParameters().getMasterVm().getQuotaId());
    getVmTemplate().setdedicated_vm_for_vds(getParameters().getMasterVm().getdedicated_vm_for_vds());
    getVmTemplate().setMigrationSupport(getParameters().getMasterVm().getMigrationSupport());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void endDefaultOperations() {
    endTemplateRelatedOperations();
    endUnlockOps();
}
#method_after
private void endDefaultOperations() {
    endUnlockOps();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        RemoveTemplateInSpm(getVmTemplate().getstorage_pool_id().getValue(), getVmTemplateId());
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getstorage_pool_id() == null ? null : getVdsGroup().getstorage_pool_id().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getStoragePoolId() == null ? null : getVdsGroup().getStoragePoolId().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
    }
    return permissionCheckSubject;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    List<storage_pool_iso_map> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (storage_pool_iso_map poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (poolDomain.getstatus() == StorageDomainStatus.Locked) {
            addInvalidSDStatusMessage(poolDomain.getstatus());
            return false;
        }
    }
    return InitializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<storage_pool_iso_map> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    ProceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive
    if (getParameters().isInactive()) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.InActive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    // Pause the timers for the domain error handling
    runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearJobs));
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>GetValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getvds_spm_id())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    reconstructOpSucceeded = true;
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getvds_spm_id(), getStoragePool().getId(), getStoragePool().getname(), _newMasterStorageDomainId, domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            SearchParameters p = new SearchParameters(MessageFormat.format(DesktopsInStoragePoolQuery, getStoragePool().getname()), SearchType.VM);
            p.setMaxCount(Integer.MAX_VALUE);
            @SuppressWarnings("unchecked")
            final List<VM> vmsInPool = (List<VM>) Backend.getInstance().runInternalQuery(VdcQueryType.Search, p).getReturnValue();
            executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Void runInTransaction() {
                    for (VM vm : vmsInPool) {
                        getVmDAO().updateVmOvfGeneration(vm.getId(), 0);
                    }
                    return null;
                }
            });
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#method_after
@Override
protected void executeCommand() {
    try {
        reconstructOpSucceeded = reconstructMaster();
        connectAndRefreshAllUpHosts(reconstructOpSucceeded);
        if (!_isLastMaster && reconstructOpSucceeded) {
            // all vms/templates metadata should be copied to the new master domain, so we need
            // to perform increment of the db version for all the vms in the storage pool.
            // currently this method is used for both templates and vms.
            getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId().getValue());
        }
        setSucceeded(reconstructOpSucceeded);
    } finally {
        // reset cache and mark reconstruct for pool as finished
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new MarkPoolInReconstructModeVDSCommandParameters(getStoragePoolId().getValue(), ReconstructMarkAction.ClearCache));
    }
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).DisconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    for (VDS vds : getAllRunningVdssInPool()) {
        try {
            if (!_isLastMaster && commandSucceeded) {
                try {
                    runVdsCommand(VDSCommandType.RefreshStoragePool, new RefreshStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                } catch (VdcBLLException ex) {
                    if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                        VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds.getId(), getStoragePool().getId(), vds.getvds_spm_id(), _newMasterStorageDomainId, getStoragePool().getmaster_domain_version()));
                        if (!returnVal.getSucceeded()) {
                            log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                        }
                    } else {
                        log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                    }
                }
            }
            // only if we deactivate the storage domain we want to disconnect from it.
            if (!getParameters().isInactive()) {
                StorageHelperDirector.getInstance().getItem(getStorageDomain().getstorage_type()).disconnectStorageFromDomainByVdsId(getStorageDomain(), vds.getId());
            }
        } catch (Exception e) {
            log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
        }
    }
}
#end_block

#method_before
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
        getVmTemplateDAO().incrementVmTemplateDbGeneration(getVmTemplateId());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#method_after
private void endVmTemplateRelatedOps() {
    if (getVmTemplate() != null) {
        incrementDbGeneration();
        VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
        VmDeviceUtils.setVmDevices(getVmTemplate());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("MoveOrCopyTemplateCommand::EndMoveOrCopyCommand: VmTemplate is null, not performing full EndAction");
    }
}
#end_block

#method_before
protected void RemoveNetwork() {
    List<VmNetworkInterface> list = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplateId());
    for (VmNetworkInterface iface : list) {
        DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(iface.getId(), getVmTemplateId()));
        DbFacade.getInstance().getVmNetworkInterfaceDao().remove(iface.getId());
    // \\DbFacade.Instance.RemoveInterfaceStatistics(iface.id);
    }
}
#method_after
protected void RemoveNetwork() {
    List<VmNetworkInterface> list = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplateId());
    for (VmNetworkInterface iface : list) {
        DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(iface.getId(), getVmTemplateId()));
        DbFacade.getInstance().getVmNetworkInterfaceDao().remove(iface.getId());
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate() != null) {
        UpdateVmTemplate();
        if (getVmTemplate().getstorage_pool_id() != null && !VmTemplateHandler.BlankVmTemplateId.equals(getVmTemplate().getId())) {
            getVmTemplateDAO().incrementVmTemplateDbGeneration(getVmTemplate().getId());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVmTemplate() != null) {
        getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
        UpdateVmTemplate();
        setSucceeded(true);
    }
}
#end_block

#method_before
private void UpdateVmTemplate() {
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
}
#method_after
private void UpdateVmTemplate() {
    DbFacade.getInstance().getVmTemplateDao().update(getVmTemplate());
    // also update the smartcard device
    VmDeviceUtils.updateSmartcardDevice(getVmTemplateId(), getParameters().getVmTemplateData().isSmartcardEnabled());
}
#end_block

#method_before
@OnTimerMethodAnnotation("ovfUpdate_timer")
public void ovfUpdate_timer() {
    log.info("OvfDataUpdater: Attempting to update VMs/Templates Ovf.");
    List<storage_pool> storagePools = DbFacade.getInstance().getStoragePoolDao().getAll();
    for (storage_pool pool : storagePools) {
        try {
            if (StoragePoolStatus.Up == pool.getstatus()) {
                log.infoFormat("OvfDataUpdater: Attempting to update VMs/Templates Ovf in Data Center {0}", pool.getname());
                List<VM> vmsForUpdate = getVmsForUpdate(DbFacade.getInstance().getVmDao().getAllVmsForOvfUpdateForStoragePool(pool.getId()));
                VmCommand.updateVmInSpm(pool.getId(), vmsForUpdate);
                if (!vmsForUpdate.isEmpty()) {
                    for (VM vm : vmsForUpdate) {
                        DbFacade.getInstance().getVmDao().updateVmOvfGeneration(vm.getId(), vm.getStaticData().getDb_generation());
                    }
                }
                List<VmTemplate> templatesForUpdate = getTemplatesForUpdate(DbFacade.getInstance().getVmTemplateDao().getAllVmTemplatesForOvfUpdateForStoragePool(pool.getId()));
                if (!templatesForUpdate.isEmpty()) {
                    VmTemplateCommand.UpdateTemplateInSpm(pool.getId(), templatesForUpdate);
                    for (VmTemplate template : templatesForUpdate) {
                        DbFacade.getInstance().getVmDao().updateVmOvfGeneration(template.getId(), template.getDb_generation());
                    }
                }
            }
        } catch (Exception ex) {
            addAuditLogError(pool.getname());
            log.errorFormat("Exception while trying to update VMs/Templates ovf in Data Center {0}, the exception is {1}", pool.getname(), ex.getMessage());
        }
    }
}
#method_after
@OnTimerMethodAnnotation("ovfUpdate_timer")
public void ovfUpdate_timer() {
    itemsCountPerUpdate = reloadConfigValue();
    log.info("OvfDataUpdater: Attempting to update VMs/Templates Ovf.");
    List<storage_pool> storagePools = getStoragePoolDao().getAllByStatus(StoragePoolStatus.Up);
    for (storage_pool pool : storagePools) {
        try {
            log.infoFormat("Attempting to update VM OVFs in Data Center {0}", pool.getname());
            initProccessedInfoLists();
            updateOvfForVmsOfStoragePool(pool.getId());
            log.infoFormat("Successfully updated VM OVFs in Data Center {0}", pool.getname());
            log.infoFormat("Attempting to update template OVFs in Data Center {0}", pool.getname());
            updateOvfForTemplatesOfStoragePool(pool.getId());
            log.infoFormat("Succesfully updated templates OVFs in Data Center {0}", pool.getname());
            log.infoFormat("Attempting to remove uneeded template/vm OVFs in Data Center {0}", pool.getname());
            removeOvfForTemplatesAndVmsOfStoragePool(pool.getId());
            log.infoFormat("Succesfully removed unneeded template/vm OVFs in Data Center {0}", pool.getname());
        } catch (Exception ex) {
            addAuditLogError(pool.getname());
            log.errorFormat("Exception while trying to update or remove VMs/Templates ovf in Data Center {0}, the exception is {1}", pool.getname(), ex.getMessage());
            log.debug(ex.getStackTrace());
        }
    }
    proccessedIdsInfo = null;
    proccessedOvfGenerationsInfo = null;
}
#end_block

#method_before
private boolean verifyDisksNotLocked(List<DiskImage> disks) {
    for (DiskImage disk : disks) {
        if (disk.getimageStatus() == ImageStatus.LOCKED) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean verifyDisksNotLocked(List<DiskImage> disks) {
    for (DiskImage disk : disks) {
        if (disk.getimageStatus() == ImageStatus.LOCKED) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void addAuditLogError(String storagePoolName) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("StoragePoolName", storagePoolName);
    AuditLogDirector.log(logable, AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED);
}
#method_after
protected void addAuditLogError(String storagePoolName) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.AddCustomValue("StoragePoolName", storagePoolName);
    AuditLogDirector.log(logable, AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED);
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setOvf_generation(rs.getLong("ovf_generation"));
    entity.setDb_generation(rs.getLong("db_generation"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setos(VmOsType.forValue(rs.getInt("os")));
    entity.setdescription(rs.getString("description"));
    entity.setcreation_date(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setpriority(rs.getInt("priority"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    OvfDataUpdater.getInstance().InitOvfDataUpdater();
    log.infoFormat("OvfDataUpdater: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    log.infoFormat("InitResourceManager: {0}", new Date());
    ResourceManager.getInstance().init();
    AsyncTaskManager.getInstance().InitAsyncTaskManager();
    log.infoFormat("AsyncTaskManager: {0}", new Date());
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    log.infoFormat("OvfDataUpdater: {0}", new Date());
    if (Config.<Boolean>GetValue(ConfigValues.EnableVdsLoadBalancing)) {
        VdsLoadBalancer.EnableLoadBalancer();
    }
    log.infoFormat("VdsLoadBalancer: {0}", new Date());
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            log.infoFormat("MacPoolManager started: {0}", new Date());
            MacPoolManager.getInstance().initialize();
            log.infoFormat("MacPoolManager finished: {0}", new Date());
        }
    });
    StoragePoolStatusHandler.Init();
    GlusterManager.getInstance().init();
    try {
        log.infoFormat("Init VM Custom Properties utilities: {0}", new Date());
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.errorFormat("Initialization failed. Exception message is {0} ", e.getMessage());
        log.debug("Initialization failed ", e);
        throw new RuntimeException(e);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    if (autoStartup != other.autoStartup) {
        return false;
    }
    if (autosuspend != other.autosuspend) {
        return false;
    }
    if (cpusPerSocket != other.cpusPerSocket) {
        return false;
    }
    if (creationDate == null) {
        if (other.creationDate != null) {
            return false;
        }
    } else if (!creationDate.equals(other.creationDate)) {
        return false;
    }
    if (defaultBootSequence != other.defaultBootSequence) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (domain == null) {
        if (other.domain != null) {
            return false;
        }
    } else if (!domain.equals(other.domain)) {
        return false;
    }
    if (fail_back != other.fail_back) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (initrdUrl == null) {
        if (other.initrdUrl != null) {
            return false;
        }
    } else if (!initrdUrl.equals(other.initrdUrl)) {
        return false;
    }
    if (isoPath == null) {
        if (other.isoPath != null) {
            return false;
        }
    } else if (!isoPath.equals(other.isoPath)) {
        return false;
    }
    if (kernelParams == null) {
        if (other.kernelParams != null) {
            return false;
        }
    } else if (!kernelParams.equals(other.kernelParams)) {
        return false;
    }
    if (kernelUrl == null) {
        if (other.kernelUrl != null) {
            return false;
        }
    } else if (!kernelUrl.equals(other.kernelUrl)) {
        return false;
    }
    if (mOs != other.mOs) {
        return false;
    }
    if (memSizeMB != other.memSizeMB) {
        return false;
    }
    if (niceLevel != other.niceLevel) {
        return false;
    }
    if (numOfSockets != other.numOfSockets) {
        return false;
    }
    if (numOfMonitors != other.numOfMonitors) {
        return false;
    }
    if (origin != other.origin) {
        return false;
    }
    if (priority != other.priority) {
        return false;
    }
    if (stateless != other.stateless) {
        return false;
    }
    if (smartcardEnabled != other.smartcardEnabled) {
        return false;
    }
    if (deleteProtected != other.deleteProtected) {
        return false;
    }
    if (timezone == null) {
        if (other.timezone != null) {
            return false;
        }
    } else if (!timezone.equals(other.timezone)) {
        return false;
    }
    if (usbPolicy != other.usbPolicy) {
        return false;
    }
    if (vds_group_id == null) {
        if (other.vds_group_id != null) {
            return false;
        }
    } else if (!vds_group_id.equals(other.vds_group_id)) {
        return false;
    }
    if (vmType != other.vmType) {
        return false;
    }
    if (quotaId == null) {
        if (other.quotaId != null)
            return false;
    } else if (!quotaId.equals(other.quotaId))
        return false;
    if (allowConsoleReconnect != other.allowConsoleReconnect) {
        return false;
    }
    if (dedicated_vm_for_vds == null) {
        if (other.dedicated_vm_for_vds != null) {
            return false;
        }
    } else {
        if (!dedicated_vm_for_vds.equals(other.dedicated_vm_for_vds)) {
            return false;
        }
    }
    if (migrationSupport != other.migrationSupport) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getVmName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setVmName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    return entity;
}
#end_block

#method_before
@Override
public List<VmTemplate> getAllTemplatesRelatedToQuotaId(Guid quotaId) {
    return getCallsHandler().executeReadList("GetAllVmTemplatesRelatedToQuotaId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource());
}
#method_after
@Override
public List<VmTemplate> getAllTemplatesRelatedToQuotaId(Guid quotaId) {
    return getCallsHandler().executeReadList("GetAllVmTemplatesRelatedToQuotaId", VMTemplateRowMapper.instance, getCustomMapSqlParameterSource().addValue("quota_id", quotaId));
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_HOST_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#method_after
private static void initGlusterVolumeSeverities() {
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTIONS_RESET_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REBALANCE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_ADD_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_ADD_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_REPLACE_BRICK_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_SERVERS_LIST_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_START_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROFILE_STOP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_INFO_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_COMMAND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_CREATED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_DELETED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_SET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_OPTION_RESET_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_PROPERTIES_CHANGED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_VOLUME_BRICK_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#method_after
private static void initHostSeverities() {
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_TEST_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    mSeverities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ALERT_FENCING_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initVMSeverities() {
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_INTERNAL, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_VM_POOL_TO_AD_GROUP_FAILED_INTERNAL, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_VM_POOL_TO_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_AD_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.AUTO_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.AUTO_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CANCEL_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.TEMPLATE_IMPORT_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_IMPORT_INFO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_NOT_RESPONDING, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_TRYING_RERUN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_PAUSED_ENOSPC, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EIO, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_PAUSED_EPERM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_POWER_DOWN_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RUN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PAUSE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_PAUSE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_FINISH_FAILURE_WILL_TRY_AGAIN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_SUSPEND_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOP_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STOP_SUSPENDED_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_SUSPEND_VM_OK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOP_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_STARTED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_FINISHED_WITH_ILLEGAL_DISKS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CHANGE_DISK_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EJECT_VM_FLOPPY, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_DISK_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESUME_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_RESUME_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_STARTED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_INITIATED_RUN_VM_FAILED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_EXPORT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_EXPORT_TEMPLATE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_INITIATED_SHUTDOWN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_SHUTDOWN_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_STOPPED_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_STOPPING_VM_INSTEAD_OF_SHUTDOWN, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_DISK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_DISK, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_DISK_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_DISK_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_MOVED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_MOVED_VM_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_MOVE_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_ADD_VM_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE_FINISHED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ADD_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_UPDATE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_VM_TEMPLATE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_ATTACH_USER_TO_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_USER_TO_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CREATE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_FAILED_CREATE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_REMOVE_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_TRY_BACK_TO_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_TRY_BACK_TO_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_START, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_RESTORE_FROM_SNAPSHOT_FINISH_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_RESTORE_FROM_SNAPSHOT, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_PASSWORD_CHANGE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_CLEAR_UNKNOWN_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CLEAR_UNKNOWN_VMS, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_ABORT, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTANANCE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN_ERROR, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_MIGRATION_DONE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.RUN_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_SET_TO_UNKNOWN_STATUS, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.USER_LOGGED_OUT_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DETACH_USER_FROM_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_DETACH_USER_FROM_VM, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.VM_DOWN, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_FAILED_CHANGE_FLOPPY_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_FAILED_FROM_TO, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UPDATE_VM_POOL_WITH_VMS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOGGED_IN_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_LOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_UNLOCKED_VM, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_MIGRATION_ON_CONNECT_CHECK_SUCCEEDED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.USER_DEDICATE_VM_TO_POWERCLIENT_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.VM_CLEARED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.HA_VM_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.HA_VM_RESTART_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.USER_FAILED_ATTACH_DISK_TO_VM, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    mSeverities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    if (!returnValue) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__ADD);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
    }
    return returnValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    setVdsGroupId(getParameters().getVdsStaticData().getvds_group_id());
    getParameters().setVdsForUniqueId(null);
    // Check if this is a valid cluster
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        returnValue = false;
    } else {
        VDS vds = getParameters().getvds();
        String vdsName = vds.getvds_name();
        String hostName = vds.gethost_name();
        int maxVdsNameLength = Config.<Integer>GetValue(ConfigValues.MaxVdsNameLength);
        // check that vds name is not null or empty
        if (vdsName == null || vdsName.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
            returnValue = false;
        // check that VDS name is not too long
        } else if (vdsName.length() > maxVdsNameLength) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
            returnValue = false;
        // check that VDS hostname does not contain special characters.
        } else if (!ValidationUtils.validHostname(hostName)) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_VDS_HOSTNAME);
            returnValue = false;
        } else {
            returnValue = returnValue && validateSingleHostAttachedToLocalStorage();
            if (Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers) && !FileUtil.fileExists(Config.resolveCertificatePath())) {
                addCanDoActionMessage(VdcBllMessages.VDS_TRY_CREATE_SECURE_CERTIFICATE_NOT_FOUND);
                returnValue = false;
            } else if (!getParameters().getAddPending() && StringUtils.isEmpty(getParameters().getRootPassword())) {
                // We block vds installations if it's not a RHEV-H and password is empty
                // Note that this may override local host SSH policy. See BZ#688718.
                addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_INSTALL_EMPTY_PASSWORD);
                returnValue = false;
            } else if (!IsPowerManagementLegal(getParameters().getVdsStaticData(), getVdsGroup().getcompatibility_version().toString())) {
                returnValue = false;
            } else {
                returnValue = returnValue && canConnect(vds);
            }
        }
    }
    if (isGlusterSupportEnabled()) {
        if (clusterHasServers()) {
            upServer = ClusterUtils.getInstance().getUpServer(getVdsGroupId());
            if (upServer == null) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NO_GLUSTER_HOST_TO_PEER_PROBE);
                returnValue = false;
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private Guid[] getUserAndGroupIdsForUser(Guid userId) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", userId);
    DbUser user = (DbUser) query.uniqueResult();
    if (user == null) {
        return new Guid[0];
    }
    query = getSession().createQuery("from ad_groups where name in (:names)");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<AdGroups> groups = query.list();
    Guid[] result = new Guid[groups.size() + 1];
    result[0] = userId;
    for (int index = 0; index < groups.size(); index++) {
        result[index + 1] = groups.get(index).getid();
    }
    return result;
}
#method_after
private Guid[] getUserAndGroupIdsForUser(Guid userId) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", userId);
    DbUser user = (DbUser) query.uniqueResult();
    if (user == null) {
        return new Guid[0];
    }
    query = getSession().createQuery("from ad_groups where name in (:names)");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<LdapGroup> groups = query.list();
    Guid[] result = new Guid[groups.size() + 1];
    result[0] = userId;
    for (int index = 0; index < groups.size(); index++) {
        result[index + 1] = groups.get(index).getid();
    }
    return result;
}
#end_block

#method_before
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.StartProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParametes permissionParams;
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParametes();
        if (user.getIsGroup()) {
            permissionParams.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
        } else {
            permissionParams.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
    Cancel();
}
#method_after
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null && !model.getIsEveryoneSelected()) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    model.StartProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    PermissionsOperationsParametes permissionParams;
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(ApplicationGuids.quotaConsumer.asGuid());
        permissions perm = tempVar2;
        perm.setObjectId(((Quota) getEntity()).getId());
        perm.setObjectType(VdcObjectType.Quota);
        permissionParams = new PermissionsOperationsParametes();
        if (user.getIsGroup()) {
            permissionParams.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
        } else {
            permissionParams.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
        }
        permissionParams.setPermission(perm);
        list.add(permissionParams);
    }
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            QuotaUserListModel localModel = (QuotaUserListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
    Cancel();
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<AdUser> results = new ArrayList<AdUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<AdUser> tempUsers = (java.util.ArrayList<AdUser>) LdapFactory.getInstance(getDomain()).RunAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).RunAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
private void PopulateGroups() {
    try {
        boolean performPopulate = true;
        List<AdUser> users = (List<AdUser>) getReturnValue();
        if (getParameters() instanceof LdapSearchByUserIdListParameters) {
            LdapSearchByUserIdListParameters params = (LdapSearchByUserIdListParameters) getParameters();
            performPopulate = params.getPerformGroupsQueryInsideCmd();
        }
        if (performPopulate) {
            LdapBrokerUtils.performGroupPopulationForUsers(users, getLoginName(), getPassword(), getDomain(), new ArrayList<AdGroups>());
        }
    } catch (RuntimeException ex) {
        log.infoFormat("GetAdUserByUserIdListCommand failed. Exception: {0}", ex);
    }
}
#method_after
private void PopulateGroups() {
    try {
        boolean performPopulate = true;
        List<LdapUser> users = (List<LdapUser>) getReturnValue();
        if (getParameters() instanceof LdapSearchByUserIdListParameters) {
            LdapSearchByUserIdListParameters params = (LdapSearchByUserIdListParameters) getParameters();
            performPopulate = params.getPerformGroupsQueryInsideCmd();
        }
        if (performPopulate) {
            LdapBrokerUtils.performGroupPopulationForUsers(users, getLoginName(), getPassword(), getDomain(), new ArrayList<LdapGroup>());
        }
    } catch (RuntimeException ex) {
        log.infoFormat("GetAdUserByUserIdListCommand failed. Exception: {0}", ex);
    }
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    AdGroups entity = new AdGroups();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    LdapGroup entity = new LdapGroup();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#end_block

#method_before
protected List<AdGroups> setUpGroups() {
    List<AdGroups> groups = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        groups.add(getEntity(i));
    }
    return groups;
}
#method_after
protected List<LdapGroup> setUpGroups() {
    List<LdapGroup> groups = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        groups.add(getEntity(i));
    }
    return groups;
}
#end_block

#method_before
protected AdGroups getAdGroup(int index) {
    AdGroups adGroup = new AdGroups();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#method_after
protected LdapGroup getAdGroup(int index) {
    LdapGroup adGroup = new LdapGroup();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#end_block

#method_before
protected AdGroups getAdGroupWithDomain(int index) {
    AdGroups adGroup = new AdGroups();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(DOMAIN + "/" + NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#method_after
protected LdapGroup getAdGroupWithDomain(int index) {
    LdapGroup adGroup = new LdapGroup();
    adGroup.setid(GUIDS[index]);
    adGroup.setname(DOMAIN + "/" + NAMES[index]);
    adGroup.setdomain(DOMAIN);
    return adGroup;
}
#end_block

#method_before
public static AdGroups setUpEntityExpectations(AdGroups entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getdomain()).andReturn(DOMAIN).anyTimes();
    expect(entity.getstatus()).andReturn(AdRefStatus.Active).anyTimes();
    return entity;
}
#method_after
public static LdapGroup setUpEntityExpectations(LdapGroup entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getdomain()).andReturn(DOMAIN).anyTimes();
    expect(entity.getstatus()).andReturn(AdRefStatus.Active).anyTimes();
    return entity;
}
#end_block

#method_before
public void add() {
    if (getWindow() != null) {
        return;
    }
    AdElementListModel model = new AdElementListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addUsersAndGroupsTitle());
    // $NON-NLS-1$
    model.setHashName("add_users_and_groups");
    model.setExcludeItems(DataProvider.GetUserList());
    model.setIsRoleListHidden(true);
    model.getIsEveryoneSelectionHidden().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAdd", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void add() {
    if (getWindow() != null) {
        return;
    }
    AdElementListModel model = new AdElementListModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().addUsersAndGroupsTitle());
    // $NON-NLS-1$
    model.setHashName("add_users_and_groups");
    model.setIsRoleListHidden(true);
    model.getIsEveryoneSelectionHidden().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnAdd", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.getIsGroup()) {
            AddUserParameters tempVar = new AddUserParameters();
            tempVar.setVdcUser(new VdcUser(item.getuser_id(), item.getusername(), item.getdomain()));
            parameters.add(tempVar);
        } else {
            AddUserParameters tempVar2 = new AddUserParameters();
            tempVar2.setAdGroup(new AdGroups(item.getuser_id(), item.getname(), item.getdomain()));
            parameters.add(tempVar2);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddUser, parameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
public void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    for (DbUser item : items) {
        if (!item.getIsGroup()) {
            AddUserParameters tempVar = new AddUserParameters();
            tempVar.setVdcUser(new VdcUser(item.getuser_id(), item.getusername(), item.getdomain()));
            parameters.add(tempVar);
        } else {
            AddUserParameters tempVar2 = new AddUserParameters();
            tempVar2.setAdGroup(new LdapGroup(item.getuser_id(), item.getname(), item.getdomain()));
            parameters.add(tempVar2);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddUser, parameters, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void ExecuteQuery() {
    AdGroups group = InternalBrokerUtils.getGroupByGroupGuid(getGroupId());
    setReturnValue(group);
    if (group != null) {
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void ExecuteQuery() {
    LdapGroup group = InternalBrokerUtils.getGroupByGroupGuid(getGroupId());
    setReturnValue(group);
    if (group != null) {
        setSucceeded(true);
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
@Override
public permissions getForRoleAndAdElementAndObjectWithGroupCheck(Guid roleid, Guid elementid, Guid objectid) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", objectid);
    DbUser user = (DbUser) query.uniqueResult();
    query = getSession().createQuery("from ad_groups where name in :names");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<AdGroups> groups = query.list();
    List<Guid> ids = new ArrayList<Guid>();
    ids.add(user.getuser_id());
    for (AdGroups group : groups) {
        ids.add(group.getid());
    }
    return fillInPermissionDetails(findOneByCriteria(Restrictions.eq("roleId", roleid), Restrictions.eq("adElementId", elementid), Restrictions.eq("objectId", objectid), Restrictions.in("adElementId", ids)));
}
#method_after
@Override
public permissions getForRoleAndAdElementAndObjectWithGroupCheck(Guid roleid, Guid elementid, Guid objectid) {
    Query query = getSession().createQuery("from DbUser where id = :id");
    query.setParameter("id", objectid);
    DbUser user = (DbUser) query.uniqueResult();
    query = getSession().createQuery("from ad_groups where name in :names");
    query.setParameterList("names", user.getGroupsAsArray());
    @SuppressWarnings("unchecked")
    List<LdapGroup> groups = query.list();
    List<Guid> ids = new ArrayList<Guid>();
    ids.add(user.getuser_id());
    for (LdapGroup group : groups) {
        ids.add(group.getid());
    }
    return fillInPermissionDetails(findOneByCriteria(Restrictions.eq("roleId", roleid), Restrictions.eq("adElementId", elementid), Restrictions.eq("objectId", objectid), Restrictions.in("adElementId", ids)));
}
#end_block

#method_before
public AdGroups getUserGroup() {
    return userGroup;
}
#method_after
public LdapGroup getUserGroup() {
    return userGroup;
}
#end_block

#method_before
protected List<AdGroups> getEntityList() {
    List<AdGroups> entities = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#method_after
protected List<LdapGroup> getEntityList() {
    List<LdapGroup> entities = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#end_block

#method_before
protected AdGroups getEntity(int index) {
    return setUpEntityExpectations(control.createMock(AdGroups.class), index);
}
#method_after
protected LdapGroup getEntity(int index) {
    return setUpEntityExpectations(control.createMock(LdapGroup.class), index);
}
#end_block

#method_before
static AdGroups setUpEntityExpectations(AdGroups entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getname()).andReturn(NAMES[index]).anyTimes();
    return entity;
}
#method_after
static LdapGroup setUpEntityExpectations(LdapGroup entity, int index) {
    expect(entity.getid()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getname()).andReturn(NAMES[index]).anyTimes();
    return entity;
}
#end_block

#method_before
private List<AdUser> searchAdUsers() {
    return adSearch(LdapQueryType.searchUsers, AdActionType.SearchUserByQuery);
}
#method_after
private List<LdapUser> searchAdUsers() {
    return adSearch(LdapQueryType.searchUsers, AdActionType.SearchUserByQuery);
}
#end_block

#method_before
private List<AdGroups> searchAdGroups() {
    return adSearch(LdapQueryType.searchGroups, AdActionType.SearchGroupsByQuery);
}
#method_after
private List<LdapGroup> searchAdGroups() {
    return adSearch(LdapQueryType.searchGroups, AdActionType.SearchGroupsByQuery);
}
#end_block

#method_before
private List<Quota> searchQuota() {
    return genericSearch(getDbFacade().getQuotaDao(), true, null);
}
#method_after
private List<Quota> searchQuota() {
    List<Quota> quotaList = genericSearch(getDbFacade().getQuotaDao(), true, null);
    QuotaManager.getInstance().updateUsage(quotaList);
    return quotaList;
}
#end_block

#method_before
protected AdUser populateUserData(AdUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, AdGroups> groupsDict = new java.util.HashMap<String, AdGroups>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
protected void PopulateGroup(LdapQueryData queryData, String domain, java.util.Map<String, AdGroups> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                PopulateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("PopulateGroup failed. Exception: {0}", e);
    }
}
#method_after
protected void PopulateGroup(LdapQueryData queryData, String domain, java.util.Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                PopulateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("PopulateGroup failed. Exception: {0}", e);
    }
}
#end_block

#method_before
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, AdGroups> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    proceedGroupsSearchResult(groupsList, groupsDict, generator);
}
#method_after
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    proceedGroupsSearchResult(groupsList, groupsDict, generator);
}
#end_block

#method_before
private void proceedGroupsSearchResult(List<String> groupDNList, Map<String, AdGroups> groupsDict, GroupsDNQueryGenerator generator) {
    if (groupDNList == null) {
        return;
    }
    for (String groupDN : groupDNList) {
        String groupName = LdapBrokerUtils.generateGroupDisplayValue(groupDN);
        if (!groupsDict.containsKey(groupName)) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
            if (group == null) {
                group = new AdGroups();
                group.setname(groupName);
            }
            group.setDistinguishedName(groupDN);
            groupsDict.put(groupName, group);
            generator.add(groupDN);
        }
    }
}
#method_after
private void proceedGroupsSearchResult(List<String> groupDNList, Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    if (groupDNList == null) {
        return;
    }
    for (String groupDN : groupDNList) {
        String groupName = LdapBrokerUtils.generateGroupDisplayValue(groupDN);
        if (!groupsDict.containsKey(groupName)) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
            if (group == null) {
                group = new LdapGroup();
                group.setname(groupName);
            }
            group.setDistinguishedName(groupDN);
            groupsDict.put(groupName, group);
            generator.add(groupDN);
        }
    }
}
#end_block

#method_before
protected GroupsDNQueryGenerator createGroupsGeneratorForUser(AdUser user) {
    List<String> dnsList = new ArrayList<String>();
    for (AdGroups adGroup : user.getGroups().values()) {
        dnsList.add(adGroup.getDistinguishedName());
    }
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(new HashSet<String>(dnsList));
    return generator;
}
#method_after
protected GroupsDNQueryGenerator createGroupsGeneratorForUser(LdapUser user) {
    List<String> dnsList = new ArrayList<String>();
    for (LdapGroup adGroup : user.getGroups().values()) {
        dnsList.add(adGroup.getDistinguishedName());
    }
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(new HashSet<String>(dnsList));
    return generator;
}
#end_block

#method_before
public void create() {
    log.infoFormat("UsersDomainsCacheManager: {0}", new java.util.Date());
    String authMethod = Config.<String>GetValue(ConfigValues.AuthenticationMethod);
    if (!authMethod.equalsIgnoreCase("LDAP")) {
        return;
    }
    List<String> domains = LdapBrokerUtils.getDomainsList(true);
    Map<String, LdapProviderType> domainLDAPProviders = parseLDAPProviders();
    fillLdapServersMap();
    fillLdapSecurityAuthenticationMap();
    fillUsersMap();
    fillPasswordsMap();
    for (String domainName : domains) {
        domainName = domainName.toLowerCase();
        domainsUsersInfoByUserNameAndDomainName.put(domainName, new ConcurrentHashMap<String, UserDomainInfo>());
        Domain domain = new Domain(domainName);
        domain.setLdapProviderType(domainLDAPProviders.get(domainName) == null ? LdapProviderType.general : domainLDAPProviders.get(domainName));
        domain.setLdapSecurityAuthentication(getDomainSecurityAuthentication(domainName));
        domainsByName.put(domainName, domain);
        domain.setUserName(userPerDomain.get(domainName));
        domain.setPassword(passwordPerDomain.get(domainName));
        // Each domain has LDAP servers that one of them should be used to
        // perform an LDAP query against the domain
        obtainLDAPServersForDomain(domain);
        groupsPerDomain.put(domain.getName(), new ConcurrentHashMap<String, AdGroups>());
    }
    DbUserCacheManager.getInstance().init();
    log.infoFormat("DbUserCacheManager: {0}", new java.util.Date());
}
#method_after
public void create() {
    log.infoFormat("UsersDomainsCacheManager: {0}", new java.util.Date());
    String authMethod = Config.<String>GetValue(ConfigValues.AuthenticationMethod);
    if (!authMethod.equalsIgnoreCase("LDAP")) {
        return;
    }
    List<String> domains = LdapBrokerUtils.getDomainsList(true);
    Map<String, LdapProviderType> domainLDAPProviders = parseLDAPProviders();
    fillLdapServersMap();
    fillLdapSecurityAuthenticationMap();
    fillUsersMap();
    fillPasswordsMap();
    for (String domainName : domains) {
        domainName = domainName.toLowerCase();
        domainsUsersInfoByUserNameAndDomainName.put(domainName, new ConcurrentHashMap<String, UserDomainInfo>());
        Domain domain = new Domain(domainName);
        domain.setLdapProviderType(domainLDAPProviders.get(domainName) == null ? LdapProviderType.general : domainLDAPProviders.get(domainName));
        domain.setLdapSecurityAuthentication(getDomainSecurityAuthentication(domainName));
        domainsByName.put(domainName, domain);
        domain.setUserName(userPerDomain.get(domainName));
        domain.setPassword(passwordPerDomain.get(domainName));
        // Each domain has LDAP servers that one of them should be used to
        // perform an LDAP query against the domain
        obtainLDAPServersForDomain(domain);
        groupsPerDomain.put(domain.getName(), new ConcurrentHashMap<String, LdapGroup>());
    }
    DbUserCacheManager.getInstance().init();
    log.infoFormat("DbUserCacheManager: {0}", new java.util.Date());
}
#end_block

#method_before
Group lookupGroup(Guid guid) {
    String id = guid.toString();
    for (AdGroups group : getGroupsFromDomain()) {
        if (group.getid().toString().equals(id))
            return mapAdGroup(group);
    }
    return notFound();
}
#method_after
Group lookupGroup(Guid guid) {
    String id = guid.toString();
    for (LdapGroup group : getGroupsFromDomain()) {
        if (group.getid().toString().equals(id))
            return mapAdGroup(group);
    }
    return notFound();
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    return setUpEntityExpectations(control.createMock(AdGroups.class), index);
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    return setUpEntityExpectations(control.createMock(LdapGroup.class), index);
}
#end_block

#method_before
protected List<AdGroups> getEntityList() {
    List<AdGroups> entities = new ArrayList<AdGroups>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#method_after
protected List<LdapGroup> getEntityList() {
    List<LdapGroup> entities = new ArrayList<LdapGroup>();
    for (int i = 0; i < NAMES.length; i++) {
        entities.add(getEntity(i));
    }
    return entities;
}
#end_block

#method_before
@Override
public void remove(Guid id) {
    /*
         * This implementation was necessary in order to handle cascading deletes of what is in the tags_user_group_map
         * table. it can be moved to the default generic implementation when the association between ad_groups and tags
         * are handled via @OneToMany relationships.
         */
    Session session = getSession();
    Transaction transaction = session.beginTransaction();
    Query query = session.createQuery("delete from tags_user_group_map tugm where tugm.groupId = :group_id");
    query.setParameter("group_id", id);
    query.executeUpdate();
    AdGroups instance = get(id);
    if (instance != null) {
        session.delete(instance);
    }
    transaction.commit();
}
#method_after
@Override
public void remove(Guid id) {
    /*
         * This implementation was necessary in order to handle cascading deletes of what is in the tags_user_group_map
         * table. it can be moved to the default generic implementation when the association between ad_groups and tags
         * are handled via @OneToMany relationships.
         */
    Session session = getSession();
    Transaction transaction = session.beginTransaction();
    Query query = session.createQuery("delete from tags_user_group_map tugm where tugm.groupId = :group_id");
    query.setParameter("group_id", id);
    query.executeUpdate();
    LdapGroup instance = get(id);
    if (instance != null) {
        session.delete(instance);
    }
    transaction.commit();
}
#end_block

#method_before
@Override
public List<AdGroups> getAllTimeLeasedForPool(int id) {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public List<LdapGroup> getAllTimeLeasedForPool(int id) {
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
public void setAdGroup(AdGroups adGroup) {
    this.adGroup = adGroup;
}
#method_after
public void setAdGroup(LdapGroup adGroup) {
    this.adGroup = adGroup;
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return adGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return adGroup;
}
#end_block

#method_before
public void setAdUser(AdUser adUser) {
    this.adUser = adUser;
}
#method_after
public void setAdUser(LdapUser ldapUser) {
    this.ldapUser = ldapUser;
}
#end_block

#method_before
public AdUser getAdUser() {
    return adUser;
}
#method_after
public LdapUser getAdUser() {
    return ldapUser;
}
#end_block

#method_before
protected AdGroups getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        mGroup = DbFacade.getInstance().getAdGroupDao().get(getGroupId());
    }
    return mGroup;
}
#method_after
protected LdapGroup getAdGroup() {
    if (mGroup == null && !getGroupId().equals(Guid.Empty)) {
        mGroup = DbFacade.getInstance().getAdGroupDao().get(getGroupId());
    }
    return mGroup;
}
#end_block

#method_before
public static AdGroups initAdGroup(AdGroups adGroup) {
    AdGroups dbGroup = DbFacade.getInstance().getAdGroupDao().get(adGroup.getid());
    if (dbGroup == null) {
        DbFacade.getInstance().getAdGroupDao().save(adGroup);
        dbGroup = adGroup;
    }
    return dbGroup;
}
#method_after
public static LdapGroup initAdGroup(LdapGroup adGroup) {
    LdapGroup dbGroup = DbFacade.getInstance().getAdGroupDao().get(adGroup.getid());
    if (dbGroup == null) {
        DbFacade.getInstance().getAdGroupDao().save(adGroup);
        dbGroup = adGroup;
    }
    return dbGroup;
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    String domain = (String) getDomain().getSelectedItem();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                AdUser a = (AdUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setuser_id(a.getUserId());
                    tempVar.setIsGroup(false);
                    tempVar.setname(a.getName());
                    tempVar.setsurname(a.getSurName());
                    tempVar.setusername(a.getUserName());
                    tempVar.setdomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                AdGroups a = (AdGroups) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setuser_id(a.getid());
                    tempVar3.setIsGroup(true);
                    tempVar3.setname(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setsurname("");
                    // $NON-NLS-1$
                    tempVar3.setusername("");
                    tempVar3.setdomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    String domain = (String) getDomain().getSelectedItem();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapUser a = (LdapUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setuser_id(a.getUserId());
                    tempVar.setIsGroup(false);
                    tempVar.setname(a.getName());
                    tempVar.setsurname(a.getSurName());
                    tempVar.setusername(a.getUserName());
                    tempVar.setdomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getuser_id());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setuser_id(a.getid());
                    tempVar3.setIsGroup(true);
                    tempVar3.setname(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setsurname("");
                    // $NON-NLS-1$
                    tempVar3.setusername("");
                    tempVar3.setdomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            OnUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
private void updateDBUserFromADUser(DbUser dbUser, AdUser adUser, HashSet<Guid> updatedUsers) {
    boolean succeded = false;
    // dbUser.domain);
    if ((adUser == null) || (adUser.getUserId().equals(Guid.Empty)) || (!adUser.getUserId().equals(dbUser.getuser_id()))) {
        if (dbUser.getstatus() != 0) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getname());
            dbUser.setstatus(0);
            succeded = true;
        }
    } else {
        if (dbUser.getstatus() == 0) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getname());
            dbUser.setstatus(1);
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getname(), adUser.getName())) {
            dbUser.setname(adUser.getName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getsurname(), adUser.getSurName())) {
            dbUser.setsurname(adUser.getSurName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getdomain(), adUser.getDomainControler())) {
            dbUser.setdomain(adUser.getDomainControler());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getusername(), adUser.getUserName())) {
            dbUser.setusername(adUser.getUserName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getgroups(), adUser.getGroup())) {
            dbUser.setgroups(adUser.getGroup());
            succeded = true;
            updatedUsers.add(dbUser.getuser_id());
        }
        if (!StringUtils.equals(dbUser.getdepartment(), adUser.getDepartment())) {
            dbUser.setdepartment(adUser.getDepartment());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getrole(), adUser.getTitle())) {
            dbUser.setrole(adUser.getTitle());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getemail(), adUser.getEmail())) {
            dbUser.setemail(adUser.getEmail());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), adUser.getGroupIds())) {
            dbUser.setGroupIds(adUser.getGroupIds());
            succeded = true;
        }
        if (succeded) {
            dbUser.setstatus(dbUser.getstatus() + 1);
        }
    }
    if (succeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    } else {
    }
}
#method_after
private void updateDBUserFromADUser(DbUser dbUser, LdapUser adUser, HashSet<Guid> updatedUsers) {
    boolean succeded = false;
    // dbUser.domain);
    if ((adUser == null) || (adUser.getUserId().equals(Guid.Empty)) || (!adUser.getUserId().equals(dbUser.getuser_id()))) {
        if (dbUser.getstatus() != 0) {
            log.warnFormat("User {0} not found in directory server, its status switched to InActive", dbUser.getname());
            dbUser.setstatus(0);
            succeded = true;
        }
    } else {
        if (dbUser.getstatus() == 0) {
            log.warnFormat("Inactive User {0} found in directory server, its status switched to Active", dbUser.getname());
            dbUser.setstatus(1);
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getname(), adUser.getName())) {
            dbUser.setname(adUser.getName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getsurname(), adUser.getSurName())) {
            dbUser.setsurname(adUser.getSurName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getdomain(), adUser.getDomainControler())) {
            dbUser.setdomain(adUser.getDomainControler());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getusername(), adUser.getUserName())) {
            dbUser.setusername(adUser.getUserName());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getgroups(), adUser.getGroup())) {
            dbUser.setgroups(adUser.getGroup());
            succeded = true;
            updatedUsers.add(dbUser.getuser_id());
        }
        if (!StringUtils.equals(dbUser.getdepartment(), adUser.getDepartment())) {
            dbUser.setdepartment(adUser.getDepartment());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getrole(), adUser.getTitle())) {
            dbUser.setrole(adUser.getTitle());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getemail(), adUser.getEmail())) {
            dbUser.setemail(adUser.getEmail());
            succeded = true;
        }
        if (!StringUtils.equals(dbUser.getGroupIds(), adUser.getGroupIds())) {
            dbUser.setGroupIds(adUser.getGroupIds());
            succeded = true;
        }
        if (succeded) {
            dbUser.setstatus(dbUser.getstatus() + 1);
        }
    }
    if (succeded) {
        DbFacade.getInstance().getDbUserDao().update(dbUser);
    } else {
    }
}
#end_block

#method_before
public void refreshAllUserData(List<AdGroups> updatedGroups) {
    try {
        log.info("DbUserCacheManager::refreshAllUserData() - entered");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        java.util.HashMap<String, java.util.HashMap<Guid, DbUser>> userByDomains = new java.util.HashMap<String, java.util.HashMap<Guid, DbUser>>();
        /**
         * Filter all users by domains
         */
        for (DbUser user : filteredUsers) {
            java.util.HashMap<Guid, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getdomain())) {
                domainUser = new java.util.HashMap<Guid, DbUser>();
                userByDomains.put(user.getdomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getdomain());
            }
            domainUser.put(user.getuser_id(), user);
        }
        if (userByDomains.size() != 0) {
            /**
             * refresh users in each domain separately
             */
            for (String domain : userByDomains.keySet()) {
                java.util.ArrayList<AdUser> adUsers = (java.util.ArrayList<AdUser>) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, new java.util.ArrayList<Guid>(userByDomains.get(domain).keySet()), false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, updatedGroups);
                    for (AdUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = userByDomains.get(domain).values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.getstatus() != 0) {
                            log.warnFormat("User {0} not found in directory sevrer, its status switched to InActive", dbUser.getname());
                            dbUser.setstatus(AsyncTaskStatusEnum.unknown.getValue());
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("DbUserCacheManager::refreshAllUserData() - failed with exception", e);
    }
}
#method_after
public void refreshAllUserData(List<LdapGroup> updatedGroups) {
    try {
        log.info("DbUserCacheManager::refreshAllUserData() - entered");
        List<DbUser> allUsers = DbFacade.getInstance().getDbUserDao().getAll();
        List<String> domainsList = LdapBrokerUtils.getDomainsList(true);
        List<DbUser> filteredUsers = LinqUtils.filter(allUsers, new UsersPerDomainPredicate(domainsList));
        java.util.HashMap<String, java.util.HashMap<Guid, DbUser>> userByDomains = new java.util.HashMap<String, java.util.HashMap<Guid, DbUser>>();
        /**
         * Filter all users by domains
         */
        for (DbUser user : filteredUsers) {
            java.util.HashMap<Guid, DbUser> domainUser;
            if (!userByDomains.containsKey(user.getdomain())) {
                domainUser = new java.util.HashMap<Guid, DbUser>();
                userByDomains.put(user.getdomain(), domainUser);
            } else {
                domainUser = userByDomains.get(user.getdomain());
            }
            domainUser.put(user.getuser_id(), user);
        }
        if (userByDomains.size() != 0) {
            /**
             * refresh users in each domain separately
             */
            for (String domain : userByDomains.keySet()) {
                java.util.ArrayList<LdapUser> adUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(domain, new java.util.ArrayList<Guid>(userByDomains.get(domain).keySet()), false)).getReturnValue();
                HashSet<Guid> updatedUsers = new HashSet<Guid>();
                if (adUsers == null) {
                    log.warn("No users returned from directory server during refresh users");
                } else {
                    LdapBrokerUtils.performGroupPopulationForUsers(adUsers, domain, updatedGroups);
                    for (LdapUser adUser : adUsers) {
                        updateDBUserFromADUser(userByDomains.get(domain).get(adUser.getUserId()), adUser, updatedUsers);
                        userByDomains.get(domain).remove(adUser.getUserId());
                    }
                }
                Collection<DbUser> usersForDomain = userByDomains.get(domain).values();
                if (usersForDomain == null) {
                    log.warnFormat("No users for domain {0}", domain);
                } else {
                    for (DbUser dbUser : usersForDomain) {
                        if (dbUser.getstatus() != 0) {
                            log.warnFormat("User {0} not found in directory sevrer, its status switched to InActive", dbUser.getname());
                            dbUser.setstatus(AsyncTaskStatusEnum.unknown.getValue());
                            DbFacade.getInstance().getDbUserDao().update(dbUser);
                        }
                    }
                }
                // group or role was changed
                if (updatedUsers.size() > 0) {
                    DbFacade.getInstance().updateLastAdminCheckStatus(updatedUsers.toArray(new Guid[updatedUsers.size()]));
                }
            }
        }
    } catch (RuntimeException e) {
        log.error("DbUserCacheManager::refreshAllUserData() - failed with exception", e);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    List<AdGroups> groups = updateGroups();
    refreshAllUserData(groups);
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    List<LdapGroup> groups = updateGroups();
    refreshAllUserData(groups);
}
#end_block

#method_before
private List<AdGroups> updateGroups() {
    List<AdGroups> groups = DbFacade.getInstance().getAdGroupDao().getAll();
    for (AdGroups group : groups) {
        // following code should not occur
        if (group.getdomain() == null && group.getname().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getname()).append(" is null. This should not occur, please check that domain name is passed corectly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getname().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setdomain(newDomainName);
        }
        // to fetch for them
        if (group.getdomain() != null && !group.getdomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getdomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getname(), group.getdomain());
            } else {
                AdGroups groupFromAD = (AdGroups) LdapFactory.getInstance(group.getdomain()).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getdomain(), group.getid())).getReturnValue();
                if (group.getstatus() == AdRefStatus.Active && (groupFromAD == null || groupFromAD.getstatus() == AdRefStatus.Inactive)) {
                    group.setstatus(AdRefStatus.Inactive);
                    DbFacade.getInstance().getAdGroupDao().update(group);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getname(), groupFromAD.getname()) || group.getstatus() != groupFromAD.getstatus() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    DbFacade.getInstance().getAdGroupDao().update(groupFromAD);
                }
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(groupFromAD.getMemberOf());
                }
            }
        }
    }
    return groups;
}
#method_after
private List<LdapGroup> updateGroups() {
    List<LdapGroup> groups = DbFacade.getInstance().getAdGroupDao().getAll();
    for (LdapGroup group : groups) {
        // following code should not occur
        if (group.getdomain() == null && group.getname().contains("@")) {
            StringBuilder logMsg = new StringBuilder();
            logMsg.append("domain name for ad group ").append(group.getname()).append(" is null. This should not occur, please check that domain name is passed corectly from client");
            log.warn(logMsg.toString());
            String partAfterAtSign = group.getname().split("[@]", -1)[1];
            String newDomainName = partAfterAtSign;
            if (partAfterAtSign.contains("/")) {
                String partPreviousToSlashSign = partAfterAtSign.split("[/]", -1)[0];
                newDomainName = partPreviousToSlashSign;
            }
            group.setdomain(newDomainName);
        }
        // to fetch for them
        if (group.getdomain() != null && !group.getdomain().isEmpty()) {
            if (UsersDomainsCacheManagerService.getInstance().getDomain(group.getdomain()) == null) {
                log.errorFormat("Cannot query for group {0} from domain {1} because the domain is not configured. Please use the manage domains utility if you wish to add this domain.", group.getname(), group.getdomain());
            } else {
                LdapGroup groupFromAD = (LdapGroup) LdapFactory.getInstance(group.getdomain()).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(group.getdomain(), group.getid())).getReturnValue();
                if (group.getstatus() == AdRefStatus.Active && (groupFromAD == null || groupFromAD.getstatus() == AdRefStatus.Inactive)) {
                    group.setstatus(AdRefStatus.Inactive);
                    DbFacade.getInstance().getAdGroupDao().update(group);
                } else if (groupFromAD != null && (!StringUtils.equals(group.getname(), groupFromAD.getname()) || group.getstatus() != groupFromAD.getstatus() || !StringUtils.equals(group.getDistinguishedName(), groupFromAD.getDistinguishedName()))) {
                    DbFacade.getInstance().getAdGroupDao().update(groupFromAD);
                }
                // memberOf is not persistent and should be set in the returned groups list from the LDAP queries
                if (groupFromAD != null) {
                    group.setMemberOf(groupFromAD.getMemberOf());
                }
            }
        }
    }
    return groups;
}
#end_block

#method_before
@Override
protected AdGroups getEntity(int index) {
    AdGroups entity = new AdGroups();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#method_after
@Override
protected LdapGroup getEntity(int index) {
    LdapGroup entity = new LdapGroup();
    entity.setid(GUIDS[index]);
    entity.setname(NAMES[index]);
    entity.setdomain(DOMAIN);
    return entity;
}
#end_block

#method_before
private void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar4);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
private void OnAdd() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.getIsEveryoneSelected() && model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    if (model.getIsEveryoneSelected()) {
        DbUser tempVar = new DbUser();
        tempVar.setuser_id(ApplicationGuids.everyone.asGuid());
        items.add(tempVar);
    } else {
        for (Object item : model.getItems()) {
            EntityModel entityModel = (EntityModel) item;
            if (entityModel.getIsSelected()) {
                items.add((DbUser) entityModel.getEntity());
            }
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    // adGroup/user
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar2 = new permissions();
        tempVar2.setad_element_id(user.getuser_id());
        tempVar2.setrole_id(role.getId());
        permissions perm = tempVar2;
        perm.setObjectId(getEntityGuid());
        perm.setObjectType(this.getObjectType());
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar3);
        } else {
            PermissionsOperationsParametes tempVar4 = new PermissionsOperationsParametes();
            tempVar4.setPermission(perm);
            tempVar4.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar4);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
protected Guid getEntityGuid() {
    return DataProvider.GetEntityGuid(getEntity());
}
#method_after
protected Guid getEntityGuid() {
    return AsyncDataProvider.GetEntityGuid(getEntity());
}
#end_block

#method_before
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof storage_pool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof storage_domains) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof vm_pools) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    return VdcObjectType.Unknown;
}
#method_after
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof storage_pool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof storage_domains) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof vm_pools) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    if (getEntity() instanceof Network) {
        return VdcObjectType.Network;
    }
    return VdcObjectType.Unknown;
}
#end_block

#method_before
@Override
public AdGroups get(Guid id) {
    return getCallsHandler().executeRead("Getad_groupsByid", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("id", id));
}
#method_after
@Override
public LdapGroup get(Guid id) {
    return getCallsHandler().executeRead("Getad_groupsByid", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("id", id));
}
#end_block

#method_before
@Override
public AdGroups getByName(String name) {
    return getCallsHandler().executeRead("Getad_groupsByName", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("name", name));
}
#method_after
@Override
public LdapGroup getByName(String name) {
    return getCallsHandler().executeRead("Getad_groupsByName", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("name", name));
}
#end_block

#method_before
@Override
public List<AdGroups> getAll() {
    return getCallsHandler().executeReadList("GetAllFromad_groups", new ADGroupRowMapper(), getCustomMapSqlParameterSource());
}
#method_after
@Override
public List<LdapGroup> getAll() {
    return getCallsHandler().executeReadList("GetAllFromad_groups", new ADGroupRowMapper(), getCustomMapSqlParameterSource());
}
#end_block

#method_before
@Override
public List<AdGroups> getAllTimeLeasedForPool(int id) {
    return getCallsHandler().executeReadList("Gettime_leasedad_groups_by_vm_pool_id", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("vmPoolId", id));
}
#method_after
@Override
public List<LdapGroup> getAllTimeLeasedForPool(int id) {
    return getCallsHandler().executeReadList("Gettime_leasedad_groups_by_vm_pool_id", new ADGroupRowMapper(), getCustomMapSqlParameterSource().addValue("vmPoolId", id));
}
#end_block

#method_before
@Override
public void save(AdGroups group) {
    insertOrUpdate(group, "Insertad_groups");
}
#method_after
@Override
public void save(LdapGroup group) {
    insertOrUpdate(group, "Insertad_groups");
}
#end_block

#method_before
@Override
public void update(AdGroups group) {
    insertOrUpdate(group, "Updatead_groups");
}
#method_after
@Override
public void update(LdapGroup group) {
    insertOrUpdate(group, "Updatead_groups");
}
#end_block

#method_before
private void insertOrUpdate(final AdGroups group, final String storedProcName) {
    getCallsHandler().executeModification(storedProcName, getCustomMapSqlParameterSource().addValue("id", group.getid()).addValue("name", group.getname()).addValue("status", group.getstatus()).addValue("domain", group.getdomain()).addValue("distinguishedname", group.getDistinguishedName()));
}
#method_after
private void insertOrUpdate(final LdapGroup group, final String storedProcName) {
    getCallsHandler().executeModification(storedProcName, getCustomMapSqlParameterSource().addValue("id", group.getid()).addValue("name", group.getname()).addValue("status", group.getstatus()).addValue("domain", group.getdomain()).addValue("distinguishedname", group.getDistinguishedName()));
}
#end_block

#method_before
@Override
public AdGroups mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    AdGroups entity = new AdGroups();
    entity.setid(Guid.createGuidFromString(rs.getString("id")));
    entity.setname(rs.getString("name"));
    entity.setstatus(AdRefStatus.forValue(rs.getInt("status")));
    entity.setdomain(rs.getString("domain"));
    entity.setDistinguishedName(rs.getString("distinguishedname"));
    return entity;
}
#method_after
@Override
public LdapGroup mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    LdapGroup entity = new LdapGroup();
    entity.setid(Guid.createGuidFromString(rs.getString("id")));
    entity.setname(rs.getString("name"));
    entity.setstatus(AdRefStatus.forValue(rs.getInt("status")));
    entity.setdomain(rs.getString("domain"));
    entity.setDistinguishedName(rs.getString("distinguishedname"));
    return entity;
}
#end_block

#method_before
public static void performGroupPopulationForUsers(ArrayList<AdUser> adUsers, String domain, List<AdGroups> updatedGroups) {
    Domain domainObject = UsersDomainsCacheManagerService.getInstance().getDomain(domain.toLowerCase());
    String user = domainObject.getUserName();
    String password = domainObject.getPassword();
    performGroupPopulationForUsers(adUsers, user, password, domain, updatedGroups);
}
#method_after
public static void performGroupPopulationForUsers(List<LdapUser> users, String loginName, String password, String domainName, List<LdapGroup> updatedGroups) {
    // A list that holds the results of the LDAP queries for groups - both from this method + from previous LDAP
    // queries for groups that populated groups
    // that are now in updatedGroups list
    List<GroupSearchResult> results = new ArrayList<GroupSearchResult>();
    HashMap<String, java.util.HashMap<Guid, LdapUser>> groupsAdUsersMap = new java.util.HashMap<String, java.util.HashMap<Guid, LdapUser>>();
    Set<String> currentGroupsForSearch = new HashSet<String>();
    // Constructs a map that holds the groups that were already previously queried (for example, by
    // DbUserCacheManager.updateDbGroups
    Map<Guid, LdapGroup> alreadyQueriedGroups = new HashMap<Guid, LdapGroup>();
    if (updatedGroups != null) {
        for (LdapGroup adGroup : updatedGroups) {
            alreadyQueriedGroups.put(adGroup.getid(), adGroup);
        }
    }
    // Passes on all the users
    for (LdapUser user : users) {
        // Passes on all known groups of a given user.
        for (Map.Entry<String, LdapGroup> groupEntry : user.getGroups().entrySet()) {
            java.util.HashMap<Guid, LdapUser> map;
            String groupName = groupEntry.getKey();
            Guid groupId = groupEntry.getValue().getid();
            String groupDN = groupEntry.getValue().getDistinguishedName();
            // if so - add it to the search results list, and not to the groups to be queried
            if (!groupsAdUsersMap.containsKey(groupName)) {
                map = new java.util.HashMap<Guid, LdapUser>();
                groupsAdUsersMap.put(groupName, map);
                LdapGroup alreadyUpdatedGroup = alreadyQueriedGroups.get(groupId);
                // list
                if (alreadyUpdatedGroup != null) {
                    results.add(new GroupSearchResult(alreadyUpdatedGroup));
                } else {
                    // the group was not already queried - make sure it will be queried.
                    currentGroupsForSearch.add(groupDN);
                }
            } else {
                map = groupsAdUsersMap.get(groupName);
            }
            if (!map.containsKey(user.getUserId())) {
                map.put(user.getUserId(), user);
            }
        }
    }
    // Generate the LDAP query and pass the results (both the results from previous population and from
    // this population) to further processing
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator(currentGroupsForSearch);
    List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
    for (LdapQueryData queryData : partialQueries) {
        List<GroupSearchResult> searchResults = performGroupQuery(loginName, password, domainName, queryData);
        if (searchResults != null) {
            // Add all LDAP results to the results list - it now contains objects retreived from ldap, and objects
            // that
            // were previously queried.
            results.addAll(searchResults);
        }
    }
    for (GroupSearchResult groupSearchResult : results) {
        ProceedGroupsSearchResult(groupSearchResult, groupsAdUsersMap, currentGroupsForSearch);
    }
}
#end_block

#method_before
private static void AddGroupToUser(AdUser user, String groupName) {
    if (!user.getGroups().containsKey(groupName)) {
        AdGroups group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
        if (group != null) {
            user.getGroups().put(groupName, group);
        } else {
            user.getGroups().put(groupName, new AdGroups());
        }
    }
}
#method_after
private static void AddGroupToUser(LdapUser user, String groupName) {
    if (!user.getGroups().containsKey(groupName)) {
        LdapGroup group = DbFacade.getInstance().getAdGroupDao().getByName(groupName);
        if (group != null) {
            user.getGroups().put(groupName, group);
        } else {
            user.getGroups().put(groupName, new LdapGroup());
        }
    }
}
#end_block

#method_before
private static void ProceedGroupsSearchResult(GroupSearchResult searchResult, Map<String, java.util.HashMap<Guid, AdUser>> _groupsAdUsersMap, Set<String> currentGroupsForSearch) {
    List<String> memberOf = searchResult.getMemberOf();
    String groupName = searchResult.getDistinguishedName();
    groupName = generateGroupDisplayValue(groupName);
    java.util.HashMap<Guid, AdUser> groupUsers = _groupsAdUsersMap.get(groupName);
    if (memberOf == null) {
        return;
    }
    // The group may be a member of other groups - check for all the groups it is member in (all parent groups)
    for (String groupVal : memberOf) {
        String parentGroupName = generateGroupDisplayValue(groupVal);
        if (!_groupsAdUsersMap.containsKey(parentGroupName)) {
            currentGroupsForSearch.add(parentGroupName);
            java.util.HashMap<Guid, AdUser> map = new java.util.HashMap<Guid, AdUser>();
            if (groupUsers != null) {
                for (AdUser user : groupUsers.values()) {
                    map.put(user.getUserId(), user);
                    AddGroupToUser(user, parentGroupName);
                }
            }
            _groupsAdUsersMap.put(parentGroupName, map);
        } else {
            java.util.HashMap<Guid, AdUser> parentGroupUser = _groupsAdUsersMap.get(parentGroupName);
            if (parentGroupUser != null && groupUsers != null) {
                for (Guid userId : groupUsers.keySet()) {
                    if (!parentGroupUser.containsKey(userId)) {
                        parentGroupUser.put(userId, groupUsers.get(userId));
                        AddGroupToUser(groupUsers.get(userId), parentGroupName);
                    }
                }
            }
        }
    }
}
#method_after
private static void ProceedGroupsSearchResult(GroupSearchResult searchResult, Map<String, java.util.HashMap<Guid, LdapUser>> _groupsAdUsersMap, Set<String> currentGroupsForSearch) {
    List<String> memberOf = searchResult.getMemberOf();
    String groupName = searchResult.getDistinguishedName();
    groupName = generateGroupDisplayValue(groupName);
    java.util.HashMap<Guid, LdapUser> groupUsers = _groupsAdUsersMap.get(groupName);
    if (memberOf == null) {
        return;
    }
    // The group may be a member of other groups - check for all the groups it is member in (all parent groups)
    for (String groupVal : memberOf) {
        String parentGroupName = generateGroupDisplayValue(groupVal);
        if (!_groupsAdUsersMap.containsKey(parentGroupName)) {
            currentGroupsForSearch.add(parentGroupName);
            java.util.HashMap<Guid, LdapUser> map = new java.util.HashMap<Guid, LdapUser>();
            if (groupUsers != null) {
                for (LdapUser user : groupUsers.values()) {
                    map.put(user.getUserId(), user);
                    AddGroupToUser(user, parentGroupName);
                }
            }
            _groupsAdUsersMap.put(parentGroupName, map);
        } else {
            java.util.HashMap<Guid, LdapUser> parentGroupUser = _groupsAdUsersMap.get(parentGroupName);
            if (parentGroupUser != null && groupUsers != null) {
                for (Guid userId : groupUsers.keySet()) {
                    if (!parentGroupUser.containsKey(userId)) {
                        parentGroupUser.put(userId, groupUsers.get(userId));
                        AddGroupToUser(groupUsers.get(userId), parentGroupName);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(AdGroups.class).addAnnotatedClass(async_tasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(bookmarks.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(storage_domain_dynamic.class).addAnnotatedClass(storage_domain_static.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(storage_server_connections.class).addAnnotatedClass(tags.class).addAnnotatedClass(tags_user_group_map.class).addAnnotatedClass(tags_user_map.class).addAnnotatedClass(tags_vds_map.class).addAnnotatedClass(tags_vm_map.class).addAnnotatedClass(tags_vm_pool_map.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(storage_pool_iso_map.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(LdapGroup.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        Guid groupId = result.getGuid();
        if (!getGroupId().equals(groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new AdGroups(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new AdGroups(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    Object group = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    queryData.setFilterParameters(new Object[] { getGroupId() });
    queryData.setLdapQueryType(LdapQueryType.getGroupByGuid);
    queryData.setDomain(getDomain());
    Object searchResult = directorySearcher.FindOne(queryData);
    if (searchResult != null) {
        GroupSearchResult result = (GroupSearchResult) searchResult;
        Guid groupId = result.getGuid();
        if (!getGroupId().equals(groupId)) {
            /**
             * Cannot find group - group is Inactive
             */
            group = new LdapGroup(getGroupId());
        } else {
            String distinguishedName = result.getDistinguishedName();
            List<String> memberOf = result.getMemberOf();
            String groupName = LdapBrokerUtils.generateGroupDisplayValue(distinguishedName);
            group = new LdapGroup(groupId, groupName, getDomain(), distinguishedName, memberOf);
        }
    }
    setReturnValue(group);
    setSucceeded(true);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid userid) {
    List<vm_pools> result = new ArrayList<vm_pools>();
    /* we need to get the user, then get the list of ad groups for that user */
    Query query = getSession().createQuery("from DbUser where id = :user_id");
    query.setParameter("user_id", userid);
    DbUser user = (DbUser) query.uniqueResult();
    if (user != null) {
        Criteria criteria = getSession().createCriteria(AdGroups.class).add(Restrictions.in("name", splitApartNames(user.getgroups())));
        List<AdGroups> adElements = criteria.list();
        Guid[] ids = new Guid[adElements.size() + 1];
        ids[0] = userid;
        for (int index = 0; index < adElements.size(); index++) {
            ids[index + 1] = adElements.get(index).getid();
        }
        query = getSession().createQuery("select pool " + "from vm_pools pool, permissions perms, roles role " + "where pool.id = perms.objectId " + "and perms.adElementId in ( :adElements ) " + "and perms.roleId = role.id " + "and role.type = 2");
        query.setParameterList("adElements", ids);
        result = query.list();
    }
    return result;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<vm_pools> getAllForUser(Guid userid) {
    List<vm_pools> result = new ArrayList<vm_pools>();
    /* we need to get the user, then get the list of ad groups for that user */
    Query query = getSession().createQuery("from DbUser where id = :user_id");
    query.setParameter("user_id", userid);
    DbUser user = (DbUser) query.uniqueResult();
    if (user != null) {
        Criteria criteria = getSession().createCriteria(LdapGroup.class).add(Restrictions.in("name", splitApartNames(user.getgroups())));
        List<LdapGroup> adElements = criteria.list();
        Guid[] ids = new Guid[adElements.size() + 1];
        ids[0] = userid;
        for (int index = 0; index < adElements.size(); index++) {
            ids[index + 1] = adElements.get(index).getid();
        }
        query = getSession().createQuery("select pool " + "from vm_pools pool, permissions perms, roles role " + "where pool.id = perms.objectId " + "and perms.adElementId in ( :adElements ) " + "and perms.roleId = role.id " + "and role.type = 2");
        query.setParameterList("adElements", ids);
        result = query.list();
    }
    return result;
}
#end_block

#method_before
@Override
protected AdGroups getExpectedResult() {
    return new AdGroups(Guid.NewGuid(), NAME_TO_SEARCH, DOMAIN);
}
#method_after
@Override
protected LdapGroup getExpectedResult() {
    return new LdapGroup(Guid.NewGuid(), NAME_TO_SEARCH, DOMAIN);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAdGroupDao());
    // create some test data
    newAdGroup = new AdGroups();
    newAdGroup.setid(Guid.NewGuid());
    newAdGroup.setdomain("domain");
    newAdGroup.setname("name");
    newAdGroup.setstatus(AdRefStatus.Active);
    existingAdGroup = dao.get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1"));
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = prepareDAO(dbFacade.getAdGroupDao());
    // create some test data
    newAdGroup = new LdapGroup();
    newAdGroup.setid(Guid.NewGuid());
    newAdGroup.setdomain("domain");
    newAdGroup.setname("name");
    newAdGroup.setstatus(AdRefStatus.Active);
    existingAdGroup = dao.get(new Guid("b399944a-81ab-4ec5-8266-e19ba7c3c9d1"));
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    AdGroups result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    LdapGroup result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGet() {
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testGet() {
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testGetByNameWithInvalidName() {
    AdGroups result = dao.getByName("thisnameisinvalid");
    assertNull(result);
}
#method_after
@Test
public void testGetByNameWithInvalidName() {
    LdapGroup result = dao.getByName("thisnameisinvalid");
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetByName() {
    AdGroups result = dao.getByName(existingAdGroup.getname());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testGetByName() {
    LdapGroup result = dao.getByName(existingAdGroup.getname());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testGetAll() {
    List<AdGroups> result = dao.getAll();
    assertEquals(AD_GROUP_COUNT, result.size());
}
#method_after
@Test
public void testGetAll() {
    List<LdapGroup> result = dao.getAll();
    assertEquals(AD_GROUP_COUNT, result.size());
}
#end_block

#method_before
@Test
public void testSave() {
    dao.save(newAdGroup);
    AdGroups result = dao.getByName(newAdGroup.getname());
    assertEquals(newAdGroup, result);
}
#method_after
@Test
public void testSave() {
    dao.save(newAdGroup);
    LdapGroup result = dao.getByName(newAdGroup.getname());
    assertEquals(newAdGroup, result);
}
#end_block

#method_before
@Test
public void testUpdate() {
    existingAdGroup.setname(existingAdGroup.getname().toUpperCase());
    existingAdGroup.setdomain(existingAdGroup.getdomain().toUpperCase());
    existingAdGroup.setstatus(AdRefStatus.Inactive);
    dao.update(existingAdGroup);
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#method_after
@Test
public void testUpdate() {
    existingAdGroup.setname(existingAdGroup.getname().toUpperCase());
    existingAdGroup.setdomain(existingAdGroup.getdomain().toUpperCase());
    existingAdGroup.setstatus(AdRefStatus.Inactive);
    dao.update(existingAdGroup);
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNotNull(result);
    assertEquals(existingAdGroup, result);
}
#end_block

#method_before
@Test
public void testRemove() {
    dao.remove(existingAdGroup.getid());
    AdGroups result = dao.get(existingAdGroup.getid());
    assertNull(result);
}
#method_after
@Test
public void testRemove() {
    dao.remove(existingAdGroup.getid());
    LdapGroup result = dao.get(existingAdGroup.getid());
    assertNull(result);
}
#end_block

#method_before
private void OnAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar = new permissions();
        tempVar.setad_element_id(user.getuser_id());
        tempVar.setrole_id(role.getId());
        permissions perm = tempVar;
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar2 = new PermissionsOperationsParametes();
            tempVar2.setPermission(perm);
            tempVar2.setAdGroup(new AdGroups(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar2);
        } else {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar3);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#method_after
private void OnAttach() {
    AdElementListModel model = (AdElementListModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (model.getSelectedItems() == null) {
        Cancel();
        return;
    }
    ArrayList<DbUser> items = new ArrayList<DbUser>();
    for (Object item : model.getItems()) {
        EntityModel entityModel = (EntityModel) item;
        if (entityModel.getIsSelected()) {
            items.add((DbUser) entityModel.getEntity());
        }
    }
    Role role = (Role) model.getRole().getSelectedItem();
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (DbUser user : items) {
        permissions tempVar = new permissions();
        tempVar.setad_element_id(user.getuser_id());
        tempVar.setrole_id(role.getId());
        permissions perm = tempVar;
        if (user.getIsGroup()) {
            PermissionsOperationsParametes tempVar2 = new PermissionsOperationsParametes();
            tempVar2.setPermission(perm);
            tempVar2.setAdGroup(new LdapGroup(user.getuser_id(), user.getname(), user.getdomain()));
            list.add(tempVar2);
        } else {
            PermissionsOperationsParametes tempVar3 = new PermissionsOperationsParametes();
            tempVar3.setPermission(perm);
            tempVar3.setVdcUser(new VdcUser(user.getuser_id(), user.getusername(), user.getdomain()));
            list.add(tempVar3);
        }
    }
    model.StartProgress(null);
    Frontend.RunMultipleAction(VdcActionType.AddSystemPermission, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
            AdElementListModel localModel = (AdElementListModel) result.getState();
            localModel.StopProgress();
            Cancel();
        }
    }, model);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getVdcUser() != null) {
        AddCustomValue("NewUserName", getParameters().getVdcUser().getUserName());
        userId = getParameters().getVdcUser().getUserId();
        domain = getParameters().getVdcUser().getDomainControler();
        AdUser adUser = (AdUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdGroup() != null) {
        AddCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        AdGroups adGroup = (AdGroups) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getVdcUser() != null) {
        AddCustomValue("NewUserName", getParameters().getVdcUser().getUserName());
        userId = getParameters().getVdcUser().getUserId();
        domain = getParameters().getVdcUser().getDomainControler();
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdGroup() != null) {
        AddCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        LdapGroup adGroup = (LdapGroup) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return privateAdGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return privateAdGroup;
}
#end_block

#method_before
public void setAdGroup(AdGroups value) {
    privateAdGroup = value;
}
#method_after
public void setAdGroup(LdapGroup value) {
    privateAdGroup = value;
}
#end_block

#method_before
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        AdGroups group = new AdGroups();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#method_after
protected PermissionsOperationsParametes getPrincipal(permissions entity, Permission permission) {
    PermissionsOperationsParametes ret = null;
    if (isUserSubCollection() || permission.isSetUser()) {
        VdcUser user = new VdcUser();
        user.setUserId(isUserSubCollection() ? targetId : asGuid(permission.getUser().getId()));
        user.setDomainControler(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, user);
    } else if (isGroupSubCollection() || permission.isSetGroup()) {
        LdapGroup group = new LdapGroup();
        group.setid(isGroupSubCollection() ? targetId : asGuid(permission.getGroup().getId()));
        group.setdomain(getCurrent().get(Principal.class).getDomain());
        ret = new PermissionsOperationsParametes(entity, group);
    }
    return ret;
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = Group.class)
public static Group map(DbUser entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getuser_id().toString());
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapGroup.class, to = Group.class)
public static Group map(LdapGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getname());
    model.setId(entity.getid().toString());
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<AdGroups> groupList = new java.util.ArrayList<AdGroups>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                AdGroups group = new AdGroups(searchResult.getGuid(), groupName, getDomain(), distinguishedName, memberOf);
                initGroupFromDb(group);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    java.util.ArrayList<LdapGroup> groupList = new java.util.ArrayList<LdapGroup>();
    List<GroupSearchResult> searchResults = (List<GroupSearchResult>) directorySearcher.FindAll(getLdapQueryData());
    {
        for (GroupSearchResult searchResult : searchResults) {
            String distinguishedName = searchResult.getDistinguishedName();
            List<String> memberOf = searchResult.getMemberOf();
            if (distinguishedName != null) {
                String groupName = LdapBrokerUtils.generateGroupDisplayValue(searchResult.getDistinguishedName());
                LdapGroup group = new LdapGroup(searchResult.getGuid(), groupName, getDomain(), distinguishedName, memberOf);
                initGroupFromDb(group);
                groupList.add(group);
            }
        }
    }
    setReturnValue(groupList);
    setSucceeded(true);
}
#end_block

#method_before
private void initGroupFromDb(AdGroups group) {
    AdGroups dbGroup = DbFacade.getInstance().getAdGroupDao().get(group.getid());
}
#method_after
private void initGroupFromDb(LdapGroup group) {
    LdapGroup dbGroup = DbFacade.getInstance().getAdGroupDao().get(group.getid());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                tags_user_group_map map = new tags_user_group_map(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    AppendCustomValue("AttachGroupsNames", group.getname(), ", ");
                }
            } else {
                if (group != null) {
                    AppendCustomValue("AttachGroupsNamesExists", group.getname(), ", ");
                }
            }
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) == null) {
                TagsUserGroupMap map = new TagsUserGroupMap(groupGuid, getTagId());
                DbFacade.getInstance().getTagDao().attachUserGroupToTag(map);
                noActionDone = false;
                if (group != null) {
                    AppendCustomValue("AttachGroupsNames", group.getname(), ", ");
                }
            } else {
                if (group != null) {
                    AppendCustomValue("AttachGroupsNamesExists", group.getname(), ", ");
                }
            }
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void setUpGetEntityExpectations(int index) throws Exception {
    AdGroups user = BackendGroupsResourceTest.setUpEntityExpectations(control.createMock(AdGroups.class), index);
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": name=*", SearchType.AdGroup, user);
}
#method_after
protected void setUpGetEntityExpectations(int index) throws Exception {
    LdapGroup user = BackendGroupsResourceTest.setUpEntityExpectations(control.createMock(LdapGroup.class), index);
    setUpGetEntityExpectations("ADGROUP@" + DOMAIN + ": name=*", SearchType.AdGroup, user);
}
#end_block

#method_before
public AdGroups getAdGroup() {
    return _adGroup;
}
#method_after
public LdapGroup getAdGroup() {
    return _adGroup;
}
#end_block

#method_before
protected Groups mapDomainGroupsCollection(List<AdGroups> entities) {
    Groups collection = new Groups();
    for (AdGroups entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#method_after
protected Groups mapDomainGroupsCollection(List<LdapGroup> entities) {
    Groups collection = new Groups();
    for (LdapGroup entity : entities) {
        collection.getGroups().add(addLinks(modifyDomain(mapAdGroup(entity)), true));
    }
    return collection;
}
#end_block

#method_before
protected Group mapAdGroup(AdGroups entity) {
    return getMapper(AdGroups.class, Group.class).map(entity, null);
}
#method_after
protected Group mapAdGroup(LdapGroup entity) {
    return getMapper(LdapGroup.class, Group.class).map(entity, null);
}
#end_block

#method_before
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), AdGroups.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#method_after
protected String getSearchPattern(String param, String domain) {
    String constraint = QueryHelper.getConstraint(getUriInfo(), LdapGroup.class, false);
    final StringBuilder sb = new StringBuilder(128);
    sb.append(MessageFormat.format(AD_SEARCH_TEMPLATE, parent != null ? parent.getDirectory().getName() : domain == null ? getCurrent().get(Principal.class).getDomain() : domain));
    sb.append(StringHelper.isNullOrEmpty(constraint) ? "name=" + param : constraint);
    return sb.toString();
}
#end_block

#method_before
protected AdGroups getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<AdGroups> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (AdGroups adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#method_after
protected LdapGroup getAdGroup(Group group) {
    if (group.getId() != null) {
        return lookupGroupById(asGuid(group.getId()));
    }
    List<LdapGroup> adGroups = asCollection(getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*", getDomainName(group.getName()))));
    for (LdapGroup adGroup : adGroups) {
        if (adGroup.getname().equals(group.getName())) {
            return adGroup;
        }
    }
    return entityNotFound();
}
#end_block

#method_before
protected List<AdGroups> getGroupsFromDomain() {
    return asCollection(AdGroups.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#method_after
protected List<LdapGroup> getGroupsFromDomain() {
    return asCollection(LdapGroup.class, getEntity(ArrayList.class, SearchType.AdGroup, getSearchPattern("*")));
}
#end_block

#method_before
public AdGroups lookupGroupById(Guid id) {
    return getEntity(AdGroups.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#method_after
public LdapGroup lookupGroupById(Guid id) {
    return getEntity(LdapGroup.class, VdcQueryType.GetAdGroupById, new GetAdGroupByIdParameters(id), id.toString(), true);
}
#end_block

#method_before
@Override
public AdGroups lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#method_after
@Override
public LdapGroup lookupEntity(Guid nullId) {
    return lookupGroupById(id);
}
#end_block

#method_before
public static AdGroups getGroupByGroupGuid(Guid groupGuid) {
    return null;
}
#method_after
public static LdapGroup getGroupByGroupGuid(Guid groupGuid) {
    return null;
}
#end_block

#method_before
public static AdUser getUserByUserGuid(Guid userGuid) {
    AdUser retVal = null;
    DbUser dbUser = getDbUserDAO().get(userGuid);
    if (dbUser != null) {
        retVal = new AdUser(dbUser);
    }
    return retVal;
}
#method_after
public static LdapUser getUserByUserGuid(Guid userGuid) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().get(userGuid);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#end_block

#method_before
public static AdUser getUserByUPN(String userName) {
    AdUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByUsername(userName);
    if (dbUser != null) {
        retVal = new AdUser(dbUser);
    }
    return retVal;
}
#method_after
public static LdapUser getUserByUPN(String userName) {
    LdapUser retVal = null;
    DbUser dbUser = getDbUserDAO().getByUsername(userName);
    if (dbUser != null) {
        retVal = new LdapUser(dbUser);
    }
    return retVal;
}
#end_block

#method_before
public static List<AdGroups> getAllGroups() {
    return new ArrayList<AdGroups>();
}
#method_after
public static List<LdapGroup> getAllGroups() {
    return new ArrayList<LdapGroup>();
}
#end_block

#method_before
public static List<AdUser> getAllUsers() {
    List<AdUser> users = new ArrayList<AdUser>();
    AdUser user = getUserByUserGuid(ADMIN_GUID);
    if (user != null) {
        users.add(user);
    }
    return users;
}
#method_after
public static List<LdapUser> getAllUsers() {
    List<LdapUser> users = new ArrayList<LdapUser>();
    LdapUser user = getUserByUserGuid(ADMIN_GUID);
    if (user != null) {
        users.add(user);
    }
    return users;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            AdGroups group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    AppendCustomValue("DetachGroupsNames", group.getname(), ", ");
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid groupGuid : getGroupList()) {
            LdapGroup group = DbFacade.getInstance().getAdGroupDao().get(groupGuid);
            if (DbFacade.getInstance().getTagDao().getTagUserGroupByGroupIdAndByTagId(getTagId(), groupGuid) != null) {
                if (group != null) {
                    AppendCustomValue("DetachGroupsNames", group.getname(), ", ");
                }
                DbFacade.getInstance().getTagDao().detachUserGroupFromTag(getTagId(), groupGuid);
                noActionDone = false;
                setSucceeded(true);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void ExecuteQuery() {
    java.util.List<AdGroups> groupList = InternalBrokerUtils.getAllGroups();
    setReturnValue(groupList);
    setSucceeded(true);
}
#method_after
@Override
protected void ExecuteQuery() {
    java.util.List<LdapGroup> groupList = InternalBrokerUtils.getAllGroups();
    setReturnValue(groupList);
    setSucceeded(true);
}
#end_block

#method_before
@Mapping(from = AdUser.class, to = User.class)
public static User map(AdUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (AdGroups adgroup : entity.getGroups().values()) {
            Group group = new Group();
            group.setName(adgroup.getname());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringHelper.isNullOrEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomainControler());
        dom.setId(new NGuid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapUser.class, to = VdcUser.class)
public static VdcUser map(LdapUser adUser, VdcUser template) {
    VdcUser vdcUser = template != null ? template : new VdcUser();
    vdcUser.setUserId(adUser.getUserId());
    vdcUser.setUserName(adUser.getUserName());
    vdcUser.setSurName(adUser.getSurName());
    vdcUser.setDomainControler(adUser.getDomainControler());
    return vdcUser;
}
#end_block

#method_before
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(network_cluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#method_after
protected SessionFactory getSessionFactory() {
    if (sessionFactory == null) {
        sessionFactory = new AnnotationConfiguration().addAnnotatedClass(action_version_map.class).addAnnotatedClass(ad_groups.class).addAnnotatedClass(AsyncTasks.class).addAnnotatedClass(AuditLog.class).addAnnotatedClass(Bookmark.class).addAnnotatedClass(DbUser.class).addAnnotatedClass(DiskImage.class).addAnnotatedClass(DiskImageDynamic.class).addAnnotatedClass(event_map.class).addAnnotatedClass(event_notification_hist.class).addAnnotatedClass(event_notification_methods.class).addAnnotatedClass(event_subscriber.class).addAnnotatedClass(image_storage_domain_map.class).addAnnotatedClass(image_vm_map.class).addAnnotatedClass(LUN_storage_server_connection_map.class).addAnnotatedClass(LUNs.class).addAnnotatedClass(NetworkCluster.class).addAnnotatedClass(Network.class).addAnnotatedClass(permissions.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(Role.class).addAnnotatedClass(RoleGroupMap.class).addAnnotatedClass(StorageDomainDynamic.class).addAnnotatedClass(StorageDomainStatic.class).addAnnotatedClass(storage_pool.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(StorageServerConnections.class).addAnnotatedClass(tags.class).addAnnotatedClass(TagsUserGroupMap.class).addAnnotatedClass(TagsUserMap.class).addAnnotatedClass(TagsVdsMap.class).addAnnotatedClass(TagsVmMap.class).addAnnotatedClass(TagsVmPoolMap.class).addAnnotatedClass(user_sessions.class).addAnnotatedClass(VdcOption.class).addAnnotatedClass(VdsDynamic.class).addAnnotatedClass(VDSGroup.class).addAnnotatedClass(VdsStatic.class).addAnnotatedClass(VdsStatistics.class).addAnnotatedClass(vm_pool_map.class).addAnnotatedClass(vm_pools.class).addAnnotatedClass(vm_template_image_map.class).addAnnotatedClass(VmDynamic.class).addAnnotatedClass(VmStatic.class).addAnnotatedClass(StoragePoolIsoMap.class).addAnnotatedClass(VmTemplate.class).configure().buildSessionFactory();
    }
    return sessionFactory;
}
#end_block

#method_before
private ActivateDeactivateVmNicParameters createActivateDeactivateParameters(Guid nicId, PlugAction plugAction) {
    ActivateDeactivateVmNicParameters activateDeactivateVmNicParameters = new ActivateDeactivateVmNicParameters(nicId, plugAction);
    activateDeactivateVmNicParameters.setVmId(getParameters().getVmId());
    return activateDeactivateVmNicParameters;
}
#method_after
private ActivateDeactivateVmNicParameters createActivateDeactivateParameters(Guid nicId, PlugAction plugAction) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nicId, plugAction);
    parameters.setVmId(getParameters().getVmId());
    return parameters;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(DbFacade.getInstance().getVmStaticDao().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateNic(getParameters().getInterface().getId(), PlugAction.PLUG);
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getParameters().getInterface().getType()).getDescription()).toString());
    this.setVmName(getVmStaticDAO().get(getParameters().getVmId()).getvm_name());
    if (StringUtils.isEmpty(getMacAddress())) {
        getParameters().getInterface().setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getParameters().getInterface().setId(Guid.NewGuid());
    getParameters().getInterface().setVmId(getParameters().getVmId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addInterfaceToDb(getParameters().getInterface());
            addInterfaceDeviceToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    boolean succeeded = true;
    if (getParameters().getInterface().isActive()) {
        succeeded = activateOrDeactivateNic(getParameters().getInterface().getId(), PlugAction.PLUG);
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    DbFacade dbFacade = DbFacade.getInstance();
    dbFacade.getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    dbFacade.getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#method_after
private void addInterfaceToDb(VmNetworkInterface vmNetworkInterface) {
    getVmNetworkInterfaceDao().save(vmNetworkInterface);
    getCompensationContext().snapshotNewEntity(vmNetworkInterface);
    getDbFacade().getVmNetworkStatisticsDao().save(vmNetworkInterface.getStatistics());
    getCompensationContext().snapshotNewEntity(vmNetworkInterface.getStatistics());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(DbFacade.getInstance().getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    boolean unlinkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!unlinkingSupported) {
        if (!getParameters().getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getParameters().getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
    }
    if (getParameters().getInterface().getNetworkName() != null) {
        // check that the exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getParameters().getInterface().getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VmStatic vm = getVm().getStaticData();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    switch(getVmDynamicDao().get(getParameters().getVmId()).getstatus()) {
        case Up:
        case Down:
        case ImageLocked:
            break;
        default:
            addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_ADD_INTERFACE_WHEN_VM_STATUS_NOT_UP_DOWN_LOCKED);
            return false;
    }
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getParameters().getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNetworkInterface> allInterfaces = new ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.add(getParameters().getInterface());
    List<Disk> allDisks = getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    String compatibilityVersion = getVm().getVdsGroupCompatibilityVersion().getValue();
    VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), compatibilityVersion);
    if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid())) {
        return false;
    }
    if (getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(vm.getvds_group_id());
        Network interfaceNetwork = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network network) {
                return network.getname().equals(getNetworkName());
            }
        });
        if (interfaceNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        } else if (!interfaceNetwork.isVmNetwork()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NOT_A_VM_NETWORK);
            addCanDoActionMessage(String.format("$networks %1$s", interfaceNetwork.getname()));
            return false;
        }
    }
    if (!StringUtils.isEmpty(getMacAddress())) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    } else if (// check
    MacPoolManager.getInstance().getavailableMacsCount() <= 0) // if
    // we
    // have
    // mac
    // address
    // in
    // pool
    {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && StringUtils.isNotEmpty(getNetworkName()) && getVm() != null) {
        Network network = getNetworkDAO().getByNameAndCluster(getNetworkName(), getVm().getVdsGroupId());
        if (getParameters().getInterface().isPortMirroring()) {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, ActionGroup.PORT_MIRRORING));
        } else {
            permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, getActionType().getActionGroup()));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected void initDeviceStructure() {
    super.initDeviceStructure();
    VmNetworkInterface nic = getParameters().getNic();
    if (nic.getNetworkName() != null) {
        deviceStruct.add(VdsProperties.network, nic.getNetworkName());
    } else {
        deviceStruct.add(VdsProperties.network, "");
    }
    deviceStruct.add(VdsProperties.linkActive, String.valueOf(nic.isLinked()));
    if (nic.isPortMirroring() && nic.getNetworkName() != null) {
        deviceStruct.add(VdsProperties.portMirroring, Collections.singletonList(nic.getNetworkName()));
    } else {
        deviceStruct.add(VdsProperties.portMirroring, new ArrayList<String>());
    }
}
#method_after
protected XmlRpcStruct initDeviceStructure() {
    XmlRpcStruct deviceStruct = new XmlRpcStruct();
    deviceStruct.add(VdsProperties.DeviceType, getParameters().getVmDevice().getType());
    deviceStruct.add(VdsProperties.Alias, getParameters().getVmDevice().getAlias());
    VmNetworkInterface nic = getParameters().getNic();
    deviceStruct.add(VdsProperties.network, StringUtils.defaultString(nic.getNetworkName()));
    deviceStruct.add(VdsProperties.linkActive, String.valueOf(nic.isLinked()));
    deviceStruct.add(VdsProperties.portMirroring, nic.isPortMirroring() && nic.getNetworkName() != null ? Collections.singletonList(nic.getNetworkName()) : Collections.<String>emptyList());
    return deviceStruct;
}
#end_block

#method_before
public boolean isValidVmNetwork(VmNetworkInterface iface, Map<String, Network> networksByName) {
    String networkName = iface.getNetworkName();
    if (networkName == null) {
        return true;
    }
    return (networksByName.containsKey(networkName) && networksByName.get(networkName).isVmNetwork());
}
#method_after
public boolean isValidVmNetwork(VmNetworkInterface iface, Map<String, Network> networksByName) {
    String networkName = iface.getNetworkName();
    return networkName == null || ((networksByName.containsKey(networkName) && networksByName.get(networkName).isVmNetwork()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(oldIface);
            DbFacade.getInstance().getVmNetworkInterfaceDao().update(getInterface());
            if (macAddressChanged) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            }
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(updateHost());
}
#method_after
@Override
protected void executeVmCommand() {
    AddCustomValue("InterfaceType", (VmInterfaceType.forValue(getInterface().getType()).getDescription()).toString());
    getInterface().setSpeed(VmInterfaceType.forValue(getInterface().getType()).getSpeed());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(oldIface);
            getVmNetworkInterfaceDao().update(getInterface());
            if (macAddressChanged) {
                MacPoolManager.getInstance().freeMac(oldIface.getMacAddress());
            }
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setSucceeded(updateHost());
}
#end_block

#method_before
private boolean updateHost() {
    if (getRequiredVdsAction() != null) {
        switch(getRequiredVdsAction()) {
            case plug:
                {
                    return activateNic(getInterface().getId(), PlugAction.PLUG);
                }
            case unplug:
                {
                    return activateNic(getInterface().getId(), PlugAction.UNPLUG);
                }
            case update:
                {
                    runVdsCommand(VDSCommandType.UpdateVmInterface, new UpdateVmInterfaceVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getInterface().getId()), oldVmDevice));
                }
        }
    }
    return true;
}
#method_after
private boolean updateHost() {
    if (getVm().getStatus() == VMStatus.Up) {
        setVdsId(getVm().getRunOnVds().getValue());
    }
    if (getRequiredAction() != null) {
        switch(getRequiredAction()) {
            case PLUG:
                {
                    return activateOrDeactivateNic(getInterface().getId(), PlugAction.PLUG);
                }
            case UNPLUG:
                {
                    return activateOrDeactivateNic(getInterface().getId(), PlugAction.UNPLUG);
                }
            case UPDATE_VM_DEVICE:
                {
                    runVdsCommand(VDSCommandType.UpdateVmInterface, new VmNicDeviceVDSParameters(getVdsId(), getVm(), getVmNetworkInterfaceDao().get(getInterface().getId()), oldVmDevice));
                    break;
                }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getParameters().getVmId()));
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = DbFacade.getInstance().getVmStaticDao().get(getParameters().getVmId());
    List<Disk> allDisks = DbFacade.getInstance().getDiskDao().getAllForVm(getParameters().getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    if (getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    if (getRequiredVdsAction() == VdsAction.unplugPlug) {
        addCanDoActionMessage(VdcBllMessages.CANNOT_PERFOM_HOT_UPDATE);
        return false;
    }
    boolean linkingSupported = Config.<Boolean>GetValue(ConfigValues.NetworkLinkingSupported, getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!linkingSupported) {
        if (!getInterface().isLinked()) {
            addCanDoActionMessage(VdcBllMessages.UNLINKING_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getInterface().getNetworkName() == null) {
            addCanDoActionMessage(VdcBllMessages.NULL_NETWORK_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
        if (getRequiredVdsAction() == VdsAction.update) {
            addCanDoActionMessage(VdcBllMessages.HOT_VM_INTERFACE_UPDATE_IS_NOT_SUPPORTED);
            addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion().getValue()));
            return false;
        }
    } else {
        if (getRequiredVdsAction() == VdsAction.update) {
            if (getInterface().isPortMirroring()) {
                addCanDoActionMessage(VdcBllMessages.CANNOT_PERFOM_HOT_UPDATE_WITH_PORT_MIRRORING);
                return false;
            }
        }
    }
    if (getInterface().getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(vm.getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return n.getname().equals(getInterface().getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!updateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_CANNOT_CHANGE_STATUS_WHEN_NOT_DOWN_UP);
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNetworkInterface> interfaces = getVmNetworkInterfaceDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNetworkInterface>() {

        @Override
        public boolean eval(VmNetworkInterface i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterface().getName())) {
        if (!VmHandler.IsNotDuplicateInterfaceName(interfaces, getInterface().getName(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    // check that not exceeded PCI and IDE limit
    java.util.ArrayList<VmNetworkInterface> allInterfaces = new java.util.ArrayList<VmNetworkInterface>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    List<Disk> allDisks = getDiskDao().getAllForVm(getVmId());
    if (!checkPciAndIdeLimit(vm.getnum_of_monitors(), allInterfaces, allDisks, getReturnValue().getCanDoActionMessages())) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__INTERFACE);
        return false;
    }
    if (getInterface().getVmTemplateId() != null) {
        addCanDoActionMessage(VdcBllMessages.NETWORK_INTERFACE_TEMPLATE_CANNOT_BE_SET);
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion().getValue());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.networkNameValid()) || !validate(nicValidator.hotUpdatePossible())) {
        return false;
    }
    if (getInterface().getNetworkName() != null) {
        // check that the network exists in current cluster
        List<Network> networks = getNetworkDAO().getAllForCluster(vm.getvds_group_id());
        if (null == LinqUtils.firstOrNull(networks, new Predicate<Network>() {

            @Override
            public boolean eval(Network n) {
                return n.getname().equals(getInterface().getNetworkName());
            }
        })) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER);
            return false;
        }
    }
    macAddressChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macAddressChanged) {
        Regex re = new Regex(ValidationUtils.INVALID_NULLABLE_MAC_ADDRESS);
        if (re.IsMatch(getMacAddress())) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_INVALID_MAC_ADDRESS);
            return false;
        }
        Boolean allowDupMacs = Config.<Boolean>GetValue(ConfigValues.AllowDuplicateMacAddresses);
        // this must be the last check because it adds the mac address to the pool
        if (!MacPoolManager.getInstance().AddMac(getMacAddress()) && !allowDupMacs) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_MAC_ADDRESS_IN_USE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getParameters().getInterface() != null && getVm() != null && getParameters().getInterface().isPortMirroring()) {
        permissionList.add(new PermissionSubject(getVm().getStoragePoolId(), VdcObjectType.StoragePool, ActionGroup.PORT_MIRRORING));
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getInterface() != null && StringUtils.isNotEmpty(getNetworkName()) && getVm() != null) {
        VmNetworkInterface iface = getVmNetworkInterfaceDao().get(getInterface().getId());
        if (iface != null) {
            Network network = getNetworkDAO().getByNameAndCluster(getNetworkName(), getVm().getVdsGroupId());
            if (getInterface().isPortMirroring() && (isNetworkChanged(iface) || !iface.isPortMirroring())) {
                permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, ActionGroup.PORT_MIRRORING));
            } else {
                // If the vNic's network is changed, the user should have permission for using the new network
                if (isNetworkChanged(iface)) {
                    permissionList.add(new PermissionSubject(network == null ? null : network.getId(), VdcObjectType.Network, getActionType().getActionGroup()));
                }
            }
        }
    }
    return permissionList;
}
#end_block

#method_before
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getVdsGroupId().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return n.getname().equals(iface.getNetworkName());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#method_after
private void UpdateVmNetworks() {
    // check if the cluster has changed
    if (!getVm().getVdsGroupId().equals(getParameters().getVmStaticData().getvds_group_id())) {
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(getParameters().getVmStaticData().getvds_group_id());
        List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getVmStaticData().getId());
        for (final VmNetworkInterface iface : interfaces) {
            Network net = LinqUtils.firstOrNull(networks, new Predicate<Network>() {

                @Override
                public boolean eval(Network n) {
                    return n.getName().equals(iface.getNetworkName());
                }
            });
            // interface connection
            if (net == null) {
                iface.setNetworkName(null);
                DbFacade.getInstance().getVmNetworkInterfaceDao().update(iface);
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        tempVar.setGetAll(true);
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                storage_domain_static targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = sourceDomainValidator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages());
    }
    if (retVal && getSourceDomain().getstorage_domain_type() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, DiskImageList> templates = (Map) qretVal.getReturnValue();
            DiskImageList images = new DiskImageList();
            for (VmTemplate t : templates.keySet()) {
                if (t.getId().equals(getVmTemplate().getId())) {
                    images = templates.get(t);
                    getVmTemplate().setInterfaces(t.getInterfaces());
                    break;
                }
            }
            ArrayList<DiskImage> list = new ArrayList<DiskImage>(Arrays.asList(images.getDiskImages()));
            getParameters().setImages(list);
            getVmTemplate().setImages(list);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            Map<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : list) {
                storage_domains storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validator.isDomainExistAndActive(getReturnValue().getCanDoActionMessages()) && validator.domainIsValidDestination(getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getstorage_type(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setstorage_pool_id(getParameters().getStoragePoolId());
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getname()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<storage_domains, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getsize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<storage_domains, Integer> entry : domainMap.entrySet()) {
            retVal = StorageDomainSpaceChecker.hasSpaceForRequest(entry.getKey(), entry.getValue());
            if (!retVal) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW);
                break;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(getVmTemplate().getInterfaces());
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).InnerText);
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).InnerText : "");
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(networkName)) {
        iface.setNetworkName(networkName);
    } else {
        iface.setNetworkName(null);
    }
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    if (linkedNode != null) {
        iface.setLinked(Boolean.valueOf(linkedNode.InnerText));
    } else {
        iface.setLinked(true);
    }
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#method_after
protected void updateSingleNic(XmlNode node, VmNetworkInterface iface) {
    iface.setName(node.SelectSingleNode(OvfProperties.VMD_NAME, _xmlNS).InnerText);
    iface.setMacAddress((node.SelectSingleNode("rasd:MACAddress", _xmlNS) != null) ? node.SelectSingleNode("rasd:MACAddress", _xmlNS).InnerText : "");
    String networkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).InnerText;
    iface.setNetworkName(StringUtils.defaultIfEmpty(networkName, null));
    XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
    iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.InnerText));
    String resourceSubType = node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText;
    if (StringUtils.isNotEmpty(resourceSubType)) {
        iface.setType(Integer.parseInt(resourceSubType));
    }
    XmlNode speed = node.SelectSingleNode("rasd:speed", _xmlNS);
    iface.setSpeed((speed != null) ? Integer.parseInt(speed.InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
}
#end_block

#method_before
private void initInterfaces(VM vm) {
    List<VmNetworkInterface> interfaceList = new ArrayList<VmNetworkInterface>();
    VmNetworkInterface vmInterface = new VmNetworkInterface();
    vmInterface.setStatistics(new VmNetworkStatistics());
    vmInterface.setId(Guid.NewGuid());
    vmInterface.setName("eth77");
    vmInterface.setNetworkName("blue");
    vmInterface.setLinked(false);
    vmInterface.setSpeed(1000);
    vmInterface.setType(3);
    vmInterface.setMacAddress("01:C0:81:21:71:17");
    VmNetworkInterface vmInterface2 = new VmNetworkInterface();
    vmInterface2.setStatistics(new VmNetworkStatistics());
    vmInterface2.setId(Guid.NewGuid());
    vmInterface2.setName("eth88");
    vmInterface2.setNetworkName(null);
    vmInterface2.setLinked(true);
    vmInterface2.setSpeed(1234);
    vmInterface2.setType(1);
    vmInterface2.setMacAddress("02:C1:92:22:25:28");
    interfaceList.add(vmInterface);
    interfaceList.add(vmInterface2);
    vm.setInterfaces(interfaceList);
}
#method_after
private void initInterfaces(VM vm) {
    VmNetworkInterface vmInterface = new VmNetworkInterface();
    vmInterface.setStatistics(new VmNetworkStatistics());
    vmInterface.setId(Guid.NewGuid());
    vmInterface.setName("eth77");
    vmInterface.setNetworkName("blue");
    vmInterface.setLinked(false);
    vmInterface.setSpeed(1000);
    vmInterface.setType(3);
    vmInterface.setMacAddress("01:C0:81:21:71:17");
    VmNetworkInterface vmInterface2 = new VmNetworkInterface();
    vmInterface2.setStatistics(new VmNetworkStatistics());
    vmInterface2.setId(Guid.NewGuid());
    vmInterface2.setName("eth88");
    vmInterface2.setNetworkName(null);
    vmInterface2.setLinked(true);
    vmInterface2.setSpeed(1234);
    vmInterface2.setType(1);
    vmInterface2.setMacAddress("02:C1:92:22:25:28");
    vm.setInterfaces(Arrays.asList(vmInterface, vmInterface2));
}
#end_block

#method_before
@Override
protected void ReadHardwareSection(XmlNode section) {
    XmlNodeList list = section.SelectNodes("Item");
    for (XmlNode node : list) {
        int resourceType = Integer.parseInt(node.SelectSingleNode("rasd:ResourceType", _xmlNS).InnerText);
        switch(resourceType) {
            // CPU
            case 3:
                _vmTemplate.setnum_of_sockets(Integer.parseInt(node.SelectSingleNode("rasd:num_of_sockets", _xmlNS).InnerText));
                _vmTemplate.setcpu_per_socket(Integer.parseInt(node.SelectSingleNode("rasd:cpu_per_socket", _xmlNS).InnerText));
                break;
            // Memory
            case 4:
                _vmTemplate.setmem_size_mb(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
                break;
            // Image
            case 17:
                final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).InnerText);
                DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

                    @Override
                    public boolean eval(DiskImage diskImage) {
                        return diskImage.getImageId().equals(guid);
                    }
                });
                image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).InnerText));
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText)) {
                    image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText));
                }
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText)) {
                    image.setit_guid(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText));
                }
                image.setappList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).InnerText);
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText)) {
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText))));
                }
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText)) {
                    image.setstorage_pool_id(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText));
                }
                final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).InnerText);
                if (creationDate != null) {
                    image.setcreation_date(creationDate);
                }
                final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).InnerText);
                if (lastModified != null) {
                    image.setlastModified(lastModified);
                }
                readVmDevice(node, _vmTemplate, image.getId(), Boolean.TRUE);
                break;
            // Network
            case 10:
                VmNetworkInterface iface = getNetwotkInterface(node);
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText)) {
                    iface.setType(Integer.parseInt(node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText));
                }
                String resourceSubNetworkName = node.SelectSingleNode("rasd:Connection", _xmlNS).InnerText;
                if (StringUtils.isNotEmpty(resourceSubNetworkName)) {
                    iface.setNetworkName(resourceSubNetworkName);
                } else {
                    iface.setNetworkName(null);
                }
                XmlNode linkedNode = node.SelectSingleNode("rasd:Linked", _xmlNS);
                if (linkedNode != null) {
                    iface.setLinked(Boolean.valueOf(linkedNode.InnerText));
                } else {
                    iface.setLinked(true);
                }
                iface.setName(node.SelectSingleNode("rasd:Name", _xmlNS).InnerText);
                iface.setSpeed((node.SelectSingleNode("rasd:speed", _xmlNS) != null) ? Integer.parseInt(node.SelectSingleNode("rasd:speed", _xmlNS).InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
                _vmTemplate.getInterfaces().add(iface);
                readVmDevice(node, _vmTemplate, iface.getId(), Boolean.TRUE);
                break;
            // CDROM
            case 15:
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.TRUE);
                break;
            // USB
            case 23:
                _vmTemplate.setusb_policy(UsbPolicy.forStringValue(node.SelectSingleNode("rasd:UsbPolicy", _xmlNS).InnerText));
                break;
            // Monitor
            case 20:
                _vmTemplate.setnum_of_monitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.TRUE);
                break;
            // OTHER
            case 0:
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.FALSE);
                break;
        }
    }
}
#method_after
@Override
protected void ReadHardwareSection(XmlNode section) {
    XmlNodeList list = section.SelectNodes("Item");
    for (XmlNode node : list) {
        int resourceType = Integer.parseInt(node.SelectSingleNode("rasd:ResourceType", _xmlNS).InnerText);
        switch(resourceType) {
            // CPU
            case 3:
                _vmTemplate.setnum_of_sockets(Integer.parseInt(node.SelectSingleNode("rasd:num_of_sockets", _xmlNS).InnerText));
                _vmTemplate.setcpu_per_socket(Integer.parseInt(node.SelectSingleNode("rasd:cpu_per_socket", _xmlNS).InnerText));
                break;
            // Memory
            case 4:
                _vmTemplate.setmem_size_mb(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
                break;
            // Image
            case 17:
                final Guid guid = new Guid(node.SelectSingleNode("rasd:InstanceId", _xmlNS).InnerText);
                DiskImage image = LinqUtils.firstOrNull(_images, new Predicate<DiskImage>() {

                    @Override
                    public boolean eval(DiskImage diskImage) {
                        return diskImage.getImageId().equals(guid);
                    }
                });
                image.setId(OvfParser.GetImageGrupIdFromImageFile(node.SelectSingleNode("rasd:HostResource", _xmlNS).InnerText));
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText)) {
                    image.setParentId(new Guid(node.SelectSingleNode("rasd:Parent", _xmlNS).InnerText));
                }
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText)) {
                    image.setit_guid(new Guid(node.SelectSingleNode("rasd:Template", _xmlNS).InnerText));
                }
                image.setappList(node.SelectSingleNode("rasd:ApplicationList", _xmlNS).InnerText);
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText)) {
                    image.setstorage_ids(new ArrayList<Guid>(Arrays.asList(new Guid(node.SelectSingleNode("rasd:StorageId", _xmlNS).InnerText))));
                }
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText)) {
                    image.setstorage_pool_id(new Guid(node.SelectSingleNode("rasd:StoragePoolId", _xmlNS).InnerText));
                }
                final Date creationDate = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:CreationDate", _xmlNS).InnerText);
                if (creationDate != null) {
                    image.setcreation_date(creationDate);
                }
                final Date lastModified = OvfParser.UtcDateStringToLocaDate(node.SelectSingleNode("rasd:LastModified", _xmlNS).InnerText);
                if (lastModified != null) {
                    image.setlastModified(lastModified);
                }
                readVmDevice(node, _vmTemplate, image.getId(), Boolean.TRUE);
                break;
            // Network
            case 10:
                VmNetworkInterface iface = getNetwotkInterface(node);
                if (!StringHelper.isNullOrEmpty(node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText)) {
                    iface.setType(Integer.parseInt(node.SelectSingleNode("rasd:ResourceSubType", _xmlNS).InnerText));
                }
                String resourceSubNetworkName = node.SelectSingleNode(OvfProperties.VMD_CONNECTION, _xmlNS).InnerText;
                iface.setNetworkName(StringUtils.defaultIfEmpty(resourceSubNetworkName, null));
                XmlNode linkedNode = node.SelectSingleNode(OvfProperties.VMD_LINKED, _xmlNS);
                iface.setLinked(linkedNode == null ? true : Boolean.valueOf(linkedNode.InnerText));
                iface.setName(node.SelectSingleNode("rasd:Name", _xmlNS).InnerText);
                iface.setSpeed((node.SelectSingleNode("rasd:speed", _xmlNS) != null) ? Integer.parseInt(node.SelectSingleNode("rasd:speed", _xmlNS).InnerText) : VmInterfaceType.forValue(iface.getType()).getSpeed());
                _vmTemplate.getInterfaces().add(iface);
                readVmDevice(node, _vmTemplate, iface.getId(), Boolean.TRUE);
                break;
            // CDROM
            case 15:
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.TRUE);
                break;
            // USB
            case 23:
                _vmTemplate.setusb_policy(UsbPolicy.forStringValue(node.SelectSingleNode("rasd:UsbPolicy", _xmlNS).InnerText));
                break;
            // Monitor
            case 20:
                _vmTemplate.setnum_of_monitors(Integer.parseInt(node.SelectSingleNode("rasd:VirtualQuantity", _xmlNS).InnerText));
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.TRUE);
                break;
            // OTHER
            case 0:
                readVmDevice(node, _vmTemplate, Guid.NewGuid(), Boolean.FALSE);
                break;
        }
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#method_after
public static void updateVDSDynamicData(VDS vds, XmlRpcStruct xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setcpu_cores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setcpu_sockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setcpu_model(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setcpu_speed_mh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setphysical_mem_mb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setkvm_enabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setreserved_mem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setguest_overhead(guestOverhead != null ? guestOverhead : 0);
    vds.setcpu_flags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setsupported_cluster_levels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setsupported_engines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.getItem(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
}
#end_block

#method_before
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / VdsSelector.geteffective_cpu_cores(vds);
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#method_after
public static boolean hasCpuToRunVM(VDS vds, VM vm) {
    if (vds.getusage_cpu_percent() == null || vm.getUsageCpuPercent() == null) {
        return false;
    }
    // The predicted CPU is actually the CPU that the VM will take considering how many cores it has and now many
    // cores the host has. This is why we take both parameters into consideration.
    int predictedVmCpu = (vm.getUsageCpuPercent() * vm.getNumOfCpus()) / VdsSelector.getEffectiveCpuCores(vds);
    boolean result = vds.getusage_cpu_percent() + predictedVmCpu <= vds.gethigh_utilization();
    if (log.isDebugEnabled()) {
        log.debugFormat("Host {0} has {1}% CPU load; VM {2} is predicted to have {3}% CPU load; " + "High threshold is {4}%. Host is {5}suitable in terms of CPU.", vds.getvds_name(), vds.getusage_cpu_percent(), vm.getVmName(), predictedVmCpu, vds.gethigh_utilization(), (result ? "" : "not "));
    }
    return result;
}
#end_block

#method_before
private double calcDistributeMetric(VDS vds, VM vm) {
    int vcpu = Config.<Integer>GetValue(ConfigValues.VcpuConsumptionPercentage);
    int spmCpu = (vds.getspm_status() == VdsSpmStatus.None) ? 0 : Config.<Integer>GetValue(ConfigValues.SpmVCpuConsumption);
    int hostCores = VdsSelector.geteffective_cpu_cores(vds);
    double hostCpu = vds.getusage_cpu_percent();
    double pendingVcpus = vds.getpending_vcpus_count();
    return (hostCpu / vcpu) + (pendingVcpus + vm.getNumOfCpus() + spmCpu) / hostCores;
}
#method_after
private double calcDistributeMetric(VDS vds, VM vm) {
    int vcpu = Config.<Integer>GetValue(ConfigValues.VcpuConsumptionPercentage);
    int spmCpu = (vds.getspm_status() == VdsSpmStatus.None) ? 0 : Config.<Integer>GetValue(ConfigValues.SpmVCpuConsumption);
    int hostCores = VdsSelector.getEffectiveCpuCores(vds);
    double hostCpu = vds.getusage_cpu_percent();
    double pendingVcpus = vds.getpending_vcpus_count();
    return (hostCpu / vcpu) + (pendingVcpus + vm.getNumOfCpus() + spmCpu) / hostCores;
}
#end_block

#method_before
@Override
public boolean IsBetter(VDS x, VDS y, VM vm) {
    if (VdsSelector.geteffective_cpu_cores(x) == null || VdsSelector.geteffective_cpu_cores(y) == null || x.getusage_cpu_percent() == null || y.getusage_cpu_percent() == null || x.getpending_vcpus_count() == null || y.getpending_vcpus_count() == null) {
        return false;
    }
    return calcDistributeMetric(x, vm) > calcDistributeMetric(y, vm);
}
#method_after
@Override
public boolean IsBetter(VDS x, VDS y, VM vm) {
    if (VdsSelector.getEffectiveCpuCores(x) == null || VdsSelector.getEffectiveCpuCores(y) == null || x.getusage_cpu_percent() == null || y.getusage_cpu_percent() == null || x.getpending_vcpus_count() == null || y.getpending_vcpus_count() == null) {
        return false;
    }
    return calcDistributeMetric(x, vm) > calcDistributeMetric(y, vm);
}
#end_block

#method_before
@Override
protected void InitOverUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() > vmCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o2.getvm_count() - o1.getvm_count();
        }
    });
    setOverUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitOverUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() > vmCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o2.getvm_count() - o1.getvm_count();
        }
    });
    setOverUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
@Override
protected void InitUnderUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < vmCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o1.getvm_count() - o2.getvm_count();
        }
    });
    setUnderUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitUnderUtilizedList() {
    int vmCount = 0;
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                vmCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int vmCountTemp = vmCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < vmCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    Collections.sort(vdses, new Comparator<VDS>() {

        @Override
        public int compare(VDS o1, VDS o2) {
            return o1.getvm_count() - o2.getvm_count();
        }
    });
    setUnderUtilizedServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
@Override
protected void InitReadyToMigrationList() {
    int highVdsCount = 0;
    int lowVdsCount = 0;
    int afterThreasholdInPercent = Config.<Integer>GetValue(ConfigValues.UtilizationThresholdInPercent);
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int highVdsCountTemp = highVdsCount;
    final int lowVdsCountTemp = lowVdsCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < highVdsCountTemp * VdsSelector.geteffective_cpu_cores(p) && p.getvm_count() >= lowVdsCountTemp * VdsSelector.geteffective_cpu_cores(p);
        }
    });
    setReadyToMigrationServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#method_after
@Override
protected void InitReadyToMigrationList() {
    int highVdsCount = 0;
    int lowVdsCount = 0;
    int afterThreasholdInPercent = Config.<Integer>GetValue(ConfigValues.UtilizationThresholdInPercent);
    switch(getDefaultSelectionAlgorithm()) {
        case EvenlyDistribute:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForEvenlyDistribute) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForEvenlyDistribute);
                break;
            }
        case PowerSave:
            {
                highVdsCount = Math.min(afterThreasholdInPercent * Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) / 100, Config.<Integer>GetValue(ConfigValues.HighUtilizationForPowerSave) - 1);
                lowVdsCount = Config.<Integer>GetValue(ConfigValues.LowUtilizationForPowerSave);
                break;
            }
    }
    final int highVdsCountTemp = highVdsCount;
    final int lowVdsCountTemp = lowVdsCount;
    List<VDS> vdses = LinqUtils.filter(getAllRelevantVdss(), new Predicate<VDS>() {

        @Override
        public boolean eval(VDS p) {
            return p.getvm_count() < highVdsCountTemp * VdsSelector.getEffectiveCpuCores(p) && p.getvm_count() >= lowVdsCountTemp * VdsSelector.getEffectiveCpuCores(p);
        }
    });
    setReadyToMigrationServers(LinqUtils.toMap(vdses, new DefaultMapper<VDS, Guid>() {

        @Override
        public Guid createKey(VDS vds) {
            return vds.getId();
        }
    }));
}
#end_block

#method_before
private int calculateCpuUsage(VDS o1) {
    return o1.getusage_cpu_percent() * VdsSelector.geteffective_cpu_cores(o1) / o1.getvds_strength();
}
#method_after
private int calculateCpuUsage(VDS o1) {
    return o1.getusage_cpu_percent() * VdsSelector.getEffectiveCpuCores(o1) / o1.getvds_strength();
}
#end_block

#method_before
private void UpdateProperties() {
    VDS vds = getEntity();
    setOS(vds.gethost_os());
    setKernelVersion(vds.getkernel_version());
    setKvmVersion(vds.getkvm_version());
    setLibvirtVersion(vds.getlibvirt_version());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getspice_version());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setActiveVms(vds.getvm_active());
    setCpuName(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuType(vds.getcpu_model());
    setNumberOfSockets(vds.getcpu_sockets());
    setCoresPerSocket((vds.getcpu_cores() != null && vds.getcpu_sockets() != null) ? vds.getcpu_cores() / vds.getcpu_sockets() : null);
    // vdsm may be accounting for hyperthreading already by doubling the core count
    setCpuHyperthreading(// $NON-NLS-1$
    vds.getvdsm_count_threads_as_cores() == null ? // $NON-NLS-1$
    "Unknown" : (// $NON-NLS-1$
    vds.getvdsm_count_threads_as_cores() ? // $NON-NLS-1$
    "Virtual (vdsm.conf setting)" : // $NON-NLS-1$ //$NON-NLS-2$
    (vds.getcpu_ht_enabled() ? "Enabled" : "Disabled")));
    setPhysicalMemory(vds.getphysical_mem_mb());
    setSwapTotal(vds.getswap_total());
    setSwapFree(vds.getswap_free());
    setSharedMemory(vds.getmem_shared_percent());
    setMemoryPageSharing(vds.getksm_state());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
}
#method_after
private void UpdateProperties() {
    VDS vds = getEntity();
    setOS(vds.gethost_os());
    setKernelVersion(vds.getkernel_version());
    setKvmVersion(vds.getkvm_version());
    setLibvirtVersion(vds.getlibvirt_version());
    setVdsmVersion(vds.getVersion());
    setSpiceVersion(vds.getspice_version());
    setIScsiInitiatorName(vds.getIScsiInitiatorName());
    setActiveVms(vds.getvm_active());
    setCpuName(vds.getCpuName() != null ? vds.getCpuName().getCpuName() : null);
    setCpuType(vds.getcpu_model());
    setNumberOfSockets(vds.getcpu_sockets());
    setCoresPerSocket((vds.getcpu_cores() != null && vds.getcpu_sockets() != null) ? vds.getcpu_cores() / vds.getcpu_sockets() : null);
    if (vds.getvds_group_compatibility_version() != null && Version.v3_2.compareTo(vds.getvds_group_compatibility_version()) > 0) {
        // Members of pre-3.2 clusters don't support SMT; here we act like a 3.1 engine
        // $NON-NLS-1$
        setThreadsPerCore("Unsupported");
    } else if (vds.getCpuThreads() == null || vds.getcpu_cores() == null) {
        // $NON-NLS-1$
        setThreadsPerCore("Unknown");
    } else {
        Integer threads = vds.getCpuThreads() / vds.getcpu_cores();
        // $NON-NLS-1$ //$NON-NLS-2$
        setThreadsPerCore(threads.toString() + (threads > 1 ? " (SMT Enabled)" : " (SMT Disabled)"));
    }
    setPhysicalMemory(vds.getphysical_mem_mb());
    setSwapTotal(vds.getswap_total());
    setSwapFree(vds.getswap_free());
    setSharedMemory(vds.getmem_shared_percent());
    setMemoryPageSharing(vds.getksm_state());
    setAutomaticLargePage(vds.getTransparentHugePagesState());
}
#end_block

#method_before
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setEnableOvirtService(new EntityModel());
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    setEnableGlusterService(new EntityModel());
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCPUOvercommit(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#method_after
public void Init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel());
    setDescription(new EntityModel());
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && (Boolean) getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && (Boolean) getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel());
    setOptimizationForServer(new EntityModel());
    setOptimizationForDesktop(new EntityModel());
    setOptimizationCustom(new EntityModel());
    EntityModel tempVar = new EntityModel();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.GetClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.GetClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel(true));
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.GetClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.GetClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    getVersion().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            fetchFingerprint((String) getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel());
    setIsImportGlusterConfiguration(new EntityModel());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && (Boolean) getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity((boolean) getEntity().getcount_threads_as_cores());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (storage_pool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getdescription());
    setMemoryOverCommit(getEntity().getmax_vds_memory_over_commit());
    getCountThreadsAsCores().setEntity((boolean) getEntity().getCountThreadsAsCores());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<storage_pool> dataCenters = (ArrayList<storage_pool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            for (storage_pool a : dataCenters) {
                if (clusterModel.getEntity().getStoragePoolId() != null && a.getId().equals(clusterModel.getEntity().getStoragePoolId())) {
                    clusterModel.getDataCenter().setSelectedItem(a);
                    break;
                }
            }
            clusterModel.getDataCenter().setIsChangable(clusterModel.getDataCenter().getSelectedItem() == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
        }
    };
    AsyncDataProvider.GetDataCenterList(_asyncQuery);
}
#end_block

#method_before
private void Version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = (Version) getVersion().getSelectedItem();
    } else {
        version = ((storage_pool) getDataCenter().getSelectedItem()).getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = (ServerCpu) clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.FirstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                InitCPU();
            }
        }
    };
    AsyncDataProvider.GetCPUList(_asyncQuery, version);
    // CPU Overcommit is only available for clusters of version 3.2 or greater
    getVersionSupportsCPUOvercommit().setEntity(version.compareTo(Version.v3_2) >= 0);
}
#method_after
private void Version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = (Version) getVersion().getSelectedItem();
    } else {
        version = ((storage_pool) getDataCenter().getSelectedItem()).getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            ServerCpu oldSelectedCpu = (ServerCpu) clusterModel.getCPU().getSelectedItem();
            clusterModel.getCPU().setItems(cpus);
            clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.FirstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
            if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
                InitCPU();
            }
        }
    };
    AsyncDataProvider.GetCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
}
#end_block

#method_before
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.FirstOrDefault(versions, new Linq.VersionPredicate(((VDSGroup) clusterModel.getEntity()).getcompatibility_version())));
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#method_after
private void StoragePool_SelectedItemChanged(EventArgs e) {
    // possible versions for new cluster (when editing cluster, this event won't occur)
    // are actually the possible versions for the data-center that the cluster is going
    // to be attached to.
    storage_pool selectedDataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (selectedDataCenter == null) {
        return;
    }
    if (selectedDataCenter.getstorage_pool_type() == StorageType.LOCALFS) {
        setIsResiliencePolicyTabAvailable(false);
    } else {
        setIsResiliencePolicyTabAvailable(true);
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<Version> versions = (ArrayList<Version>) result;
            clusterModel.getVersion().setItems(versions);
            if (!versions.contains(clusterModel.getVersion().getSelectedItem())) {
                if (versions.contains(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version())) {
                    clusterModel.getVersion().setSelectedItem(((storage_pool) clusterModel.getDataCenter().getSelectedItem()).getcompatibility_version());
                } else {
                    clusterModel.getVersion().setSelectedItem(Linq.SelectHighestVersion(versions));
                }
            } else if (clusterModel.getIsEdit()) {
                clusterModel.getVersion().setSelectedItem(Linq.FirstOrDefault(versions, new Linq.VersionPredicate(clusterModel.getEntity().getcompatibility_version())));
            }
        }
    };
    AsyncDataProvider.GetDataCenterVersions(_asyncQuery, selectedDataCenter.getId());
}
#end_block

#method_before
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#method_after
public static void GetGlusterHosts(AsyncQuery aQuery, String hostAddress, String rootPassword, String fingerprint) {
    GlusterServersQueryParameters parameters = new GlusterServersQueryParameters(hostAddress, rootPassword);
    parameters.setFingerprint(fingerprint);
    Frontend.RunQuery(VdcQueryType.GetGlusterServers, parameters, aQuery);
}
#end_block

#method_before
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    getAllFromExportDomainQueryParamenters.setGetAll(true);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#method_after
public static void GetAllTemplatesFromExportDomain(AsyncQuery aQuery, Guid storagePoolId, Guid storageDomainId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? source : new HashMap<VmTemplate, ArrayList<DiskImage>>();
        }
    };
    GetAllFromExportDomainQueryParameters getAllFromExportDomainQueryParamenters = new GetAllFromExportDomainQueryParameters(storagePoolId, storageDomainId);
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, getAllFromExportDomainQueryParamenters, aQuery);
}
#end_block

#method_before
public static ArrayList<VmOsType> GetWindowsOsTypes() {
    if (windowsOsTypes != null) {
        return windowsOsTypes;
    }
    /**
     * ** TODO: remove once the gwt is using generic api instead of backend! ****
     */
    windowsOsTypes = new ArrayList<VmOsType>(Arrays.asList(new VmOsType[] { VmOsType.Windows2003, VmOsType.Windows2003x64, VmOsType.Windows2008, VmOsType.Windows2008R2x64, VmOsType.Windows2008x64, VmOsType.Windows7, VmOsType.Windows7x64, VmOsType.WindowsXP }));
    return windowsOsTypes;
/**
 * ***************************************************************************
 */
}
#method_after
public static ArrayList<VmOsType> GetWindowsOsTypes() {
    if (windowsOsTypes != null) {
        return windowsOsTypes;
    }
    /**
     * ** TODO: remove once the gwt is using generic api instead of backend! ****
     */
    windowsOsTypes = new ArrayList<VmOsType>();
    for (VmOsType type : VmOsType.values()) {
        if (type.isWindows()) {
            windowsOsTypes.add(type);
        }
    }
    return windowsOsTypes;
/**
 * ***************************************************************************
 */
}
#end_block

#method_before
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    ClusterModel model = new ClusterModel();
    model.setEntity(cluster);
    model.Init(true);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    model.setHashName("edit_cluster");
    model.setOriginalName(cluster.getname());
    model.getName().setEntity(cluster.getname());
    model.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    model.getEnableOvirtService().setIsChangable(false);
    model.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    model.getEnableGlusterService().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(model);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
            if (volumes.size() > 0) {
                clusterModel.getEnableGlusterService().setIsChangable(false);
            } else {
                clusterModel.getEnableGlusterService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
    AsyncQuery asyncQuery1 = new AsyncQuery();
    asyncQuery1.setModel(model);
    asyncQuery1.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            ClusterModel clusterModel = (ClusterModel) model1;
            ArrayList<VM> vmList = (ArrayList<VM>) result;
            if (vmList.size() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
            } else {
                clusterModel.getEnableOvirtService().setIsChangable(true);
            }
        }
    };
    AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        model.getName().setIsChangable(false);
        // $NON-NLS-1$
        model.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void Edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.Init(true);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getname());
    clusterModel.getName().setEntity(cluster.getname());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    AsyncDataProvider.GetAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVolumeList(asyncQuery, cluster.getname());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.GetVmListByClusterName(asyncQuery1, cluster.getname());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void OnSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuSmt", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        OnSaveConfirmCpuSmt();
    }
}
#method_after
private void OnSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        OnSaveConfirmCpuThreads();
    }
}
#end_block

#method_before
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setcount_threads_as_cores(((Boolean) model.getVersionSupportsCPUOvercommit().getEntity()) && ((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void OnSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = (Version) model.getVersion().getSelectedItem();
    cluster.setname((String) model.getName().getEntity());
    cluster.setdescription((String) model.getDescription().getEntity());
    cluster.setStoragePoolId(((storage_pool) model.getDataCenter().getSelectedItem()).getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setcpu_name(((ServerCpu) model.getCPU().getSelectedItem()).getCpuName());
    }
    cluster.setmax_vds_memory_over_commit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals((Boolean) model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals((Boolean) model.getCountThreadsAsCores().getEntity()));
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setcompatibility_version(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService((Boolean) model.getEnableOvirtService().getEntity());
    cluster.setGlusterService((Boolean) model.getEnableGlusterService().getEntity());
    model.StartProgress(null);
    Frontend.RunAction(model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            ClusterListModel localModel = (ClusterListModel) result.getState();
            if ((Boolean) model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.PostOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            Map<String, String> hostMap = (Map<String, String>) result;
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#method_after
private void fetchAndImportClusterHosts(final ClusterModel clusterModel) {
    getWindow().StartProgress(null);
    AsyncQuery aQuery = new AsyncQuery();
    aQuery.setModel(this);
    aQuery.setHandleFailure(true);
    aQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            getWindow().StopProgress();
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) result;
            if (returnValue == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            } else if (!returnValue.getSucceeded()) {
                clusterModel.setMessage(returnValue.getExceptionString());
                return;
            }
            Map<String, String> hostMap = (Map<String, String>) returnValue.getReturnValue();
            if (hostMap == null) {
                onEmptyGlusterHosts(clusterModel);
                return;
            }
            if (// $NON-NLS-1$
            hostMap.containsValue(null) || hostMap.containsValue("")) {
                onGlusterHostsWithoutFingerprint(hostMap, clusterModel);
                return;
            }
            ArrayList<EntityModel> list = new ArrayList<EntityModel>();
            for (Map.Entry<String, String> host : hostMap.entrySet()) {
                HostDetailModel hostModel = new HostDetailModel(host.getKey(), host.getValue());
                hostModel.setName(host.getKey());
                // $NON-NLS-1$
                hostModel.setPassword("");
                EntityModel entityModel = new EntityModel(hostModel);
                list.add(entityModel);
            }
            importClusterHosts(clusterModel, list);
        }
    };
    AsyncDataProvider.GetGlusterHosts(aQuery, (String) clusterModel.getGlusterHostAddress().getEntity(), (String) clusterModel.getGlusterHostPassword().getEntity(), (String) clusterModel.getGlusterHostFingerprint().getEntity());
}
#end_block

#method_before
public void postOnSaveInternalWithImport(VdcReturnValueBase returnValue) {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    hostsModel.getClusterModel().setClusterId((Guid) returnValue.getActionReturnValue());
    addHosts(hostsModel);
}
#method_after
public void postOnSaveInternalWithImport(VdcReturnValueBase returnValue) {
    MultipleHostsModel hostsModel = (MultipleHostsModel) getWindow();
    if (returnValue != null && returnValue.getSucceeded()) {
        hostsModel.getClusterModel().setClusterId((Guid) returnValue.getActionReturnValue());
        addHosts(hostsModel);
    }
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuSmt")) {
        OnSaveConfirmCpuSmt();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewCommand()) {
        New();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        OnSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        OnSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupRootPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuOvercommitPanelTitle.setText(constants.clusterPopupCpuOvercommitPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
}
#method_after
private void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    cPUEditor.setLabel(constants.clusterPopupCPULabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupRootPasswordLabel());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
}
#end_block

#method_before
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
}
#method_after
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
}
#end_block

#method_before
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuOvercommitInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuOvercommitInfo()), resources);
}
#method_after
private void initInfoIcons(ApplicationResources resources, ApplicationConstants constants, ApplicationTemplates templates) {
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", constants.clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", constants.clusterPopupCpuThreadsInfo()), resources);
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCPUOvercommit().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuOvercommitPanel.setVisible((Boolean) object.getVersionSupportsCPUOvercommit().getEntity());
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    Driver.driver.edit(object);
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible((Boolean) object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) object.getVersionSupportsCpuThreads().getEntity());
        }
    });
}
#end_block

#method_before
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit())));
    }
}
#method_after
private void optimizationCustomFormatter(ClusterModel object) {
    if (object.getOptimizationCustom() != null && object.getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(messages.clusterPopupMemoryOptimizationCustomLabel(String.valueOf(object.getMemoryOverCommit())));
    }
}
#end_block

#method_before
private void initialize(ApplicationResources resources, ApplicationTemplates templates) {
    dataCenterVersionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).getValue();
        }
    });
    clusterCpuNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    // Optimization options.
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    optimizationCustomEditor.setVisible(false);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", getConstants().clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuOvercommitInfo = new InfoIcon(templates.italicFixedWidth("600px", getConstants().clusterPopupCpuOvercommitInfo()), resources);
}
#method_after
private void initialize(ApplicationResources resources, ApplicationTemplates templates) {
    dataCenterVersionEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((Version) object).getValue();
        }
    });
    clusterCpuNameEditor = new ListModelListBoxEditor<Object>(new NullSafeRenderer<Object>() {

        @Override
        public String renderNullSafe(Object object) {
            return ((ServerCpu) object).getCpuName();
        }
    });
    // Optimization options.
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    optimizationCustomEditor.setVisible(false);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    memoryOptimizationInfo = new InfoIcon(templates.italicFixedWidth("465px", getConstants().clusterPopupMemoryOptimizationInfo()), resources);
    // $NON-NLS-1$
    cpuThreadsInfo = new InfoIcon(templates.italicFixedWidth("600px", getConstants().clusterPopupCpuThreadsInfo()), resources);
}
#end_block

#method_before
void localize() {
    generalTab.setLabel(getConstants().hostPopupGeneralTabLabel());
    dataCenterButton.setText(getConstants().editText());
    dataCenterNameEditor.setLabel(getConstants().nameLabel());
    dataCenterDescriptionEditor.setLabel(getConstants().descriptionLabel());
    dataCenterVersionEditor.setLabel(getConstants().dataCenterPopupVersionLabel());
    clusterButton.setText(getConstants().editText());
    clusterNameEditor.setLabel(getConstants().clusterPopupNameLabel());
    clusterDescriptionEditor.setLabel(getConstants().clusterPopupDescriptionLabel());
    clusterCpuNameEditor.setLabel(getConstants().clusterPopupCPULabel());
    storageButton.setText(getConstants().editText());
    storageNameEditor.setLabel(getConstants().storagePopupNameLabel());
    pathLabel.setText(getConstants().configureLocalStoragePopupPathLabel());
    optimizationTab.setLabel(getConstants().clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(getConstants().clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(getConstants().clusterPopupOptimizationNoneLabel());
    cpuOvercommitPanelTitle.setText(getConstants().clusterPopupCpuOvercommitPanelTitle());
    countThreadsAsCoresEditor.setLabel(getConstants().clusterPopupCountThreadsAsCoresLabel());
}
#method_after
void localize() {
    generalTab.setLabel(getConstants().hostPopupGeneralTabLabel());
    dataCenterButton.setText(getConstants().editText());
    dataCenterNameEditor.setLabel(getConstants().nameLabel());
    dataCenterDescriptionEditor.setLabel(getConstants().descriptionLabel());
    dataCenterVersionEditor.setLabel(getConstants().dataCenterPopupVersionLabel());
    clusterButton.setText(getConstants().editText());
    clusterNameEditor.setLabel(getConstants().clusterPopupNameLabel());
    clusterDescriptionEditor.setLabel(getConstants().clusterPopupDescriptionLabel());
    clusterCpuNameEditor.setLabel(getConstants().clusterPopupCPULabel());
    storageButton.setText(getConstants().editText());
    storageNameEditor.setLabel(getConstants().storagePopupNameLabel());
    pathLabel.setText(getConstants().configureLocalStoragePopupPathLabel());
    optimizationTab.setLabel(getConstants().clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(getConstants().clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(getConstants().clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(getConstants().clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(getConstants().clusterPopupCountThreadsAsCoresLabel());
}
#end_block

#method_before
@Override
public void edit(final ConfigureLocalStorageModel model) {
    Driver.driver.edit(model);
    dataCenterNameEditor.setEnabled(false);
    clusterNameEditor.setEnabled(false);
    storageNameEditor.setEnabled(false);
    optimizationForServerFormatter(model);
    optimizationForDesktopFormatter(model);
    optimizationCustomFormatter(model);
    model.getCluster().getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(model);
        }
    });
    model.getCluster().getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(model);
        }
    });
    model.getCluster().getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) model.getCluster().getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(model);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    model.getCluster().getVersionSupportsCPUOvercommit().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuOvercommitPanel.setVisible((Boolean) model.getCluster().getVersionSupportsCPUOvercommit().getEntity());
        }
    });
}
#method_after
@Override
public void edit(final ConfigureLocalStorageModel model) {
    Driver.driver.edit(model);
    dataCenterNameEditor.setEnabled(false);
    clusterNameEditor.setEnabled(false);
    storageNameEditor.setEnabled(false);
    optimizationForServerFormatter(model);
    optimizationForDesktopFormatter(model);
    optimizationCustomFormatter(model);
    model.getCluster().getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(model);
        }
    });
    model.getCluster().getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(model);
        }
    });
    model.getCluster().getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ((Boolean) model.getCluster().getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(model);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    model.getCluster().getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible((Boolean) model.getCluster().getVersionSupportsCpuThreads().getEntity());
        }
    });
}
#end_block

#method_before
private void optimizationCustomFormatter(ConfigureLocalStorageModel model) {
    if (model.getCluster() != null && model.getCluster().getOptimizationCustom() != null && model.getCluster().getOptimizationCustom().getEntity() != null) {
        // use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(getMessages().clusterPopupMemoryOptimizationCustomLabel(String.valueOf(model.getCluster().getMemoryOverCommit())));
    }
}
#method_after
private void optimizationCustomFormatter(ConfigureLocalStorageModel model) {
    if (model.getCluster() != null && model.getCluster().getOptimizationCustom() != null && model.getCluster().getOptimizationCustom().getEntity() != null) {
        // Use current value because object.getOptimizationCustom.getEntity() can be null
        optimizationCustomEditor.setLabel(getMessages().clusterPopupMemoryOptimizationCustomLabel(String.valueOf(model.getCluster().getMemoryOverCommit())));
    }
}
#end_block

#method_before
@Test
public void testCanDoAction() {
    expectGetStoragePool(STORAGE_POOL_ID);
    expectGetStorageDomain(STORAGE_DOMAIN_ID, STORAGE_POOL_ID, StorageDomainType.Data, StorageType.NFS);
    expectGetVds(VDS_ID);
    expectGetIsoMap(STORAGE_DOMAIN_ID);
    expectBusinessEntitySnapshotDAO();
    RemoveStorageDomainCommand<RemoveStorageDomainParameters> cmd = createCommand(true);
    assertTrue(cmd.canDoAction());
    checkSucceeded(cmd, false);
    cmd.setActionMessageParameters();
    checkMessages(cmd, VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN, VdcBllMessages.VAR__ACTION__REMOVE);
}
#method_after
@Test
public void testCanDoAction() {
    expectGetStoragePool(STORAGE_POOL_ID);
    expectGetStorageDomain(STORAGE_DOMAIN_ID, STORAGE_POOL_ID, StorageDomainType.Data, StorageType.NFS);
    expectGetVds(VDS_ID);
    expectGetIsoMap(STORAGE_DOMAIN_ID);
    expectBusinessEntitySnapshotDAO();
    RemoveStorageDomainCommand<RemoveStorageDomainParameters> cmd = createCommand(true);
    assertTrue(cmd.canDoAction());
    checkSucceeded(cmd, false);
    assertEquals("Wrong number of messages", 0, cmd.getReturnValue().getCanDoActionMessages().size());
}
#end_block

#method_before
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    command.setActionMessageParameters();
    List<String> messages = command.getReturnValue().getCanDoActionMessages();
    assertEquals("Wrong number of messages", 3, messages.size());
    assertEquals("Wrong message", VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.name(), messages.get(0));
    assertEquals("Wrong message", VdcBllMessages.VAR__TYPE__STORAGE__DOMAIN.name(), messages.get(1));
    assertEquals("Wrong message", VdcBllMessages.VAR__ACTION__REMOVE.name(), messages.get(2));
}
#method_after
@Test
public void testCanDoActionNonExistingStorageDomain() {
    // All the mock DAOs return nulls (which mocks the objects do not exist)
    // canDoAction should return false, not crash with NullPointerExcpetion
    assertFalse("canDoActtion shouldn't be possible for a non-existant storage domain", command.canDoAction());
    checkMessages(command, VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
}
#end_block

#method_before
public void initQuotaList(ResourcesModel model) {
    List<QuotaPerUserUsageEntity> list = (List<QuotaPerUserUsageEntity>) model.getUsedQuotaPercentage().getEntity();
    QuotaPerUserUsageEntity aggregatedUsage = new QuotaPerUserUsageEntity(Guid.Empty, "", 0, 0, 0, 0, 0, 0);
    boolean unlimitedVcpu = false;
    boolean unlimitedMem = false;
    boolean unlimitedStorage = false;
    if (list != null) {
        cpusQuotasList.clear();
        memoryQuotasList.clear();
        storageQuotasList.clear();
        cpusQuotasList.setSpacing(7);
        memoryQuotasList.setSpacing(7);
        storageQuotasList.setSpacing(7);
        for (QuotaPerUserUsageEntity quotaPerUserUsageEntity : list) {
            unlimitedMem |= quotaPerUserUsageEntity.isUnlimitedMemory();
            unlimitedStorage |= quotaPerUserUsageEntity.isUnlimitedStorage();
            unlimitedVcpu |= quotaPerUserUsageEntity.isUnlimitedVcpu();
            aggregate(aggregatedUsage, quotaPerUserUsageEntity);
            addQuotaToVcpuQuotaList(quotaPerUserUsageEntity);
            addQuotaToMemoryQuotaList(quotaPerUserUsageEntity);
            addQuotaToStorageQuotaList(quotaPerUserUsageEntity);
        }
        if (unlimitedVcpu) {
            cpusProgressBar.setUnlimited(true);
        } else {
            cpusProgressBar.setValueA((int) aggregatedUsage.getOthersVcpuUsagePercentage());
            cpusProgressBar.setValueB((int) aggregatedUsage.getUserVcpuUsagePercentage());
            cpusProgressBar.setTitle(messages.quotaFreeCpus(aggregatedUsage.getFreeVcpu()));
        }
        if (unlimitedMem) {
            memoryProgressBar.setUnlimited(true);
        } else {
            memoryProgressBar.setValueA((int) aggregatedUsage.getOthersMemoryUsagePercentage());
            memoryProgressBar.setValueB((int) aggregatedUsage.getUserMemoryUsagePercentage());
            String freeMem = aggregatedUsage.getFreeMemory() > 4096 ? // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() + "MB";
            memoryProgressBar.setTitle(constants.freeMemory() + freeMem);
        }
        if (unlimitedStorage) {
            storageProgressBar.setUnlimited(true);
        } else {
            storageProgressBar.setValueA((int) aggregatedUsage.getOthersStorageUsagePercentage());
            storageProgressBar.setValueB((int) aggregatedUsage.getUserStorageUsagePercentage());
            String freeStorage = aggregatedUsage.getFreeStorage() == 0 ? // $NON-NLS-1$
            "0" : diskSizeRenderer.render(aggregatedUsage.getFreeStorage());
            storageProgressBar.setTitle(constants.freeStorage() + freeStorage);
        }
        // $NON-NLS-1$  //$NON-NLS-2$
        vcpuExpander.setTitleWhenCollapsed(constants.showQuotaDistribution() + " (" + list.size() + ")");
    }
}
#method_after
public void initQuotaList(ResourcesModel model) {
    List<QuotaUsagePerUser> list = (List<QuotaUsagePerUser>) model.getUsedQuotaPercentage().getEntity();
    QuotaUsagePerUser aggregatedUsage = new QuotaUsagePerUser(Guid.Empty, "", 0, 0, 0, 0, 0, 0);
    boolean unlimitedVcpu = false;
    boolean unlimitedMem = false;
    boolean unlimitedStorage = false;
    if (list != null) {
        cpusQuotasList.clear();
        memoryQuotasList.clear();
        storageQuotasList.clear();
        cpusQuotasList.setSpacing(7);
        memoryQuotasList.setSpacing(7);
        storageQuotasList.setSpacing(7);
        for (QuotaUsagePerUser quotaPerUserUsageEntity : list) {
            unlimitedMem |= quotaPerUserUsageEntity.isUnlimitedMemory();
            unlimitedStorage |= quotaPerUserUsageEntity.isUnlimitedStorage();
            unlimitedVcpu |= quotaPerUserUsageEntity.isUnlimitedVcpu();
            aggregate(aggregatedUsage, quotaPerUserUsageEntity);
            addQuotaToVcpuQuotaList(quotaPerUserUsageEntity);
            addQuotaToMemoryQuotaList(quotaPerUserUsageEntity);
            addQuotaToStorageQuotaList(quotaPerUserUsageEntity);
        }
        if (unlimitedVcpu) {
            cpusProgressBar.setUnlimited(true);
        } else {
            cpusProgressBar.setValueA((int) aggregatedUsage.getOthersVcpuUsagePercentage());
            cpusProgressBar.setValueB((int) aggregatedUsage.getUserVcpuUsagePercentage());
            cpusProgressBar.setTitle(messages.quotaFreeCpus(aggregatedUsage.getFreeVcpu()));
        }
        if (unlimitedMem) {
            memoryProgressBar.setUnlimited(true);
        } else {
            memoryProgressBar.setValueA((int) aggregatedUsage.getOthersMemoryUsagePercentage());
            memoryProgressBar.setValueB((int) aggregatedUsage.getUserMemoryUsagePercentage());
            String freeMem = aggregatedUsage.getFreeMemory() > 4096 ? // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
            aggregatedUsage.getFreeMemory() + "MB";
            memoryProgressBar.setTitle(constants.freeMemory() + freeMem);
        }
        if (unlimitedStorage) {
            storageProgressBar.setUnlimited(true);
        } else {
            storageProgressBar.setValueA((int) aggregatedUsage.getOthersStorageUsagePercentage());
            storageProgressBar.setValueB((int) aggregatedUsage.getUserStorageUsagePercentage());
            String freeStorage = aggregatedUsage.getFreeStorage() == 0 ? // $NON-NLS-1$
            "0" : diskSizeRenderer.render(aggregatedUsage.getFreeStorage());
            storageProgressBar.setTitle(constants.freeStorage() + freeStorage);
        }
        // $NON-NLS-1$  //$NON-NLS-2$
        vcpuExpander.setTitleWhenCollapsed(constants.showQuotaDistribution() + " (" + list.size() + ")");
    }
}
#end_block

#method_before
private void addQuotaToVcpuQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedVcpu()) {
        vcpuQuotaProgressBar.setUnlimited(true);
    } else {
        vcpuQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersVcpuUsagePercentage());
        vcpuQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserVcpuUsagePercentage());
        vcpuQuotaProgressBar.setTitle(messages.quotaFreeCpus(quotaPerUserUsageEntity.getFreeVcpu()));
        if (quotaPerUserUsageEntity.getVcpuTotalUsage() == 0) {
            vcpuQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(vcpuQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    cpusQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToVcpuQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar vcpuQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedVcpu()) {
        vcpuQuotaProgressBar.setUnlimited(true);
    } else {
        vcpuQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersVcpuUsagePercentage());
        vcpuQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserVcpuUsagePercentage());
        vcpuQuotaProgressBar.setTitle(messages.quotaFreeCpus(quotaPerUserUsageEntity.getFreeVcpu()));
        if (quotaPerUserUsageEntity.getVcpuTotalUsage() == 0) {
            vcpuQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(cpusQuotasList, quotaPerUserUsageEntity.getQuotaName(), vcpuQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToMemoryQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedMemory()) {
        memoryQuotaProgressBar.setUnlimited(true);
    } else {
        memoryQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersMemoryUsagePercentage());
        memoryQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserMemoryUsagePercentage());
        String freeMem = quotaPerUserUsageEntity.getFreeMemory() > 4096 ? // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() + "MB";
        memoryQuotaProgressBar.setTitle(constants.freeMemory() + freeMem);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            memoryQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(memoryQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    memoryQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToMemoryQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar memoryQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedMemory()) {
        memoryQuotaProgressBar.setUnlimited(true);
    } else {
        memoryQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersMemoryUsagePercentage());
        memoryQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserMemoryUsagePercentage());
        String freeMem = quotaPerUserUsageEntity.getFreeMemory() > 4096 ? // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() / 1024 + "GB" : // $NON-NLS-1$
        quotaPerUserUsageEntity.getFreeMemory() + "MB";
        memoryQuotaProgressBar.setTitle(constants.freeMemory() + freeMem);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            memoryQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(memoryQuotasList, quotaPerUserUsageEntity.getQuotaName(), memoryQuotaProgressBar);
}
#end_block

#method_before
private void addQuotaToStorageQuotaList(QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedStorage()) {
        storageQuotaProgressBar.setUnlimited(true);
    } else {
        storageQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersStorageUsagePercentage());
        storageQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserStorageUsagePercentage());
        String freeStorage = quotaPerUserUsageEntity.getFreeStorage() == 0 ? // $NON-NLS-1$
        "0" : diskSizeRenderer.render(quotaPerUserUsageEntity.getFreeStorage());
        storageQuotaProgressBar.setTitle(constants.freeStorage() + freeStorage);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            storageQuotaProgressBar.setZeroValue();
        }
    }
    VerticalPanel verticalPanel = new VerticalPanel();
    Label quotaName = new Label();
    quotaName.setText(quotaPerUserUsageEntity.getQuotaName());
    verticalPanel.add(quotaName);
    verticalPanel.add(storageQuotaProgressBar);
    // $NON-NLS-1$
    verticalPanel.setWidth("100%");
    storageQuotasList.add(verticalPanel);
}
#method_after
private void addQuotaToStorageQuotaList(QuotaUsagePerUser quotaPerUserUsageEntity) {
    QuotaProgressBar storageQuotaProgressBar = new QuotaProgressBar();
    if (quotaPerUserUsageEntity.isUnlimitedStorage()) {
        storageQuotaProgressBar.setUnlimited(true);
    } else {
        storageQuotaProgressBar.setValueA((int) quotaPerUserUsageEntity.getOthersStorageUsagePercentage());
        storageQuotaProgressBar.setValueB((int) quotaPerUserUsageEntity.getUserStorageUsagePercentage());
        String freeStorage = quotaPerUserUsageEntity.getFreeStorage() == 0 ? // $NON-NLS-1$
        "0" : diskSizeRenderer.render(quotaPerUserUsageEntity.getFreeStorage());
        storageQuotaProgressBar.setTitle(constants.freeStorage() + freeStorage);
        if (quotaPerUserUsageEntity.getMemoryTotalUsage() == 0) {
            storageQuotaProgressBar.setZeroValue();
        }
    }
    addQuotaRow(storageQuotasList, quotaPerUserUsageEntity.getQuotaName(), storageQuotaProgressBar);
}
#end_block

#method_before
private void aggregate(QuotaPerUserUsageEntity aggregatedUsage, QuotaPerUserUsageEntity quotaPerUserUsageEntity) {
    aggregatedUsage.setVcpuLimit(quotaPerUserUsageEntity.getVcpuLimit() + aggregatedUsage.getVcpuLimit());
    aggregatedUsage.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + aggregatedUsage.getVcpuUsageForUser());
    aggregatedUsage.setVcpuTotalUsage(quotaPerUserUsageEntity.getVcpuTotalUsage() + aggregatedUsage.getVcpuTotalUsage());
    aggregatedUsage.setMemoryLimit(quotaPerUserUsageEntity.getMemoryLimit() + aggregatedUsage.getMemoryLimit());
    aggregatedUsage.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + aggregatedUsage.getMemoryUsageForUser());
    aggregatedUsage.setMemoryTotalUsage(quotaPerUserUsageEntity.getMemoryTotalUsage() + aggregatedUsage.getMemoryTotalUsage());
    aggregatedUsage.setStorageLimit(quotaPerUserUsageEntity.getStorageLimit() + aggregatedUsage.getStorageLimit());
    aggregatedUsage.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + aggregatedUsage.getStorageUsageForUser());
    aggregatedUsage.setStorageTotalUsage(quotaPerUserUsageEntity.getStorageTotalUsage() + aggregatedUsage.getStorageTotalUsage());
}
#method_after
private void aggregate(QuotaUsagePerUser aggregatedUsage, QuotaUsagePerUser quotaPerUserUsageEntity) {
    aggregatedUsage.setVcpuLimit(quotaPerUserUsageEntity.getVcpuLimit() + aggregatedUsage.getVcpuLimit());
    aggregatedUsage.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + aggregatedUsage.getVcpuUsageForUser());
    aggregatedUsage.setVcpuTotalUsage(quotaPerUserUsageEntity.getVcpuTotalUsage() + aggregatedUsage.getVcpuTotalUsage());
    aggregatedUsage.setMemoryLimit(quotaPerUserUsageEntity.getMemoryLimit() + aggregatedUsage.getMemoryLimit());
    aggregatedUsage.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + aggregatedUsage.getMemoryUsageForUser());
    aggregatedUsage.setMemoryTotalUsage(quotaPerUserUsageEntity.getMemoryTotalUsage() + aggregatedUsage.getMemoryTotalUsage());
    aggregatedUsage.setStorageLimit(quotaPerUserUsageEntity.getStorageLimit() + aggregatedUsage.getStorageLimit());
    aggregatedUsage.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + aggregatedUsage.getStorageUsageForUser());
    aggregatedUsage.setStorageTotalUsage(quotaPerUserUsageEntity.getStorageTotalUsage() + aggregatedUsage.getStorageTotalUsage());
}
#end_block

#method_before
@Override
protected void SyncSearch() {
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            ArrayList<VM> list = (ArrayList<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // TODO: Insert dummy data regarding disks and snapshots.
            for (VM vm : list) {
            // vm.DiskList =
            // new[]
            // {
            // new DiskImage
            // {
            // internal_drive_mapping = "1",
            // SizeInGigabytes = 100,
            // ActualSize = 50,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage()
            // }
            // },
            // new DiskImage
            // {
            // internal_drive_mapping = "2",
            // SizeInGigabytes = 200,
            // ActualSize = 80,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage(),
            // new DiskImage()
            // }
            // }
            // };
            }
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isStatusUp()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(SizeParser(definedMemory));
            getUsedMemory().setEntity(SizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
            // async Query for quota
            AsyncQuery _asyncQueryForQuota = new AsyncQuery();
            _asyncQueryForQuota.setModel(this);
            GetQuotasByAdElementIdQueryParameters parameters = new GetQuotasByAdElementIdQueryParameters();
            // parameters.setAdElementId(new Guid(Frontend.getLoggedInUser().getGroupIds()));    //TODO
            parameters.setRefresh(getIsQueryFirstTime());
            parameters.setIncludeUsageData(true);
            parameters.setVms(list);
            Frontend.RunQuery(VdcQueryType.GetQuotasByAdElementId, parameters, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void OnSuccess(Object model, Object ReturnValue) {
                    getUsedQuotaPercentage().setEntity(((VdcQueryReturnValue) ReturnValue).getReturnValue());
                }
            }));
        }
    };
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters(Frontend.getLoggedInUser().getUserId());
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#method_after
@Override
protected void SyncSearch() {
    super.SyncSearch();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            ResourcesModel resourcesModel = (ResourcesModel) model;
            ArrayList<VM> list = (ArrayList<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            // TODO: Insert dummy data regarding disks and snapshots.
            for (VM vm : list) {
            // vm.DiskList =
            // new[]
            // {
            // new DiskImage
            // {
            // internal_drive_mapping = "1",
            // SizeInGigabytes = 100,
            // ActualSize = 50,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage()
            // }
            // },
            // new DiskImage
            // {
            // internal_drive_mapping = "2",
            // SizeInGigabytes = 200,
            // ActualSize = 80,
            // Snapshots =
            // new[]
            // {
            // new DiskImage(),
            // new DiskImage(),
            // new DiskImage()
            // }
            // }
            // };
            }
            // Update calculated properties.
            int runningVMs = 0;
            int definedCPUs = 0;
            int usedCPUs = 0;
            int definedMemory = 0;
            int usedMemory = 0;
            long totalDisksSize = 0;
            long totalSnapshotsSize = 0;
            int numOfSnapshots = 0;
            for (VM vm : list) {
                definedCPUs += vm.getNumOfCpus();
                definedMemory += vm.getVmMemSizeMb();
                if (vm.isStatusUp()) {
                    runningVMs++;
                    usedCPUs += vm.getNumOfCpus();
                    usedMemory += vm.getVmMemSizeMb();
                }
                if (vm.getDiskList() != null) {
                    for (DiskImage disk : vm.getDiskList()) {
                        totalDisksSize += disk.getSizeInGigabytes();
                        totalSnapshotsSize += (long) disk.getActualDiskWithSnapshotsSize();
                        numOfSnapshots += disk.getSnapshots().size();
                    }
                }
            }
            getDefinedVMs().setEntity(list.size());
            getRunningVMs().setEntity(runningVMs);
            getRunningVMsPercentage().setEntity(list.isEmpty() ? 0 : runningVMs * 100 / list.size());
            getDefinedCPUs().setEntity(definedCPUs);
            getUsedCPUs().setEntity(usedCPUs);
            getUsedCPUsPercentage().setEntity(usedCPUs * 100 / definedCPUs);
            getDefinedMemory().setEntity(SizeParser(definedMemory));
            getUsedMemory().setEntity(SizeParser(usedMemory));
            getUsedMemoryPercentage().setEntity(usedMemory * 100 / definedMemory);
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalDisksSize().setEntity(totalDisksSize >= 1 ? totalDisksSize + "GB" : "<1GB");
            // $NON-NLS-1$ //$NON-NLS-2$
            getTotalSnapshotsSize().setEntity(totalSnapshotsSize >= 1 ? totalSnapshotsSize + "GB" : "<1GB");
            getNumOfSnapshots().setEntity(numOfSnapshots);
            Collections.sort(list, COMPARATOR);
            resourcesModel.setItems(list);
        }
    };
    // async Query for quota
    AsyncQuery _asyncQueryForQuota = new AsyncQuery();
    _asyncQueryForQuota.setModel(this);
    GetQuotasConsumptionForCurrentUserQueryParameters parameters = new GetQuotasConsumptionForCurrentUserQueryParameters();
    parameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetQuotasConsumptionForCurrentUser, parameters, new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object ReturnValue) {
            getUsedQuotaPercentage().setEntity(((VdcQueryReturnValue) ReturnValue).getReturnValue());
        }
    }));
    // Items property will contain list of VMs.
    GetUserVmsByUserIdAndGroupsParameters getUserVmsByUserIdAndGroupsParameters = new GetUserVmsByUserIdAndGroupsParameters(Frontend.getLoggedInUser().getUserId());
    getUserVmsByUserIdAndGroupsParameters.setIncludeDiskData(true);
    getUserVmsByUserIdAndGroupsParameters.setRefresh(getIsQueryFirstTime());
    Frontend.RunQuery(VdcQueryType.GetUserVmsByUserIdAndGroups, getUserVmsByUserIdAndGroupsParameters, _asyncQuery);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList) && canDoSnapshot(getVm());
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        VmValidator vmValidator = new VmValidator(getVm());
        result = validate(new SnapshotsValidator().vmNotDuringSnapshot(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()) && canDoSnapshot(getVm()) && ImagesHandler.PerformImagesChecks(getVm(), getReturnValue().getCanDoActionMessages(), getVm().getStoragePoolId(), Guid.Empty, true, true, true, true, true, false, true, true, disksList);
    }
    return result;
}
#end_block

#method_before
private boolean canDoSnapshot(VM vm) {
    // if version is 3.0 - live snapshot is not available, thus if vm is up snapshot is not possible so it needs to be
    // checked if it's up or not
    // if version is 3.1,  there is no need to check if vm is up since in any case snapshot is possible
    boolean canSnapshot = true;
    if (!isLiveSnapshotEnabled() && !ImagesHandler.isVmDown(vm)) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
        canSnapshot = false;
    }
    return canSnapshot;
}
#method_after
private boolean canDoSnapshot(VM vm) {
    // if live snapshot is enabled, there is no need to check if vm is up since in any case snapshot is possible
    if (!isLiveSnapshotEnabled() && !ImagesHandler.isVmDown(vm)) {
        // if there is no live snapshot and the vm is up - snapshot is not possible
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DATA_CENTER_VERSION_DOESNT_SUPPORT_LIVE_SNAPSHOT);
    }
    return true;
}
#end_block

#method_before
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    if (disk != null) {
        String vmName = "";
        int count = 1;
        if (vm != null) {
            vmName = vm.getVmName();
            count = vm.getDiskMapCount() + 1;
        }
        disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
        return true;
    } else {
        log.errorFormat("Disk object is null");
        return false;
    }
}
#method_after
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    return setDiskAlias(disk, vm, nullSafeGetCount(vm));
}
#end_block

#method_before
public static boolean setDiskAlias(BaseDisk disk, VM vm) {
    if (disk != null) {
        String vmName = "";
        int count = 1;
        if (vm != null) {
            vmName = vm.getVmName();
            count = vm.getDiskMapCount() + 1;
        }
        disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
        return true;
    } else {
        log.errorFormat("Disk object is null");
        return false;
    }
}
#method_after
public static boolean setDiskAlias(BaseDisk disk, VM vm, int count) {
    if (disk == null) {
        log.error("Disk object is null");
        return false;
    }
    String vmName = nullSafeGetVmName(vm);
    disk.setDiskAlias(getSuggestedDiskAlias(disk, vmName, count));
    return true;
}
#end_block

#method_before
public static boolean CheckImageConfiguration(storage_domain_static storageDomain, DiskImageBase diskInfo, List<String> messages) {
    boolean result = true;
    if ((diskInfo.getvolume_type() == VolumeType.Preallocated && diskInfo.getvolume_format() == VolumeFormat.COW) || ((storageDomain.getstorage_type() == StorageType.FCP || storageDomain.getstorage_type() == StorageType.ISCSI) && (diskInfo.getvolume_type() == VolumeType.Sparse && diskInfo.getvolume_format() == VolumeFormat.RAW)) || (diskInfo.getvolume_format() == VolumeFormat.Unassigned || diskInfo.getvolume_type() == VolumeType.Unassigned)) {
        // not supported
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED.toString());
    }
    return result;
}
#method_after
public static boolean CheckImageConfiguration(StorageDomainStatic storageDomain, DiskImageBase diskInfo, List<String> messages) {
    boolean result = true;
    if ((diskInfo.getvolume_type() == VolumeType.Preallocated && diskInfo.getvolume_format() == VolumeFormat.COW) || ((storageDomain.getstorage_type() == StorageType.FCP || storageDomain.getstorage_type() == StorageType.ISCSI) && (diskInfo.getvolume_type() == VolumeType.Sparse && diskInfo.getvolume_format() == VolumeFormat.RAW)) || (diskInfo.getvolume_format() == VolumeFormat.Unassigned || diskInfo.getvolume_type() == VolumeType.Unassigned)) {
        // not supported
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED.toString());
    }
    return result;
}
#end_block

#method_before
public static boolean CheckImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    storage_domain_static storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = CheckImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result)
            break;
    }
    return result;
}
#method_after
public static boolean CheckImagesConfiguration(Guid storageDomainId, Collection<? extends Disk> disksConfigList, List<String> messages) {
    boolean result = true;
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(storageDomainId);
    for (Disk diskInfo : disksConfigList) {
        if (DiskStorageType.IMAGE == diskInfo.getDiskStorageType()) {
            result = CheckImageConfiguration(storageDomain, (DiskImage) diskInfo, messages);
        }
        if (!result)
            break;
    }
    return result;
}
#end_block

#method_before
public static boolean isStoragePoolValid(Guid storagePoolId) {
    boolean isValid = true;
    storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
    if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
        isValid = false;
    }
    return isValid;
}
#method_after
public static boolean isStoragePoolValid(Guid storagePoolId) {
    storage_pool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePoolId);
    if (pool == null || pool.getstatus() != StoragePoolStatus.Up) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static void removeLunDisk(LunDisk lunDisk) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    DbFacade.getInstance().getDiskLunMapDao().remove(new DiskLunMapId(lunDisk.getId(), lun.getLUN_id()));
    DbFacade.getInstance().getBaseDiskDao().remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<storage_server_connections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#method_after
public static void removeLunDisk(LunDisk lunDisk) {
    DbFacade.getInstance().getVmDeviceDao().remove(new VmDeviceId(lunDisk.getId(), null));
    LUNs lun = lunDisk.getLun();
    DbFacade.getInstance().getDiskLunMapDao().remove(new DiskLunMapId(lunDisk.getId(), lun.getLUN_id()));
    DbFacade.getInstance().getBaseDiskDao().remove(lunDisk.getId());
    lun.setLunConnections(new ArrayList<StorageServerConnections>(DbFacade.getInstance().getStorageServerConnectionDao().getAllForLun(lun.getLUN_id())));
    if (!lun.getLunConnections().isEmpty()) {
        StorageHelperDirector.getInstance().getItem(lun.getLunConnections().get(0).getstorage_type()).removeLun(lun);
    } else {
        // if there are no connections then the lun is fcp.
        StorageHelperDirector.getInstance().getItem(StorageType.FCP).removeLun(lun);
    }
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    // TODO
    hostCpuEditor.setLabel(constants.useHostCpu());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    hostCpuEditor.setLabel(constants.useHostCpu());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                highAvailabilityTab.setVisible((Boolean) vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if ((Boolean) vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesAvailable".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesTab.setVisible(vm.getIsCustomPropertiesAvailable());
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                disksAllocationPanel.setVisible(isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                storageAllocationPanel.setVisible(isProvisioningAvailable || isDisksAvailable);
                if (vm.getDisks() != null) {
                    for (DiskModel diskModel : vm.getDisks()) {
                        if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) diskModel.getDisk()).getimageStatus() == ImageStatus.ILLEGAL) {
                            generalWarningMessage.setText(constants.illegalDisksInVm());
                            return;
                        }
                    }
                }
            }
        }
    });
    // High Availability only avail in server mode
    highAvailabilityTab.setVisible(vm.getVmType().equals(VmType.Server));
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsLinux_Unassign_UnknownOS".equals(propName)) {
                // $NON-NLS-1$
                linuxBootOptionsPanel.setVisible(vm.getIsLinux_Unassign_UnknownOS());
            }
        }
    });
    // only avail for desktop mode
    isStatelessEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    numOfMonitorsEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    allowConsoleReconnectEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
    vm.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                highAvailabilityTab.setVisible((Boolean) vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if ((Boolean) vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                disksAllocationPanel.setVisible(isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                storageAllocationPanel.setVisible(isProvisioningAvailable || isDisksAvailable);
                if (vm.getDisks() != null) {
                    for (DiskModel diskModel : vm.getDisks()) {
                        if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) diskModel.getDisk()).getimageStatus() == ImageStatus.ILLEGAL) {
                            generalWarningMessage.setText(constants.illegalDisksInVm());
                            return;
                        }
                    }
                }
            }
        }
    });
    // High Availability only avail in server mode
    highAvailabilityTab.setVisible(vm.getVmType().equals(VmType.Server));
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsLinux_Unassign_UnknownOS".equals(propName)) {
                // $NON-NLS-1$
                linuxBootOptionsPanel.setVisible(vm.getIsLinux_Unassign_UnknownOS());
            }
        }
    });
    // only avail for desktop mode
    isStatelessEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    numOfMonitorsEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    allowConsoleReconnectEditor.setVisible(vm.getVmType().equals(VmType.Desktop));
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
    vm.getCpuPinning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuPinningLabel.setVisible(vm.getCpuPinning().getIsAvailable());
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    runVMOnSpecificHostEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    dontMigrateVMEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    quotaEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = generalAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    runVMOnSpecificHostEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    dontMigrateVMEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.equals(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryStarted();
    } else if (ev.equals(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        Frontend_QueryComplete();
    } else if (ev.equals(ListModel.SelectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            DataCenter_SelectedItemChanged(sender, args);
        } else if (sender == getTemplate()) {
            Template_SelectedItemChanged(sender, args);
        } else if (sender == getCluster()) {
            Cluster_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getTimeZone()) {
            TimeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            DefaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            OSType_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            FirstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            DisplayProtocol_SelectedItemChanged(sender, args);
            InitUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            NumOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            CoresPerSocket_EntityChanged(sender, args);
        }
    } else if (ev.equals(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            MemSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            TotalCPUCores_EntityChanged(sender, args);
        } else if (sender == getRunVMOnSpecificHost()) {
            RunVMOnSpecificHost_EntityChanged(sender, args);
        } else if (sender == getDontMigrateVM()) {
            DontMigrateVM_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            IsAutoAssign_EntityChanged(sender, args);
        } else if (sender == getProvisioning()) {
            Provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        }
    }
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid;
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (AsyncDataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getdisplay_type() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (DataProvider.IsWindowsOsType(vm.getvm_os())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#method_after
private void UpdateConsoleModels() {
    List tempVar = getSelectedItems();
    List selectedItems = (tempVar != null) ? tempVar : new ArrayList();
    Object tempVar2 = getSelectedItem();
    VM vm = (VM) ((tempVar2 instanceof VM) ? tempVar2 : null);
    if (vm == null || selectedItems.size() > 1) {
        setDefaultConsoleModel(null);
        setAdditionalConsoleModel(null);
        setHasAdditionalConsoleModel(false);
    } else {
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
        }
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel a : cachedModels) {
            a.setEntity(null);
            a.setEntity(vm);
        }
        setDefaultConsoleModel(vm.getDisplayType() == DisplayType.vnc ? cachedModels.get(1) : cachedModels.get(0));
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            for (ConsoleModel a : cachedModels) {
                if (a instanceof RdpConsoleModel) {
                    setAdditionalConsoleModel(a);
                    break;
                }
            }
            setHasAdditionalConsoleModel(true);
        } else {
            setAdditionalConsoleModel(null);
            setHasAdditionalConsoleModel(false);
        }
    }
}
#end_block

#method_before
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getvm_type());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getvm_type() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getvm_type() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void Edit() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.setVmType(vm.getVmType());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getMessages().editVmTitle(vm.getVmType() == VmType.Server ? ConstantsManager.getInstance().getConstants().serverVmType() : ConstantsManager.getInstance().getConstants().desktopVmType()));
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    model.setHashName("edit_" + (vm.getVmType() == VmType.Server ? "server" : "desktop"));
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.Initialize(this.getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> list = new ArrayList<String>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        list.add(a.getvm_name());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> list = new ArrayList<String>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        list.add(a.getVmName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<VM>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<NGuid, ArrayList<VM>> t = new HashMap<NGuid, ArrayList<VM>>();
    for (VM a : vms) {
        if (!t.containsKey(a.getstorage_pool_id())) {
            t.put(a.getstorage_pool_id(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getstorage_pool_id());
        list.add(a);
    }
    return t.size() > 1;
}
#method_after
@Override
protected boolean entitiesSelectedOnDifferentDataCenters() {
    ArrayList<VM> vms = new ArrayList<VM>();
    for (Object selectedItem : getSelectedItems()) {
        VM a = (VM) selectedItem;
        vms.add(a);
    }
    Map<NGuid, ArrayList<VM>> t = new HashMap<NGuid, ArrayList<VM>>();
    for (VM a : vms) {
        if (!t.containsKey(a.getStoragePoolId())) {
            t.put(a.getStoragePoolId(), new ArrayList<VM>());
        }
        ArrayList<VM> list = t.get(a.getStoragePoolId());
        list.add(a);
    }
    return t.size() > 1;
}
#end_block

#method_before
@Override
protected String extractNameFromEntity(VM entity) {
    return entity.getvm_name();
}
#method_after
@Override
protected String extractNameFromEntity(VM entity) {
    return entity.getVmName();
}
#end_block

#method_before
private void PostGetTemplatesNotPresentOnExportDomain(storage_pool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((storage_domains) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.GetAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getvmt_guid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getvmt_guid().equals(NGuid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getvmt_name())) {
                            templateDic.put(vm.getvmt_name(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getvmt_name()).add(vm.getvm_name());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempStr = "Template " + keyValuePair.getKey() + " (for ";
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        // $NON-NLS-1$
                        tempStr += tempList.get(i) + ", ";
                    }
                    // $NON-NLS-1$
                    tempStr += tempList.get(i) + ")";
                    missingTemplates.add(tempStr);
                }
                vmListModel.PostExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void PostGetTemplatesNotPresentOnExportDomain(storage_pool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((storage_domains) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.GetAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void OnSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                // check if relevant templates are already there
                for (Object selectedItem : vmListModel.getSelectedItems()) {
                    VM vm = (VM) selectedItem;
                    boolean hasMatch = false;
                    for (VmTemplate a : templatesDiskSet.keySet()) {
                        if (vm.getVmtGuid().equals(a.getId())) {
                            hasMatch = true;
                            break;
                        }
                    }
                    if (!vm.getVmtGuid().equals(NGuid.Empty) && !hasMatch) {
                        if (!templateDic.containsKey(vm.getVmtName())) {
                            templateDic.put(vm.getVmtName(), new ArrayList<String>());
                        }
                        templateDic.get(vm.getVmtName()).add(vm.getVmName());
                    }
                }
                String tempStr;
                ArrayList<String> tempList;
                ArrayList<String> missingTemplates = new ArrayList<String>();
                for (Map.Entry<String, ArrayList<String>> keyValuePair : templateDic.entrySet()) {
                    tempList = keyValuePair.getValue();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    tempStr = "Template " + keyValuePair.getKey() + " (for ";
                    int i;
                    for (i = 0; i < tempList.size() - 1; i++) {
                        // $NON-NLS-1$
                        tempStr += tempList.get(i) + ", ";
                    }
                    // $NON-NLS-1$
                    tempStr += tempList.get(i) + ")";
                    missingTemplates.add(tempStr);
                }
                vmListModel.PostExportGetMissingTemplates(missingTemplates);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.getis_stateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getkernel_params());
    model.getKernel_path().setEntity(vm.getkernel_url());
    model.getInitrd_path().setEntity(vm.getinitrd_url());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getvds_group_compatibility_version()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getvds_group_compatibility_version()));
    model.setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(vm.getvm_os()) || vm.getvm_os() == VmOsType.Unassigned || vm.getvm_os() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(DataProvider.IsWindowsOsType(vm.getvm_os()));
    model.getIsVmFirstRun().setEntity(!vm.getis_initialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getvm_domain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void RunOnce() {
    VM vm = (VM) getSelectedItem();
    RunOnceModel model = new RunOnceModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("run_virtual_machine");
    model.getAttachIso().setEntity(false);
    model.getAttachFloppy().setEntity(false);
    model.getRunAsStateless().setEntity(vm.isStateless());
    model.getRunAndPause().setEntity(false);
    model.setHwAcceleration(true);
    // passing Kernel parameters
    model.getKernel_parameters().setEntity(vm.getKernelParams());
    model.getKernel_path().setEntity(vm.getKernelUrl());
    model.getInitrd_path().setEntity(vm.getInitrdUrl());
    // Custom Properties
    model.getCustomPropertySheet().setKeyValueString(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.getCustomPropertySheet().setEntity(vm.getCustomProperties());
    model.setCustomPropertiesKeysList(this.getCustomPropertiesKeysList().get(vm.getVdsGroupCompatibilityVersion()));
    model.setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(vm.getVmOs()) || vm.getVmOs() == VmOsType.Unassigned || vm.getVmOs() == VmOsType.Other);
    model.getIsLinuxOptionsAvailable().setEntity(model.getIsLinux_Unassign_UnknownOS());
    model.setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(vm.getVmOs()));
    model.getIsVmFirstRun().setEntity(!vm.isInitialized());
    model.getSysPrepDomainName().setSelectedItem(vm.getVmDomain());
    RunOnceUpdateDisplayProtocols(vm);
    RunOnceUpdateFloppy(vm, new ArrayList<String>());
    RunOnceUpdateImages(vm);
    RunOnceUpdateDomains();
    RunOnceUpdateBootSequence(vm);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRunOnce", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void RunOnceUpdateDisplayProtocols(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    boolean isVncSelected = vm.getdefault_display_type() == DisplayType.vnc;
    model.getDisplayConsole_Vnc_IsSelected().setEntity(isVncSelected);
    model.getDisplayConsole_Spice_IsSelected().setEntity(!isVncSelected);
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(isVncSelected ? vncProtocol : qxlProtocol);
}
#method_after
private void RunOnceUpdateDisplayProtocols(VM vm) {
    RunOnceModel model = (RunOnceModel) getWindow();
    EntityModel tempVar = new EntityModel();
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    tempVar.setEntity(DisplayType.vnc);
    EntityModel vncProtocol = tempVar;
    EntityModel tempVar2 = new EntityModel();
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    tempVar2.setEntity(DisplayType.qxl);
    EntityModel qxlProtocol = tempVar2;
    boolean isVncSelected = vm.getDefaultDisplayType() == DisplayType.vnc;
    model.getDisplayConsole_Vnc_IsSelected().setEntity(isVncSelected);
    model.getDisplayConsole_Spice_IsSelected().setEntity(!isVncSelected);
    ArrayList<EntityModel> items = new ArrayList<EntityModel>();
    items.add(vncProtocol);
    items.add(qxlProtocol);
    model.getDisplayProtocol().setItems(items);
    model.getDisplayProtocol().setSelectedItem(isVncSelected ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
public void RunOnceUpdateFloppy(VM vm, ArrayList<String> images) {
    RunOnceModel model = (RunOnceModel) getWindow();
    if (DataProvider.IsWindowsOsType(vm.getvm_os())) {
        // Add a pseudo floppy disk image used for Windows' sysprep.
        if (!vm.getis_initialized()) {
            // $NON-NLS-1$
            images.add(0, "[sysprep]");
            model.getAttachFloppy().setEntity(true);
        } else {
            // $NON-NLS-1$
            images.add("[sysprep]");
        }
    }
    model.getFloppyImage().setItems(images);
    if (model.getFloppyImage().getIsChangable() && model.getFloppyImage().getSelectedItem() == null) {
        model.getFloppyImage().setSelectedItem(Linq.FirstOrDefault(images));
    }
}
#method_after
public void RunOnceUpdateFloppy(VM vm, ArrayList<String> images) {
    RunOnceModel model = (RunOnceModel) getWindow();
    if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
        // Add a pseudo floppy disk image used for Windows' sysprep.
        if (!vm.isInitialized()) {
            // $NON-NLS-1$
            images.add(0, "[sysprep]");
            model.getAttachFloppy().setEntity(true);
        } else {
            // $NON-NLS-1$
            images.add("[sysprep]");
        }
    }
    model.getFloppyImage().setItems(images);
    if (model.getFloppyImage().getIsChangable() && model.getFloppyImage().getSelectedItem() == null) {
        model.getFloppyImage().setSelectedItem(Linq.FirstOrDefault(images));
    }
}
#end_block

#method_before
private void RunOnceUpdateImages(VM vm) {
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model2, Object result) {
            VmListModel vmListModel2 = (VmListModel) model2;
            VM selectedVM = (VM) vmListModel2.getSelectedItem();
            ArrayList<String> images = (ArrayList<String>) result;
            vmListModel2.RunOnceUpdateFloppy(selectedVM, images);
        }
    };
    AsyncDataProvider.GetFloppyImageList(_asyncQuery2, vm.getstorage_pool_id());
    AsyncQuery getImageListQuery = new AsyncQuery();
    getImageListQuery.setModel(this);
    getImageListQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            VmListModel vmListModel1 = (VmListModel) model1;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel1.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            runOnceModel.getIsoImage().setItems(images);
            if (runOnceModel.getIsoImage().getIsChangable() && runOnceModel.getIsoImage().getSelectedItem() == null) {
                runOnceModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getImageListQuery, vm.getstorage_pool_id());
}
#method_after
private void RunOnceUpdateImages(VM vm) {
    AsyncQuery _asyncQuery2 = new AsyncQuery();
    _asyncQuery2.setModel(this);
    _asyncQuery2.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model2, Object result) {
            VmListModel vmListModel2 = (VmListModel) model2;
            VM selectedVM = (VM) vmListModel2.getSelectedItem();
            ArrayList<String> images = (ArrayList<String>) result;
            vmListModel2.RunOnceUpdateFloppy(selectedVM, images);
        }
    };
    AsyncDataProvider.GetFloppyImageList(_asyncQuery2, vm.getStoragePoolId());
    AsyncQuery getImageListQuery = new AsyncQuery();
    getImageListQuery.setModel(this);
    getImageListQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model1, Object result) {
            VmListModel vmListModel1 = (VmListModel) model1;
            RunOnceModel runOnceModel = (RunOnceModel) vmListModel1.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            runOnceModel.getIsoImage().setItems(images);
            if (runOnceModel.getIsoImage().getIsChangable() && runOnceModel.getIsoImage().getSelectedItem() == null) {
                runOnceModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getImageListQuery, vm.getStoragePoolId());
}
#end_block

#method_before
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getvm_type());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#method_after
private void NewTemplate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewTemplateVmModelBehavior(vm));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newTemplateTitle());
    // $NON-NLS-1$
    model.setHashName("new_template");
    model.setIsNew(true);
    model.setVmType(vm.getVmType());
    model.Initialize(getSystemTreeSelectedItem());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnNewTemplate", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
    model.getIsHighlyAvailable().setEntity(vm.getStaticData().getauto_startup());
}
#end_block

#method_before
public void PostNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setvm_type(model.getVmType());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setvm_os((VmOsType) model.getOSType().getSelectedItem());
    tempVar.setnum_of_monitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setvm_domain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setvm_mem_size_mb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setvds_group_id(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    tempVar.settime_zone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    tempVar.setnum_of_sockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setcpu_per_socket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setis_auto_suspend(false);
    tempVar.setis_stateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setdefault_boot_sequence(model.getBootSequence());
    tempVar.setauto_startup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setiso_path(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setusb_policy(vm.getusb_policy());
    tempVar.setinitrd_url(vm.getinitrd_url());
    tempVar.setkernel_url(vm.getkernel_url());
    tempVar.setkernel_params(vm.getkernel_params());
    tempVar.setdedicated_vm_for_vds(vm.getdedicated_vm_for_vds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setdefault_display_type((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setpriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.Cancel();
            }
        }
    }, this);
}
#method_after
public void PostNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType(model.getVmType());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((VmOsType) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(((VDSGroup) model.getCluster().getSelectedItem()).getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((Map.Entry<String, String>) model.getTimeZone().getSelectedItem()).getKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setAutoSuspend(false);
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap((Boolean) model.getDisksAllocationModel().getIsSingleStorageDomain().getEntity()));
    model.StartProgress(null);
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void Executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().StopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.Cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void Migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>Cast(getSelectedItems()));
    AsyncDataProvider.GetUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.PostMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getvds_group_name());
}
#method_after
private void Migrate() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MigrateModel model = new MigrateModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().migrateVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("migrate_virtual_machine");
    model.setVmsOnSameCluster(true);
    model.setIsAutoSelect(true);
    model.setVmList(Linq.<VM>Cast(getSelectedItems()));
    AsyncDataProvider.GetUpHostListByCluster(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            VmListModel vmListModel = (VmListModel) target;
            vmListModel.PostMigrateGetUpHosts((ArrayList<VDS>) returnValue);
        }
    }), vm.getVdsGroupName());
}
#end_block

#method_before
private void PostMigrateGetUpHosts(ArrayList<VDS> hosts) {
    MigrateModel model = (MigrateModel) getWindow();
    NGuid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (!a.getvds_group_id().equals(((VM) getSelectedItems().get(0)).getvds_group_id())) {
            model.setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = a.getrun_on_vds().getValue();
        } else if (allRunOnSameVds && !run_on_vds.equals(a.getrun_on_vds().getValue())) {
            allRunOnSameVds = false;
        }
    }
    model.setIsHostSelAvailable(model.getVmsOnSameCluster() && hosts.size() > 0);
    if (model.getVmsOnSameCluster() && allRunOnSameVds) {
        VDS runOnSameVDS = null;
        for (VDS host : hosts) {
            if (host.getId().equals(run_on_vds)) {
                runOnSameVDS = host;
            }
        }
        hosts.remove(runOnSameVDS);
    }
    if (hosts.isEmpty()) {
        model.setIsHostSelAvailable(false);
        if (allRunOnSameVds) {
            model.setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    } else {
        model.getHosts().setItems(hosts);
        model.getHosts().setSelectedItem(Linq.FirstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#method_after
private void PostMigrateGetUpHosts(ArrayList<VDS> hosts) {
    MigrateModel model = (MigrateModel) getWindow();
    NGuid run_on_vds = null;
    boolean allRunOnSameVds = true;
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        if (!a.getVdsGroupId().equals(((VM) getSelectedItems().get(0)).getVdsGroupId())) {
            model.setVmsOnSameCluster(false);
        }
        if (run_on_vds == null) {
            run_on_vds = a.getRunOnVds().getValue();
        } else if (allRunOnSameVds && !run_on_vds.equals(a.getRunOnVds().getValue())) {
            allRunOnSameVds = false;
        }
    }
    model.setIsHostSelAvailable(model.getVmsOnSameCluster() && hosts.size() > 0);
    if (model.getVmsOnSameCluster() && allRunOnSameVds) {
        VDS runOnSameVDS = null;
        for (VDS host : hosts) {
            if (host.getId().equals(run_on_vds)) {
                runOnSameVDS = host;
            }
        }
        hosts.remove(runOnSameVDS);
    }
    if (hosts.isEmpty()) {
        model.setIsHostSelAvailable(false);
        if (allRunOnSameVds) {
            model.setNoSelAvailable(true);
            // $NON-NLS-1$
            UICommand tempVar = new UICommand("Cancel", this);
            tempVar.setTitle(ConstantsManager.getInstance().getConstants().close());
            tempVar.setIsDefault(true);
            tempVar.setIsCancel(true);
            model.getCommands().add(tempVar);
        }
    } else {
        model.getHosts().setItems(hosts);
        model.getHosts().setSelectedItem(Linq.FirstOrDefault(hosts));
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("OnMigrate", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar2.setIsDefault(true);
        model.getCommands().add(tempVar2);
        // $NON-NLS-1$
        UICommand tempVar3 = new UICommand("Cancel", this);
        tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar3.setIsCancel(true);
        model.getCommands().add(tempVar3);
    }
}
#end_block

#method_before
private void OnMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.StartProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getrun_on_vds().getValue().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    }
}
#method_after
private void OnMigrate() {
    MigrateModel model = (MigrateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.StartProgress(null);
    if (model.getIsAutoSelect()) {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            list.add(new MigrateVmParameters(true, a.getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVm, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    } else {
        ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
        for (Object item : getSelectedItems()) {
            VM a = (VM) item;
            if (a.getRunOnVds().getValue().equals(((VDS) model.getHosts().getSelectedItem()).getId())) {
                continue;
            }
            list.add(new MigrateVmToServerParameters(true, a.getId(), ((VDS) model.getHosts().getSelectedItem()).getId()));
        }
        Frontend.RunMultipleAction(VdcActionType.MigrateVmToServer, list, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void Executed(FrontendMultipleActionAsyncResult result) {
                MigrateModel localModel = (MigrateModel) result.getState();
                localModel.StopProgress();
                Cancel();
            }
        }, model);
    }
}
#end_block

#method_before
private void Shutdown() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().shutdownVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("shut_down_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getvm_name());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnShutdown", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void Shutdown() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().shutdownVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("shut_down_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getVmName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnShutdown", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void stop() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("stop_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getvm_name());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void stop() {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().stopVirtualMachinesTitle());
    // $NON-NLS-1$
    model.setHashName("stop_virtual_machine");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getVmName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnStop", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void Run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        boolean reinitialize = !a.getis_initialized() && DataProvider.IsWindowsOsType(a.getvm_os());
        RunVmParams tempVar = new RunVmParams(a.getId());
        tempVar.setReinitialize(reinitialize);
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void Run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        boolean reinitialize = !a.isInitialized() && AsyncDataProvider.IsWindowsOsType(a.getVmOs());
        RunVmParams tempVar = new RunVmParams(a.getId());
        tempVar.setReinitialize(reinitialize);
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void Executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void ChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = // $NON-NLS-1$
    new ArrayList<String>(Arrays.asList(new String[] { "No CDs" }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            if (images.size() > 0) {
                images.add(0, ConsoleModel.EjectLabel);
                _attachCdModel.getIsoImage().setItems(images);
            }
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getIrsImageListCallback, vm.getstorage_pool_id());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void ChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = // $NON-NLS-1$
    new ArrayList<String>(Arrays.asList(new String[] { "No CDs" }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            if (images.size() > 0) {
                images.add(0, ConsoleModel.EjectLabel);
                _attachCdModel.getIsoImage().setItems(images);
            }
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.FirstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.GetIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void RetrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Guid storagePoolId = vm.getstorage_pool_id();
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.EjectLabel);
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ArrayList<String> list = new ArrayList<String>();
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCDsTitle());
    getIsoImages().add(tempVar4);
}
#method_after
private void RetrieveIsoImages() {
    Object tempVar = getSelectedItem();
    VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
    if (vm == null) {
        return;
    }
    Guid storagePoolId = vm.getStoragePoolId();
    getIsoImages().clear();
    ChangeCDModel tempVar2 = new ChangeCDModel();
    tempVar2.setTitle(ConsoleModel.EjectLabel);
    ChangeCDModel ejectModel = tempVar2;
    ejectModel.getExecutedEvent().addListener(this);
    getIsoImages().add(ejectModel);
    ArrayList<String> list = new ArrayList<String>();
    ChangeCDModel tempVar4 = new ChangeCDModel();
    tempVar4.setTitle(ConstantsManager.getInstance().getConstants().noCDsTitle());
    getIsoImages().add(tempVar4);
}
#end_block

#method_before
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        OnSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void ExecuteCommand(UICommand command) {
    super.ExecuteCommand(command);
    if (command == getNewServerCommand()) {
        NewServer();
    } else if (command == getNewDesktopCommand()) {
        NewDesktop();
    } else if (command == getEditCommand()) {
        Edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        Run();
    } else if (command == getPauseCommand()) {
        Pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        Shutdown();
    } else if (command == getMigrateCommand()) {
        Migrate();
    } else if (command == getNewTemplateCommand()) {
        NewTemplate();
    } else if (command == getRunOnceCommand()) {
        RunOnce();
    } else if (command == getExportCommand()) {
        Export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getMoveCommand()) {
        Move();
    } else if (command == getGuideCommand()) {
        Guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        RetrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        ChangeCD();
    } else if (command == getAssignTagsCommand()) {
        AssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnAssignTags")) {
        OnAssignTags();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        Cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        preSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        OnRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExport")) {
        OnExport();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnExportNoTemplates")) {
        OnExportNoTemplates();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        CancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelError")) {
        CancelError();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRunOnce")) {
        OnRunOnce();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnNewTemplate")) {
        OnNewTemplate();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnMigrate")) {
        OnMigrate();
    } else if (command == getCancelMigrateCommand()) {
        CancelMigration();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnShutdown")) {
        OnShutdown();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnStop")) {
        OnStop();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnChangeCD")) {
        OnChangeCD();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
protected Guid extractStoragePoolIdNullSafe(VM entity) {
    return entity.getstorage_pool_id();
}
#method_after
@Override
protected Guid extractStoragePoolIdNullSafe(VM entity) {
    return entity.getStoragePoolId();
}
#end_block

#method_before
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getdescription()).addValue("mem_size_mb", vm.getmem_size_mb()).addValue("os", vm.getos()).addValue("vds_group_id", vm.getvds_group_id()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getvm_name()).addValue("vmt_guid", vm.getvmt_guid()).addValue("num_of_monitors", vm.getnum_of_monitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.getis_initialized()).addValue("is_auto_suspend", vm.getis_auto_suspend()).addValue("num_of_sockets", vm.getnum_of_sockets()).addValue("cpu_per_socket", vm.getcpu_per_socket()).addValue("usb_policy", vm.getusb_policy()).addValue("time_zone", vm.gettime_zone()).addValue("auto_startup", vm.getauto_startup()).addValue("is_stateless", vm.getis_stateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getdedicated_vm_for_vds()).addValue("fail_back", vm.getfail_back()).addValue("vm_type", vm.getvm_type()).addValue("nice_level", vm.getnice_level()).addValue("default_boot_sequence", vm.getdefault_boot_sequence()).addValue("default_display_type", vm.getdefault_display_type()).addValue("priority", vm.getpriority()).addValue("iso_path", vm.getiso_path()).addValue("origin", vm.getorigin()).addValue("initrd_url", vm.getinitrd_url()).addValue("kernel_url", vm.getkernel_url()).addValue("kernel_params", vm.getkernel_params()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()));
}
#method_after
@Override
public void save(VM vm) {
    getCallsHandler().executeModification("InsertVm", getCustomMapSqlParameterSource().addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_guid", vm.getId()).addValue("vm_name", vm.getVmName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("allow_console_reconnect", vm.getAllowConsoleReconnect()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setvm_name(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setvm_mem_size_mb(rs.getInt("vm_mem_size_mb"));
    entity.setvmt_guid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setvm_os(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setvm_description(rs.getString("vm_description"));
    entity.setvds_group_id(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setvm_domain(rs.getString("vm_domain"));
    entity.setvm_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setvds_group_name(rs.getString("vds_group_name"));
    entity.setvds_group_description(rs.getString("vds_group_description"));
    entity.setvmt_name(rs.getString("vmt_name"));
    entity.setvmt_mem_size_mb(rs.getInt("vmt_mem_size_mb"));
    entity.setvmt_os(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setvmt_creation_date(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setvmt_child_count(rs.getInt("vmt_child_count"));
    entity.setvmt_num_of_cpus(rs.getInt("vmt_num_of_cpus"));
    entity.setvmt_num_of_sockets(rs.getInt("vmt_num_of_sockets"));
    entity.setvmt_cpu_per_socket(rs.getInt("vmt_cpu_per_socket"));
    entity.setvmt_description(rs.getString("vmt_description"));
    entity.setstatus(VMStatus.forValue(rs.getInt("status")));
    entity.setvm_ip(rs.getString("vm_ip"));
    entity.setvm_host(rs.getString("vm_host"));
    entity.setvm_pid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setguest_cur_user_name(rs.getString("guest_cur_user_name"));
    entity.setguest_last_login_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setguest_cur_user_id(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setguest_last_logout_time(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setguest_os(rs.getString("guest_os"));
    entity.setcpu_user(rs.getDouble("cpu_user"));
    entity.setcpu_sys(rs.getDouble("cpu_sys"));
    entity.setelapsed_time(rs.getDouble("elapsed_time"));
    entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
    entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
    entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setrun_on_vds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setmigrating_to_vds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setapp_list(rs.getString("app_list"));
    entity.setdisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setnum_of_monitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setis_initialized(rs.getBoolean("is_initialized"));
    entity.setis_auto_suspend(rs.getBoolean("is_auto_suspend"));
    entity.setnum_of_sockets(rs.getInt("num_of_sockets"));
    entity.setcpu_per_socket(rs.getInt("cpu_per_socket"));
    entity.setusb_policy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setacpi_enable((Boolean) rs.getObject("acpi_enable"));
    entity.setsession(SessionState.forValue(rs.getInt("session")));
    entity.setdisplay_ip(rs.getString("display_ip"));
    entity.setdisplay_type(DisplayType.forValue(rs.getInt("display_type")));
    entity.setkvm_enable((Boolean) rs.getObject("kvm_enable"));
    entity.setboot_sequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setrun_on_vds_name(rs.getString("run_on_vds_name"));
    entity.settime_zone(rs.getString("time_zone"));
    entity.setdisplay_secure_port((Integer) rs.getObject("display_secure_port"));
    entity.setutc_diff((Integer) rs.getObject("utc_diff"));
    entity.setauto_startup(rs.getBoolean("auto_startup"));
    entity.setis_stateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setdedicated_vm_for_vds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setfail_back(rs.getBoolean("fail_back"));
    entity.setlast_vds_run_on(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setclient_ip(rs.getString("client_ip"));
    entity.setguest_requested_memory((Integer) rs.getObject("guest_requested_memory"));
    entity.setvds_group_cpu_name(rs.getString("vds_group_cpu_name"));
    entity.setvm_type(VmType.forValue(rs.getInt("vm_type")));
    entity.setstorage_pool_id(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setstorage_pool_name(rs.getString("storage_pool_name"));
    entity.setselection_algorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setnice_level(rs.getInt("nice_level"));
    entity.sethibernation_vol_handle(rs.getString("hibernation_vol_handle"));
    entity.setdefault_boot_sequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setdefault_display_type(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setpriority(rs.getInt("priority"));
    entity.setiso_path(rs.getString("iso_path"));
    entity.setorigin(OriginType.forValue(rs.getInt("origin")));
    entity.setinitrd_url(rs.getString("initrd_url"));
    entity.setkernel_url(rs.getString("kernel_url"));
    entity.setkernel_params(rs.getString("kernel_params"));
    entity.setvds_group_compatibility_version(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setVmName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurUserName(rs.getString("guest_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestCurUserId(NGuid.createGuidFromString(rs.getString("guest_cur_user_id")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    return entity;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + (is_initialized ? 1231 : 1237);
    result = prime * result + m_nDiskSize;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmt_guid == null) ? 0 : vmt_guid.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + (is_initialized ? 1231 : 1237);
    result = prime * result + m_nDiskSize;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((vmt_guid == null) ? 0 : vmt_guid.hashCode());
    result = prime * result + (useHostCpuFlags ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    if (defaultDisplayType != other.defaultDisplayType) {
        return false;
    }
    if (is_initialized != other.is_initialized) {
        return false;
    }
    if (m_nDiskSize != other.m_nDiskSize) {
        return false;
    }
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    if (predefinedProperties == null) {
        if (other.predefinedProperties != null) {
            return false;
        }
    } else if (!predefinedProperties.equals(other.predefinedProperties)) {
        return false;
    }
    if (userDefinedProperties == null) {
        if (other.userDefinedProperties != null) {
            return false;
        }
    } else if (!userDefinedProperties.equals(other.userDefinedProperties)) {
        return false;
    }
    if (vmt_guid == null) {
        if (other.vmt_guid != null) {
            return false;
        }
    } else if (!vmt_guid.equals(other.vmt_guid)) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!super.equals(obj)) {
        return false;
    }
    if (!(obj instanceof VmStatic)) {
        return false;
    }
    VmStatic other = (VmStatic) obj;
    if (defaultDisplayType != other.defaultDisplayType) {
        return false;
    }
    if (is_initialized != other.is_initialized) {
        return false;
    }
    if (m_nDiskSize != other.m_nDiskSize) {
        return false;
    }
    if (name == null) {
        if (other.name != null) {
            return false;
        }
    } else if (!name.equals(other.name)) {
        return false;
    }
    if (predefinedProperties == null) {
        if (other.predefinedProperties != null) {
            return false;
        }
    } else if (!predefinedProperties.equals(other.predefinedProperties)) {
        return false;
    }
    if (userDefinedProperties == null) {
        if (other.userDefinedProperties != null) {
            return false;
        }
    } else if (!userDefinedProperties.equals(other.userDefinedProperties)) {
        return false;
    }
    if (vmt_guid == null) {
        if (other.vmt_guid != null) {
            return false;
        }
    } else if (!vmt_guid.equals(other.vmt_guid)) {
        return false;
    }
    if (useHostCpuFlags != other.useHostCpuFlags) {
        return false;
    }
    return true;
}
#end_block

#method_before
public static void unlockVm(final VM vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm.getDynamicData(), vm.getstatus());
            UnLockVm(vm);
            compensationContext.stateChanged();
            return null;
        }
    });
}
#method_after
public static void unlockVm(final VM vm, final CompensationContext compensationContext) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            compensationContext.snapshotEntityStatus(vm.getDynamicData(), vm.getStatus());
            UnLockVm(vm);
            compensationContext.stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
public static void UnLockVm(VM vm) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
    vm.setstatus(VMStatus.Down);
}
#method_after
public static void UnLockVm(VM vm) {
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SetVmStatus, new SetVmStatusVDSCommandParameters(vm.getId(), VMStatus.Down));
    vm.setStatus(VMStatus.Down);
}
#end_block

#method_before
public static void UpdateVmGuestAgentVersion(final VM vm) {
    if (vm.getapp_list() != null) {
        final String[] parts = vm.getapp_list().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final String agentAppName = Config.<String>GetValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>GetValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(ObjectUtils.toString(vm.getos().getOsType()).toLowerCase());
            for (final String part : parts) {
                if (StringUtils.containsIgnoreCase(part, agentAppName)) {
                    vm.setGuestAgentVersion(GetApplicationVersion(part, agentAppName));
                }
                if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                    vm.setSpiceDriverVersion(GetApplicationVersion(part, spiceDriverInGuest));
                }
            }
        }
    }
}
#method_after
public static void UpdateVmGuestAgentVersion(final VM vm) {
    if (vm.getAppList() != null) {
        final String[] parts = vm.getAppList().split("[,]", -1);
        if (parts != null && parts.length != 0) {
            final String agentAppName = Config.<String>GetValue(ConfigValues.AgentAppName);
            final Map<String, String> spiceDriversInGuest = Config.<Map<String, String>>GetValue(ConfigValues.SpiceDriverNameInGuest);
            final String spiceDriverInGuest = spiceDriversInGuest.get(ObjectUtils.toString(vm.getOs().getOsType()).toLowerCase());
            for (final String part : parts) {
                if (StringUtils.containsIgnoreCase(part, agentAppName)) {
                    vm.setGuestAgentVersion(GetApplicationVersion(part, agentAppName));
                }
                if (StringUtils.containsIgnoreCase(part, spiceDriverInGuest)) {
                    vm.setSpiceDriverVersion(GetApplicationVersion(part, spiceDriverInGuest));
                }
            }
        }
    }
}
#end_block

#method_before
public String getUserDefinedProperties() {
    return mVmStatic.getUserDefinedProperties();
}
#method_after
public String getUserDefinedProperties() {
    return vmStatic.getUserDefinedProperties();
}
#end_block

#method_before
public void setUserDefinedProperties(String userDefinedProperties) {
    mVmStatic.setUserDefinedProperties(userDefinedProperties);
}
#method_after
public void setUserDefinedProperties(String userDefinedProperties) {
    vmStatic.setUserDefinedProperties(userDefinedProperties);
}
#end_block

#method_before
public String getPredefinedProperties() {
    return mVmStatic.getPredefinedProperties();
}
#method_after
public String getPredefinedProperties() {
    return vmStatic.getPredefinedProperties();
}
#end_block

#method_before
public String getCustomProperties() {
    return mVmStatic.getCustomProperties();
}
#method_after
public String getCustomProperties() {
    return vmStatic.getCustomProperties();
}
#end_block

#method_before
public void setCustomProperties(String customProperties) {
    mVmStatic.setCustomProperties(customProperties);
}
#method_after
public void setCustomProperties(String customProperties) {
    vmStatic.setCustomProperties(customProperties);
}
#end_block

#method_before
public void setPredefinedProperties(String predefinedProperties) {
    mVmStatic.setPredefinedProperties(predefinedProperties);
}
#method_after
public void setPredefinedProperties(String predefinedProperties) {
    vmStatic.setPredefinedProperties(predefinedProperties);
}
#end_block

#method_before
public VmPauseStatus getVmPauseStatus() {
    return this.mVmDynamic.getPauseStatus();
}
#method_after
public VmPauseStatus getVmPauseStatus() {
    return this.vmDynamic.getPauseStatus();
}
#end_block

#method_before
public void setVmPauseStatus(VmPauseStatus aPauseStatus) {
    this.mVmDynamic.setPauseStatus(aPauseStatus);
}
#method_after
public void setVmPauseStatus(VmPauseStatus aPauseStatus) {
    this.vmDynamic.setPauseStatus(aPauseStatus);
}
#end_block

#method_before
@Override
public Guid getId() {
    return this.mVmStatic.getId();
}
#method_after
@Override
public Guid getId() {
    return this.vmStatic.getId();
}
#end_block

#method_before
@Override
public void setId(Guid value) {
    this.mVmStatic.setId(value);
    this.mVmDynamic.setId(value);
    this.mVmStatistics.setId(value);
}
#method_after
@Override
public void setId(Guid value) {
    this.vmStatic.setId(value);
    this.vmDynamic.setId(value);
    this.vmStatistics.setId(value);
}
#end_block

#method_before
public Guid getQuotaId() {
    return this.mVmStatic.getQuotaId();
}
#method_after
public Guid getQuotaId() {
    return this.vmStatic.getQuotaId();
}
#end_block

#method_before
public void setQuotaId(Guid value) {
    this.mVmStatic.setQuotaId(value);
}
#method_after
public void setQuotaId(Guid value) {
    this.vmStatic.setQuotaId(value);
}
#end_block

#method_before
public String getQuotaName() {
    return this.mVmStatic.getQuotaName();
}
#method_after
public String getQuotaName() {
    return this.vmStatic.getQuotaName();
}
#end_block

#method_before
public void setQuotaName(String value) {
    this.mVmStatic.setQuotaName(value);
}
#method_after
public void setQuotaName(String value) {
    this.vmStatic.setQuotaName(value);
}
#end_block

#method_before
public boolean isQuotaDefault() {
    return this.mVmStatic.isQuotaDefault();
}
#method_after
public boolean isQuotaDefault() {
    return this.vmStatic.isQuotaDefault();
}
#end_block

#method_before
public void setIsQuotaDefault(boolean isQuotaDefault) {
    this.mVmStatic.setIsQuotaDefault(isQuotaDefault);
}
#method_after
public void setIsQuotaDefault(boolean isQuotaDefault) {
    this.vmStatic.setIsQuotaDefault(isQuotaDefault);
}
#end_block

#method_before
public QuotaEnforcementTypeEnum getQuotaEnforcementType() {
    return this.mVmStatic.getQuotaEnforcementType();
}
#method_after
public QuotaEnforcementTypeEnum getQuotaEnforcementType() {
    return this.vmStatic.getQuotaEnforcementType();
}
#end_block

#method_before
public void setQuotaEnforcementType(QuotaEnforcementTypeEnum quotaEnforcementType) {
    this.mVmStatic.setQuotaEnforcementType(quotaEnforcementType);
}
#method_after
public void setQuotaEnforcementType(QuotaEnforcementTypeEnum quotaEnforcementType) {
    this.vmStatic.setQuotaEnforcementType(quotaEnforcementType);
}
#end_block

#method_before
public boolean getAllowConsoleReconnect() {
    return this.mVmStatic.getAllowConsoleReconnect();
}
#method_after
public boolean getAllowConsoleReconnect() {
    return this.vmStatic.getAllowConsoleReconnect();
}
#end_block

#method_before
public void setAllowConsoleReconnect(boolean value) {
    this.mVmStatic.setAllowConsoleReconnect(value);
}
#method_after
public void setAllowConsoleReconnect(boolean value) {
    this.vmStatic.setAllowConsoleReconnect(value);
}
#end_block

#method_before
public boolean isSmartcardEnabled() {
    return mVmStatic.isSmartcardEnabled();
}
#method_after
public boolean isSmartcardEnabled() {
    return vmStatic.isSmartcardEnabled();
}
#end_block

#method_before
public void setSmartcardEnabled(boolean isSmartcardEnabled) {
    mVmStatic.setSmartcardEnabled(isSmartcardEnabled);
}
#method_after
public void setSmartcardEnabled(boolean isSmartcardEnabled) {
    vmStatic.setSmartcardEnabled(isSmartcardEnabled);
}
#end_block

#method_before
public void setDeleteProtected(boolean deleteProtected) {
    mVmStatic.setDeleteProtected(deleteProtected);
}
#method_after
public void setDeleteProtected(boolean deleteProtected) {
    vmStatic.setDeleteProtected(deleteProtected);
}
#end_block

#method_before
public boolean isDeleteProtected() {
    return mVmStatic.isDeleteProtected();
}
#method_after
public boolean isDeleteProtected() {
    return vmStatic.isDeleteProtected();
}
#end_block

#method_before
public Date getLastStartTime() {
    return this.mVmDynamic.getLastStartTime();
}
#method_after
public Date getLastStartTime() {
    return this.vmDynamic.getLastStartTime();
}
#end_block

#method_before
public void setLastStartTime(Date value) {
    this.mVmDynamic.setLastStartTime(value);
}
#method_after
public void setLastStartTime(Date value) {
    this.vmDynamic.setLastStartTime(value);
}
#end_block

#method_before
public NGuid getConsoleUserId() {
    return this.mVmDynamic.getConsoleUserId();
}
#method_after
public NGuid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#end_block

#method_before
public void setConsoleUserId(NGuid value) {
    this.mVmDynamic.setConsoleUserId(value);
}
#method_after
public void setConsoleUserId(NGuid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#end_block

#method_before
public NGuid getmigrating_to_vds() {
    return this.mVmDynamic.getmigrating_to_vds();
}
#method_after
public NGuid getmigrating_to_vds() {
    return this.vmDynamic.getmigrating_to_vds();
}
#end_block

#method_before
public VmExitStatus getExitStatus() {
    return this.mVmDynamic.getExitStatus();
}
#method_after
public VmExitStatus getExitStatus() {
    return this.vmDynamic.getExitStatus();
}
#end_block

#method_before
public void setExitStatus(VmExitStatus value) {
    this.mVmDynamic.setExitStatus(value);
}
#method_after
public void setExitStatus(VmExitStatus value) {
    this.vmDynamic.setExitStatus(value);
}
#end_block

#method_before
public String getExitMessage() {
    return this.mVmDynamic.getExitMessage();
}
#method_after
public String getExitMessage() {
    return this.vmDynamic.getExitMessage();
}
#end_block

#method_before
public void setExitMessage(String value) {
    this.mVmDynamic.setExitMessage(value);
}
#method_after
public void setExitMessage(String value) {
    this.vmDynamic.setExitMessage(value);
}
#end_block

#method_before
public String getHash() {
    return mVmDynamic.getHash();
}
#method_after
public String getHash() {
    return vmDynamic.getHash();
}
#end_block

#method_before
public void setHash(String hash) {
    mVmDynamic.setHash(hash);
}
#method_after
public void setHash(String hash) {
    vmDynamic.setHash(hash);
}
#end_block

#method_before
public Double getRoundedElapsedTime() {
    return this.mVmStatistics.getRoundedElapsedTime();
}
#method_after
public Double getRoundedElapsedTime() {
    return this.vmStatistics.getRoundedElapsedTime();
}
#end_block

#method_before
public void setRoundedElapsedTime(Double value) {
    this.mVmStatistics.setRoundedElapsedTime(value);
}
#method_after
public void setRoundedElapsedTime(Double value) {
    this.vmStatistics.setRoundedElapsedTime(value);
}
#end_block

#method_before
public MigrationSupport getMigrationSupport() {
    return this.mVmStatic.getMigrationSupport();
}
#method_after
public MigrationSupport getMigrationSupport() {
    return this.vmStatic.getMigrationSupport();
}
#end_block

#method_before
public void setMigrationSupport(MigrationSupport migrationSupport) {
    this.mVmStatic.setMigrationSupport(migrationSupport);
}
#method_after
public void setMigrationSupport(MigrationSupport migrationSupport) {
    this.vmStatic.setMigrationSupport(migrationSupport);
}
#end_block

#method_before
public void setExportDate(Date value) {
    this.mVmStatic.setExportDate(value);
}
#method_after
public void setExportDate(Date value) {
    this.vmStatic.setExportDate(value);
}
#end_block

#method_before
public Date getExportDate() {
    return this.mVmStatic.getExportDate();
}
#method_after
public Date getExportDate() {
    return this.vmStatic.getExportDate();
}
#end_block

#method_before
public List<VmNetworkInterface> getInterfaces() {
    return mVmStatic.getInterfaces();
}
#method_after
public List<VmNetworkInterface> getInterfaces() {
    return vmStatic.getInterfaces();
}
#end_block

#method_before
public void setInterfaces(List<VmNetworkInterface> value) {
    mVmStatic.setInterfaces(value);
}
#method_after
public void setInterfaces(List<VmNetworkInterface> value) {
    vmStatic.setInterfaces(value);
}
#end_block

#method_before
public ArrayList<DiskImage> getImages() {
    return mVmStatic.getImages();
}
#method_after
public ArrayList<DiskImage> getImages() {
    return vmStatic.getImages();
}
#end_block

#method_before
public void setImages(ArrayList<DiskImage> value) {
    mVmStatic.setImages(value);
}
#method_after
public void setImages(ArrayList<DiskImage> value) {
    vmStatic.setImages(value);
}
#end_block

#method_before
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getguest_last_login_time() != null && (getguest_last_logout_time() == null || getguest_last_login_time().compareTo(getguest_last_logout_time()) > 0)) {
        setguest_last_logout_time(new Date());
    }
}
#method_after
public void guestLogoutTimeTreatmentAfterDestroy() {
    if (getGuestLastLoginTime() != null && (getGuestLastLogoutTime() == null || getGuestLastLoginTime().compareTo(getGuestLastLogoutTime()) > 0)) {
        setGuestLastLogoutTime(new Date());
    }
}
#end_block

#method_before
public boolean isStatusUp() {
    return isStatusUp(getstatus());
}
#method_after
public boolean isStatusUp() {
    return isStatusUp(getStatus());
}
#end_block

#method_before
public boolean getIsFirstRun() {
    return mVmStatic.getIsFirstRun();
}
#method_after
public boolean getIsFirstRun() {
    return vmStatic.getIsFirstRun();
}
#end_block

#method_before
public double getDiskSize() {
    if (_diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                _diskSize += ((DiskImage) disk).getsize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return _diskSize;
}
#method_after
public double getDiskSize() {
    if (diskSize == 0) {
        for (Disk disk : getDiskMap().values()) {
            if (DiskStorageType.IMAGE == disk.getDiskStorageType()) {
                diskSize += ((DiskImage) disk).getsize() / Double.valueOf(1024 * 1024 * 1024);
            }
        }
    }
    return diskSize;
}
#end_block

#method_before
public void setDiskSize(double value) {
    _diskSize = value;
}
#method_after
public void setDiskSize(double value) {
    diskSize = value;
}
#end_block

#method_before
public VmDynamic getDynamicData() {
    return mVmDynamic;
}
#method_after
public VmDynamic getDynamicData() {
    return vmDynamic;
}
#end_block

#method_before
public void setDynamicData(VmDynamic value) {
    mVmDynamic = value;
}
#method_after
public void setDynamicData(VmDynamic value) {
    vmDynamic = value;
}
#end_block

#method_before
public VmStatic getStaticData() {
    return mVmStatic;
}
#method_after
public VmStatic getStaticData() {
    return vmStatic;
}
#end_block

#method_before
public void setStaticData(VmStatic value) {
    if (mVmStatic == null) {
        mVmStatic = new VmStatic();
    }
    mVmStatic = value;
}
#method_after
public void setStaticData(final VmStatic value) {
    // TODO this null protection is here for historical reasons, it may not be needed anymore
    if (value == null) {
        vmStatic = new VmStatic();
    } else {
        vmStatic = value;
    }
}
#end_block

#method_before
public VmStatistics getStatisticsData() {
    return mVmStatistics;
}
#method_after
public VmStatistics getStatisticsData() {
    return vmStatistics;
}
#end_block

#method_before
public void setStatisticsData(VmStatistics value) {
    mVmStatistics = value;
}
#method_after
public void setStatisticsData(VmStatistics value) {
    vmStatistics = value;
}
#end_block

#method_before
public int getMigreatingToPort() {
    return mMigreatingToPort;
}
#method_after
public int getMigreatingToPort() {
    return migreatingToPort;
}
#end_block

#method_before
public void setMigreatingToPort(int value) {
    mMigreatingToPort = value;
}
#method_after
public void setMigreatingToPort(int value) {
    migreatingToPort = value;
}
#end_block

#method_before
public int getMigreatingFromPort() {
    return mMigreatingFromPort;
}
#method_after
public int getMigreatingFromPort() {
    return migreatingFromPort;
}
#end_block

#method_before
public void setMigreatingFromPort(int value) {
    mMigreatingFromPort = value;
}
#method_after
public void setMigreatingFromPort(int value) {
    migreatingFromPort = value;
}
#end_block

#method_before
public Map<Guid, Disk> getDiskMap() {
    return mDiskMap;
}
#method_after
public Map<Guid, Disk> getDiskMap() {
    return diskMap;
}
#end_block

#method_before
public void setDiskMap(Map<Guid, Disk> diskMap) {
    mDiskMap = diskMap;
}
#method_after
public void setDiskMap(Map<Guid, Disk> diskMap) {
    this.diskMap = diskMap;
}
#end_block

#method_before
public int getDiskMapCount() {
    return mDiskMap.size();
}
#method_after
public int getDiskMapCount() {
    return diskMap.size();
}
#end_block

#method_before
public int getMinAllocatedMem() {
    return mVmStatic.getMinAllocatedMem();
}
#method_after
public int getMinAllocatedMem() {
    return vmStatic.getMinAllocatedMem();
}
#end_block

#method_before
public void setMinAllocatedMem(int value) {
    mVmStatic.setMinAllocatedMem(value);
}
#method_after
public void setMinAllocatedMem(int value) {
    vmStatic.setMinAllocatedMem(value);
}
#end_block

#method_before
public String getCdPath() {
    return mCdPath;
}
#method_after
public String getCdPath() {
    return cdPath;
}
#end_block

#method_before
public void setCdPath(String value) {
    mCdPath = value;
}
#method_after
public void setCdPath(String value) {
    cdPath = value;
}
#end_block

#method_before
public String getFloppyPath() {
    return mFloppyPath;
}
#method_after
public String getFloppyPath() {
    return floppyPath;
}
#end_block

#method_before
public void setFloppyPath(String value) {
    mFloppyPath = value;
}
#method_after
public void setFloppyPath(String value) {
    floppyPath = value;
}
#end_block

#method_before
public void setRunAndPause(boolean value) {
    mRunAndPause = value;
}
#method_after
public void setRunAndPause(boolean value) {
    runAndPause = value;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setstatus(vm.getstatus());
    setrun_on_vds(vdsId);
    setrun_on_vds_name(vdsName);
    setdisplay(vm.getdisplay());
    setdisplay_secure_port(vm.getdisplay_secure_port());
    setvm_host(vm.getvm_host());
    setvm_ip(vm.getvm_ip());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setapp_list(vm.getapp_list());
    // }
    setguest_os(vm.getguest_os());
    setdisplay_type(vm.getdisplay_type());
    setdisplay_ip(vm.getdisplay_ip());
    setkvm_enable(vm.getkvm_enable());
    setacpi_enable(vm.getacpi_enable());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setutc_diff(vm.getutc_diff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setclient_ip(vm.getclient_ip());
    setVmPauseStatus(vm.getPauseStatus());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getstatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getdisplay());
    setDisplaySecurePort(vm.getdisplay_secure_port());
    setVmHost(vm.getvm_host());
    setVmIp(vm.getvm_ip());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getapp_list());
    // }
    setGuestOs(vm.getguest_os());
    setDisplayType(vm.getdisplay_type());
    setDisplayIp(vm.getdisplay_ip());
    setKvmEnable(vm.getkvm_enable());
    setAcpiEnable(vm.getacpi_enable());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getutc_diff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getclient_ip());
    setVmPauseStatus(vm.getPauseStatus());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setelapsed_time(vmStatistics.getelapsed_time());
    setusage_network_percent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setcpu_sys(vmStatistics.getcpu_sys());
    setcpu_user(vmStatistics.getcpu_user());
    if ((getcpu_sys() != null) && (getcpu_user() != null)) {
        Double percent = (getcpu_sys() + getcpu_user()) / new Double(vm.getnum_of_cpus());
        setusage_cpu_percent(percent.intValue());
        if (getusage_cpu_percent() != null && getusage_cpu_percent() > 100) {
            setusage_cpu_percent(100);
        }
    }
    // -------- memory --------------
    setusage_mem_percent(vmStatistics.getusage_mem_percent());
}
#method_after
public void updateRunTimeStatisticsData(VmStatistics vmStatistics, VM vm) {
    setElapsedTime(vmStatistics.getelapsed_time());
    setUsageNetworkPercent(vmStatistics.getusage_network_percent());
    vm.getStatisticsData().setDisksUsage(vmStatistics.getDisksUsage());
    // -------- cpu --------------
    setCpuSys(vmStatistics.getcpu_sys());
    setCpuUser(vmStatistics.getcpu_user());
    if ((getCpuSys() != null) && (getCpuUser() != null)) {
        Double percent = (getCpuSys() + getCpuUser()) / new Double(vm.getNumOfCpus());
        setUsageCpuPercent(percent.intValue());
        if (getUsageCpuPercent() != null && getUsageCpuPercent() > 100) {
            setUsageCpuPercent(100);
        }
    }
    // -------- memory --------------
    setUsageMemPercent(vmStatistics.getusage_mem_percent());
}
#end_block

#method_before
public String getVmPoolName() {
    return mVmPoolName;
}
#method_after
public String getVmPoolName() {
    return vmPoolName;
}
#end_block

#method_before
public void setVmPoolName(String value) {
    mVmPoolName = value;
}
#method_after
public void setVmPoolName(String value) {
    vmPoolName = value;
}
#end_block

#method_before
public NGuid getVmPoolId() {
    return mVmPoolId;
}
#method_after
public NGuid getVmPoolId() {
    return vmPoolId;
}
#end_block

#method_before
public void setVmPoolId(NGuid value) {
    mVmPoolId = value;
}
#method_after
public void setVmPoolId(NGuid value) {
    vmPoolId = value;
}
#end_block

#method_before
public Version getSpiceDriverVersion() {
    return privateSpiceDriverVersion;
}
#method_after
public Version getSpiceDriverVersion() {
    return spiceDriverVersion;
}
#end_block

#method_before
public void setSpiceDriverVersion(Version value) {
    privateSpiceDriverVersion = value;
}
#method_after
public void setSpiceDriverVersion(Version value) {
    spiceDriverVersion = value;
}
#end_block

#method_before
@Override
public ArrayList<String> getChangeablePropertiesList() {
    return _vmProperties;
}
#method_after
@Override
public ArrayList<String> getChangeablePropertiesList() {
    return vmProperties;
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return mVmStatic.getDiskList();
}
#method_after
public ArrayList<DiskImage> getDiskList() {
    return vmStatic.getDiskList();
}
#end_block

#method_before
public Map<Guid, VmDevice> getManagedVmDeviceMap() {
    return mVmStatic.getManagedVmDeviceMap();
}
#method_after
public Map<Guid, VmDevice> getManagedVmDeviceMap() {
    return vmStatic.getManagedVmDeviceMap();
}
#end_block

#method_before
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    mVmStatic.setManagedDeviceMap(map);
}
#method_after
public void setManagedDeviceMap(Map<Guid, VmDevice> map) {
    vmStatic.setManagedDeviceMap(map);
}
#end_block

#method_before
public List<VmDevice> getVmUnamagedDeviceList() {
    return mVmStatic.getUnmanagedDeviceList();
}
#method_after
public List<VmDevice> getVmUnamagedDeviceList() {
    return vmStatic.getUnmanagedDeviceList();
}
#end_block

#method_before
public void setUnmanagedDeviceList(List<VmDevice> list) {
    mVmStatic.setUnmanagedDeviceList(list);
}
#method_after
public void setUnmanagedDeviceList(List<VmDevice> list) {
    vmStatic.setUnmanagedDeviceList(list);
}
#end_block

#method_before
public void setRunOnce(boolean value) {
    isRunOnce = value;
}
#method_after
public void setRunOnce(boolean value) {
    runOnce = value;
}
#end_block

#method_before
public boolean isRunOnce() {
    return isRunOnce;
}
#method_after
public boolean isRunOnce() {
    return runOnce;
}
#end_block

#method_before
public boolean isUseHostCpuFlags() {
    return mVmStatic.isUseHostCpuFlags();
}
#method_after
public boolean isUseHostCpuFlags() {
    return vmStatic.isUseHostCpuFlags();
}
#end_block

#method_before
public void setUseHostCpuFlags(boolean useHostCpuFlags) {
    mVmStatic.setUseHostCpuFlags(useHostCpuFlags);
}
#method_after
public void setUseHostCpuFlags(boolean useHostCpuFlags) {
    vmStatic.setUseHostCpuFlags(useHostCpuFlags);
}
#end_block

#method_before
public String getCpuPinning() {
    return mVmStatic.getCpuPinning();
}
#method_after
public String getCpuPinning() {
    return vmStatic.getCpuPinning();
}
#end_block

#method_before
public void setCpuPinning(String cpuPinning) {
    mVmStatic.setCpuPinning(cpuPinning);
}
#method_after
public void setCpuPinning(String cpuPinning) {
    vmStatic.setCpuPinning(cpuPinning);
}
#end_block

#method_before
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getvm_name());
    createInfo.add(VdsProperties.mem_size_mb, vm.getvm_mem_size_mb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getnum_of_cpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getcpu_per_socket())));
    }
    final String compatibilityVersion = vm.getvds_group_compatibility_version().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getkvm_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getacpi_enable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.getRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.add(VdsProperties.cpuType, "hostPassthrough");
    } else {
        if (vm.getvds_group_cpu_flags_data() != null) {
            createInfo.add(VdsProperties.cpuType, vm.getvds_group_cpu_flags_data());
        }
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getnice_level())).toString());
    if (vm.getstatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.gethibernation_vol_handle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.gethibernation_vol_handle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getvm_os().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getdisplay_type() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.getTransparentHugePages() ? "true" : "false");
}
#method_after
protected void buildVmProperties() {
    createInfo.add(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.add(VdsProperties.vm_name, vm.getVmName());
    createInfo.add(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    createInfo.add(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.add(VdsProperties.num_of_cpus, (new Integer(vm.getNumOfCpus())).toString());
    if (Config.<Boolean>GetValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.add(VdsProperties.cores_per_socket, (Integer.toString(vm.getCpuPerSocket())));
    }
    final String compatibilityVersion = vm.getVdsGroupCompatibilityVersion().toString();
    addCpuPinning(compatibilityVersion);
    createInfo.add(VdsProperties.emulatedMachine, Config.<String>GetValue(ConfigValues.EmulatedMachine, compatibilityVersion));
    // enabled.
    if (Config.<Boolean>GetValue(ConfigValues.SSLEnabled)) {
        createInfo.add(VdsProperties.spiceSslCipherSuite, Config.<String>GetValue(ConfigValues.CipherSuite));
        createInfo.add(VdsProperties.SpiceSecureChannels, Config.<String>GetValue(ConfigValues.SpiceSecureChannels, compatibilityVersion));
    }
    createInfo.add(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.add(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.add(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.add(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.add(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getVdsGroupCpuFlagsData() != null) {
        createInfo.add(VdsProperties.cpuType, vm.getVdsGroupCpuFlagsData());
    }
    createInfo.add(VdsProperties.niceLevel, (new Integer(vm.getNiceLevel())).toString());
    if (vm.getStatus() == VMStatus.Suspended && !StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.add(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    createInfo.add(VdsProperties.KeyboardLayout, Config.<String>GetValue(ConfigValues.VncKeyboardLayout));
    if (vm.getVmOs().isLinux()) {
        createInfo.add(VdsProperties.PitReinjection, "false");
    }
    if (vm.getDisplayType() == DisplayType.vnc) {
        createInfo.add(VdsProperties.TabletEnable, "true");
    }
    createInfo.add(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
}
#end_block

#method_before
protected void buildVmNetworkCluster() {
    // set Display network
    List<network_cluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getvds_group_id());
    network_cluster networkCluster = null;
    for (network_cluster tempNetworkCluster : all) {
        if (tempNetworkCluster.getis_display()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getnetwork_id())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.add(VdsProperties.displaynetwork, net.getname());
        }
    }
}
#method_after
protected void buildVmNetworkCluster() {
    // set Display network
    List<network_cluster> all = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(vm.getVdsGroupId());
    network_cluster networkCluster = null;
    for (network_cluster tempNetworkCluster : all) {
        if (tempNetworkCluster.getis_display()) {
            networkCluster = tempNetworkCluster;
            break;
        }
    }
    if (networkCluster != null) {
        Network net = null;
        List<Network> allNetworks = DbFacade.getInstance().getNetworkDao().getAll();
        for (Network tempNetwork : allNetworks) {
            if (tempNetwork.getId().equals(networkCluster.getnetwork_id())) {
                net = tempNetwork;
                break;
            }
        }
        if (net != null) {
            createInfo.add(VdsProperties.displaynetwork, net.getname());
        }
    }
}
#end_block

#method_before
protected void buildVmBootOptions() {
    // Boot Options
    if (!StringUtils.isEmpty(vm.getinitrd_url())) {
        createInfo.add(VdsProperties.InitrdUrl, vm.getinitrd_url());
    }
    if (!StringUtils.isEmpty(vm.getkernel_url())) {
        createInfo.add(VdsProperties.KernelUrl, vm.getkernel_url());
        if (!StringUtils.isEmpty(vm.getkernel_params())) {
            createInfo.add(VdsProperties.KernelParams, vm.getkernel_params());
        }
    }
}
#method_after
protected void buildVmBootOptions() {
    // Boot Options
    if (!StringUtils.isEmpty(vm.getInitrdUrl())) {
        createInfo.add(VdsProperties.InitrdUrl, vm.getInitrdUrl());
    }
    if (!StringUtils.isEmpty(vm.getKernelUrl())) {
        createInfo.add(VdsProperties.KernelUrl, vm.getKernelUrl());
        if (!StringUtils.isEmpty(vm.getKernelParams())) {
            createInfo.add(VdsProperties.KernelParams, vm.getKernelParams());
        }
    }
}
#end_block

#method_before
protected void buildVmTimeZone() {
    // send vm_dynamic.utc_diff if exist, if not send vm_static.time_zone
    if (vm.getutc_diff() != null) {
        createInfo.add(VdsProperties.utc_diff, vm.getutc_diff().toString());
    } else {
        // get vm timezone
        String timeZone = TimeZoneInfo.Local.getId();
        if (!StringUtils.isEmpty(vm.gettime_zone())) {
            timeZone = vm.gettime_zone();
        }
        int offset = 0;
        String javaZoneId = null;
        if (vm.getos().isWindows()) {
            // convert to java & calculate offset
            javaZoneId = WindowsJavaTimezoneMapping.windowsToJava.get(timeZone);
        } else {
            javaZoneId = timeZone;
        }
        if (javaZoneId != null) {
            offset = (TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000);
        }
        createInfo.add(VdsProperties.utc_diff, "" + offset);
    }
}
#method_after
protected void buildVmTimeZone() {
    // send vm_dynamic.utc_diff if exist, if not send vm_static.time_zone
    if (vm.getUtcDiff() != null) {
        createInfo.add(VdsProperties.utc_diff, vm.getUtcDiff().toString());
    } else {
        // get vm timezone
        String timeZone = TimeZoneInfo.Local.getId();
        if (!StringUtils.isEmpty(vm.getTimeZone())) {
            timeZone = vm.getTimeZone();
        }
        int offset = 0;
        String javaZoneId = null;
        if (vm.getOs().isWindows()) {
            // convert to java & calculate offset
            javaZoneId = WindowsJavaTimezoneMapping.windowsToJava.get(timeZone);
        } else {
            javaZoneId = timeZone;
        }
        if (javaZoneId != null) {
            offset = (TimeZone.getTimeZone(javaZoneId).getOffset(new Date().getTime()) / 1000);
        }
        createInfo.add(VdsProperties.utc_diff, "" + offset);
    }
}
#end_block

#method_before
@Override
protected String getProgressText(T object) {
    Integer progressValue = getProgressValue(object);
    if (progressValue != null && progressValue >= 100) {
        // $NON-NLS-1$
        return "Exceeded";
    }
    if (progressValue != null && progressValue < 0) {
        // $NON-NLS-1$
        return "Unlimited";
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    return progressValue != null ? progressValue + "%" : "0%";
}
#method_after
@Override
protected String getProgressText(T object) {
    Integer progressValue = getProgressValue(object);
    if (progressValue != null && progressValue >= 100) {
        return getaApplicationConstants().exceeded();
    }
    if (progressValue != null && progressValue < 0) {
        return getaApplicationConstants().unlimited();
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    return progressValue != null ? progressValue + "%" : "0%";
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    // getTable().addColumn(new TextColumnWithTooltip<Quota>() {
    // @Override
    // public String getValue(Quota object) {
    // return object.getStoragePoolName() == null ? "" : object.getStoragePoolName(); //$NON-NLS-1$
    // }
    // }, constants.dcQuota(), "150px"); //$NON-NLS-1$
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5120) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1025) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                // $NON-NLS-1$
                returnVal = "Unlimited";
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveQuotaCommand();
        }
    });
}
#method_after
void initTable(final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new QuotaDcStatusColumn(), constants.empty(), "30px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getQuotaName() == null ? "" : object.getQuotaName();
        }
    }, constants.nameQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            // $NON-NLS-1$
            return object.getDescription() == null ? "" : object.getDescription();
        }
    }, constants.descriptionQuota(), // $NON-NLS-1$
    "120px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedMemoryQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            long allocated = 0;
            long used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getMemSizeMB();
                used = object.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getMemSizeMB();
                    used += quotaVdsGroup.getMemSizeMBUsage();
                }
            }
            value = (int) (allocated - used);
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 MB";
            } else if (value <= 5 * 1024) {
                // $NON-NLS-1$
                returnVal = value + "MB";
            } else {
                // $NON-NLS-1$
                returnVal = decimalFormat.format((double) value / 1024) + "GB";
            }
            return returnVal;
        }
    }, constants.freeMemory(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) (((double) used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.runningCpuQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            int value;
            int allocated = 0;
            int used = 0;
            if (object.getGlobalQuotaVdsGroup() != null) {
                allocated = object.getGlobalQuotaVdsGroup().getVirtualCpu();
                used = object.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
            } else {
                for (QuotaVdsGroup quotaVdsGroup : object.getQuotaVdsGroups()) {
                    allocated += quotaVdsGroup.getVirtualCpu();
                    used += quotaVdsGroup.getVirtualCpuUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0";
            } else {
                // $NON-NLS-1$
                returnVal = value + "";
            }
            return returnVal;
        }
    }, constants.freeVcpu(), // $NON-NLS-1$
    "80px");
    getTable().addColumn(new QuotaPercentColumn<Quota>() {

        @Override
        protected Integer getProgressValue(Quota object) {
            int value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            if (allocated == 0) {
                return 0;
            }
            value = (int) ((used / allocated) * 100);
            return allocated < 0 ? -1 : value > 100 ? 100 : value;
        }

        @Override
        public ApplicationConstants getaApplicationConstants() {
            return constants;
        }
    }, constants.usedStorageQuota(), // $NON-NLS-1$
    "100px");
    getTable().addColumn(new TextColumnWithTooltip<Quota>() {

        @Override
        public String getValue(Quota object) {
            double value;
            double allocated = 0;
            double used = 0;
            if (object.getGlobalQuotaStorage() != null) {
                allocated = object.getGlobalQuotaStorage().getStorageSizeGB();
                used = object.getGlobalQuotaStorage().getStorageSizeGBUsage();
            } else {
                for (QuotaStorage quotaStorage : object.getQuotaStorages()) {
                    allocated += quotaStorage.getStorageSizeGB();
                    used += quotaStorage.getStorageSizeGBUsage();
                }
            }
            value = allocated - used;
            String returnVal;
            if (allocated < 0) {
                returnVal = constants.unlimited();
            } else if (value <= 0) {
                // $NON-NLS-1$
                returnVal = "0 GB";
            } else {
                returnVal = diskSizeRenderer.render(value);
            }
            return returnVal;
        }
    }, constants.freeStorage(), // $NON-NLS-1$
    "80px");
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.addQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.editQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.copyQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneQuotaCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<Quota>(constants.removeQuota()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveQuotaCommand();
        }
    });
}
#end_block

#method_before
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
                return true;
            }
        }
    }
    return true;
}
#method_after
/**
 * Validate parameters. Look for null pointers and missing data Complete the missing data in the parameters from DB
 * and cache all the needed entities.
 *
 * @param parameters
 *            - Quota consumption parameters
 */
private boolean validateAndCompleteParameters(QuotaConsumptionParametersWrapper parameters, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
        return true;
    }
    boolean hardEnforcement = QuotaEnforcementTypeEnum.HARD_ENFORCEMENT == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType();
    // for each parameter - check and complete
    for (QuotaConsumptionParameter param : parameters.getParameters()) {
        // check that quota id is valid and fetch the quota from db (or cache). add the quota to the param
        boolean validQuotaId = checkAndFetchQuota(parameters, param, auditLogPair);
        boolean validVdsGroup = true;
        boolean validStorageDomain = true;
        if (validQuotaId) {
            // vds group id which is handled by this quota
            if (param instanceof QuotaVdsGroupConsumptionParameter) {
                validVdsGroup = checkVdsGroupMatchQuota(parameters, param);
            }
            // storage domain id which is handled by this quota
            if (param instanceof QuotaStorageConsumptionParameter) {
                validStorageDomain = checkStoragePoolMatchQuota(parameters, param);
            }
        }
        if (!validQuotaId || !validVdsGroup || !validStorageDomain) {
            // if in hard enforcement - return false
            if (hardEnforcement) {
                return false;
            } else {
                // clear any messages written to the canDoActionMessages
                parameters.getCanDoActionMessages().clear();
                if (QuotaEnforcementTypeEnum.DISABLED == parameters.getAuditLogable().getStoragePool().getQuotaEnforcementType()) {
                    auditLogPair.setFirst(null);
                }
            }
        }
    }
    parameters.getParameters().removeAll(corruptedParameters);
    corruptedParameters.clear();
    return true;
}
#end_block

#method_before
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#method_after
private boolean checkAndFetchQuota(QuotaConsumptionParametersWrapper parameters, QuotaConsumptionParameter param, Pair<AuditLogType, AuditLogableBase> auditLogPair) throws InvalidQuotaParametersException {
    if (param.getQuotaGuid() == null || Guid.Empty.equals(param.getQuotaGuid())) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NOT_VALID.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("No Quota id passed from command: {0}", parameters.getAuditLogable().getClass().getName());
        corruptedParameters.add(param);
        return false;
    }
    Quota quota = fetchQuotaFromCache(param.getQuotaGuid(), parameters.getStoragePool().getId());
    if (quota == null) {
        parameters.getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_QUOTA_IS_NO_LONGER_AVAILABLE_IN_SYSTEM.toString());
        auditLogPair.setFirst(param.getParameterType() == QuotaConsumptionParameter.ParameterType.STORAGE ? AuditLogType.MISSING_QUOTA_STORAGE_PARAMETERS_PERMISSIVE_MODE : AuditLogType.MISSING_QUOTA_CLUSTER_PARAMETERS_PERMISSIVE_MODE);
        log.errorFormat("The quota id {0} is not found in backend and DB.", param.getQuotaGuid().toString());
        corruptedParameters.add(param);
        return false;
    } else {
        param.setQuota(quota);
    }
    if (!quota.getStoragePoolId().equals(parameters.getStoragePoolId())) {
        throw new InvalidQuotaParametersException("The Quota storage pool id does not match the passed storage pool");
    }
    return true;
}
#end_block

#method_before
public void updateUsage(List<Quota> quotaList) {
    lock.writeLock().lock();
    try {
        for (Quota quotaExternal : quotaList) {
            Quota quota = null;
            // look for the quota in the cache
            for (Map<Guid, Quota> quotaMap : storagePoolQuotaMap.values()) {
                quota = quotaMap.get(quotaExternal.getId());
                if (quota != null) {
                    break;
                }
            }
            // if quota not in cache look for it in DB and add it to cache
            if (quota == null) {
                quota = getQuotaDAO().getById(quotaExternal.getId());
                if (quota != null) {
                    if (!storagePoolQuotaMap.containsKey(quota.getStoragePoolId())) {
                        storagePoolQuotaMap.put(quota.getStoragePoolId(), new HashMap<Guid, Quota>());
                    }
                    storagePoolQuotaMap.get(quota.getStoragePoolId()).put(quota.getId(), quota);
                }
            }
            copyUsageData(quota, quotaExternal);
        }
    } finally {
        lock.writeLock().unlock();
    }
}
#method_after
public void updateUsage(List<Quota> quotaList) {
    List<Quota> needToCache = new ArrayList<Quota>();
    if (quotaList == null) {
        return;
    }
    lock.readLock().lock();
    try {
        for (Quota quotaExternal : quotaList) {
            // look for the quota in the cache
            Map<Guid, Quota> quotaMap = storagePoolQuotaMap.get(quotaExternal.getStoragePoolId());
            Quota quota = null;
            if (quotaMap != null) {
                quota = quotaMap.get(quotaExternal.getId());
            }
            // if quota not in cache look for it in DB and add it to cache
            if (quota == null) {
                needToCache.add(quotaExternal);
            } else {
                copyUsageData(quota, quotaExternal);
            }
        }
    } finally {
        lock.readLock().unlock();
    }
    // if some of the quota are not in cache and need to be cached
    if (!needToCache.isEmpty()) {
        lock.writeLock().lock();
        try {
            for (Quota quotaExternal : needToCache) {
                if (!storagePoolQuotaMap.containsKey(quotaExternal.getStoragePoolId())) {
                    storagePoolQuotaMap.put(quotaExternal.getStoragePoolId(), new HashMap<Guid, Quota>());
                }
                Quota quota = fetchQuotaFromCache(quotaExternal.getId(), quotaExternal.getStoragePoolId());
                if (quota != null) {
                    copyUsageData(quota, quotaExternal);
                }
            }
        } finally {
            lock.writeLock().unlock();
        }
    }
}
#end_block

#method_before
private void countPersonalUsage(List<VM> vms, Map<Guid, QuotaPerUserUsageEntity> quotaPerUserUsageEntityMap) {
    for (VM vm : vms) {
        // if vm is running and have a quota
        if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
            QuotaPerUserUsageEntity quotaPerUserUsageEntity = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
            // add the vm cpu and mem to the user quota consumption
            if (quotaPerUserUsageEntity != null) {
                quotaPerUserUsageEntity.setMemoryUsageForUser(quotaPerUserUsageEntity.getMemoryUsageForUser() + vm.getMemSizeMb());
                quotaPerUserUsageEntity.setVcpuUsageForUser(quotaPerUserUsageEntity.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
            }
        }
        // for each image of each disk of the vm - if it has a quota
        for (DiskImage image : vm.getDiskList()) {
            QuotaPerUserUsageEntity quotaPerUserUsageEntity = quotaPerUserUsageEntityMap.get(image.getQuotaId());
            double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
            // add the disk size to the user storage consumption
            if (quotaPerUserUsageEntity != null) {
                quotaPerUserUsageEntity.setStorageUsageForUser(quotaPerUserUsageEntity.getStorageUsageForUser() + imageSize);
            }
        }
    }
}
#method_after
private void countPersonalUsage(List<VM> vms, Map<Guid, QuotaUsagePerUser> quotaPerUserUsageEntityMap) {
    if (vms != null) {
        for (VM vm : vms) {
            // if vm is running and have a quota
            if (vm.getStatus() != VMStatus.Down && vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.ImageIllegal && vm.getStatus() != VMStatus.ImageLocked && vm.getStatus() != VMStatus.PoweringDown && vm.getQuotaId() != null) {
                QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(vm.getQuotaId());
                // add the vm cpu and mem to the user quota consumption
                if (quotaUsagePerUser != null) {
                    quotaUsagePerUser.setMemoryUsageForUser(quotaUsagePerUser.getMemoryUsageForUser() + vm.getMemSizeMb());
                    quotaUsagePerUser.setVcpuUsageForUser(quotaUsagePerUser.getVcpuUsageForUser() + vm.getCpuPerSocket() * vm.getNumOfSockets());
                }
            }
            // for each image of each disk of the vm - if it has a quota
            for (DiskImage image : vm.getDiskList()) {
                QuotaUsagePerUser quotaUsagePerUser = quotaPerUserUsageEntityMap.get(image.getQuotaId());
                double imageSize = image.getImage().isActive() ? image.getSizeInGigabytes() : image.getActualSize();
                // add the disk size to the user storage consumption
                if (quotaUsagePerUser != null) {
                    quotaUsagePerUser.setStorageUsageForUser(quotaUsagePerUser.getStorageUsageForUser() + imageSize);
                }
            }
        }
    }
}
#end_block

#method_before
private QuotaPerUserUsageEntity addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                storageLimit += quotaStorage.getStorageSizeGB();
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                memLimit += quotaVdsGroup.getMemSizeMB();
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                cpuLimit += quotaVdsGroup.getVirtualCpu();
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaPerUserUsageEntity(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#method_after
private QuotaUsagePerUser addQuotaEntry(Quota quota) {
    // if quota is not null (found in cache or DB) - add entry to quotaPerUserUsageEntityMap
    if (quota != null) {
        double storageLimit = 0;
        double storageUsage = 0;
        int cpuLimit = 0;
        int cpuUsage = 0;
        long memLimit = 0;
        long memUsage = 0;
        // calc storage
        if (quota.getGlobalQuotaStorage() != null) {
            storageLimit = quota.getGlobalQuotaStorage().getStorageSizeGB();
            storageUsage = quota.getGlobalQuotaStorage().getStorageSizeGBUsage();
        } else {
            for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
                storageLimit += quotaStorage.getStorageSizeGB();
                storageUsage += quotaStorage.getStorageSizeGBUsage();
            }
        }
        // calc cpu and mem
        if (quota.getGlobalQuotaVdsGroup() != null) {
            memLimit = quota.getGlobalQuotaVdsGroup().getMemSizeMB();
            memUsage = quota.getGlobalQuotaVdsGroup().getMemSizeMBUsage();
            cpuLimit = quota.getGlobalQuotaVdsGroup().getVirtualCpu();
            cpuUsage = quota.getGlobalQuotaVdsGroup().getVirtualCpuUsage();
        } else {
            for (QuotaVdsGroup quotaVdsGroup : quota.getQuotaVdsGroups()) {
                memLimit += quotaVdsGroup.getMemSizeMB();
                memUsage += quotaVdsGroup.getMemSizeMBUsage();
                cpuLimit += quotaVdsGroup.getVirtualCpu();
                cpuUsage += quotaVdsGroup.getVirtualCpuUsage();
            }
        }
        return new QuotaUsagePerUser(quota.getId(), quota.getQuotaName(), storageLimit, storageUsage, cpuLimit, cpuUsage, memLimit, memUsage);
    }
    return null;
}
#end_block

#method_before
private ServiceInfo parseServiceInfo(Map<String, Object> volumeServiceInfo) {
    ServiceInfo serviceInfo = new ServiceInfo();
    if (volumeServiceInfo.containsKey(HOSTNAME)) {
        serviceInfo.setHostName((String) volumeServiceInfo.get(HOSTNAME));
    }
    if (volumeServiceInfo.containsKey(STATUS)) {
        String brickStatus = (String) volumeServiceInfo.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            serviceInfo.setStatus(GlusterStatus.UP);
            // parse the port and pid only if the brick is online.
            if (volumeServiceInfo.containsKey(PORT)) {
                serviceInfo.setPort(Integer.valueOf((String) volumeServiceInfo.get(PORT)));
            }
            if (volumeServiceInfo.containsKey(PID)) {
                serviceInfo.setPid(Integer.valueOf((String) volumeServiceInfo.get(PID)));
            }
        } else {
            serviceInfo.setStatus(GlusterStatus.DOWN);
        }
    }
    return serviceInfo;
}
#method_after
private ServiceInfo parseServiceInfo(Map<String, Object> volumeServiceInfo) {
    ServiceInfo serviceInfo = new ServiceInfo();
    if (volumeServiceInfo.containsKey(HOSTNAME)) {
        serviceInfo.setHostName((String) volumeServiceInfo.get(HOSTNAME));
    }
    if (volumeServiceInfo.containsKey(STATUS)) {
        String brickStatus = (String) volumeServiceInfo.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            serviceInfo.setStatus(GlusterStatus.UP);
            // parse the port and pid only if the brick is online.
            if (volumeServiceInfo.containsKey(PORT)) {
                serviceInfo.setPort(Integer.parseInt((String) volumeServiceInfo.get(PORT)));
            }
            if (volumeServiceInfo.containsKey(PID)) {
                serviceInfo.setPid(Integer.parseInt((String) volumeServiceInfo.get(PID)));
            }
        } else {
            serviceInfo.setStatus(GlusterStatus.DOWN);
        }
    }
    return serviceInfo;
}
#end_block

#method_before
private BrickProperties getBrickProperties(GlusterVolumeEntity volume, Map<String, Object> brick) {
    BrickProperties brickProperties = new BrickProperties();
    GlusterBrickEntity brickEntity = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brick.get(BRICK));
    if (brickEntity != null) {
        brickProperties.setBrickId(brickEntity.getId());
    }
    if (brick.containsKey(PORT)) {
        brickProperties.setPort(Integer.valueOf((String) brick.get(PORT)));
    }
    if (brick.containsKey(PID)) {
        brickProperties.setPid(Integer.valueOf((String) brick.get(PID)));
    }
    if (brick.containsKey(STATUS)) {
        String brickStatus = (String) brick.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            brickProperties.setStatus(GlusterStatus.UP);
        } else {
            brickProperties.setStatus(GlusterStatus.DOWN);
        }
    }
    // Fetch the volume status detail
    if (brick.containsKey(DETAIL_SIZE_TOTAL)) {
        brickProperties.setTotalSize(Double.valueOf((String) brick.get(DETAIL_SIZE_TOTAL)));
    }
    if (brick.containsKey(DETAIL_SIZE_FREE)) {
        brickProperties.setFreeSize(Double.valueOf((String) brick.get(DETAIL_SIZE_FREE)));
    }
    if (brick.containsKey(DETAIL_DEVICE)) {
        brickProperties.setDevice((String) brick.get(DETAIL_DEVICE));
    }
    if (brick.containsKey(DETAIL_BLOCK_SIZE)) {
        brickProperties.setBlockSize(Integer.valueOf((String) brick.get(DETAIL_BLOCK_SIZE)));
    }
    if (brick.containsKey(DETAIL_MNT_OPTIONS)) {
        brickProperties.setMntOptions((String) brick.get(DETAIL_MNT_OPTIONS));
    }
    if (brick.containsKey(DETAIL_FS_NAME)) {
        brickProperties.setFsName((String) brick.get(DETAIL_FS_NAME));
    }
    return brickProperties;
}
#method_after
private BrickProperties getBrickProperties(GlusterVolumeEntity volume, Map<String, Object> brick) {
    BrickProperties brickProperties = new BrickProperties();
    GlusterBrickEntity brickEntity = GlusterCoreUtil.getBrickByQualifiedName(volume.getBricks(), (String) brick.get(BRICK));
    if (brickEntity != null) {
        brickProperties.setBrickId(brickEntity.getId());
    }
    if (brick.containsKey(STATUS)) {
        String brickStatus = (String) brick.get(STATUS);
        if (brickStatus.toUpperCase().equals(ONLINE)) {
            brickProperties.setStatus(GlusterStatus.UP);
            if (brick.containsKey(PORT)) {
                brickProperties.setPort(Integer.parseInt((String) brick.get(PORT)));
            }
            if (brick.containsKey(PID)) {
                brickProperties.setPid(Integer.parseInt((String) brick.get(PID)));
            }
        } else {
            brickProperties.setStatus(GlusterStatus.DOWN);
        }
    }
    // Fetch the volume status detail
    if (brick.containsKey(DETAIL_SIZE_TOTAL)) {
        brickProperties.setTotalSize(Double.valueOf((String) brick.get(DETAIL_SIZE_TOTAL)));
    }
    if (brick.containsKey(DETAIL_SIZE_FREE)) {
        brickProperties.setFreeSize(Double.valueOf((String) brick.get(DETAIL_SIZE_FREE)));
    }
    if (brick.containsKey(DETAIL_DEVICE)) {
        brickProperties.setDevice((String) brick.get(DETAIL_DEVICE));
    }
    if (brick.containsKey(DETAIL_BLOCK_SIZE)) {
        brickProperties.setBlockSize(Integer.valueOf((String) brick.get(DETAIL_BLOCK_SIZE)));
    }
    if (brick.containsKey(DETAIL_MNT_OPTIONS)) {
        brickProperties.setMntOptions((String) brick.get(DETAIL_MNT_OPTIONS));
    }
    if (brick.containsKey(DETAIL_FS_NAME)) {
        brickProperties.setFsName((String) brick.get(DETAIL_FS_NAME));
    }
    return brickProperties;
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    super.updateConsoleModel(item);
    if (item.getEntity() != null) {
        // Adjust item's default console for userportal 'Basic View'
        item.getDefaultConsole().setForceVmStatusUp(true);
    }
}
#method_after
@Override
protected void updateConsoleModel(UserPortalItemModel item) {
    super.updateConsoleModel(item);
    if (item.getEntity() != null) {
        // Adjust item's default console for userportal 'Basic View'
        item.getDefaultConsole().setForceVmStatusUp(true);
    }
}
#end_block

#method_before
private void Spice_MenuItemSelected(Object sender, SpiceMenuItemEventArgs e) {
    if (getEntity() != null) {
        // SpiceMenuCommandItem item = menu.Descendants()
        // .OfType<SpiceMenuCommandItem>()
        // .FirstOrDefault(a => a.Id == e.MenuItemId);
        SpiceMenuCommandItem item = null;
        for (SpiceMenuItem a : menu.Descendants()) {
            if (a.getClass() == SpiceMenuCommandItem.class && a.getId() == e.getMenuItemId()) {
                item = (SpiceMenuCommandItem) a;
                break;
            }
        }
        if (item != null) {
            if (StringHelper.stringsEqual(item.getCommandName(), CommandPlay)) {
                // use sysprep iff the vm is not initialized and vm has Win OS
                boolean reinitialize = !getEntity().isInitialized() && DataProvider.IsWindowsOsType(getEntity().getVmOs());
                RunVmParams tempVar = new RunVmParams(getEntity().getId());
                tempVar.setRunAsStateless(getEntity().isStateless());
                tempVar.setReinitialize(reinitialize);
                Frontend.RunMultipleAction(VdcActionType.RunVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { tempVar })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandSuspend)) {
                Frontend.RunMultipleAction(VdcActionType.HibernateVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new HibernateVmParameters(getEntity().getId()) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandStop)) {
                Frontend.RunMultipleAction(VdcActionType.ShutdownVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ShutdownVmParameters(getEntity().getId(), true) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandChangeCD)) {
                Frontend.RunMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(getEntity().getId(), // $NON-NLS-1$
                StringHelper.stringsEqual(item.getText(), EjectLabel) ? "" : item.getText()) })));
            }
        }
    }
}
#method_after
private void Spice_MenuItemSelected(Object sender, SpiceMenuItemEventArgs e) {
    if (getEntity() != null) {
        // SpiceMenuCommandItem item = menu.Descendants()
        // .OfType<SpiceMenuCommandItem>()
        // .FirstOrDefault(a => a.Id == e.MenuItemId);
        SpiceMenuCommandItem item = null;
        for (SpiceMenuItem a : menu.Descendants()) {
            if (a.getClass() == SpiceMenuCommandItem.class && a.getId() == e.getMenuItemId()) {
                item = (SpiceMenuCommandItem) a;
                break;
            }
        }
        if (item != null) {
            if (StringHelper.stringsEqual(item.getCommandName(), CommandPlay)) {
                // use sysprep iff the vm is not initialized and vm has Win OS
                boolean reinitialize = !getEntity().isInitialized() && AsyncDataProvider.IsWindowsOsType(getEntity().getVmOs());
                RunVmParams tempVar = new RunVmParams(getEntity().getId());
                tempVar.setRunAsStateless(getEntity().isStateless());
                tempVar.setReinitialize(reinitialize);
                Frontend.RunMultipleAction(VdcActionType.RunVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { tempVar })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandSuspend)) {
                Frontend.RunMultipleAction(VdcActionType.HibernateVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new HibernateVmParameters(getEntity().getId()) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandStop)) {
                Frontend.RunMultipleAction(VdcActionType.ShutdownVm, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ShutdownVmParameters(getEntity().getId(), true) })));
            } else if (StringHelper.stringsEqual(item.getCommandName(), CommandChangeCD)) {
                Frontend.RunMultipleAction(VdcActionType.ChangeDisk, new ArrayList<VdcActionParametersBase>(Arrays.asList(new VdcActionParametersBase[] { new ChangeDiskCommandParameters(getEntity().getId(), // $NON-NLS-1$
                StringHelper.stringsEqual(item.getText(), EjectLabel) ? "" : item.getText()) })));
            }
        }
    }
}
#end_block

#method_before
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = DataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#method_after
@Override
public void Executed(FrontendMultipleQueryAsyncResult result) {
    List<VdcQueryReturnValue> returnValues = result.getReturnValues();
    boolean success = true;
    for (VdcQueryReturnValue returnValue : returnValues) {
        if (!returnValue.getSucceeded()) {
            success = false;
            break;
        }
    }
    if (!success) {
        boolean enableSpiceRootCertificateValidation = (Boolean) result.getReturnValues().get(3).getReturnValue();
        VdcQueryReturnValue caCertificateReturnValue = result.getReturnValues().get(5);
        // If only the caCertificate query failed - ignore failure (goto OnSuccess)
        if (!caCertificateReturnValue.getSucceeded() && !enableSpiceRootCertificateValidation) {
            // If succeeded goto 'OnSuccess'; Otherwise, 'OnFailure'.
            for (VdcQueryReturnValue returnValue : returnValues) {
                if (!returnValue.getSucceeded() && returnValue != caCertificateReturnValue) {
                    return;
                }
            }
        }
    }
    String cipherSuite = null;
    String spiceSecureChannels = null;
    boolean isSSLEnabled = (Boolean) returnValues.get(0).getReturnValue();
    if (isSSLEnabled) {
        cipherSuite = (String) returnValues.get(1).getReturnValue();
        spiceSecureChannels = (String) returnValues.get(2).getReturnValue();
    }
    // $NON-NLS-1$
    String certificateSubject = "";
    // $NON-NLS-1$
    String caCertificate = "";
    if ((Boolean) returnValues.get(3).getReturnValue()) {
        certificateSubject = (String) returnValues.get(4).getReturnValue();
        caCertificate = (String) returnValues.get(5).getReturnValue();
    }
    getspice().setHost(getEntity().getDisplayIp());
    getspice().setSmartcardEnabled(getEntity().isSmartcardEnabled());
    getspice().setPort((getEntity().getDisplay() == null ? 0 : getEntity().getDisplay()));
    getspice().setPassword(ticket);
    getspice().setNumberOfMonitors(getEntity().getNumOfMonitors());
    // $NON-NLS-1$
    getspice().setGuestHostName(getEntity().getVmHost().split("[ ]", -1)[0]);
    if (getEntity().getDisplaySecurePort() != null) {
        getspice().setSecurePort(getEntity().getDisplaySecurePort());
    }
    if (!StringHelper.isNullOrEmpty(spiceSecureChannels)) {
        getspice().setSslChanels(spiceSecureChannels);
    }
    if (!StringHelper.isNullOrEmpty(cipherSuite)) {
        getspice().setCipherSuite(cipherSuite);
    }
    getspice().setHostSubject(certificateSubject);
    getspice().setTrustStore(caCertificate);
    String toggleFullScreenKeys = (String) returnValues.get(6).getReturnValue();
    String releaseCursorKeys = (String) returnValues.get(7).getReturnValue();
    // $NON-NLS-1$
    String ctrlAltDel = "ctrl+alt+del";
    // $NON-NLS-1$
    String ctrlAltEnd = "ctrl+alt+end";
    String toggleFullScreenKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((toggleFullScreenKeys != null) ? toggleFullScreenKeys : // $NON-NLS-1$
    "shift+f11");
    String releaseCursorKeysTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource((releaseCursorKeys != null) ? releaseCursorKeys : // $NON-NLS-1$
    "shift+f12");
    String ctrlAltDelTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltDel);
    String ctrlAltEndTranslated = AsyncDataProvider.GetComplexValueFromSpiceRedKeysResource(ctrlAltEnd);
    getspice().setTitle(getEntity().getVmName() + // $NON-NLS-1$
    ":%d" + (StringHelper.isNullOrEmpty(releaseCursorKeysTranslated) ? "" : (// $NON-NLS-1$ //$NON-NLS-2$
    " - " + ConstantsManager.getInstance().getMessages().pressKeyToReleaseCursor(releaseCursorKeysTranslated))));
    // If 'AdminConsole' is true, send true; otherwise, false should be sent only for VMs with SPICE driver
    // installed.
    getspice().setAdminConsole(getConfigurator().getSpiceAdminConsole() ? true : getEntity().getSpiceDriverVersion() != null ? false : true);
    // Update 'UsbListenPort' value
    getspice().setUsbListenPort(getConfigurator().getIsUsbEnabled() && getEntity().getUsbPolicy() == UsbPolicy.ENABLED_LEGACY ? getConfigurator().getSpiceDefaultUsbPort() : getConfigurator().getSpiceDisableUsbListenPort());
    // At lease one of the hot-keys is not empty -> send it to SPICE:
    if (!StringHelper.isNullOrEmpty(releaseCursorKeys) || !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) {
        String comma = // $NON-NLS-1$
        (!StringHelper.isNullOrEmpty(releaseCursorKeys) && !StringHelper.isNullOrEmpty(toggleFullScreenKeys)) ? // $NON-NLS-1$
        "," : // $NON-NLS-1$
        "";
        String releaseCursorKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(releaseCursorKeys) ? "" : "release-cursor=" + releaseCursorKeys;
        String toggleFullScreenKeysParameter = // $NON-NLS-1$ //$NON-NLS-2$
        StringHelper.isNullOrEmpty(toggleFullScreenKeys) ? "" : "toggle-fullscreen=" + toggleFullScreenKeys;
        getspice().setHotKey(releaseCursorKeysParameter + comma + toggleFullScreenKeysParameter);
    }
    getspice().setLocalizedStrings(new String[] { ConstantsManager.getInstance().getConstants().usb(), ConstantsManager.getInstance().getConstants().usbDevicesNoUsbdevicesClientSpiceUsbRedirectorNotInstalled() });
    // Create menu.
    int id = 1;
    menu = new SpiceMenu();
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_DEL, ConstantsManager.getInstance().getConstants().send() + " " + // $NON-NLS-1$
    ctrlAltDelTranslated + "\t" + ctrlAltEndTranslated, // $NON-NLS-1$ //$NON-NLS-2$
    ""));
    menu.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_TOGGLE_FULL_SCREEN, ConstantsManager.getInstance().getConstants().toggleFullScreen() + // $NON-NLS-1$
    "\t" + toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    SpiceMenuContainerItem specialKes = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().specialKeys());
    menu.getItems().add(specialKes);
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F11, toggleFullScreenKeysTranslated, // $NON-NLS-1$
    ""));
    specialKes.getItems().add(// $NON-NLS-1$
    new SpiceMenuCommandItem(ID_SYS_MENU_SEND_SHIFT_F12, releaseCursorKeysTranslated, ""));
    specialKes.getItems().add(new SpiceMenuCommandItem(ID_SYS_MENU_SEND_CTRL_ALT_END, ctrlAltEndTranslated, // $NON-NLS-1$
    ""));
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    SpiceMenuContainerItem changeCDItem = new SpiceMenuContainerItem(id, ConstantsManager.getInstance().getConstants().changeCd());
    id++;
    ArrayList<String> isos = new ArrayList<String>();
    if (returnValues.size() > 8) {
        ArrayList<RepoFileMetaData> repoList = (ArrayList<RepoFileMetaData>) returnValues.get(8).getReturnValue();
        for (RepoFileMetaData RepoFileMetaData : repoList) {
            isos.add(RepoFileMetaData.getRepoFileName());
        }
    }
    isos = isos.size() > 0 ? isos : new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    Collections.sort(isos);
    for (String fileName : isos) {
        changeCDItem.getItems().add(new SpiceMenuCommandItem(id, fileName, CommandChangeCD));
        id++;
    }
    changeCDItem.getItems().add(new SpiceMenuCommandItem(id, EjectLabel, CommandChangeCD));
    id++;
    menu.getItems().add(changeCDItem);
    menu.getItems().add(new SpiceMenuSeparatorItem(id));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().playSpiceConsole(), CommandPlay));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().suspendSpiceConsole(), CommandSuspend));
    id++;
    menu.getItems().add(new SpiceMenuCommandItem(id, ConstantsManager.getInstance().getConstants().stopSpiceConsole(), CommandStop));
    getspice().setMenu(menu.toString());
    getspice().setGuestID(getEntity().getId().toString());
    // Subscribe to events.
    getspice().getDisconnectedEvent().addListener(this);
    getspice().getMenuItemSelectedEvent().addListener(this);
    if (StringHelper.isNullOrEmpty(getEntity().getDisplayIp()) || // $NON-NLS-1$
    StringHelper.stringsEqual(getEntity().getDisplayIp(), "0")) {
        determineIpAndConnect(getEntity().getId());
    } else {
        // Try to connect.
        SpiceConnect();
    }
}
#end_block

#method_before
@Override
public Boolean isRaiseErrorModalPanel(VdcQueryType queryType) {
    return false;
}
#method_after
@Override
public Boolean isRaiseErrorModalPanel(VdcActionType actionType, VdcFault fault) {
    return (actionType != VdcActionType.LoginUser) && !(actionType == VdcActionType.VmLogon && fault.getError() == VdcBllErrors.nonresp);
}
#end_block

#method_before
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (shouldRaiseErrorDialog(action, fault))
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(EnumTranslator.createAndTranslate(action), fault.getMessage()));
}
#method_after
@Override
public void runActionExecutionFailed(VdcActionType action, VdcFault fault) {
    if (isRaiseErrorModalPanel(action, fault))
        errorPopupManager.show(messages.uiCommonRunActionExecutionFailed(EnumTranslator.createAndTranslate(action), fault.getMessage()));
}
#end_block

#method_before
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues, List<VdcFault> faults) {
    String actionStr = EnumTranslator.createAndTranslate(action);
    List<String> errors = new ArrayList<String>();
    for (VdcReturnValueBase v : returnValues) {
        if (shouldRaiseErrorDialog(action, v.getFault()))
            errors.add(messages.uiCommonRunActionFailed(v.getCanDoActionMessages().iterator().next()));
    }
    for (VdcFault fault : faults) {
        if (shouldRaiseErrorDialog(action, fault))
            errors.add(messages.uiCommonRunActionExecutionFailed(actionStr, fault.getMessage()));
    }
    errorPopupManager.show(ErrorMessageFormatter.formatErrorMessages(errors));
}
#method_after
@Override
public void runMultipleActionFailed(VdcActionType action, List<VdcReturnValueBase> returnValues, List<VdcFault> faults) {
    String actionStr = EnumTranslator.createAndTranslate(action);
    List<String> errors = new ArrayList<String>();
    for (VdcReturnValueBase v : returnValues) {
        if (isRaiseErrorModalPanel(action, v.getFault()))
            errors.add(messages.uiCommonRunActionFailed(v.getCanDoActionMessages().iterator().next()));
    }
    for (VdcFault fault : faults) {
        if (isRaiseErrorModalPanel(action, fault))
            errors.add(messages.uiCommonRunActionExecutionFailed(actionStr, fault.getMessage()));
    }
    errorPopupManager.show(ErrorMessageFormatter.formatErrorMessages(errors));
}
#end_block

#method_before
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (DataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#method_after
protected void updateConsoleModel(UserPortalItemModel item) {
    if (item.getEntity() != null) {
        Object tempVar = item.getEntity();
        VM vm = (VM) ((tempVar instanceof VM) ? tempVar : null);
        if (vm == null) {
            return;
        }
        // Caching console model if needed
        if (!cachedConsoleModels.containsKey(vm.getId())) {
            SpiceConsoleModel spiceConsoleModel = new SpiceConsoleModel();
            spiceConsoleModel.getErrorEvent().addListener(this);
            spiceConsoleModel.setModel(this);
            VncConsoleModel vncConsoleModel = new VncConsoleModel();
            vncConsoleModel.setModel(this);
            RdpConsoleModel rdpConsoleModel = new RdpConsoleModel();
            cachedConsoleModels.put(vm.getId(), new ArrayList<ConsoleModel>(Arrays.asList(new ConsoleModel[] { spiceConsoleModel, vncConsoleModel, rdpConsoleModel })));
            updateDefaultSelectedConsoleProtocol(vm);
        }
        // Getting cached console model
        ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
        for (ConsoleModel cachedModel : cachedModels) {
            cachedModel.setEntity(null);
            cachedModel.setEntity(vm);
        }
        // Set default console by vm's display type
        item.setDefaultConsole(determineConsoleModelFromVm(vm, cachedModels));
        // Update additional console
        if (AsyncDataProvider.IsWindowsOsType(vm.getVmOs())) {
            item.setAdditionalConsole(cachedModels.get(RDP_INDEX));
            item.setHasAdditionalConsole(true);
        } else {
            item.setAdditionalConsole(null);
            item.setHasAdditionalConsole(false);
        }
    }
}
#end_block

#method_before
protected void acquireLock(Guid clusterId) {
    getLockManager().acquireLockWait(getEngineLock(clusterId));
}
#method_after
protected void acquireLock(Guid clusterId) {
    lockManager.acquireLockWait(getEngineLock(clusterId));
}
#end_block

#method_before
protected void releaseLock(Guid clusterId) {
    getLockManager().releaseLock(getEngineLock(clusterId));
}
#method_after
protected void releaseLock(Guid clusterId) {
    lockManager.releaseLock(getEngineLock(clusterId));
}
#end_block

#method_before
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    for (PermissionSubject permSubject : permSubjects) {
        final Guid objectId = permSubject.getObjectId();
        final VdcObjectType objectType = permSubject.getObjectType();
        final ActionGroup objectActionGroup = permSubject.getActionGroup();
        // if objectId is null we can't check permission
        if (objectId == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("The object to check is null for action {0}.", getActionType());
            }
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Check that an action group is defined for this action;
        if (objectActionGroup == null) {
            if (log.isDebugEnabled()) {
                log.debugFormat("No action group is defined for action {0}.", getActionType());
            }
            return false;
        }
        // Check the authorization:
        if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
            addCanDoActionMessage(permSubject.getMessage());
            return false;
        }
    }
    // If we are here then we should grant the permission:
    return true;
}
#method_after
protected boolean isUserAuthorizedToRunAction() {
    // Skip check if this is an internal action:
    if (isInternalExecution()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check skipped for internal action {0}.", getActionType());
        }
        return true;
    }
    // Skip check if multilevel administration is disabled:
    if (!MultiLevelAdministrationHandler.isMultilevelAdministrationOn()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Permission check for action {0} skipped because multilevel administration is disabled.", getActionType());
        }
        return true;
    }
    // Deny the permissions if there is no logged in user:
    if (getCurrentUser() == null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_NOT_LOGGED_IN);
        return false;
    }
    // Get identifiers and types of the objects whose permissions have to be
    // checked:
    final List<PermissionSubject> permSubjects = getPermissionCheckSubjects();
    if (permSubjects == null || permSubjects.isEmpty()) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The set of objects to check is null or empty for action {0}.", getActionType());
        }
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    if (isQuotaDependant()) {
        addQuotaPermissionSubject(permSubjects);
    }
    // If we are here then we should grant the permission:
    return checkPermissions(permSubjects);
}
#end_block

#method_before
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new async_tasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#method_after
protected SPMAsyncTask concreteCreateTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parametersForTask = getParametersForTask(parentCommand, getParameters());
    AsyncTaskParameters p = new AsyncTaskParameters(asyncTaskCreationInfo, new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getTaskID(), parametersForTask, asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType()));
    p.setEntityId(getParameters().getEntityId());
    return AsyncTaskManager.getInstance().CreateTask(internalGetTaskType(), p);
}
#end_block

#method_before
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(DataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(DataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#method_after
private void OSType_SelectedItemChanged(Object sender, EventArgs args) {
    VmOsType osType = (VmOsType) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.IsWindowsOsType(osType));
    setIsLinux_Unassign_UnknownOS(AsyncDataProvider.IsLinuxOsType(osType) || osType == VmOsType.Unassigned || osType == VmOsType.Other);
    getInitrd_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getInitrd_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_path().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsChangable(getIsLinux_Unassign_UnknownOS());
    getKernel_parameters().setIsAvailable(getIsLinux_Unassign_UnknownOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateTimeZone();
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(DataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#method_after
private LengthValidation createNameLengthValidation(VmOsType osType) {
    // for template dialog, name max length is 40 chars
    if (this.getBehavior() instanceof TemplateVmModelBehavior) {
        return new LengthValidation(40);
    }
    // for VM it depends on the OS type
    return new LengthValidation(AsyncDataProvider.IsWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT);
}
#end_block

#method_before
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (DataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || DataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#method_after
public boolean Validate() {
    getDataCenter().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getCluster().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().ValidateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().ValidateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    storage_pool dataCenter = (storage_pool) getDataCenter().getSelectedItem();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().ValidateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    getDescription().ValidateEntity(new IValidation[] { new AsciiOrNoneValidation() });
    if (getOSType().getIsValid()) {
        VmOsType osType = (VmOsType) getOSType().getSelectedItem();
        // $NON-NLS-1$
        String nameExpr = "^[-\\w\\.]{1,";
        String nameMsg;
        if (AsyncDataProvider.IsWindowsOsType(osType)) {
            nameExpr += WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(WINDOWS_VM_NAME_MAX_LIMIT);
        } else {
            nameExpr += NON_WINDOWS_VM_NAME_MAX_LIMIT;
            nameMsg = ConstantsManager.getInstance().getMessages().nameMustConataionOnlyAlphanumericChars(NON_WINDOWS_VM_NAME_MAX_LIMIT);
        }
        // $NON-NLS-1$
        nameExpr += "}$";
        getName().ValidateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(this.getBehavior() instanceof TemplateVmModelBehavior ? 40 : 64), new RegexValidation(nameExpr, nameMsg) });
        getDescription().ValidateEntity(new IValidation[] { new LengthValidation(255) });
        boolean is64OsType = (osType == VmOsType.Other || osType == VmOsType.OtherLinux || AsyncDataProvider.Is64bitOsType(osType));
        int maxMemSize = is64OsType ? get_MaxMemSize64() : get_MaxMemSize32();
        ValidateMemorySize(getMemSize(), maxMemSize, _minMemSize);
        if (!(this.getBehavior() instanceof TemplateVmModelBehavior)) {
            // Minimum 'Physical Memory Guaranteed' is 1MB
            ValidateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
        }
    }
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    VmTemplate template = (VmTemplate) getTemplate().getSelectedItem();
    storage_domains storageDomain = (storage_domains) getStorageDomain().getSelectedItem();
    getTemplate().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().ValidateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().ValidateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getKernel_path().setIsValid(true);
    getKernel_parameters().setIsValid(true);
    getInitrd_path().setIsValid(true);
    if (getKernel_path().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_path().setEntity("");
    }
    if (getKernel_parameters().getEntity() == null) {
        // $NON-NLS-1$
        getKernel_parameters().setEntity("");
    }
    if (getInitrd_path().getEntity() == null) {
        // $NON-NLS-1$
        getInitrd_path().setEntity("");
    }
    if (isLinux_Unassign_UnknownOS && ((((String) getKernel_parameters().getEntity()).length() > 0 || ((String) getInitrd_path().getEntity()).length() > 0) && ((String) getKernel_path().getEntity()).length() == 0)) {
        boolean kernelParamInvalid = false;
        boolean inetdPathInvalid = false;
        if (((String) getKernel_parameters().getEntity()).length() > 0) {
            getKernel_parameters().setIsValid(false);
            kernelParamInvalid = true;
        }
        if (((String) getInitrd_path().getEntity()).length() > 0) {
            getInitrd_path().setIsValid(false);
            inetdPathInvalid = true;
        }
        String msg = ConstantsManager.getInstance().getMessages().invalidPath(kernelParamInvalid ? ConstantsManager.getInstance().getConstants().kernelInvalid() : // $NON-NLS-1$
        "", kernelParamInvalid && inetdPathInvalid ? ConstantsManager.getInstance().getConstants().or() : // $NON-NLS-1$
        "", inetdPathInvalid ? ConstantsManager.getInstance().getConstants().inetdInvalid() : // $NON-NLS-1$
        "");
        getKernel_path().setIsValid(false);
        getInitrd_path().getInvalidityReasons().add(msg);
        getKernel_parameters().getInvalidityReasons().add(msg);
        getKernel_path().getInvalidityReasons().add(msg);
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenter().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getCluster().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && behavior.Validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    messageLabel.getElement().setInnerHTML(message != null ? message.replace("\n", "<br/>") : "");
}
#method_after
@Override
public void setMessage(String message) {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    messageHTML.setHTML(SafeHtmlUtils.fromString(message != null ? message : "").asString().replace("\n", "<br>"));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (networkExists()) {
        getNetworkClusterDAO().update(getParameters().getNetworkCluster());
    } else {
        getNetworkClusterDAO().save(new network_cluster(getVdsGroupId(), getNetwork().getId(), NetworkStatus.Operational, false, getParameters().getNetworkCluster().isRequired()));
    }
    if (getNetwork().getCluster().getis_display()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    SetNetworkStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (networkExists()) {
        getNetworkClusterDAO().update(getNetworkCluster());
    } else {
        getNetworkClusterDAO().save(new network_cluster(getVdsGroupId(), getNetwork().getId(), NetworkStatus.Operational, false, getNetworkCluster().isRequired()));
    }
    if (getNetwork().getCluster().getis_display()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    SetNetworkStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#end_block

#method_before
private boolean logicalNetworkExists() {
    if (getNetworkDAO().get(getParameters().getNetworkCluster().getnetwork_id()) != null) {
        return true;
    }
    addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS);
    return false;
}
#method_after
private boolean logicalNetworkExists() {
    if (getNetworkDAO().get(getNetworkCluster().getnetwork_id()) != null) {
        return true;
    }
    addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS);
    return false;
}
#end_block

#method_before
private boolean networkExists() {
    List<network_cluster> networks = getNetworkClusterDAO().getAllForCluster(getVdsGroupId());
    for (network_cluster network_cluster : networks) {
        if (network_cluster.getnetwork_id().equals(getParameters().getNetworkCluster().getnetwork_id())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkExists() {
    List<network_cluster> networks = getNetworkClusterDAO().getAllForCluster(getVdsGroupId());
    for (network_cluster network_cluster : networks) {
        if (network_cluster.getnetwork_id().equals(getNetworkCluster().getnetwork_id())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (networkExists()) {
        return Collections.singletonList(new PermissionSubject(getParameters().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CONFIGURE_CLUSTER_NETWORK));
    } else {
        Guid networkId = getParameters().getNetwork() == null ? null : getParameters().getNetwork().getId();
        return Collections.singletonList(new PermissionSubject(networkId, VdcObjectType.Network, getActionType().getActionGroup()));
    }
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissions = new ArrayList<PermissionSubject>();
    Guid networkId = getNetworkCluster() == null ? null : getNetworkCluster().getnetwork_id();
    // require permissions on network
    permissions.add(new PermissionSubject(networkId, VdcObjectType.Network, getActionType().getActionGroup()));
    // require permissions on cluster the network is attached to
    if (networkExists()) {
        permissions.add(new PermissionSubject(getParameters().getVdsGroupId(), VdcObjectType.VdsGroups, ActionGroup.CONFIGURE_CLUSTER_NETWORK));
    }
    return permissions;
}
#end_block

#method_before
private HttpRequest setUpRequestExpectations(String credentials, boolean valid, boolean preferHeader) {
    Scheme authorizer = control.createMock(Scheme.class);
    challenger.setScheme(authorizer);
    Current current = control.createMock(Current.class);
    challenger.setCurrent(current);
    HttpRequest request = control.createMock(HttpRequest.class);
    HttpHeaders headers = control.createMock(HttpHeaders.class);
    expect(request.getHttpHeaders()).andReturn(headers);
    List<String> authHeaders = new ArrayList<String>();
    if (preferHeader) {
        List<String> preferHeaders = new ArrayList<String>();
        preferHeaders.add(SessionUtils.PERSIST_FIELD_VALUE);
        expect(headers.getRequestHeader(SessionUtils.PREFER_HEADER_FIELD)).andReturn(preferHeaders);
    }
    if (credentials != null) {
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders);
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders);
        Principal principal = new Principal(USER, SECRET, DOMAIN);
        expect(authorizer.decode(headers)).andReturn(principal);
        authHeaders.add(credentials);
        if (valid) {
            current.set(principal);
            EasyMock.expectLastCall();
            current.set(challenger);
            EasyMock.expectLastCall();
        }
    }
    control.replay();
    return request;
}
#method_after
private HttpRequest setUpRequestExpectations(String credentials, boolean valid, boolean preferHeader) {
    Scheme authorizer = control.createMock(Scheme.class);
    challenger.setScheme(authorizer);
    Current current = control.createMock(Current.class);
    challenger.setCurrent(current);
    HttpRequest request = control.createMock(HttpRequest.class);
    HttpHeaders headers = control.createMock(HttpHeaders.class);
    expect(request.getHttpHeaders()).andReturn(headers);
    List<String> authHeaders = new ArrayList<String>();
    if (preferHeader) {
        List<String> preferHeaders = new ArrayList<String>();
        preferHeaders.add(SessionUtils.PERSIST_FIELD_VALUE);
        expect(headers.getRequestHeader(SessionUtils.PREFER_HEADER_FIELD)).andReturn(preferHeaders);
    }
    if (credentials != null) {
        expect(headers.getRequestHeader(HttpHeaders.AUTHORIZATION)).andReturn(authHeaders).anyTimes();
        Principal principal = new Principal(USER, SECRET, DOMAIN);
        expect(authorizer.decode(headers)).andReturn(principal);
        authHeaders.add(credentials);
        if (valid) {
            current.set(principal);
            EasyMock.expectLastCall();
            current.set(challenger);
            EasyMock.expectLastCall();
        }
    }
    control.replay();
    return request;
}
#end_block

#method_before
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepXPPath));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey));
            break;
        case Windows2003:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003));
            break;
        case Windows2003x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003x64));
            break;
        case Windows2008:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008));
            break;
        case Windows2008x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008x64));
            break;
        case Windows2008R2x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8R2Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008R2));
            break;
        case Windows7:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7));
            break;
        case Windows7x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7x64));
            break;
        case Windows8:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8));
            break;
        case Windows8x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8x64));
            break;
        case Windows2012:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012));
            break;
        case Windows2012x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012x64));
            break;
        default:
            break;
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#method_after
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepXPPath));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey));
            break;
        case Windows2003:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003));
            break;
        case Windows2003x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K3Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2003x64));
            break;
        case Windows2008:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008));
            break;
        case Windows2008x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008x64));
            break;
        case Windows2008R2x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrep2K8R2Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKey2008R2));
            break;
        case Windows7:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7));
            break;
        case Windows7x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows7x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindow7x64));
            break;
        case Windows8:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8));
            break;
        case Windows8x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows8x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows8x64));
            break;
        case Windows2012x64:
            sysPrepContent = LoadFile(Config.<String>GetValue(ConfigValues.SysPrepWindows2012x64Path));
            sysPrepContent = replace(sysPrepContent, "$ProductKey$", Config.<String>GetValue(ConfigValues.ProductKeyWindows2012x64));
            break;
        default:
            break;
    }
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#end_block

#method_before
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.gettime_zone())) {
        vm.settime_zone(TimeZoneInfo.Local.getId());
    }
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
        case Windows2003:
        case Windows2003x64:
            // send correct time zone as sysprep expect to get it (a wierd
            // number)
            timeZone = getTimezoneIndexByKey(vm.gettime_zone());
            break;
        case Windows2008:
        default:
            timeZone = vm.gettime_zone();
            break;
    }
    return timeZone;
}
#method_after
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.getTimeZone())) {
        vm.setTimeZone(TimeZoneInfo.Local.getId());
    }
    switch(vm.getStaticData().getos()) {
        case WindowsXP:
        case Windows2003:
        case Windows2003x64:
            // send correct time zone as sysprep expect to get it (a wierd
            // number)
            timeZone = getTimezoneIndexByKey(vm.getTimeZone());
            break;
        case Windows2008:
        default:
            timeZone = vm.getTimeZone();
            break;
    }
    return timeZone;
}
#end_block

#method_before
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (String s : EnumCompat.GetNames(VDSType.class)) {
        if (StringHelper.stringsEqual(s, VDSType.PowerClient.toString())) {
            if (showPowerclient) {
                ret.add(s);
            }
        } else {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (VDSType vdsType : VDSType.values()) {
        if (VDSType.PowerClient == vdsType) {
            if (showPowerclient) {
                ret.add(vdsType.name());
            }
        } else {
            ret.add(vdsType.name());
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EnumCompat.GetValues(EventNotificationEntity.class)) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>();
    for (VmInterfaceType item : EnumCompat.GetValues(VmInterfaceType.class)) {
        list.add(item);
    }
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        list.remove(VmInterfaceType.e1000);
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#method_after
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>(Arrays.asList(VmInterfaceType.values()));
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#end_block

#method_before
public static Iterable GetUsbPolicyList() {
    return EnumCompat.GetValues(UsbPolicy.class);
}
#method_after
public static Iterable GetUsbPolicyList() {
    return Arrays.asList(UsbPolicy.values());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(NGuid.Empty);
    staticVm.setvmt_guid(entity.getId());
    staticVm.setdomain(entity.getdomain());
    staticVm.setvds_group_id(entity.getvds_group_id());
    staticVm.setmem_size_mb(entity.getmem_size_mb());
    staticVm.setos(entity.getos());
    staticVm.setnice_level(entity.getnice_level());
    staticVm.setfail_back(entity.getfail_back());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setis_stateless(entity.getis_stateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setauto_startup(entity.getauto_startup());
    staticVm.setdefault_boot_sequence(entity.getdefault_boot_sequence());
    staticVm.setvm_type(entity.getvm_type());
    entity.setdefault_display_type(entity.getdefault_display_type());
    staticVm.setiso_path(entity.getiso_path());
    staticVm.setnum_of_sockets(entity.getnum_of_sockets());
    staticVm.setcpu_per_socket(entity.getcpu_per_socket());
    staticVm.setkernel_url(entity.getkernel_url());
    staticVm.setkernel_params(entity.getkernel_params());
    staticVm.setinitrd_url(entity.getinitrd_url());
    staticVm.settime_zone(entity.gettime_zone());
    staticVm.setnum_of_monitors(entity.getnum_of_monitors());
    staticVm.setAllowConsoleReconnect(entity.getAllowConsoleReconnect());
    staticVm.setpriority(entity.getpriority());
    staticVm.setusb_policy(entity.getusb_policy());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setvm_name(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(new Guid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setdescription(vm.getDescription());
    }
    if (vm.isSetMemory()) {
        staticVm.setmem_size_mb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getmem_size_mb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setmem_size_mb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setvmt_guid(new Guid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setvds_group_id(new Guid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setcpu_per_socket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setnum_of_sockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            OsType osType = OsType.fromValue(vm.getOs().getType());
            if (osType != null) {
                staticVm.setos(map(osType, null));
            }
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setdefault_boot_sequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setkernel_url(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setinitrd_url(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setkernel_params(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setvm_type(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setis_stateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setauto_startup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setpriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setorigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setdefault_display_type(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setnum_of_monitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setdedicated_vm_for_vds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setdomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.settime_zone(TimeZoneMapping.getWindows(vm.getTimezone()));
    }
    if (vm.isSetCustomProperties() && vm.getCustomProperties().isSetCustomProperty()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetUsb() && vm.getUsb().isSetEnabled()) {
        staticVm.setusb_policy(vm.getUsb().isEnabled() ? UsbPolicy.ENABLED_LEGACY : UsbPolicy.DISABLED);
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(new Guid(vm.getQuota().getId()));
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getvm_name());
    model.setDescription(entity.getvm_description());
    model.setMemory((long) entity.getmem_size_mb() * BYTES_PER_MB);
    if (entity.getvmt_guid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getvmt_guid().toString());
    }
    if (entity.getstatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getstatus(), null)));
        if (entity.getstatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getvm_os() != null || entity.getboot_sequence() != null || entity.getkernel_url() != null || entity.getinitrd_url() != null || entity.getkernel_params() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getvm_os() != null) {
            OsType osType = VmMapper.map(entity.getos(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getboot_sequence() != null) {
            for (Boot boot : map(entity.getdefault_boot_sequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getkernel_url());
        os.setInitrd(entity.getinitrd_url());
        os.setCmdline(entity.getkernel_params());
        model.setOs(os);
    }
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getnum_of_sockets());
    topology.setCores(entity.getnum_of_cpus() / entity.getnum_of_sockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getrun_on_vds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getrun_on_vds().toString());
    }
    if (entity.getdefault_display_type() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getdefault_display_type(), null));
        }
        model.getDisplay().setAddress(entity.getdisplay_ip());
        Integer displayPort = entity.getdisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getdisplay_secure_port();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getnum_of_monitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getvm_type(), null));
    model.setStateless(entity.getis_stateless());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.getauto_startup());
    model.getHighAvailability().setPriority(entity.getpriority());
    if (entity.getorigin() != null) {
        model.setOrigin(map(entity.getorigin(), null));
    }
    if (entity.getvm_creation_date() != null) {
        model.setCreationTime(DateMapper.map(entity.getvm_creation_date(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getdedicated_vm_for_vds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getdedicated_vm_for_vds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getvm_domain() != null && !entity.getvm_domain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getvm_domain());
        model.setDomain(domain);
    }
    if (entity.getvm_ip() != null && !entity.getvm_ip().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getvm_ip().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.gettime_zone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getusb_policy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getusb_policy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getusb_policy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getVmName());
    model.setDescription(entity.getVmDescription());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getVmOs() != null || entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        if (entity.getVmOs() != null) {
            OsType osType = VmMapper.map(entity.getOs(), null);
            if (osType != null) {
                os.setType(osType.value());
            }
        }
        if (entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                os.getBoot().add(boot);
            }
        }
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getRunOnVds() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getRunOnVds().toString());
    }
    if (entity.getDefaultDisplayType() != null) {
        model.setDisplay(new Display());
        if (getIsVmRunning(entity) && entity.getDynamicData() != null) {
            model.getDisplay().setType(map(entity.getDynamicData().getdisplay_type(), null));
        } else {
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    if (entity.getDynamicData() != null && entity.getDynamicData().getLastStartTime() != null) {
        model.setStartTime(DateMapper.map(entity.getDynamicData().getLastStartTime(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    if (entity.getVmIp() != null && !entity.getVmIp().isEmpty()) {
        model.setGuestInfo(new GuestInfo());
        model.getGuestInfo().setIps(new IPs());
        for (String item : entity.getVmIp().split(" ")) {
            if (!item.equals("")) {
                IP ip = new IP();
                ip.setAddress(item.trim());
                model.getGuestInfo().getIps().getIPs().add(ip);
            }
        }
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed(new Long(entity.getMinAllocatedMem()) * BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(TimeZoneMapping.getJava(entity.getTimeZone()));
    if (!StringHelper.isNullOrEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012:
            return OsType.WINDOWS_2012;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = VmOsType.class, to = OsType.class)
public static OsType map(VmOsType type, OsType incoming) {
    switch(type) {
        case Unassigned:
            return OsType.UNASSIGNED;
        case WindowsXP:
            return OsType.WINDOWS_XP;
        case Windows2003:
            return OsType.WINDOWS_2003;
        case Windows2008:
            return OsType.WINDOWS_2008;
        case Other:
            return OsType.OTHER;
        case OtherLinux:
            return OsType.OTHER_LINUX;
        case RHEL5:
            return OsType.RHEL_5;
        case RHEL4:
            return OsType.RHEL_4;
        case RHEL3:
            return OsType.RHEL_3;
        case Windows2003x64:
            return OsType.WINDOWS_2003X64;
        case Windows7:
            return OsType.WINDOWS_7;
        case Windows7x64:
            return OsType.WINDOWS_7X64;
        case RHEL5x64:
            return OsType.RHEL_5X64;
        case RHEL4x64:
            return OsType.RHEL_4X64;
        case RHEL3x64:
            return OsType.RHEL_3X64;
        case Windows2008x64:
            return OsType.WINDOWS_2008X64;
        case Windows2008R2x64:
            return OsType.WINDOWS_2008R2;
        case RHEL6:
            return OsType.RHEL_6;
        case RHEL6x64:
            return OsType.RHEL_6X64;
        case Windows8:
            return OsType.WINDOWS_8;
        case Windows8x64:
            return OsType.WINDOWS_8X64;
        case Windows2012x64:
            return OsType.WINDOWS_2012X64;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        default:
            return null;
    }
}
#method_after
@Mapping(from = OsType.class, to = VmOsType.class)
public static VmOsType map(OsType type, VmOsType incoming) {
    switch(type) {
        case UNASSIGNED:
            return VmOsType.Unassigned;
        case WINDOWS_XP:
            return VmOsType.WindowsXP;
        case WINDOWS_2003:
            return VmOsType.Windows2003;
        case WINDOWS_2008:
            return VmOsType.Windows2008;
        case OTHER:
            return VmOsType.Other;
        case OTHER_LINUX:
            return VmOsType.OtherLinux;
        case RHEL_5:
            return VmOsType.RHEL5;
        case RHEL_4:
            return VmOsType.RHEL4;
        case RHEL_3:
            return VmOsType.RHEL3;
        case WINDOWS_2003X64:
            return VmOsType.Windows2003x64;
        case WINDOWS_7:
            return VmOsType.Windows7;
        case WINDOWS_7X64:
            return VmOsType.Windows7x64;
        case RHEL_5X64:
            return VmOsType.RHEL5x64;
        case RHEL_4X64:
            return VmOsType.RHEL4x64;
        case RHEL_3X64:
            return VmOsType.RHEL3x64;
        case WINDOWS_2008X64:
            return VmOsType.Windows2008x64;
        case WINDOWS_2008R2:
            return VmOsType.Windows2008R2x64;
        case RHEL_6:
            return VmOsType.RHEL6;
        case RHEL_6X64:
            return VmOsType.RHEL6x64;
        case WINDOWS_8:
            return VmOsType.Windows8;
        case WINDOWS_8X64:
            return VmOsType.Windows8x64;
        case WINDOWS_2012X64:
            return VmOsType.Windows2012x64;
        default:
            return null;
    }
}
#end_block

#method_before
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getstatus() == VMStatus.Up || entity.getstatus() == VMStatus.PoweringUp || entity.getstatus() == VMStatus.WaitForLaunch || entity.getstatus() == VMStatus.PoweredDown || entity.getstatus() == VMStatus.RebootInProgress || entity.getstatus() == VMStatus.RestoringState;
}
#method_after
private static boolean getIsVmRunning(org.ovirt.engine.core.common.businessentities.VM entity) {
    return entity.getStatus() == VMStatus.Up || entity.getStatus() == VMStatus.PoweringUp || entity.getStatus() == VMStatus.WaitForLaunch || entity.getStatus() == VMStatus.PoweredDown || entity.getStatus() == VMStatus.RebootInProgress || entity.getStatus() == VMStatus.RestoringState;
}
#end_block

#method_before
@Override
public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
    final List<storage_server_connections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getstorage());
    final List<LUNs> lunsList = DbFacade.getInstance().getLunDao().getAllForVolumeGroup(storageDomain.getstorage());
    int numOfRemovedLuns = 0;
    for (LUNs lun : lunsList) {
        if (DbFacade.getInstance().getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) == null) {
            DbFacade.getInstance().getLunDao().remove(lun.getLUN_id());
            numOfRemovedLuns++;
        } else {
            DbFacade.getInstance().getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), "");
        }
    }
    if (numOfRemovedLuns > 0) {
        for (storage_server_connections connection : FilterConnectionsUsedByOthers(list, storageDomain.getstorage())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
        }
    }
    return true;
}
#method_after
@Override
public boolean StorageDomainRemoved(storage_domain_static storageDomain) {
    int numOfRemovedLuns = removeStorageDomainLuns(storageDomain);
    if (numOfRemovedLuns > 0) {
        List<storage_server_connections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getstorage());
        for (storage_server_connections connection : FilterConnectionsUsedByOthers(list, storageDomain.getstorage())) {
            DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setStorageDomainStatus(StorageDomainStatus.Locked, null);
    for (LUNs lun : getParameters().getLunsList()) {
        proceedLUNInDb(lun, getStorageDomain().getstorage_type(), getStorageDomain().getstorage());
    }
    if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId().getValue(), getStorageDomain().getId(), getParameters().getLunIds())).getSucceeded()) {
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    setStorageDomainStatus(StorageDomainStatus.Locked, null);
    for (LUNs lun : getParameters().getLunsList()) {
        proceedLUNInDb(lun, getStorageDomain().getstorage_type(), getStorageDomain().getstorage());
    }
    boolean supportForceExtendVG = Config.<Boolean>GetValue(ConfigValues.SupportForceExtendVG, getStoragePool().getcompatibility_version().toString());
    if (Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ExtendStorageDomain, new ExtendStorageDomainVDSCommandParameters(getStoragePoolId().getValue(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce(), supportForceExtendVG)).getSucceeded()) {
        setStorageDomainStatus(StorageDomainStatus.Active, null);
        setSucceeded(true);
    }
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), volumeGroupId);
    }
    for (storage_server_connections connection : lun.getLunConnections()) {
        List<storage_server_connections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.NewGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    if (getLunDao().get(lun.getLUN_id()) == null) {
        getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        getLunDao().updateLUNsVolumeGroupId(lun.getLUN_id(), volumeGroupId);
    }
    for (storage_server_connections connection : lun.getLunConnections()) {
        List<storage_server_connections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.NewGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#end_block

#method_before
@Override
public List<LUNs> getAllForVolumeGroup(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("volume_group_id", id);
    return getCallsHandler().executeReadList("GetLUNsByVolumeGroupId", MAPPER, parameterSource);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public List<LUNs> getAllForVolumeGroup(String id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("volume_group_id", id);
    return getCallsHandler().executeReadList("GetLUNsByVolumeGroupId", MAPPER, parameterSource);
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getchild_count()).addValue("creation_date", template.getcreation_date()).addValue("description", template.getdescription()).addValue("mem_size_mb", template.getmem_size_mb()).addValue("name", template.getname()).addValue("num_of_sockets", template.getnum_of_sockets()).addValue("cpu_per_socket", template.getcpu_per_socket()).addValue("os", template.getos()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getvds_group_id()).addValue("domain", template.getdomain()).addValue("num_of_monitors", template.getnum_of_monitors()).addValue("allow_console_reconnect", template.getAllowConsoleReconnect()).addValue("status", template.getstatus()).addValue("usb_policy", template.getusb_policy()).addValue("time_zone", template.gettime_zone()).addValue("fail_back", template.getfail_back()).addValue("is_auto_suspend", template.getis_auto_suspend()).addValue("vm_type", template.getvm_type()).addValue("nice_level", template.getnice_level()).addValue("default_boot_sequence", template.getdefault_boot_sequence()).addValue("default_display_type", template.getdefault_display_type()).addValue("priority", template.getpriority()).addValue("auto_startup", template.getauto_startup()).addValue("is_stateless", template.getis_stateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getiso_path()).addValue("origin", template.getorigin()).addValue("initrd_url", template.getinitrd_url()).addValue("kernel_url", template.getkernel_url()).addValue("kernel_params", template.getkernel_params()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getdedicated_vm_for_vds());
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getname());
    model.setUserName(entity.getusername());
    model.setId(entity.getuser_id().toString());
    model.setLastName(entity.getsurname());
    model.setEmail(entity.getemail());
    model.setDepartment(entity.getdepartment());
    if (entity.getgroups() != null) {
        model.setGroups(new Groups());
        // string.split for an empty string returns an array of size 1
        if (entity.getgroups().trim().length() > 0) {
            for (String name : entity.getgroups().split(",")) {
                Group group = new Group();
                group.setName(name);
                model.getGroups().getGroups().add(group);
            }
        }
    }
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getname());
    model.setUserName(entity.getusername());
    model.setId(entity.getuser_id().toString());
    model.setLastName(entity.getsurname());
    model.setEmail(entity.getemail());
    model.setDepartment(entity.getdepartment());
    if (entity.getgroups() != null && entity.getgroups().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getgroups().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringHelper.isNullOrEmpty(entity.getdomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getdomain());
        dom.setId(new NGuid(entity.getdomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getvds_name());
    if (entity.getvds_group_id() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getvds_group_id().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.gethost_name());
    if (entity.getport() > 0) {
        model.setPort(entity.getport());
    }
    HostStatus status = map(entity.getstatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getspm_status() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.gethost_os()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getksm_state()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getcpu_sockets() != null) {
        cpuTopology.setSockets(entity.getcpu_sockets());
        if (entity.getcpu_cores() != null) {
            cpuTopology.setCores(entity.getcpu_cores() / entity.getcpu_sockets());
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getcpu_model());
    if (entity.getcpu_speed_mh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getcpu_speed_mh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getvm_active());
    vmSummary.setMigrating(entity.getvm_migrating());
    vmSummary.setTotal(entity.getvm_count());
    model.setSummary(vmSummary);
    if (entity.getvds_type() != null) {
        HostType type = map(entity.getvds_type(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getphysical_mem_mb() == null ? 0 : entity.getphysical_mem_mb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    return model;
}
#end_block

#method_before
@Before
public void setUp() {
    VmHandler.Init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.NewGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setvds_group_id(group.getId());
    vmStatic.setvds_group_id(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        protected VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(backendInternal).when(command).getBackend();
}
#method_after
@Before
public void setUp() {
    VmHandler.Init();
    vm = new VM();
    vmStatic = new VmStatic();
    group = new VDSGroup();
    group.setId(Guid.NewGuid());
    group.setcompatibility_version(Version.v3_0);
    vm.setVdsGroupId(group.getId());
    vmStatic.setvds_group_id(group.getId());
    VmManagementParametersBase params = new VmManagementParametersBase();
    params.setCommandType(VdcActionType.UpdateVm);
    params.setVmStaticData(vmStatic);
    command = spy(new UpdateVmCommand<VmManagementParametersBase>(params) {

        @Override
        protected VDSGroup getVdsGroup() {
            return group;
        }
    });
    doReturn(vm).when(command).getVm();
    doReturn(backendInternal).when(command).getBackend();
}
#end_block

#method_before
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setvm_name("vm1");
    mockSameNameQuery(true);
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#method_after
@Test
public void testNameNotChanged() {
    prepareVmToPassCanDoAction();
    vm.setVmName("vm1");
    mockSameNameQuery(true);
    assertTrue("canDoAction should have passed.", command.canDoAction());
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    // check if display type was changed in given parameters
    if (vm.getdisplay_type() != vm.getdefault_display_type()) {
        if (vm.getdisplay_type() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmVideoCards() {
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    // check if display type was changed in given parameters
    if (vm.getDisplayType() != vm.getDefaultDisplayType()) {
        if (vm.getDisplayType() == DisplayType.vnc) {
            // check spice to vnc change
            XmlRpcStruct struct = new XmlRpcStruct();
            // create a monitor as an unmanaged device
            struct.add(VdsProperties.Type, VmDeviceType.VIDEO.getName());
            struct.add(VdsProperties.Device, VmDeviceType.CIRRUS.getName());
            struct.add(VdsProperties.SpecParams, getNewMonitorSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(Guid.NewGuid()));
            devices.add(struct);
        }
    } else {
        // get vm device for Video Cards from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.VIDEO.getName());
        for (VmDevice vmDevice : vmDevices) {
            // skip unmanaged devices (handled separately)
            if (!vmDevice.getIsManaged()) {
                continue;
            }
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            addAddress(vmDevice, struct);
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addToManagedDevices(vmDevice);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (vm.getHasAgent()) {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getvds_group_compatibility_version());
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getvds_group_compatibility_version());
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getvds_group_compatibility_version());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#method_after
@Override
protected void buildVmNetworkInterfaces() {
    Map<VmDeviceId, VmDevice> devicesByDeviceId = Entities.businessEntitiesById(DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceType.INTERFACE.getName(), VmDeviceType.BRIDGE.getName()));
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        // get vm device for this disk from DB
        VmDevice vmDevice = devicesByDeviceId.get(new VmDeviceId(vmInterface.getId(), vmInterface.getVmId().getValue()));
        if (vmDevice != null && vmDevice.getIsManaged() && vmDevice.getIsPlugged()) {
            XmlRpcStruct struct = new XmlRpcStruct();
            VmInterfaceType ifaceType = VmInterfaceType.rtl8139;
            if (vmInterface.getType() != null) {
                ifaceType = VmInterfaceType.forValue(vmInterface.getType());
            }
            if (ifaceType == VmInterfaceType.rtl8139_pv) {
                if (vm.getHasAgent()) {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.pv.name(), vm.getVdsGroupCompatibilityVersion());
                    // Doual Mode: in this case we have to insert 2 interfaces with the same entries except nicModel
                    XmlRpcStruct rtl8139Struct = new XmlRpcStruct();
                    addNetworkInterfaceProperties(rtl8139Struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                } else {
                    addNetworkInterfaceProperties(struct, vmInterface, vmDevice, VmInterfaceType.rtl8139.name(), vm.getVdsGroupCompatibilityVersion());
                }
            } else {
                addNetworkInterfaceProperties(struct, vmInterface, vmDevice, ifaceType.toString(), vm.getVdsGroupCompatibilityVersion());
            }
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getVmType() == VmType.Desktop) {
        // get vm device for Sound device from DB
        List<VmDevice> vmDevices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(vm.getId(), VmDeviceType.SOUND.getName());
        for (VmDevice vmDevice : vmDevices) {
            XmlRpcStruct struct = new XmlRpcStruct();
            struct.add(VdsProperties.Type, vmDevice.getType());
            struct.add(VdsProperties.Device, vmDevice.getDevice());
            struct.add(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.add(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            addAddress(vmDevice, struct);
            devices.add(struct);
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getvds_group_compatibility_version()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#method_after
@Override
protected void buildVmBootSequence() {
    // Check if boot sequence in parameters is diffrent from default boot sequence
    if (managedDevices != null) {
        // recalculate boot order from source devices and set it to target devices
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, managedDevices, VmDeviceCommonUtils.isOldClusterVersion(vm.getVdsGroupCompatibilityVersion()));
        for (VmDevice vmDevice : managedDevices) {
            for (XmlRpcStruct struct : devices) {
                String deviceId = (String) struct.getItem(VdsProperties.DeviceId);
                if (deviceId != null && deviceId.equals(vmDevice.getDeviceId().toString())) {
                    if (vmDevice.getBootOrder() > 0) {
                        struct.add(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
                    } else {
                        struct.getKeys().remove(VdsProperties.BootOrder);
                    }
                    break;
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getdisplay_type().toString());
    createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getnum_of_monitors()));
}
#method_after
@Override
protected void buildVmVideoCards() {
    // vnc,qxl
    createInfo.add(VdsProperties.display, vm.getDisplayType().toString());
    createInfo.add(VdsProperties.num_of_monitors, String.valueOf(vm.getNumOfMonitors()));
}
#end_block

#method_before
@Override
protected void buildVmSoundDevices() {
    if (vm.getvm_type() == VmType.Desktop) {
        createInfo.add(VdsProperties.soundDevice, getSoundDevice(vm.getStaticData(), vm.getvds_group_compatibility_version()));
    }
}
#method_after
@Override
protected void buildVmSoundDevices() {
    if (vm.getVmType() == VmType.Desktop) {
        createInfo.add(VdsProperties.soundDevice, getSoundDevice(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion()));
    }
}
#end_block

#method_before
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getboot_sequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB))
        createInfo.add(VdsProperties.Boot, bootSeqInDB);
    else
        // run once
        createInfo.add(VdsProperties.Boot, bootSeqInBE);
}
#method_after
@Override
protected void buildVmBootSequence() {
    // get device list for the VM
    List<VmDevice> devices = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmId(vm.getId());
    String bootSeqInDB = VmDeviceCommonUtils.getBootSequence(devices).toString().toLowerCase();
    String bootSeqInBE = vm.getBootSequence().toString().toLowerCase();
    // TODO : find another way to distinguish run vs. run-once
    if (bootSeqInBE.equals(bootSeqInDB))
        createInfo.add(VdsProperties.Boot, bootSeqInDB);
    else
        // run once
        createInfo.add(VdsProperties.Boot, bootSeqInBE);
}
#end_block

#method_before
protected VDS getVds(Guid id) {
    VDS vds = new VDS();
    vds.setId(id);
    vds.setvds_group_compatibility_version(VDS_COMPATIBILITY_VERSION);
    return vds;
}
#method_after
protected VDS getVds(Guid id) {
    VDS vds = new VDS();
    vds.setId(id);
    return vds;
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterEditor.setLabel(constants.dcVmPopup());
    clusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameEditor.setLabel(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    templateEditor.setLabel(constants.basedOnTemplateVmPopup());
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
    oSTypeEditor.setLabel(constants.osVmPopup());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    runVMOnSpecificHostEditor.setLabel(constants.runOnSelectedHostVmPopup());
    dontMigrateVMEditor.setLabel(constants.allowMigrationOnlyAdminVmPopup());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    cpuPinningLabel.setHTML(constants.cpuPinningLabelExplanation());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
}
#end_block

#method_before
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#method_after
public void SetDataCenter(UnitVmModel model, ArrayList<storage_pool> list) {
    if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(model.getBehavior().getSystemTreeSelectedItem().getType()) {
            case Templates:
            case DataCenter:
                storage_pool selectDataCenter = (storage_pool) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (selectDataCenter.getId().equals(dc.getId())) {
                        selectDataCenter = dc;
                        break;
                    }
                }
                model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { selectDataCenter })));
                model.getDataCenter().setSelectedItem(selectDataCenter);
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Cluster:
            case VMs:
                VDSGroup cluster = (VDSGroup) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(cluster.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        break;
                    }
                }
                model.getDataCenter().setIsChangable(false);
                // $NON-NLS-1$
                model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                break;
            case Host:
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(host.getStoragePoolId())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            case Storage:
                storage_domains storage = (storage_domains) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (storage_pool dc : list) {
                    if (dc.getId().equals(storage.getstorage_pool_id())) {
                        model.getDataCenter().setItems(new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dc })));
                        model.getDataCenter().setSelectedItem(dc);
                        model.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDataCenter().setInfo("Cannot choose Data Center in tree context");
                        break;
                    }
                }
                break;
            default:
                break;
        }
    } else {
        model.getDataCenter().setItems(list);
        model.getDataCenter().setSelectedItem(Linq.FirstOrDefault(list));
    }
}
#end_block

#method_before
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getvmt_guid());
}
#method_after
protected void setupTemplate(VM vm, ListModel model) {
    AsyncDataProvider.GetTemplateById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VmTemplate template = (VmTemplate) returnValue;
            model.getTemplate().setItems(new ArrayList<VmTemplate>(Arrays.asList(new VmTemplate[] { template })));
            model.getTemplate().setSelectedItem(template);
            model.getTemplate().setIsChangable(false);
            PostInitTemplate();
        }
    }, getModel().getHash()), vm.getVmtGuid());
}
#end_block

#method_before
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                storage_pool dataCenter = (storage_pool) returnValue;
                ArrayList<storage_pool> list = new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dataCenter }));
                model.SetDataCenter(model, list);
                model.getDataCenter().setIsChangable(false);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getvds_group_id());
                tempVar.setname(currentVm.getvds_group_name());
                tempVar.setcompatibility_version(currentVm.getvds_group_compatibility_version());
                tempVar.setstorage_pool_id(currentVm.getstorage_pool_id());
                VDSGroup cluster = tempVar;
                model.getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { cluster })));
                model.getCluster().setSelectedItem(cluster);
                behavior.InitTemplate();
                behavior.InitCdImage();
            }
        }
    }, getModel().getHash()), vm.getstorage_pool_id());
}
#method_after
@Override
public void Initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.Initialize(systemTreeSelectedItem);
    AsyncDataProvider.GetDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                storage_pool dataCenter = (storage_pool) returnValue;
                ArrayList<storage_pool> list = new ArrayList<storage_pool>(Arrays.asList(new storage_pool[] { dataCenter }));
                model.SetDataCenter(model, list);
                model.getDataCenter().setIsChangable(false);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setname(currentVm.getVdsGroupName());
                tempVar.setcompatibility_version(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                model.getCluster().setItems(new ArrayList<VDSGroup>(Arrays.asList(new VDSGroup[] { cluster })));
                model.getCluster().setSelectedItem(cluster);
                behavior.InitTemplate();
                behavior.InitCdImage();
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
}
#end_block

#method_before
@Override
public void DataCenter_SelectedItemChanged() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            VM vm = ((ExistingVmModelBehavior) array[0]).vm;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, vm.getvds_group_id().getValue());
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId());
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#method_after
@Override
public void DataCenter_SelectedItemChanged() {
    storage_pool dataCenter = (storage_pool) getModel().getDataCenter().getSelectedItem();
    getModel().setIsHostAvailable(dataCenter.getstorage_pool_type() != StorageType.LOCALFS);
    AsyncDataProvider.GetClusterList(new AsyncQuery(new Object[] { this, getModel() }, new INewAsyncCallback() {

        @Override
        public void OnSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) array[0];
            UnitVmModel model = (UnitVmModel) array[1];
            VM vm = ((ExistingVmModelBehavior) array[0]).vm;
            ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
            model.SetClusters(model, clusters, vm.getVdsGroupId().getValue());
            behavior.InitTemplate();
            behavior.InitCdImage();
        }
    }, getModel().getHash()), dataCenter.getId());
    if (dataCenter.getQuotaEnforcementType() != QuotaEnforcementTypeEnum.DISABLED) {
        getModel().getQuota().setIsAvailable(true);
    } else {
        getModel().getQuota().setIsAvailable(false);
    }
}
#end_block

#method_before
@Override
public void Template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getvm_name());
    getModel().getDescription().setEntity(vm.getvm_description());
    getModel().getMemSize().setEntity(vm.getvm_mem_size_mb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getvm_os());
    getModel().getDomain().setSelectedItem(vm.getvm_domain());
    getModel().getUsbPolicy().setSelectedItem(vm.getusb_policy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getnum_of_monitors());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getdefault_boot_sequence());
    getModel().getIsHighlyAvailable().setEntity(vm.getauto_startup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getnum_of_cpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isStatusUp());
    getModel().getIsStateless().setEntity(vm.getis_stateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getNumOfSockets().setSelectedItem(vm.getnum_of_sockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isStatusUp());
    getModel().getKernel_parameters().setEntity(vm.getkernel_params());
    getModel().getKernel_path().setEntity(vm.getkernel_url());
    getModel().getInitrd_path().setEntity(vm.getinitrd_url());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    if (vm.getis_initialized()) {
        getModel().getTimeZone().setIsChangable(false);
        getModel().getTimeZone().getChangeProhibitionReasons().add(// $NON-NLS-1$
        "Time Zone cannot be change since the Virtual Machine was booted at the first time.");
    }
    updateTimeZone(vm.gettime_zone());
    // Update domain list
    UpdateDomain();
    updateHostPinning(vm.getMigrationSupport());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getvmt_guid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getdefault_display_type()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(vm.getpriority());
}
#method_after
@Override
public void Template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getVmName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOs());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isStatusUp());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isStatusUp());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    if (vm.isInitialized()) {
        getModel().getTimeZone().setIsChangable(false);
        getModel().getTimeZone().getChangeProhibitionReasons().add(// $NON-NLS-1$
        "Time Zone cannot be change since the Virtual Machine was booted at the first time.");
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    UpdateDomain();
    updateHostPinning(vm.getMigrationSupport());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    InitPriority(vm.getPriority());
}
#end_block

#method_before
@Override
protected void ChangeDefualtHost() {
    super.ChangeDefualtHost();
    doChangeDefautlHost(vm.getdedicated_vm_for_vds());
}
#method_after
@Override
protected void ChangeDefualtHost() {
    super.ChangeDefualtHost();
    doChangeDefautlHost(vm.getDedicatedVmForVds());
}
#end_block

#method_before
@Override
public void UpdateMinAllocatedMemory() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    if ((Integer) getModel().getMemSize().getEntity() < vm.getvm_mem_size_mb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#method_after
@Override
public void UpdateMinAllocatedMemory() {
    VDSGroup cluster = (VDSGroup) getModel().getCluster().getSelectedItem();
    if (cluster == null) {
        return;
    }
    if ((Integer) getModel().getMemSize().getEntity() < vm.getVmMemSizeMb()) {
        double overCommitFactor = 100.0 / cluster.getmax_vds_memory_over_commit();
        getModel().getMinAllocatedMemory().setEntity((int) ((Integer) getModel().getMemSize().getEntity() * overCommitFactor));
    } else {
        getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    }
}
#end_block

#method_before
public void InitCdImage() {
    getModel().getCdImage().setSelectedItem(vm.getiso_path());
    boolean hasCd = !StringHelper.isNullOrEmpty(vm.getiso_path());
    getModel().getCdImage().setIsChangable(hasCd);
    getModel().getCdAttached().setEntity(hasCd);
    UpdateCdImage();
}
#method_after
public void InitCdImage() {
    getModel().getCdImage().setSelectedItem(vm.getIsoPath());
    boolean hasCd = !StringHelper.isNullOrEmpty(vm.getIsoPath());
    getModel().getCdImage().setIsChangable(hasCd);
    getModel().getCdAttached().setEntity(hasCd);
    UpdateCdImage();
}
#end_block

#method_before
@Override
public void Template_SelectedItemChanged() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(template.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(template.getdomain());
        getModel().getMemSize().setEntity(template.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(template.getusb_policy());
        getModel().setBootSequence(template.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(template.getauto_startup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getdedicated_vm_for_vds());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        if (getModel().getVmType() == VmType.Desktop) {
            getModel().getIsStateless().setEntity(template.getis_stateless());
            getModel().getAllowConsoleReconnect().setEntity(template.getAllowConsoleReconnect());
        }
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(template.gettime_zone())) {
            updateTimeZone(template.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(template.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == template.getdefault_display_type()) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getkernel_url());
        getModel().getKernel_parameters().setEntity(template.getkernel_params());
        getModel().getInitrd_path().setEntity(template.getinitrd_url());
        if (!template.getId().equals(NGuid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        InitPriority(template.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#method_after
@Override
public void Template_SelectedItemChanged() {
    VmTemplate template = (VmTemplate) getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(template.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(template.getdomain());
        getModel().getMemSize().setEntity(template.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(template.getusb_policy());
        getModel().setBootSequence(template.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(template.getauto_startup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getdedicated_vm_for_vds());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        if (getModel().getVmType() == VmType.Desktop) {
            getModel().getIsStateless().setEntity(template.getis_stateless());
            getModel().getAllowConsoleReconnect().setEntity(template.getAllowConsoleReconnect());
        }
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(template.gettime_zone())) {
            updateTimeZone(template.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == template.getdefault_display_type()) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getkernel_url());
        getModel().getKernel_parameters().setEntity(template.getkernel_params());
        getModel().getInitrd_path().setEntity(template.getinitrd_url());
        if (!template.getId().equals(NGuid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        InitPriority(template.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(vmBase.getdomain());
        getModel().getMemSize().setEntity(vmBase.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getusb_policy());
        getModel().setBootSequence(vmBase.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.getauto_startup());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.gettime_zone())) {
            updateTimeZone(vmBase.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getkernel_url());
        getModel().getKernel_parameters().setEntity(vmBase.getkernel_params());
        getModel().getInitrd_path().setEntity(vmBase.getinitrd_url());
        getModel().setIsDisksAvailable(true);
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        InitPriority(vmBase.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getos());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getnum_of_cpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getnum_of_sockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getnum_of_monitors());
        getModel().getDomain().setSelectedItem(vmBase.getdomain());
        getModel().getMemSize().setEntity(vmBase.getmem_size_mb());
        getModel().getUsbPolicy().setSelectedItem(vmBase.getusb_policy());
        getModel().setBootSequence(vmBase.getdefault_boot_sequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.getauto_startup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getiso_path());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getiso_path());
        }
        if (!StringHelper.isNullOrEmpty(vmBase.gettime_zone())) {
            updateTimeZone(vmBase.gettime_zone());
        } else {
            UpdateDefaultTimeZone();
        }
        // Update domain list
        UpdateDomain();
        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) getModel().getCluster().getItems();
        VDSGroup selectCluster = Linq.FirstOrDefault(clusters, new Linq.ClusterPredicate(vmBase.getvds_group_id()));
        getModel().getCluster().setSelectedItem((selectCluster != null) ? selectCluster : Linq.FirstOrDefault(clusters));
        // Update display protocol selected item
        EntityModel displayProtocol = null;
        boolean isFirst = true;
        for (Object item : getModel().getDisplayProtocol().getItems()) {
            EntityModel a = (EntityModel) item;
            if (isFirst) {
                displayProtocol = a;
                isFirst = false;
            }
            DisplayType dt = (DisplayType) a.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = a;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getkernel_url());
        getModel().getKernel_parameters().setEntity(vmBase.getkernel_params());
        getModel().getInitrd_path().setEntity(vmBase.getinitrd_url());
        getModel().setIsDisksAvailable(true);
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            InitDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        InitPriority(vmBase.getpriority());
        InitStorageDomains();
        UpdateMinAllocatedMemory();
    }
}
#end_block

#method_before
public boolean canRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator, VmPropertiesUtils vmPropsUtils) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else if (!(validationErrors = vmPropsUtils.validateVMProperties(vm.getvds_group_compatibility_version(), vm.getStaticData())).isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getdefault_boot_sequence();
        Guid storagePoolId = vm.getstorage_pool_id();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<Disk> vmDisks = getPluggedDisks(vm);
        if (boot_sequence == BootSequence.C && vmDisks.size() == 0) {
            String messageStr = !vmDisks.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmDisks.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    if (retValue && !performImageChecksForRunningVm(vm, message, runParams, vmDisks)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.getauto_startup() && !validateIsoPath(findActiveISODomain(vm.getstorage_pool_id()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) getBackend().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getstatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                        } else if (vm.getstatus() == VMStatus.Paused && vm.getrun_on_vds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDao().get(new Guid(vm.getrun_on_vds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                message.add(VdcBllMessages.VAR__HOST_STATUS__UP.toString());
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && isVmInPreview(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.getauto_startup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        if (retValue && isStatelessVm && !hasSpaceForSnapthosts(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.name());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.canFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#method_after
public boolean canRunVm(VM vm, ArrayList<String> message, RunVmParams runParams, VdsSelector vdsSelector, SnapshotsValidator snapshotsValidator, VmPropertiesUtils vmPropsUtils) {
    boolean retValue = true;
    List<VmPropertiesUtils.ValidationError> validationErrors = null;
    if (vm == null) {
        retValue = false;
        message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND.toString());
    } else if (!(validationErrors = vmPropsUtils.validateVMProperties(vm.getVdsGroupCompatibilityVersion(), vm.getStaticData())).isEmpty()) {
        VmHandler.handleCustomPropertiesError(validationErrors, message);
        retValue = false;
    } else {
        BootSequence boot_sequence = ((runParams.getBootSequence()) != null) ? runParams.getBootSequence() : vm.getDefaultBootSequence();
        Guid storagePoolId = vm.getStoragePoolId();
        // Block from running a VM with no HDD when its first boot device is
        // HD
        // and no other boot devices are configured
        List<Disk> vmDisks = getPluggedDisks(vm);
        if (boot_sequence == BootSequence.C && vmDisks.size() == 0) {
            String messageStr = !vmDisks.isEmpty() ? VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_PLUGGED_DISK.toString() : VdcBllMessages.VM_CANNOT_RUN_FROM_DISK_WITHOUT_DISK.toString();
            message.add(messageStr);
            retValue = false;
        } else {
            if (boot_sequence == BootSequence.CD && findActiveISODomain(storagePoolId) == null) {
                message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO.toString());
                retValue = false;
            } else {
                // otherwise the vm cannot be run in vdsm
                if (boot_sequence == BootSequence.N && DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(vm.getId()).size() == 0) {
                    message.add(VdcBllMessages.VM_CANNOT_RUN_FROM_NETWORK_WITHOUT_NETWORK.toString());
                    retValue = false;
                } else if (vmDisks.size() > 0) {
                    ValidationResult vmDuringSnapshotResult = snapshotsValidator.vmNotDuringSnapshot(vm.getId());
                    if (!vmDuringSnapshotResult.isValid()) {
                        message.add(vmDuringSnapshotResult.getMessage().name());
                        retValue = false;
                    }
                    if (retValue && !performImageChecksForRunningVm(vm, message, runParams, vmDisks)) {
                        retValue = false;
                    }
                    // Check if iso and floppy path exists
                    if (retValue && !vm.isAutoStartup() && !validateIsoPath(findActiveISODomain(vm.getStoragePoolId()), runParams, message)) {
                        retValue = false;
                    } else if (retValue) {
                        boolean isVmDuringInit = ((Boolean) getBackend().getResourceManager().RunVdsCommand(VDSCommandType.IsVmDuringInitiating, new IsVmDuringInitiatingVDSCommandParameters(vm.getId())).getReturnValue()).booleanValue();
                        if (vm.isStatusUp() || (vm.getStatus() == VMStatus.NotResponding) || isVmDuringInit) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING.toString());
                        } else if (vm.getStatus() == VMStatus.Paused && vm.getRunOnVds() != null) {
                            VDS vds = DbFacade.getInstance().getVdsDao().get(new Guid(vm.getRunOnVds().toString()));
                            if (vds.getstatus() != VDSStatus.Up) {
                                retValue = false;
                                message.add(VdcBllMessages.VAR__HOST_STATUS__UP.toString());
                                message.add(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL.toString());
                            }
                        }
                        boolean isStatelessVm = shouldVmRunAsStateless(runParams, vm);
                        if (retValue && isStatelessVm && isVmInPreview(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_WHILE_IN_PREVIEW.toString());
                        }
                        // if the VM itself is stateless or run once as stateless
                        if (retValue && isStatelessVm && vm.isAutoStartup()) {
                            retValue = false;
                            message.add(VdcBllMessages.VM_CANNOT_RUN_STATELESS_HA.toString());
                        }
                        if (retValue && isStatelessVm && !hasSpaceForSnapthosts(vm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW.name());
                        }
                        retValue = retValue == false ? retValue : vdsSelector.canFindVdsToRunOn(message, false);
                        /**
                         * only if can do action ok then check with actions matrix that status is valid for this
                         * action
                         */
                        if (retValue && !VdcActionUtils.CanExecute(Arrays.asList(vm), VM.class, VdcActionType.RunVm)) {
                            retValue = false;
                            message.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL.toString());
                        }
                    }
                }
            }
        }
    }
    return retValue;
}
#end_block

#method_before
protected boolean performImageChecksForRunningVm(VM vm, List<String> message, RunVmParams runParams, List<Disk> vmDisks) {
    return ImagesHandler.PerformImagesChecks(vm, message, vm.getstorage_pool_id(), Guid.Empty, !vm.getauto_startup(), true, false, false, false, false, !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), !vm.getauto_startup() || !runParams.getIsInternal() && vm.getauto_startup(), vmDisks);
}
#method_after
protected boolean performImageChecksForRunningVm(VM vm, List<String> message, RunVmParams runParams, List<Disk> vmDisks) {
    return ImagesHandler.PerformImagesChecks(vm, message, vm.getStoragePoolId(), Guid.Empty, !vm.isAutoStartup(), true, false, false, false, false, !vm.isAutoStartup() || !runParams.getIsInternal() && vm.isAutoStartup(), !vm.isAutoStartup() || !runParams.getIsInternal() && vm.isAutoStartup(), vmDisks);
}
#end_block

#method_before
public boolean shouldVmRunAsStateless(RunVmParams param, VM vm) {
    if (param.getRunAsStateless() != null) {
        return param.getRunAsStateless();
    }
    return vm.getis_stateless();
}
#method_after
public boolean shouldVmRunAsStateless(RunVmParams param, VM vm) {
    if (param.getRunAsStateless() != null) {
        return param.getRunAsStateless();
    }
    return vm.isStateless();
}
#end_block

#method_before
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (String s : EnumCompat.GetNames(VDSType.class)) {
        if (StringHelper.stringsEqual(s, VDSType.PowerClient.toString())) {
            if (showPowerclient) {
                ret.add(s);
            }
        } else {
            ret.add(s);
        }
    }
    return ret;
}
#method_after
public static ArrayList<String> GetHostTypeList(boolean showPowerclient) {
    // TODO: We can translate it here too
    ArrayList<String> ret = new ArrayList<String>();
    for (VDSType vdsType : VDSType.values()) {
        if (VDSType.PowerClient == vdsType) {
            if (showPowerclient) {
                ret.add(vdsType.name());
            }
        } else {
            ret.add(vdsType.name());
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    // TODO: We can translate it here too
    for (EventNotificationEntity entity : EnumCompat.GetValues(EventNotificationEntity.class)) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#method_after
public static ArrayList<EventNotificationEntity> GetEventNotificationTypeList() {
    ArrayList<EventNotificationEntity> ret = new ArrayList<EventNotificationEntity>();
    for (EventNotificationEntity entity : EventNotificationEntity.values()) {
        if (entity != EventNotificationEntity.UNKNOWN) {
            ret.add(entity);
        }
    }
    return ret;
}
#end_block

#method_before
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>();
    for (VmInterfaceType item : EnumCompat.GetValues(VmInterfaceType.class)) {
        list.add(item);
    }
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        list.remove(VmInterfaceType.e1000);
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#method_after
public static ArrayList<VmInterfaceType> GetNicTypeList(VmOsType osType, boolean hasDualmode) {
    ArrayList<VmInterfaceType> list = new ArrayList<VmInterfaceType>(Arrays.asList(VmInterfaceType.values()));
    // Dual mode NIC should be available only for existing NICs that have
    list.remove(VmInterfaceType.rtl8139_pv);
    // that type already
    if (IsWindowsOsType(osType)) {
        if (osType == VmOsType.WindowsXP && hasDualmode) {
            list.add(VmInterfaceType.rtl8139_pv);
        }
    }
    return list;
}
#end_block

#method_before
public static Iterable GetUsbPolicyList() {
    return EnumCompat.GetValues(UsbPolicy.class);
}
#method_after
public static Iterable GetUsbPolicyList() {
    return Arrays.asList(UsbPolicy.values());
}
#end_block

