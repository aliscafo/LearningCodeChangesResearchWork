907
#method_before
@Override
public List<Job> getJobsByOffsetAndPageSize(int offset, int pageSize) {
    return super.multiResults(getEntityManager().createNativeQuery("select * from GetJobsByOffsetAndPageSize(:offset,:pageSize)", Job.class).setParameter("offset", offset).setParameter("pageSize", pageSize));
}
#method_after
@Override
public List<Job> getJobsByOffsetAndPageSize(int offset, int pageSize) {
    List<Job> allJobs = multipleResults(entityManager.createNamedQuery("Job.getJobsByOffsetAndPageSize", Job.class).setParameter("status", JobExecutionStatus.STARTED));
    allJobs.addAll(multipleResults(entityManager.createNamedQuery("Job.getJobsByOffsetAndPageSizeNotInStatus", Job.class).setParameter("status", EnumSet.of(JobExecutionStatus.STARTED, JobExecutionStatus.UNKNOWN))));
    int endIndex = Math.min(offset + pageSize, allJobs.size());
    return allJobs.subList(offset, endIndex);
}
#end_block

#method_before
@Override
public List<Job> getJobsByCorrelationId(String correlationId) {
    return super.multiResults(getEntityManager().createQuery("select j from Job j where j.correlationId = :correlationId").setParameter("correlationId", correlationId));
}
#method_after
@Override
public List<Job> getJobsByCorrelationId(String correlationId) {
    return multipleResults(entityManager.createNamedQuery("Job.getJobsByCorrelationId", Job.class).setParameter("correlationId", correlationId));
}
#end_block

#method_before
@Override
public void deleteJobOlderThanDateWithStatus(Date sinceDate, List<JobExecutionStatus> statusesList) {
    super.updateQueryGetResult(getEntityManager().createNativeQuery("select cast(DeleteJobOlderThanDateWithStatus as text) from DeleteJobOlderThanDateWithStatus(:sinceDate,:statuses)").setParameter("sinceDate", sinceDate).setParameter("statuses", StringUtils.join(statusesList, ",")));
}
#method_after
@Override
public void deleteJobOlderThanDateWithStatus(Date sinceDate, List<JobExecutionStatus> statusesList) {
    updateQuery(entityManager.createNamedQuery("Job.deleteJobOlderThanDateWithStatus").setParameter("sinceDate", sinceDate).setParameter("statuses", statusesList));
}
#end_block

#method_before
@Override
public void updateStartedExecutionEntitiesToUnknown(Date updateTime) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("end_time", updateTime);
    getCallsHandler().executeModification("UpdateStartedExecutionEntitiesToUnknown", parameterSource);
}
#method_after
@Override
public void updateStartedExecutionEntitiesToUnknown(Date updateTime) {
    updateQueryGetResult(entityManager.createNativeQuery("select cast(UpdateStartedExecutionEntitiesToUnknown as text) from UpdateStartedExecutionEntitiesToUnknown(?)").setParameter(1, updateTime));
}
#end_block

#method_before
@Override
public void deleteRunningJobsOfTasklessCommands() {
    getCallsHandler().executeModification("DeleteRunningJobsOfTasklessCommands", getCustomMapSqlParameterSource());
}
#method_after
@Override
public void deleteRunningJobsOfTasklessCommands() {
    updateQueryGetResult(entityManager.createNativeQuery("select cast(DeleteRunningJobsOfTasklessCommands as text) from DeleteRunningJobsOfTasklessCommands()"));
}
#end_block

#method_before
@Override
public void deleteCompletedJobs(Date succeededJobs, Date failedJobs) {
    super.updateQuery(getEntityManager().createQuery("delete from Job j where j.autoCleared = true and ((j.endTime < :failedEndTime and j.status in (:failStatus)) or (j.endTime < :successEndTime and j.status = :successStatus))").setParameter("successEndTime", succeededJobs).setParameter("failedEndTime", failedJobs).setParameter("failStatus", EnumSet.of(JobExecutionStatus.FAILED, JobExecutionStatus.ABORTED, JobExecutionStatus.UNKNOWN)).setParameter("successStatus", JobExecutionStatus.FINISHED));
}
#method_after
@Override
public void deleteCompletedJobs(final Date succeededJobs, final Date failedJobs) {
    updateQuery(entityManager.createNamedQuery("Job.deleteCompletedJobs").setParameter("successEndTime", succeededJobs).setParameter("failedEndTime", failedJobs).setParameter("failStatus", EnumSet.of(JobExecutionStatus.FAILED, JobExecutionStatus.ABORTED, JobExecutionStatus.UNKNOWN)).setParameter("successStatus", JobExecutionStatus.FINISHED));
}
#end_block

#method_before
@Override
public boolean checkIfJobHasTasks(Guid jobId) {
    @SuppressWarnings("unchecked")
    List<Step> steps = super.multiResultsNoCast(getEntityManager().createQuery("select s from Step s where s.jobId = :jobId and s.externalId is not null and s.externalSystem in :systemType").setParameter("jobId", jobId).setParameter("systemType", EnumSet.of(ExternalSystemType.VDSM, ExternalSystemType.GLUSTER)));
    return steps.size() > 0;
}
#method_after
@Override
public boolean checkIfJobHasTasks(Guid jobId) {
    List<Step> steps = step.getStepsByJobIdForVdsmAndGluster(jobId);
    return !steps.isEmpty();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((actionType == null) ? 0 : actionType.hashCode());
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + ((endTime == null) ? 0 : endTime.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (isVisible ? 1231 : 1237);
    result = prime * result + ((jobSubjectEntities == null) ? 0 : jobSubjectEntities.hashCode());
    result = prime * result + ((lastUpdateTime == null) ? 0 : lastUpdateTime.hashCode());
    result = prime * result + ((ownerId == null) ? 0 : ownerId.hashCode());
    result = prime * result + ((startTime == null) ? 0 : startTime.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((steps == null) ? 0 : steps.hashCode());
    result = prime * result + (external ? 1231 : 1237);
    result = prime * result + (autoCleared ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(id);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Job)) {
        return false;
    }
    Job other = (Job) obj;
    if (actionType != other.actionType) {
        return false;
    }
    if (correlationId == null) {
        if (other.correlationId != null) {
            return false;
        }
    } else if (!correlationId.equals(other.correlationId)) {
        return false;
    }
    if (endTime == null) {
        if (other.endTime != null) {
            return false;
        }
    } else if (!endTime.equals(other.endTime)) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (isVisible != other.isVisible) {
        return false;
    }
    if (jobSubjectEntities == null) {
        if (other.jobSubjectEntities != null) {
            return false;
        }
    } else if (!jobSubjectEntities.equals(other.jobSubjectEntities)) {
        return false;
    }
    if (lastUpdateTime == null) {
        if (other.lastUpdateTime != null) {
            return false;
        }
    } else if (!lastUpdateTime.equals(other.lastUpdateTime)) {
        return false;
    }
    if (ownerId == null) {
        if (other.ownerId != null) {
            return false;
        }
    } else if (!ownerId.equals(other.ownerId)) {
        return false;
    }
    if (startTime == null) {
        if (other.startTime != null) {
            return false;
        }
    } else if (!startTime.equals(other.startTime)) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (steps == null) {
        if (other.steps != null) {
            return false;
        }
    } else if (!steps.equals(other.steps)) {
        return false;
    }
    if (external != other.external) {
        return false;
    }
    if (autoCleared != other.autoCleared) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Job)) {
        return false;
    }
    Job other = (Job) obj;
    return Objects.equals(id, other.id);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getJobDao();
    existingEntity = dao.get(EXISTING_JOB_ID);
    newEntity = generateNewEntity();
}
#end_block

#method_before
@Override
protected Job generateNewEntity() {
    Job job = new Job();
    job.setId(Guid.newGuid());
    job.setActionType(VdcActionType.ActivateStorageDomain);
    job.setDescription(VdcActionType.ActivateStorageDomain.name());
    job.setStatus(JobExecutionStatus.STARTED);
    job.setOwnerId(Guid.newGuid());
    job.setVisible(true);
    job.setStartTime(new Date());
    job.setLastUpdateTime(new Date());
    job.setCorrelationId(Guid.newGuid().toString());
    return job;
}
#method_after
private Job generateNewEntity() {
    Job job = new Job();
    job.setId(Guid.newGuid());
    job.setActionType(VdcActionType.ActivateStorageDomain);
    job.setDescription(VdcActionType.ActivateStorageDomain.name());
    job.setStatus(JobExecutionStatus.STARTED);
    job.setOwnerId(Guid.newGuid());
    job.setVisible(true);
    job.setStartTime(new Date());
    job.setLastUpdateTime(new Date());
    job.setCorrelationId(Guid.newGuid().toString());
    return job;
}
#end_block

#method_before
@Test
public void updateJobLastUpdateTime() throws ParseException {
    DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date updateDate = df.parse("2012-10-01 10:00:00");
    Job job = dao.get(getExistingEntityId());
    Date lastUpdateTime = job.getLastUpdateTime();
    dao.updateJobLastUpdateTime(getExistingEntityId(), updateDate);
    Job jobAfterUpdate = dao.get(getExistingEntityId());
    assertTrue("Compare the previous date is differ than new one", !lastUpdateTime.equals(jobAfterUpdate.getLastUpdateTime()));
    assertEquals("Compare date was persisted by reading it from database", updateDate, jobAfterUpdate.getLastUpdateTime());
}
#method_after
@Test
public void updateJobLastUpdateTime() throws ParseException {
    DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date updateDate = df.parse("2012-10-01 10:00:00");
    Job job = dao.get(EXISTING_JOB_ID);
    Date lastUpdateTime = job.getLastUpdateTime();
    dao.updateJobLastUpdateTime(EXISTING_JOB_ID, updateDate);
    Job jobAfterUpdate = dao.get(EXISTING_JOB_ID);
    assertTrue("Compare the previous date is differ than new one", !lastUpdateTime.equals(jobAfterUpdate.getLastUpdateTime()));
    assertEquals("Compare date was persisted by reading it from database", updateDate, jobAfterUpdate.getLastUpdateTime());
}
#end_block

#method_before
@Override
public List<Step> getStepsByJobId(Guid jobId) {
    return DbFacade.getInstance().getJobDao().get(jobId).getSteps();
}
#method_after
@Override
public List<Step> getStepsByJobId(Guid jobId) {
    return jobDao.get(jobId).getSteps();
}
#end_block

#method_before
@Override
public void updateJobStepsCompleted(Guid jobId, JobExecutionStatus status, Date endTime) {
    if (status != JobExecutionStatus.STARTED) {
        super.updateQuery(getEntityManager().createQuery("update Step s set s.status = :status, s.endTime = :endTime where s.status = :startedStatus and s.jobId = :jobId").setParameter("jobId", jobId).setParameter("status", status).setParameter("endTime", endTime).setParameter("startedStatus", JobExecutionStatus.STARTED));
    }
}
#method_after
@Override
public void updateJobStepsCompleted(Guid jobId, JobExecutionStatus status, Date endTime) {
    if (status != JobExecutionStatus.STARTED) {
        updateQuery(entityManager.createNamedQuery("Step.updateJobStepsCompleted").setParameter("jobId", jobId).setParameter("status", status).setParameter("endTime", endTime).setParameter("startedStatus", JobExecutionStatus.STARTED));
    }
}
#end_block

#method_before
@Override
public List<Step> getStepsByExternalId(Guid externalId) {
    return super.multiResults(getEntityManager().createQuery("select s from Step s where s.externalId = :externalId order by s.parentStepId, s.stepNumber").setParameter("externalId", externalId));
}
#method_after
@Override
public List<Step> getStepsByExternalId(Guid externalId) {
    return multipleResults(entityManager.createNamedQuery("Step.getStepsByExternalId", Step.class).setParameter("externalId", externalId));
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<Guid> getExternalIdsForRunningSteps(ExternalSystemType systemType) {
    return super.multiResultsNoCast(getEntityManager().createNativeQuery("select cast(getexternalidsfromsteps as text) from GetExternalIdsFromSteps(?,?)").setParameter(1, systemType.name()).setParameter(2, JobExecutionStatus.STARTED.name()));
}
#method_after
@Override
public List<Guid> getExternalIdsForRunningSteps(ExternalSystemType systemType) {
    return multipleResults(entityManager.createNamedQuery("Step.getExternalIdsForRunningSteps").setParameter("status", JobExecutionStatus.STARTED).setParameter("type", systemType));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((correlationId == null) ? 0 : correlationId.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((endTime == null) ? 0 : endTime.hashCode());
    result = prime * result + ((externalSystem == null) ? 0 : externalSystem.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((jobId == null) ? 0 : jobId.hashCode());
    result = prime * result + ((parentStepId == null) ? 0 : parentStepId.hashCode());
    result = prime * result + ((startTime == null) ? 0 : startTime.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + stepNumber;
    result = prime * result + ((stepType == null) ? 0 : stepType.hashCode());
    result = prime * result + ((steps == null) ? 0 : steps.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + (external ? 1231 : 1237);
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hashCode(id);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof Step)) {
        return false;
    }
    Step other = (Step) obj;
    if (correlationId == null) {
        if (other.correlationId != null) {
            return false;
        }
    } else if (!correlationId.equals(other.correlationId)) {
        return false;
    }
    if (description == null) {
        if (other.description != null) {
            return false;
        }
    } else if (!description.equals(other.description)) {
        return false;
    }
    if (endTime == null) {
        if (other.endTime != null) {
            return false;
        }
    } else if (!endTime.equals(other.endTime)) {
        return false;
    }
    if (externalSystem == null) {
        if (other.externalSystem != null) {
            return false;
        }
    } else if (!externalSystem.equals(other.externalSystem)) {
        return false;
    }
    if (id == null) {
        if (other.id != null) {
            return false;
        }
    } else if (!id.equals(other.id)) {
        return false;
    }
    if (jobId == null) {
        if (other.jobId != null) {
            return false;
        }
    } else if (!jobId.equals(other.jobId)) {
        return false;
    }
    if (parentStepId == null) {
        if (other.parentStepId != null) {
            return false;
        }
    } else if (!parentStepId.equals(other.parentStepId)) {
        return false;
    }
    if (startTime == null) {
        if (other.startTime != null) {
            return false;
        }
    } else if (!startTime.equals(other.startTime)) {
        return false;
    }
    if (status != other.status) {
        return false;
    }
    if (stepNumber != other.stepNumber) {
        return false;
    }
    if (stepType != other.stepType) {
        return false;
    }
    if (steps == null) {
        if (other.steps != null) {
            return false;
        }
    } else if (!steps.equals(other.steps)) {
        return false;
    }
    if (external != other.external) {
        return false;
    }
    if (externalId != other.externalId) {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof Step)) {
        return false;
    }
    Step other = (Step) obj;
    return Objects.equals(id, other.id);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
}
#method_after
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStepDao();
    existingStep = dao.get(EXISTING_STEP_ID);
    newStep = generateNewEntity();
}
#end_block

#method_before
@Override
protected Step generateNewEntity() {
    Step step = new Step(StepEnum.EXECUTING);
    step.setJobId(EXISTING_JOB_ID);
    step.setStepNumber(1);
    step.setDescription("Execution step");
    step.setCorrelationId("Some correlation id");
    return step;
}
#method_after
private Step generateNewEntity() {
    Step step = new Step(StepEnum.EXECUTING);
    step.setJobId(EXISTING_JOB_ID);
    step.setStepNumber(1);
    step.setDescription("Execution step");
    step.setCorrelationId("Some correlation id");
    return step;
}
#end_block

#method_before
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        for (DiskImage disk : getVmTemplate().getDiskTemplateMap().values()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
    }
    return true;
}
#method_after
@Override
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        Collection<DiskImage> templateDisks = getVmTemplate().getDiskTemplateMap().values();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage disk : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateCloneOfTemplate, buildCreateCloneOfTemplateParameters(disk));
            // if couldn't create snapshot then stop the transaction and the command
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            }
            getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
            DiskImage newImage = (DiskImage) result.getActionReturnValue();
            getSrcDiskIdToTargetDiskIdMapping().put(disk.getId(), newImage.getId());
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(ImagesHandler.filterDisksBasedOnCinder(templateDisks));
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    for (DiskImage dit : getVmTemplate().getDiskTemplateMap().values()) {
        DiskImage diskImage = diskInfoDestinationMap.get(dit.getId());
        if (!ImagesHandler.checkImageConfiguration(destStorages.get(diskImage.getStorageIds().get(0)).getStorageStaticData(), diskImage, getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    List<DiskImage> templateDiskImages = ImagesHandler.filterImageDisks(getVmTemplate().getDiskTemplateMap().values(), true, false, false);
    for (DiskImage dit : templateDiskImages) {
        if (!ImagesHandler.checkImageConfiguration(destStorages.get(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0)).getStorageStaticData(), diskInfoDestinationMap.get(dit.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean verifySourceDomains() {
    Map<Guid, StorageDomain> poolDomainsMap = Entities.businessEntitiesById(getPoolDomains());
    EnumSet<StorageDomainStatus> validDomainStatuses = EnumSet.of(StorageDomainStatus.Active);
    validDisksDomains = ImagesHandler.findDomainsInApplicableStatusForDisks(getImagesToCheckDestinationStorageDomains(), poolDomainsMap, validDomainStatuses);
    return validate(new DiskImagesValidator(getImagesToCheckDestinationStorageDomains()).diskImagesOnAnyApplicableDomains(validDisksDomains, poolDomainsMap, VdcBllMessages.ACTION_TYPE_FAILED_NO_VALID_DOMAINS_STATUS_FOR_TEMPLATE_DISKS, validDomainStatuses));
}
#method_after
@Override
protected boolean verifySourceDomains() {
    Map<Guid, StorageDomain> poolDomainsMap = Entities.businessEntitiesById(getPoolDomains());
    EnumSet<StorageDomainStatus> validDomainStatuses = EnumSet.of(StorageDomainStatus.Active);
    List<DiskImage> templateDiskImages = ImagesHandler.filterImageDisks(getImagesToCheckDestinationStorageDomains(), true, false, false);
    validDisksDomains = ImagesHandler.findDomainsInApplicableStatusForDisks(templateDiskImages, poolDomainsMap, validDomainStatuses);
    return validate(new DiskImagesValidator(templateDiskImages).diskImagesOnAnyApplicableDomains(validDisksDomains, poolDomainsMap, VdcBllMessages.ACTION_TYPE_FAILED_NO_VALID_DOMAINS_STATUS_FOR_TEMPLATE_DISKS, validDomainStatuses));
}
#end_block

#method_before
@Override
protected void chooseDisksSourceDomains() {
    diskInfoSourceMap = new HashMap<>();
    for (DiskImage disk : getImagesToCheckDestinationStorageDomains()) {
        Guid diskId = disk.getId();
        Set<Guid> validDomainsForDisk = validDisksDomains.get(diskId);
        Guid destinationDomain = retrieveDestinationDomainForDisk(diskId);
        // possibly faster operation, otherwise we'll choose random valid domain as the source.
        if (validDomainsForDisk.contains(destinationDomain)) {
            diskInfoSourceMap.put(diskId, destinationDomain);
        } else {
            diskInfoSourceMap.put(diskId, validDomainsForDisk.iterator().next());
        }
    }
}
#method_after
@Override
protected void chooseDisksSourceDomains() {
    diskInfoSourceMap = new HashMap<>();
    List<DiskImage> templateDiskImages = ImagesHandler.filterImageDisks(getImagesToCheckDestinationStorageDomains(), true, false, false);
    for (DiskImage disk : templateDiskImages) {
        Guid diskId = disk.getId();
        Set<Guid> validDomainsForDisk = validDisksDomains.get(diskId);
        Guid destinationDomain = retrieveDestinationDomainForDisk(diskId);
        // possibly faster operation, otherwise we'll choose random valid domain as the source.
        if (validDomainsForDisk.contains(destinationDomain)) {
            diskInfoSourceMap.put(diskId, destinationDomain);
        } else {
            diskInfoSourceMap.put(diskId, validDomainsForDisk.iterator().next());
        }
    }
}
#end_block

#method_before
private void addGeneralTypeColumn() {
    // TODO: replace with icon
    final AbstractTextColumn<VmDevice> deviceGeneralTypeColumn = new AbstractTextColumn<VmDevice>() {

        @Override
        public String getValue(VmDevice device) {
            return device.getType().name();
        }
    };
    deviceGeneralTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceGeneralTypeColumn, constants.deviceGeneralType(), "120px");
}
#method_after
private void addGeneralTypeColumn() {
    final VmDeviceGeneralTypeColumn<VmDevice> deviceGeneralTypeColumn = new VmDeviceGeneralTypeColumn<>();
    deviceGeneralTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(deviceGeneralTypeColumn, constants.empty(), "30px");
}
#end_block

#method_before
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmSessionsModel vmSessionsModel, final VmDevicesListModel vmDevicesListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmDevicesListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmSessionsModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final VmGeneralModel vmGeneralModel, final VmInterfaceListModel vmInterfaceListModel, final VmDiskListModel vmDiskListModel, final VmSnapshotListModel vmSnapshotListModel, final VmEventListModel vmEventListModel, final VmAppListModel<VM> vmAppListModel, final PermissionListModel<VM> permissionListModel, final VmAffinityGroupListModel vmAffinityGroupListModel, final VmSessionsModel vmSessionsModel, final VmHostDeviceListModel vmHostDeviceListModel, final VmDevicesListModel vmDevicesListModel) {
    List<HasEntity<VM>> list = new ArrayList<>();
    list.add(vmGeneralModel);
    list.add(vmInterfaceListModel);
    vmDiskListModel.setSystemTreeContext(this);
    list.add(vmDiskListModel);
    list.add(vmSnapshotListModel);
    list.add(vmEventListModel);
    list.add(vmAppListModel);
    list.add(vmDevicesListModel);
    list.add(permissionListModel);
    list.add(vmAffinityGroupListModel);
    list.add(vmSessionsModel);
    list.add(vmHostDeviceListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangable(isChangable);
}
#method_after
private void updateRemoveDisksCheckBox(EntityModel model, boolean deleteDisks, boolean isChangable, String changeProhibitionReason) {
    model.setEntity(deleteDisks);
    if (!isChangable && changeProhibitionReason != null) {
        model.setChangeProhibitionReason(changeProhibitionReason);
    }
    model.setIsChangeable(isChangable);
}
#end_block

#method_before
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    BuilderExecutor.build(model, tempVar.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), tempVar.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder(), new MigrationOptionsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return tempVar;
}
#method_after
protected static VM buildVmOnNewTemplate(UnitVmModel model, VM vm) {
    VM resultVm = new VM();
    resultVm.setId(vm.getId());
    BuilderExecutor.build(model, resultVm.getStaticData(), new CommonUnitToVmBaseBuilder());
    BuilderExecutor.build(vm.getStaticData(), resultVm.getStaticData(), new KernelParamsVmBaseToVmBaseBuilder(), new DedicatedVmForVdsVmBaseToVmBaseBuilder(), new MigrationOptionsVmBaseToVmBaseBuilder(), new UsbPolicyVmBaseToVmBaseBuilder());
    return resultVm;
}
#end_block

#method_before
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#method_after
public VmManagementParametersBase getUpdateVmParameters(boolean applyCpuChangesLater) {
    UnitVmModel model = (UnitVmModel) getWindow();
    VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
    setVmWatchdogToParams(model, updateVmParams);
    updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
    updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    updateVmParams.setBalloonEnabled(balloonEnabled(model));
    updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    updateVmParams.setApplyChangesLater(applyCpuChangesLater);
    updateVmParams.setUpdateNuma(model.isNumaChanged());
    BuilderExecutor.build(new Pair<>((UnitVmModel) getWindow(), getSelectedItem()), updateVmParams, new VmIconUnitAndVmToParameterBuilder());
    setRngDeviceToParams(model, updateVmParams);
    BuilderExecutor.build(model, updateVmParams, new UnitToGraphicsDeviceParamsBuilder());
    return updateVmParams;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (command == getSetConsoleKeyCommand()) {
        editConsoleKey();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if ("OnSetConsoleKey".equals(command.getName())) {
        // $NON-NLS-1$
        onSetConsoleKey();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
private void onRestoreFromExportDomain() {
    ImportVmFromExportDomainModel importModel = (ImportVmFromExportDomainModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    cloneObjectMap = new HashMap<>();
    objectsToClone = new ArrayList<>();
    for (Object object : importModel.getItems()) {
        ImportEntityData<Object> item = (ImportEntityData<Object>) object;
        if (item.getClone().getEntity()) {
            objectsToClone.add(object);
        }
    }
    executeImportClone(importModel);
}
#method_after
private void onRestoreFromExportDomain() {
    ImportVmModel importModel = (ImportVmModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    importModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            getWindow().stopProgress();
            setWindow(null);
        }
    });
}
#end_block

#method_before
public void detach() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachVirtualMachinesTitle());
    model.setHelpTag(HelpTag.detach_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("detach_virtual_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (VM item : getSelectedItems()) {
        list.add(item.getName());
    }
    Collections.sort(list);
    model.setItems(list);
    if (list.size() == getEntity().getAssignedVmsCount()) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangable(true);
        model.setNote(ConstantsManager.getInstance().getConstants().detachAllVmsWarning());
    }
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSurYouWantToDetachSelectedVirtualMachinesMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void detach() {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().detachVirtualMachinesTitle());
    model.setHelpTag(HelpTag.detach_virtual_machine);
    // $NON-NLS-1$
    model.setHashName("detach_virtual_machine");
    ArrayList<String> list = new ArrayList<String>();
    for (VM item : getSelectedItems()) {
        list.add(item.getName());
    }
    Collections.sort(list);
    model.setItems(list);
    if (list.size() == getEntity().getAssignedVmsCount()) {
        model.getLatch().setIsAvailable(true);
        model.getLatch().setIsChangeable(true);
        model.setNote(ConstantsManager.getInstance().getConstants().detachAllVmsWarning());
    }
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSurYouWantToDetachSelectedVirtualMachinesMsg());
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnDetach", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<ImportCloneDialogPresenterWidget> importClonePopupProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if (source.getConfirmWindow() instanceof ImportCloneModel) {
                return importClonePopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return nextRunProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#method_after
// Main List Model
@Provides
@Singleton
public MainModelProvider<VM, VmListModel<Void>> getVmListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AssignTagsPopupPresenterWidget> assignTagsPopupProvider, final Provider<VmMakeTemplatePopupPresenterWidget> makeTemplatePopupProvider, final Provider<VmRunOncePopupPresenterWidget> runOncePopupProvider, final Provider<VmChangeCDPopupPresenterWidget> changeCDPopupProvider, final Provider<PublicKeyPopupPresenterWidget> publicKeyPopupProvider, final Provider<VmExportPopupPresenterWidget> exportPopupProvider, final Provider<VmSnapshotCreatePopupPresenterWidget> createSnapshotPopupProvider, final Provider<VmMigratePopupPresenterWidget> migratePopupProvider, final Provider<VmPopupPresenterWidget> newVmPopupProvider, final Provider<GuidePopupPresenterWidget> guidePopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<VmRemovePopupPresenterWidget> vmRemoveConfirmPopupProvider, final Provider<ReportPresenterWidget> reportWindowProvider, final Provider<ConsolePopupPresenterWidget> consolePopupProvider, final Provider<VncInfoPopupPresenterWidget> vncWindoProvider, final Provider<VmNextRunConfigurationPresenterWidget> nextRunProvider, final Provider<ImportVmsPopupPresenterWidget> importVmsProvider, final Provider<CloneVmPopupPresenterWidget> cloneVmProvider, final Provider<ImportVmFromExportDomainPopupPresenterWidget> importVmFromExportDomainPopupProvider, final Provider<VmListModel<Void>> modelProvider, final Provider<CommonModel> commonModelProvider, final Provider<VmDiskPopupPresenterWidget> newDiskPopupProvider, final Provider<SingleSelectionVmDiskAttachPopupPresenterWidget> attachDiskPopupProvider, final Provider<VmDiskRemovePopupPresenterWidget> removeDiskConfirmPopupProvider) {
    MainTabModelProvider<VM, VmListModel<Void>> result = new MainTabModelProvider<VM, VmListModel<Void>>(eventBus, defaultConfirmPopupProvider, commonModelProvider) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAssignTagsCommand()) {
                return assignTagsPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getNewTemplateCommand()) {
                return makeTemplatePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRunOnceCommand()) {
                return runOncePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getChangeCdCommand()) {
                return changeCDPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getSetConsoleKeyCommand()) {
                return publicKeyPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getExportCommand()) {
                return exportPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCreateSnapshotCommand()) {
                return createSnapshotPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getMigrateCommand()) {
                return migratePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand() || lastExecutedCommand == getModel().getNewVmCommand() || "OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                if (windowModel instanceof AttachDiskModel) {
                    return attachDiskPopupProvider.get();
                } else if ((windowModel instanceof NewDiskModel) || (windowModel instanceof EditDiskModel)) {
                    return newDiskPopupProvider.get();
                } else {
                    return newVmPopupProvider.get();
                }
            } else if (lastExecutedCommand == getModel().getGuideCommand()) {
                return guidePopupProvider.get();
            } else if (windowModel instanceof VncInfoModel) {
                return vncWindoProvider.get();
            } else if (lastExecutedCommand == getModel().getEditConsoleCommand()) {
                return consolePopupProvider.get();
            } else if (lastExecutedCommand == getModel().getCloneVmCommand()) {
                return cloneVmProvider.get();
            } else if (lastExecutedCommand == getModel().getImportVmCommand() || windowModel instanceof ImportVmsModel) {
                return importVmsProvider.get();
            } else if (windowModel instanceof ImportVmFromExportDomainModel) {
                return importVmFromExportDomainPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VmListModel<Void> source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return vmRemoveConfirmPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getStopCommand() || lastExecutedCommand == getModel().getShutdownCommand()) {
                return removeConfirmPopupProvider.get();
            } else if ("OnSave".equals(lastExecutedCommand.getName())) {
                // $NON-NLS-1$
                return nextRunProvider.get();
            } else if (lastExecutedCommand == getModel().getEditCommand()) {
                return removeDiskConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }

        @Override
        protected ModelBoundPresenterWidget<? extends Model> getModelBoundWidget(UICommand lastExecutedCommand) {
            if (lastExecutedCommand instanceof ReportCommand) {
                return reportWindowProvider.get();
            } else {
                return super.getModelBoundWidget(lastExecutedCommand);
            }
        }
    };
    result.setModelProvider(modelProvider);
    return result;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmSessionsModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#method_after
@Override
protected void configure() {
    bind(new TypeLiteral<VmListModel<Void>>() {
    }).in(Singleton.class);
    bind(VmGeneralModel.class).in(Singleton.class);
    bind(VmImportGeneralModel.class).in(Singleton.class);
    bind(VmSessionsModel.class).in(Singleton.class);
    bind(VmDiskListModel.class).in(Singleton.class);
    bind(VmInterfaceListModel.class).in(Singleton.class);
    bind(VmEventListModel.class).in(Singleton.class);
    bind(VmSnapshotListModel.class).in(Singleton.class);
    bind(VmAffinityGroupListModel.class).in(Singleton.class);
    bind(new TypeLiteral<VmAppListModel<VM>>() {
    }).in(Singleton.class);
    bind(VmHostDeviceListModel.class).in(Singleton.class);
    bind(new TypeLiteral<PermissionListModel<VM>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<VmDevicesListModel<VM>>() {
    }).in(Singleton.class);
    // Form Detail Models
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<ImportVmsModel, VmImportGeneralModel>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<DetailModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).to(new TypeLiteral<DetailTabModelProvider<VmListModel<Void>, VmSessionsModel>>() {
    }).in(Singleton.class);
    // Search-able Detail Models
    bind(new TypeLiteral<SearchableDetailModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<String, VmListModel<Void>, VmAppListModel<VM>>>() {
    }).in(Singleton.class);
    // Permission Detail Model
    bind(new TypeLiteral<SearchableDetailModelProvider<Permission, VmListModel<Void>, PermissionListModel<VM>>>() {
    }).to(new TypeLiteral<PermissionModelProvider<VM, VmListModel<Void>>>() {
    }).in(Singleton.class);
    bind(new TypeLiteral<SearchableDetailModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).to(new TypeLiteral<SearchableDetailTabModelProvider<VmDevice, VmListModel<Void>, VmDevicesListModel<VM>>>() {
    }).in(Singleton.class);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDevice entity) {
    return createIdParameterMapper(entity.getId()).addValue("device", entity.getDevice()).addValue("type", entity.getType().getValue()).addValue("address", entity.getAddress()).addValue("boot_order", entity.getBootOrder()).addValue("spec_params", SerializationFactory.getSerializer().serialize(entity.getSpecParams())).addValue("is_managed", entity.getIsManaged()).addValue("is_plugged", entity.getIsPlugged()).addValue("is_readonly", entity.getIsReadOnly()).addValue("alias", entity.getAlias()).addValue("custom_properties", SerializationFactory.getSerializer().serialize(entity.getCustomProperties())).addValue("snapshot_id", entity.getSnapshotId()).addValue("logical_name", entity.getLogicalName()).addValue("is_using_scsi_reservation", entity.isUsingScsiReservation());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    return vmDevice;
}
#method_after
@SuppressWarnings("unchecked")
@Override
public VmDevice mapRow(ResultSet rs, int rowNum) throws SQLException {
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(new VmDeviceId(getGuidDefaultEmpty(rs, "device_id"), getGuidDefaultEmpty(rs, "vm_id")));
    vmDevice.setDevice(rs.getString("device"));
    vmDevice.setType(VmDeviceGeneralType.forValue(rs.getString("type")));
    vmDevice.setAddress(rs.getString("address"));
    vmDevice.setBootOrder(rs.getInt("boot_order"));
    vmDevice.setSpecParams(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("spec_params"), HashMap.class));
    vmDevice.setIsManaged(rs.getBoolean("is_managed"));
    // note - those columns are being used also in DiskVmRowMapper, therefore any related
    // change should be done there as well.
    vmDevice.setIsPlugged(rs.getBoolean("is_plugged"));
    vmDevice.setIsReadOnly(rs.getBoolean("is_readonly"));
    vmDevice.setAlias(rs.getString("alias"));
    vmDevice.setCustomProperties(SerializationFactory.getDeserializer().deserializeOrCreateNew(rs.getString("custom_properties"), LinkedHashMap.class));
    vmDevice.setSnapshotId(getGuid(rs, "snapshot_id"));
    vmDevice.setLogicalName(rs.getString("logical_name"));
    vmDevice.setUsingScsiReservation(rs.getBoolean("is_using_scsi_reservation"));
    return vmDevice;
}
#end_block

#method_before
@Override
protected VmDevice generateNewEntity() {
    Map<String, String> customProp = new LinkedHashMap<>();
    customProp.put("prop1", "value1");
    return new VmDevice(new VmDeviceId(Guid.newGuid(), EXISTING_VM_ID), VmDeviceGeneralType.DISK, "floppy", "type:'drive', controller:'0', bus:'0', unit:'1'", 2, new HashMap<String, Object>(), true, false, false, "alias", customProp, null, null);
}
#method_after
@Override
protected VmDevice generateNewEntity() {
    return createVmDevice(EXISTING_VM_ID);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOVE_BRICK_FROM_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    if (getGlusterVolume().getVolumeType().isDistributedDispersedType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOVE_BRICK_FROM_DISTRIBUTED_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    GlusterBrickValidator brickValidator = new GlusterBrickValidator();
    return validate(brickValidator.canRemoveBrick(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount(), true));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOVE_BRICK_FROM_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    GlusterBrickValidator brickValidator = new GlusterBrickValidator();
    return validate(brickValidator.canRemoveBrick(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount(), true));
}
#end_block

#method_before
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
        allowAdd = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.DISPERSE || volumeEntity.getVolumeType() == GlusterVolumeType.DISTRIBUTED_DISPERSE) {
            allowRemove = false;
            allowAdd = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#method_after
private void updateActionAvailability() {
    GlusterVolumeEntity volumeEntity = getEntity();
    boolean allowRemove = true;
    boolean allowReplace = true;
    boolean allowAdvanced = true;
    boolean allowAdd = true;
    if (volumeEntity == null || volumeEntity.getVolumeType().isDispersedType()) {
        allowRemove = false;
        allowAdd = false;
    }
    if (volumeEntity == null || getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowRemove = false;
        allowReplace = false;
        allowAdvanced = false;
    } else {
        GlusterAsyncTask volumeTask = volumeEntity.getAsyncTask();
        if (volumeTask != null && (volumeTask.getStatus() == JobExecutionStatus.STARTED || volumeTask.getType() == GlusterTaskType.REMOVE_BRICK && volumeTask.getStatus() == JobExecutionStatus.FINISHED)) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.STRIPE || getSelectedItems().size() == volumeEntity.getBricks().size()) {
            allowRemove = false;
        } else if (volumeEntity.getVolumeType() == GlusterVolumeType.REPLICATE && (volumeEntity.getBricks().size() == VolumeListModel.REPLICATE_COUNT_DEFAULT || getSelectedItems().size() > 1)) {
            allowRemove = false;
        }
        if (getSelectedItems().size() == 1) {
            allowReplace = true;
            allowAdvanced = volumeEntity.isOnline() && getSelectedItems().get(0).isOnline();
        } else {
            allowReplace = false;
            allowAdvanced = false;
        }
    }
    getRemoveBricksCommand().setIsExecutionAllowed(allowRemove);
    getReplaceBrickCommand().setIsExecutionAllowed(allowReplace);
    getBrickAdvancedDetailsCommand().setIsExecutionAllowed(allowAdvanced);
    getAddBricksCommand().setIsExecutionAllowed(allowAdd);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeSnapshotConfig cfgParam = getParameters().getConfgParam();
    String paramValue = cfgParam.getParamValue().endsWith("%") ? cfgParam.getParamValue().substring(0, cfgParam.getParamValue().length() - 1) : cfgParam.getParamValue();
    if (cfgParam.getVolumeId() != null) {
        GlusterVolumeEntity volume = DbFacade.getInstance().getGlusterVolumeDao().getById(cfgParam.getVolumeId());
        status = getBroker().glusterVolumeSnapshotConfigSet(volume.getName(), cfgParam.getParamName(), paramValue);
    } else {
        status = getBroker().glusterSnapshotConfigSet(cfgParam.getParamName(), paramValue);
    }
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeSnapshotConfig cfgParam = getParameters().getConfgParam();
    String paramValue = StringUtils.removeEnd(cfgParam.getParamValue(), "%");
    if (cfgParam.getVolumeId() != null) {
        GlusterVolumeEntity volume = DbFacade.getInstance().getGlusterVolumeDao().getById(cfgParam.getVolumeId());
        status = getBroker().glusterVolumeSnapshotConfigSet(volume.getName(), cfgParam.getParamName(), paramValue);
    } else {
        status = getBroker().glusterSnapshotConfigSet(cfgParam.getParamName(), paramValue);
    }
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
public String render(T size) {
    if (size != null) {
        Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), SizeUnit.BYTES);
        // $NON-NLS-1$
        return MESSAGES.sizeUnitString(formatSize(sizeWithUnits.getSecond()), sizeWithUnits.getFirst());
    } else {
        return constants.notAvailableLabel();
    }
}
#method_after
@Override
public String render(T size) {
    if (size != null) {
        Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), SizeUnit.BYTES);
        // $NON-NLS-1$
        return messages.sizeUnitString(formatSize(sizeWithUnits.getSecond()), sizeWithUnits.getFirst());
    } else {
        return constants.notAvailableLabel();
    }
}
#end_block

#method_before
protected void initTableColumns() {
    // Table Entity Columns
    deviceTable.addColumn(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            return entity.getName();
        }
    }, constants.deviceName());
    deviceTable.addColumnAndSetWidth(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            return entity.getDevType();
        }
    }, constants.deviceType(), // $NON-NLS-1$
    "100px");
    deviceTable.addColumnAndSetWidth(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            Pair<SizeUnit, Double> convertedSize = SizeConverter.autoConvert(entity.getSize(), SizeUnit.MB);
            // $NON-NLS-1$
            return messages.sizeUnitString(formatSize(convertedSize.getSecond()), convertedSize.getFirst());
        }
    }, constants.size(), // $NON-NLS-1$
    "100px");
}
#method_after
protected void initTableColumns() {
    // Table Entity Columns
    deviceTable.addColumn(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            return entity.getName();
        }
    }, constants.deviceName());
    deviceTable.addColumnAndSetWidth(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            return entity.getDevType();
        }
    }, constants.deviceType(), // $NON-NLS-1$
    "100px");
    deviceTable.addColumnAndSetWidth(new AbstractTextColumn<StorageDevice>() {

        @Override
        public String getValue(StorageDevice entity) {
            Pair<SizeUnit, Double> convertedSize = SizeConverter.autoConvert(entity.getSize(), SizeUnit.MiB);
            // $NON-NLS-1$
            return messages.sizeUnitString(formatSize(convertedSize.getSecond()), convertedSize.getFirst());
        }
    }, constants.size(), // $NON-NLS-1$
    "100px");
}
#end_block

#method_before
protected String getSizeString(Double size, SizeUnit inUnit) {
    if (size == null) {
        return constants.notAvailableLabel();
    } else {
        Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), inUnit);
        // $NON-NLS-1$
        return MESSAGES.sizeUnitString(formatSize(sizeWithUnits.getSecond()), sizeWithUnits.getFirst());
    }
}
#method_after
protected String getSizeString(Double size, SizeUnit inUnit) {
    if (size == null) {
        return constants.notAvailableLabel();
    } else {
        Pair<SizeUnit, Double> sizeWithUnits = SizeConverter.autoConvert(size.longValue(), inUnit);
        // $NON-NLS-1$
        return ConstantsManager.getInstance().getMessages().sizeUnitString(formatSize(sizeWithUnits.getSecond()), sizeWithUnits.getFirst());
    }
}
#end_block

#method_before
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        org.ovirt.engine.core.common.businessentities.VM entity = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid), id, true);
        vm = addLinks(populate(VmMapper.map(entity, null, false), entity));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    DisplayHelper.adjustDisplayData(this, vm);
    return removeRestrictedInfo(vm);
}
#method_after
@Override
public VM get() {
    VM vm;
    if (isNextRunRequested()) {
        org.ovirt.engine.core.common.businessentities.VM entity = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmNextRunConfiguration, new IdQueryParameters(guid), id, true);
        vm = addLinks(populate(VmMapper.map(entity, null, false), entity));
    } else {
        vm = performGet(VdcQueryType.GetVmByVmId, new IdQueryParameters(guid));
    }
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#end_block

#method_before
private VM removeRestrictedInfo(VM vm) {
    // Filtered users are not allowed to view host related information
    if (vm != null && isFiltered()) {
        vm.setHost(null);
        vm.setPlacementPolicy(null);
    }
    return vm;
}
#method_after
private void removeRestrictedInfo(VM vm) {
    // Filtered users are not allowed to view host related information
    if (isFiltered()) {
        vm.setHost(null);
        vm.setPlacementPolicy(null);
    }
}
#end_block

#method_before
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    return removeRestrictedInfo(performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider()));
}
#method_after
@Override
public VM update(VM incoming) {
    validateEnums(VM.class, incoming);
    validateParameters(incoming);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.toString().equals(get().getCluster().getId())) {
            performAction(VdcActionType.ChangeVMCluster, new ChangeVMClusterParameters(clusterId, guid));
        }
    }
    if (!isFiltered()) {
        // resolve the host's ID, because it will be needed down the line
        if (incoming.isSetPlacementPolicy() && incoming.getPlacementPolicy().isSetHost() && incoming.getPlacementPolicy().getHost().isSetName() && !incoming.getPlacementPolicy().getHost().isSetId()) {
            incoming.getPlacementPolicy().getHost().setId(getHostId(incoming.getPlacementPolicy().getHost().getName()));
        }
    } else {
        incoming.setPlacementPolicy(null);
    }
    VM vm = performUpdate(incoming, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class), VdcActionType.UpdateVm, new UpdateParametersProvider());
    if (vm != null) {
        DisplayHelper.adjustDisplayData(this, vm);
        removeRestrictedInfo(vm);
    }
    return vm;
}
#end_block

#method_before
@Override
public GraphicsConsoles list() {
    VM vm = getEntity(VM.class, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), guid.toString(), true);
    return VmMapper.map(vm, new GraphicsConsoles());
}
#method_after
@Override
public GraphicsConsoles list() {
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), guid.toString(), true);
    GraphicsConsoles consoles = new GraphicsConsoles();
    for (Map.Entry<GraphicsType, GraphicsInfo> graphicsInfo : vm.getGraphicsInfos().entrySet()) {
        consoles.getGraphicsConsoles().add(addLinks(populate(VmMapper.map(graphicsInfo, null), vm)));
    }
    return consoles;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm.getTemplate());
            VmTemplate templateEntity = lookupTemplate(templateId);
            VDSGroup cluster = getCluster(vm);
            VmStatic builtFromTemplate = VmMapper.map(templateEntity, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(templateEntity.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            org.ovirt.engine.core.common.businessentities.InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                Mapper<org.ovirt.engine.core.common.businessentities.InstanceType, VmStatic> instanceTypeMapper = getMapper(org.ovirt.engine.core.common.businessentities.InstanceType.class, VmStatic.class);
                instanceTypeEntity = lookupInstanceType(getTemplateId(vm.getInstanceType()));
                builtFromInstanceType = instanceTypeMapper.map(instanceTypeEntity, builtFromTemplate);
                builtFromInstanceType.setInstanceTypeId(getTemplateId(vm.getInstanceType()));
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && templateId.equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateEntity, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateEntity, instanceTypeEntity, cluster);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm.getTemplate());
            VmTemplate templateEntity = lookupTemplate(templateId);
            VDSGroup cluster = getCluster(vm);
            VmStatic builtFromTemplate = VmMapper.map(templateEntity, null, cluster.getCompatibilityVersion());
            // since the template cpu_profile doesn't match cluster.
            if (!vm.isSetCpuProfile() && vm.isSetCluster() && !ObjectUtils.equals(templateEntity.getVdsGroupId(), vm.getCluster().getId())) {
                builtFromTemplate.setCpuProfileId(null);
            }
            VmStatic builtFromInstanceType = null;
            org.ovirt.engine.core.common.businessentities.InstanceType instanceTypeEntity = null;
            if (vm.isSetInstanceType() && (vm.getInstanceType().isSetId() || vm.getInstanceType().isSetName())) {
                Mapper<org.ovirt.engine.core.common.businessentities.InstanceType, VmStatic> instanceTypeMapper = getMapper(org.ovirt.engine.core.common.businessentities.InstanceType.class, VmStatic.class);
                instanceTypeEntity = lookupInstanceType(getTemplateId(vm.getInstanceType()));
                builtFromInstanceType = instanceTypeMapper.map(instanceTypeEntity, builtFromTemplate);
                builtFromInstanceType.setInstanceTypeId(getTemplateId(vm.getInstanceType()));
            }
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, builtFromInstanceType != null ? builtFromInstanceType : builtFromTemplate);
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(cluster.getId());
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster.getCompatibilityVersion()));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            // migration support (disabling it in architectures that do not support this feature)
            if (!vm.isSetPlacementPolicy() && templateId.equals(Guid.Empty)) {
                staticVm.setMigrationSupport(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateEntity, instanceTypeEntity, cluster);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, instanceTypeEntity, cluster);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateEntity, instanceTypeEntity, cluster);
            }
        }
    }
    VM result = (VM) response.getEntity();
    if (result != null) {
        DisplayHelper.adjustDisplayData(this, result);
        removeRestrictedInfo(result);
    }
    return response;
}
#end_block

#method_before
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Vm
        IdsQueryParameters params = new IdsQueryParameters();
        List<Guid> ids = Entities.getIds(entities);
        params.setId(ids);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
                vm.setVmInit(initMap.get(vm.getId()));
            }
        }
    }
    VMs collection = new VMs();
    if (includeData) {
        for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
            VM vm = map(entity);
            DisplayHelper.adjustDisplayData(this, vm);
            // Filtered users are not allowed to view host related information
            if (isFiltered) {
                removeRestrictedInfoFromVM(vm);
            }
            collection.getVMs().add(addLinks(populate(vm, entity)));
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#method_after
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    Set<String> details = DetailHelper.getDetails(httpHeaders, uriInfo);
    boolean includeData = details.contains(DetailHelper.MAIN);
    boolean includeSize = details.contains("size");
    if (includeData) {
        // Fill VmInit for entities - the search query no join the VmInit to Vm
        IdsQueryParameters params = new IdsQueryParameters();
        List<Guid> ids = Entities.getIds(entities);
        params.setId(ids);
        VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
        if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
            List<VmInit> vmInits = queryReturnValue.getReturnValue();
            Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
            for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
                vm.setVmInit(initMap.get(vm.getId()));
            }
        }
    }
    VMs collection = new VMs();
    if (includeData) {
        for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
            VM vm = map(entity);
            DisplayHelper.adjustDisplayData(this, vm);
            removeRestrictedInfo(vm);
            collection.getVMs().add(addLinks(populate(vm, entity)));
        }
    }
    if (includeSize) {
        collection.setSize((long) entities.size());
    }
    return collection;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    mapVmBaseModelToEntity(staticVm, vm);
    if (!vm.isSetMemory() && staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetNumaTuneMode()) {
        NumaTuneMode mode = NumaTuneMode.fromValue(vm.getNumaTuneMode());
        if (mode != null) {
            staticVm.setNumaTuneMode(map(mode, null));
        }
    }
    if (vm.isSetExternalHostProvider()) {
        String providerId = vm.getExternalHostProvider().getId();
        staticVm.setProviderId(providerId == null ? null : GuidUtils.asGuid(providerId));
    }
    return staticVm;
}
#end_block

#method_before
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    return model;
}
#method_after
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template, boolean showDynamicInfo) {
    VM model = template != null ? template : new VM();
    mapVmBaseEntityToModel(model, entity.getStaticData());
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getInstanceTypeId() != null) {
        model.setInstanceType(new InstanceType());
        model.getInstanceType().setId(entity.getInstanceTypeId().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.isUseHostCpuFlags()) {
        model.getCpu().setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    model.getCpu().setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    model.getCpu().setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    model.setDisplay(new Display());
    // and dynamic value (current/last run value, that can be different in case of run-once or edit while running)
    if (showDynamicInfo && entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
    }
    // fill dynamic data
    if (entity.getDynamicData() != null && !entity.getStatus().isNotRunning()) {
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setRunOnce(entity.isRunOnce());
        org.ovirt.engine.core.common.businessentities.GraphicsType graphicsType = deriveGraphicsType(entity.getGraphicsInfos());
        if (graphicsType != null) {
            model.getDisplay().setType(DisplayMapper.map(graphicsType, null).value());
            GraphicsInfo graphicsInfo = entity.getGraphicsInfos().get(graphicsType);
            model.getDisplay().setAddress(graphicsInfo == null ? null : graphicsInfo.getIp());
            Integer displayPort = graphicsInfo == null ? null : graphicsInfo.getPort();
            model.getDisplay().setPort(displayPort == null || displayPort.equals(-1) ? null : displayPort);
            Integer displaySecurePort = graphicsInfo == null ? null : graphicsInfo.getTlsPort();
            model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort.equals(-1) ? null : displaySecurePort);
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    model.getDisplay().setMonitors(entity.getNumOfMonitors());
    model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
    model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
    model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    model.getDisplay().setFileTransferEnabled(entity.isSpiceFileTransferEnabled());
    model.getDisplay().setCopyPasteEnabled(entity.isSpiceCopyPasteEnabled());
    model.getDisplay().setProxy(getEffectiveSpiceProxy(entity));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
    }
    model.setNextRunConfigurationExists(entity.isNextRunConfigurationExists());
    model.setNumaTuneMode(map(entity.getNumaTuneMode(), null));
    if (entity.getProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getProviderId().toString());
    }
    return model;
}
#end_block

#method_before
// for backwards compatibility
// returns graphics type of a running vm (can be different than static graphics in vm device due to run once)
public static GraphicsType deriveGraphicsType(Map<GraphicsType, GraphicsInfo> graphicsInfos) {
    if (graphicsInfos != null) {
        if (graphicsInfos.containsKey(GraphicsType.SPICE)) {
            return GraphicsType.SPICE;
        }
        if (graphicsInfos.containsKey(GraphicsType.VNC)) {
            return GraphicsType.VNC;
        }
    }
    return null;
}
#method_after
// for backwards compatibility
// returns graphics type of a running vm (can be different than static graphics in vm device due to run once)
public static org.ovirt.engine.core.common.businessentities.GraphicsType deriveGraphicsType(Map<org.ovirt.engine.core.common.businessentities.GraphicsType, GraphicsInfo> graphicsInfos) {
    if (graphicsInfos != null) {
        if (graphicsInfos.containsKey(org.ovirt.engine.core.common.businessentities.GraphicsType.SPICE)) {
            return org.ovirt.engine.core.common.businessentities.GraphicsType.SPICE;
        }
        if (graphicsInfos.containsKey(org.ovirt.engine.core.common.businessentities.GraphicsType.VNC)) {
            return org.ovirt.engine.core.common.businessentities.GraphicsType.VNC;
        }
    }
    return null;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.NumaTuneMode.class, to = String.class)
public static String map(org.ovirt.engine.core.common.businessentities.NumaTuneMode mode, String incoming) {
    if (mode == null) {
        return null;
    }
    switch(mode) {
        case STRICT:
            return NumaTuneMode.STRICT.value();
        case INTERLEAVE:
            return NumaTuneMode.INTERLEAVE.value();
        case PREFERRED:
            return NumaTuneMode.PREFERRED.value();
        default:
            return null;
    }
}
#method_after
@Mapping(from = Map.Entry.class, to = GraphicsConsole.class)
public static GraphicsConsole map(Map.Entry<org.ovirt.engine.core.common.businessentities.GraphicsType, GraphicsInfo> graphicsInfo, GraphicsConsole template) {
    GraphicsConsole model = template != null ? template : new GraphicsConsole();
    String graphicsTypeString = map(graphicsInfo.getKey(), null).toString();
    if (graphicsTypeString != null) {
        model.setId(HexUtils.string2hex(graphicsTypeString));
        model.setProtocol(graphicsTypeString);
    }
    model.setPort(graphicsInfo.getValue().getPort());
    model.setTlsPort(graphicsInfo.getValue().getTlsPort());
    model.setAddress(graphicsInfo.getValue().getIp());
    return model;
}
#end_block

#method_before
public static VM map(String configuration, ConfigurationType type, VM vm) {
    vm.setInitialization(new Initialization());
    vm.getInitialization().setConfiguration(new Configuration());
    vm.getInitialization().getConfiguration().setData(configuration);
    vm.getInitialization().getConfiguration().setType(type.value());
    return vm;
}
#method_after
public static VM map(String data, ConfigurationType type, VM vm) {
    Initialization initialization = vm.getInitialization();
    if (initialization == null) {
        initialization = new Initialization();
        vm.setInitialization(initialization);
    }
    Configuration configuration = initialization.getConfiguration();
    if (configuration == null) {
        configuration = new Configuration();
        initialization.setConfiguration(configuration);
    }
    configuration.setData(data);
    configuration.setType(type.value());
    return vm;
}
#end_block

#method_before
@Override
public GraphicsConsole get() {
    for (GraphicsConsole graphicsConsole : parent.list().getGraphicsConsole()) {
        if (consoleId.equals(graphicsConsole.getId())) {
            return graphicsConsole;
        }
    }
    return null;
}
#method_after
@Override
public GraphicsConsole get() {
    List<String> supportedIds = new ArrayList<>();
    for (GraphicsConsole graphicsConsole : parent.list().getGraphicsConsoles()) {
        if (consoleId.equals(graphicsConsole.getId())) {
            return graphicsConsole;
        }
        supportedIds.add(graphicsConsole.getId());
    }
    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).build());
}
#end_block

#method_before
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(TabName.HOST_TAB, this.hostTab);
    getTabNameMapping().put(TabName.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(TabName.POOL_TAB, this.poolTab);
    getTabNameMapping().put(TabName.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(TabName.SYSTEM_TAB, this.systemTab);
}
#method_after
protected void populateTabMap() {
    getTabNameMapping().put(TabName.GENERAL_TAB, generalTab);
    getTabNameMapping().put(TabName.BOOT_OPTIONS_TAB, this.bootOptionsTab);
    getTabNameMapping().put(TabName.CONSOLE_TAB, this.consoleTab);
    getTabNameMapping().put(TabName.CUSTOM_PROPERTIES_TAB, this.customPropertiesTab);
    getTabNameMapping().put(TabName.HIGH_AVAILABILITY_TAB, this.highAvailabilityTab);
    getTabNameMapping().put(TabName.HOST_TAB, this.hostTab);
    getTabNameMapping().put(TabName.INITIAL_RUN_TAB, this.initialRunTab);
    getTabNameMapping().put(TabName.POOL_TAB, this.poolTab);
    getTabNameMapping().put(TabName.RESOURCE_ALLOCATION_TAB, this.resourceAllocationTab);
    getTabNameMapping().put(TabName.SYSTEM_TAB, this.systemTab);
    getTabNameMapping().put(TabName.ICON_TAB, this.iconTab);
}
#end_block

#method_before
private void initDetachableFields() {
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.RIGHT);
    StringEntityModelLabel rnglabel = new StringEntityModelLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#method_after
private void initDetachableFields() {
    detachableInstanceTypesEditor = new EntityModelDetachableWidgetWithLabel(instanceTypesEditor);
    detachableMemSizeEditor = new EntityModelDetachableWidgetWithLabel(memSizeEditor);
    isHighlyAvailableEditorWithDetachable = new EntityModelDetachableWidget(isHighlyAvailableEditor, Align.RIGHT);
    overrideMigrationDowntimeEditorWithDetachable = new EntityModelDetachableWidget(overrideMigrationDowntimeEditor, Align.IGNORE);
    overrideMigrationDowntimeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    overrideMigrationDowntimeEditor.getContentWidgetContainer().getElement().getStyle().setWidth(20, Unit.PX);
    migrationModeEditorWithDetachable = new EntityModelDetachableWidget(migrationModeEditor, Align.IGNORE);
    migrationModeEditorWithDetachable.setupContentWrapper(Align.RIGHT);
    StringEntityModelLabel rnglabel = new StringEntityModelLabel();
    rnglabel.setText(constants.rngDevEnabled());
    isRngEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(rnglabel, isRngEnabledEditor);
    isRngEnabledCheckboxWithInfoIcon.setExplanation(SafeHtmlUtils.fromTrustedString(constants.rngDevExplanation()));
}
#end_block

#method_before
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    // $NON-NLS-1$
    label.addStyleName("numCPUs_pfly_fix");
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#method_after
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    // $NON-NLS-1$
    label.addStyleName("numCPUs_pfly_fix");
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelDetachableWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(templates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#end_block

#method_before
public void setSpiceProxyOverrideExplanation(String explanation) {
    spiceProxyEnabledCheckboxWithInfoIcon.setExplanation(applicationTemplates.italicText(explanation));
}
#method_after
public void setSpiceProxyOverrideExplanation(String explanation) {
    spiceProxyEnabledCheckboxWithInfoIcon.setExplanation(templates.italicText(explanation));
}
#end_block

#method_before
protected void initPoolSpecificWidgets(CommonApplicationResources resources, final CommonApplicationMessages messages) {
    createNumOfDesktopEditors();
    incraseNumOfVmsEditor.setKeepTitleOnSetEnabled(true);
    numOfVmsEditor.setKeepTitleOnSetEnabled(true);
    newPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    editPoolPrestartedVmsIcon = new InfoIcon(applicationTemplates.italicText(messages.prestartedHelp()), resources);
    poolNameIcon = new InfoIcon(applicationTemplates.italicText(messages.poolNameHelp()), resources);
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(applicationTemplates.italicText(messages.maxAssignedVmsPerUserHelp()), resources);
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // $NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""), resources);
}
#method_after
protected void initPoolSpecificWidgets() {
    createNumOfDesktopEditors();
    newPoolPrestartedVmsIcon = new InfoIcon(templates.italicText(messages.prestartedHelp()));
    editPoolPrestartedVmsIcon = new InfoIcon(templates.italicText(messages.prestartedHelp()));
    poolNameIcon = new InfoIcon(templates.italicText(messages.poolNameHelp()));
    newPoolMaxAssignedVmsPerUserIcon = new InfoIcon(templates.italicText(messages.maxAssignedVmsPerUserHelp()));
    editPoolMaxAssignedVmsPerUserIcon = new InfoIcon(templates.italicText(messages.maxAssignedVmsPerUserHelp()));
    outOfxInPool = new ValueLabel<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return messages.outOfXVMsInPool(object.toString());
        }
    });
    // $NON-NLS-1$
    numaInfoIcon = new InfoIcon(SafeHtmlUtils.fromTrustedString(""));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = constants.clusterDefaultOption();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    final UIConstants ui_constants = ConstantsManager.getInstance().getConstants();
    watchdogModelEditor = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = ui_constants.NoWatchdog();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), ui_constants.NoWatchdog());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = constants.clusterDefaultOption();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(applicationTemplates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return EnumTranslator.getInstance().get(object.getEntity());
        }
    }, new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<UnitVmModel.GraphicsTypes>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<CpuProfile>(new NullSafeRenderer<CpuProfile>() {

        @Override
        protected String renderNullSafe(CpuProfile object) {
            return object.getName();
        }
    });
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<NumaTuneMode>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateWithVersionEditor = new ListModelTypeAheadListBoxEditor<>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<TemplateWithVersion>() {

        @Override
        public String getReplacementStringNullSafe(TemplateWithVersion templateWithVersion) {
            return getFirstColumn(templateWithVersion) + // $NON-NLS-1$
            " | " + getSecondColumn(templateWithVersion);
        }

        @Override
        public String getDisplayStringNullSafe(TemplateWithVersion templateWithVersion) {
            return typeAheadNameDescriptionTemplateNullSafe(getFirstColumn(templateWithVersion), getSecondColumn(templateWithVersion));
        }

        private String getFirstColumn(TemplateWithVersion templateWithVersion) {
            return templateWithVersion.getBaseTemplate().getName();
        }

        private String getSecondColumn(TemplateWithVersion templateWithVersion) {
            final VmTemplate versionTemplate = templateWithVersion.getTemplateVersion();
            final String versionName = versionTemplate.getTemplateVersionName() == null ? // $NON-NLS-1$
            "" : // $NON-NLS-1$
            versionTemplate.getTemplateVersionName() + " ";
            return templateWithVersion.isLatest() ? constants.latest() : // $NON-NLS-1$
            versionName + "(" + versionTemplate.getTemplateVersionNumber() + // $NON-NLS-1$
            ")";
        }
    }, new ModeSwitchingVisibilityRenderer(), new SuggestionMatcher.ContainsSuggestionMatcher());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getInstance().getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer<VmType>(), new ModeSwitchingVisibilityRenderer());
    instanceTypesEditor = new ListModelTypeAheadListBoxEditor<InstanceType>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<InstanceType>() {

        @Override
        public String getReplacementStringNullSafe(InstanceType data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(InstanceType data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    emulatedMachine = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = constants.clusterDefaultOption();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    customCpu = new ListModelTypeAheadChangeableListBoxEditor(new ListModelTypeAheadChangeableListBoxEditor.NullSafeSuggestBoxRenderer() {

        @Override
        public String getDisplayStringNullSafe(String data) {
            if (data == null || data.trim().isEmpty()) {
                data = constants.clusterDefaultOption();
            }
            return typeAheadNameTemplateNullSafe(data);
        }
    }, false, new ModeSwitchingVisibilityRenderer(), constants.clusterDefaultOption());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(numOfSocketsEditor);
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditorWithDetachable = new EntityModelDetachableWidgetWithLabel(corePerSocketEditor);
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxOnlyEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.tzVmPopup());
    timeZoneEditorWithInfo = new EntityModelWidgetWithInfo<String>(label, timeZoneEditor);
    timeZoneEditorWithInfo.setExplanation(templates.italicText(constants.timeZoneInfo()));
    // Console tab
    displayTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<DisplayType>(), new ModeSwitchingVisibilityRenderer());
    graphicsTypeEditor = new ListModelListBoxEditor<>(new EnumRenderer<UnitVmModel.GraphicsTypes>());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer<UsbPolicy>(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<>(new NameRenderer<VDS>(), new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer<MigrationSupport>(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    autoConvergeEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.autoConverge(), constants.dontAutoConverge(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    migrateCompressedEditor = new ListModelListBoxEditor<Boolean>(new BooleanRendererWithNullText(constants.compress(), constants.dontCompress(), constants.inheritFromCluster()), new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuProfilesEditor = new ListModelListBoxEditor<>(new NameRenderer<CpuProfile>());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer<UnitVmModel.CpuSharesAmount>(), new ModeSwitchingVisibilityRenderer());
    numaTuneMode = new ListModelListBoxEditor<NumaTuneMode>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return applicationTemplates.typeAheadNameDescription(name != null ? name : "", description != null ? description : "").asString();
}
#method_after
private String typeAheadNameDescriptionTemplateNullSafe(String name, String description) {
    return templates.typeAheadNameDescription(name != null ? name : "", description != null ? description : "").asString();
}
#end_block

#method_before
private String typeAheadNameTemplateNullSafe(String name) {
    if (name != null && !name.trim().isEmpty()) {
        return applicationTemplates.typeAheadName(name).asString();
    } else {
        return applicationTemplates.typeAheadEmptyContent().asString();
    }
}
#method_after
private String typeAheadNameTemplateNullSafe(String name) {
    if (name != null && !name.trim().isEmpty()) {
        return templates.typeAheadName(name).asString();
    } else {
        return templates.typeAheadEmptyContent().asString();
    }
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    instanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
}
#method_after
protected void localize() {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    vmIdEditor.setLabel(constants.vmIdPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateWithVersionEditor.setLabel(constants.template());
    detachableInstanceTypesEditor.setLabel(constants.instanceType());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isIoThreadsEnabled.setLabel(constants.ioThreadsEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Rng device tab
    rngDeviceTab.setLabel(constants.rngDeviceTab());
    isRngEnabledEditor.setLabel(constants.rngDevEnabled());
    rngPeriodEditor.setLabel(constants.rngPeriod());
    rngBytesEditor.setLabel(constants.rngBytes());
    rngSourceRandom.setLabel(constants.rngSourceRandom());
    rngSourceHwrng.setLabel(constants.rngSourceHwrng());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayTypeEditor.setLabel(constants.videoType());
    graphicsTypeEditor.setLabel(constants.graphicsProtocol());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    spiceFileTransferEnabledEditor.setLabel(constants.spiceFileTransferEnabled());
    spiceCopyPasteEnabledEditor.setLabel(constants.spiceCopyPasteEnabled());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.passThroughHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // numa
    numaTuneMode.setLabel(constants.numaTunaModeLabel());
    numaNodeCount.setLabel(constants.numaNodeCountLabel());
    numaSupportButton.setLabel(constants.numaSupportButtonLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    cpuProfilesEditor.setLabel(constants.cpuProfileLabel());
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    numOfIoThreadsEditor.setLabel(constants.numOfIoThreadsVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    detachableMemSizeEditor.setLabel(constants.memSizeVmPopup());
    totalvCPUsEditor.setLabel(constants.numOfVCPUs());
    corePerSocketEditorWithDetachable.setLabel(constants.coresPerSocket());
    numOfSocketsEditorWithDetachable.setLabel(constants.numOfSockets());
    emulatedMachine.setLabel(constants.emulatedMachineLabel());
    customCpu.setLabel(constants.cpuModelLabel());
    // Icon tab
    iconTab.setLabel(constants.iconTabVmPopup());
}
#end_block

#method_before
protected void applyStyles() {
    hostCpuEditor.addContentWidgetStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetStyleName(style.cdAttachedLabelWidth());
    cdImageEditor.addContentWidgetStyleName(style.cdImageEditor());
    numOfMonitorsEditor.addContentWidgetStyleName(style.monitorsStyles());
    numOfMonitorsEditor.setStyleName(style.monitorsStyles());
    numOfMonitorsEditor.hideLabel();
    migrationModeEditor.addContentWidgetStyleName(style.migrationSelectorInner());
    isVirtioScsiEnabled.addContentWidgetStyleName(style.isVirtioScsiEnabledEditor());
}
#method_after
protected void applyStyles() {
    hostCpuEditor.addContentWidgetContainerStyleName(style.longCheckboxContent());
    allowConsoleReconnectEditor.addContentWidgetContainerStyleName(style.longCheckboxContent());
    provisioningEditor.addContentWidgetContainerStyleName(style.provisioningEditorContent());
    provisioningThinEditor.addContentWidgetContainerStyleName(style.provisioningRadioContent());
    provisioningCloneEditor.addContentWidgetContainerStyleName(style.provisioningRadioContent());
    cdAttachedEditor.addContentWidgetContainerStyleName(style.cdAttachedLabelWidth());
    cdImageEditor.addContentWidgetContainerStyleName(style.cdImageEditor());
    numOfMonitorsEditor.addContentWidgetContainerStyleName(style.monitorsStyles());
    numOfMonitorsEditor.setStyleName(style.monitorsStyles());
    numOfMonitorsEditor.hideLabel();
    migrationModeEditor.addContentWidgetContainerStyleName(style.migrationSelectorInner());
    isVirtioScsiEnabled.addContentWidgetContainerStyleName(style.isVirtioScsiEnabledEditor());
}
#end_block

#method_before
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#method_after
@Override
public void edit(UnitVmModel model) {
    super.edit(model);
    unitVmModel = model;
    super.initializeModeSwitching(generalTab);
    priorityEditor.setRowData(new ArrayList<EntityModel>());
    priorityEditor.asEditor().edit(model.getPriority());
    driver.edit(model);
    profilesInstanceTypeEditor.edit(model.getNicsWithLogicalNetworks());
    instanceImagesEditor.edit(model.getInstanceImages());
    customPropertiesSheetEditor.edit(model.getCustomPropertySheet());
    vmInitEditor.edit(model.getVmInitModel());
    serialNumberPolicyEditor.edit(model.getSerialNumberPolicy());
    initTabAvailabilityListeners(model);
    initListeners(model);
    hideAlwaysHiddenFields();
    decorateDetachableFields();
    enableNumaSupport(model);
}
#end_block

#method_before
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(applicationTemplates.italicText(message));
}
#method_after
private void setNumaInfoMsg(String message) {
    if (message == null) {
        // $NON-NLS-1$
        message = "";
    }
    numaInfoIcon.setText(templates.italicText(message));
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable);
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("SelectedItem".equals(args.propertyName)) {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if ("IsAvailable".equals(args.propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getCompatibilityVersion() != null) {
                boolean enabled = AsyncDataProvider.getInstance().isSerialNumberPolicySupported(vdsGroup.getCompatibilityVersion().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
    object.getIsRngEnabled().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            rngPanel.setVisible(object.getIsRngEnabled().getEntity());
        }
    });
}
#end_block

#method_before
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().get(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#method_after
private void updateDisksWarningByImageStatus(List<DiskModel> disks, ImageStatus imageStatus) {
    ArrayList<String> disksAliases = getDisksAliasesByImageStatus(disks, imageStatus);
    if (!disksAliases.isEmpty()) {
        generalWarningMessage.setText(messages.disksStatusWarning(EnumTranslator.getInstance().translate(imageStatus), // $NON-NLS-1$
        (StringUtils.join(disksAliases, ", "))));
    }
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    instanceTypesEditor.setTabIndexes(nextTabIndex++);
    templateWithVersionEditor.setTabIndexes(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    vmIdEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    emulatedMachine.setTabIndex(nextTabIndex++);
    customCpu.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayTypeEditor.setTabIndex(nextTabIndex++);
    graphicsTypeEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    spiceFileTransferEnabledEditor.setTabIndex(nextTabIndex++);
    spiceCopyPasteEnabledEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    autoConvergeEditor.setTabIndex(nextTabIndex++);
    migrateCompressedEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    numaNodeCount.setTabIndex(nextTabIndex++);
    numaTuneMode.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    cpuProfilesEditor.setTabIndex(nextTabIndex++);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    numOfIoThreadsEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Rng Tab==
    nextTabIndex = rngDeviceTab.setTabIndexes(nextTabIndex);
    isRngEnabledEditor.setTabIndex(nextTabIndex++);
    rngPeriodEditor.setTabIndex(nextTabIndex++);
    rngBytesEditor.setTabIndex(nextTabIndex++);
    rngSourceRandom.setTabIndex(nextTabIndex++);
    rngSourceHwrng.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    // ==Icon Tab==
    nextTabIndex = iconTab.setTabIndexes(nextTabIndex);
    iconEditorWidget.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(allTabs(), simpleField().visibleInAdvancedModeOnly()).putAll(adancedFieldsFromGeneralTab(), simpleField().visibleInAdvancedModeOnly()).putAll(consoleTabWidgets(), simpleField().visibleInAdvancedModeOnly()).update(consoleTab, simpleField()).update(numOfMonitorsEditor, simpleField()).update(isSingleQxlEnabledEditor, simpleField()).putOne(isSoundcardEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isConsoleDeviceEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceFileTransferEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(spiceCopyPasteEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(instanceImagesEditor, hiddenField());
}
#end_block

#method_before
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab);
}
#method_after
protected List<Widget> allTabs() {
    return Arrays.<Widget>asList(initialRunTab, consoleTab, hostTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, rngDeviceTab, highAvailabilityTab, poolTab, systemTab, iconTab);
}
#end_block

#method_before
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, detachableMemSizeEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#method_after
protected List<Widget> detachableWidgets() {
    return Arrays.<Widget>asList(totalvCPUsEditorWithInfoIcon, numOfSocketsEditorWithDetachable, corePerSocketEditorWithDetachable, isHighlyAvailableEditorWithDetachable, priorityLabelWithDetachable, migrationModeEditorWithDetachable, memAllocationLabel, ioThreadsLabel, detachableMemSizeEditor, detachableInstanceTypesEditor, overrideMigrationDowntimeEditorWithDetachable);
}
#end_block

#method_before
private List<DialogTab> allDialogTabs() {
    return Arrays.asList(generalTab, poolTab, initialRunTab, consoleTab, hostTab, highAvailabilityTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, systemTab, rngDeviceTab);
}
#method_after
private List<DialogTab> allDialogTabs() {
    return Arrays.asList(generalTab, poolTab, initialRunTab, consoleTab, hostTab, highAvailabilityTab, resourceAllocationTab, bootOptionsTab, customPropertiesTab, systemTab, rngDeviceTab, iconTab);
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getCpuProfiles().setIsChangable(false);
        getVmId().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplateWithVersion().setIsChangable(false);
        getInstanceTypes().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCustomCpu().setIsChangable(false);
        getEmulatedMachine().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==High Availability Tab==
        getWatchdogModelEditor().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayType().setIsChangable(false);
        getGraphicsType().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        getMigrationDowntime().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangable(false);
        getRngPeriod().setIsChangable(false);
        getRngBytes().setIsChangable(false);
        getRngSourceRandom().setIsChangable(false);
        getRngSourceHwrng().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        getCustomPropertySheet().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangeable(!value);
        getQuota().setIsChangeable(false);
        getCpuProfiles().setIsChangeable(false);
        getVmId().setIsChangeable(false);
        getNumOfDesktops().setIsChangeable(false);
        getPrestartedVms().setIsChangeable(false);
        getMaxAssignedVmsPerUser().setIsChangeable(false);
        getBaseTemplate().setIsChangeable(false);
        getTemplateWithVersion().setIsChangeable(false);
        getInstanceTypes().setIsChangeable(false);
        getMemSize().setIsChangeable(false);
        getTotalCPUCores().setIsChangeable(false);
        getCustomCpu().setIsChangeable(false);
        getEmulatedMachine().setIsChangeable(false);
        getCoresPerSocket().setIsChangeable(false);
        getNumOfSockets().setIsChangeable(false);
        getSerialNumberPolicy().setIsChangeable(false);
        getOSType().setIsChangeable(false);
        getIsStateless().setIsChangeable(false);
        getIsRunAndPause().setIsChangeable(false);
        getIsDeleteProtected().setIsChangeable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangeable(false);
        // ==Console Tab==
        getDisplayType().setIsChangeable(false);
        getGraphicsType().setIsChangeable(false);
        getUsbPolicy().setIsChangeable(false);
        getNumOfMonitors().setIsChangeable(false);
        getIsSingleQxlEnabled().setIsChangeable(false);
        getIsSmartcardEnabled().setIsChangeable(false);
        getAllowConsoleReconnect().setIsChangeable(false);
        getVncKeyboardLayout().setIsChangeable(false);
        getSsoMethodNone().setIsChangeable(false);
        getSsoMethodGuestAgent().setIsChangeable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangeable(false);
        getDefaultHost().setIsChangeable(false);
        getHostCpu().setIsChangeable(false);
        getMigrationMode().setIsChangeable(false);
        getCpuPinning().setIsChangeable(false);
        getMigrationDowntime().setIsChangeable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangeable(false);
        getProvisioning().setIsChangeable(false);
        getProvisioningThin_IsSelected().setIsChangeable(false);
        getProvisioningClone_IsSelected().setIsChangeable(false);
        getDisksAllocationModel().setIsChangeable(false);
        getIoThreadsEnabled().setIsChangeable(false);
        getNumOfIoThreads().setIsChangeable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangeable(false);
        getSecondBootDevice().setIsChangeable(false);
        getCdAttached().setIsChangeable(false);
        getCdImage().setIsChangeable(false);
        getKernel_path().setIsChangeable(false);
        getInitrd_path().setIsChangeable(false);
        getKernel_parameters().setIsChangeable(false);
        // ==Random Generator Tab==
        getIsRngEnabled().setIsChangeable(false);
        getRngPeriod().setIsChangeable(false);
        getRngBytes().setIsChangeable(false);
        getRngSourceRandom().setIsChangeable(false);
        getRngSourceHwrng().setIsChangeable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangeable(false);
        getCustomPropertySheet().setIsChangeable(false);
        // ==Icon Tab==
        getIcon().setIsChangeable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public ListModel<EntityModel<DisplayType>> getDisplayType() {
    return displayType;
}
#method_after
public ListModel<DisplayType> getDisplayType() {
    return displayType;
}
#end_block

#method_before
private void setDisplayType(NotChangableForVmInPoolListModel<EntityModel<DisplayType>> value) {
    displayType = value;
}
#method_after
private void setDisplayType(NotChangableForVmInPoolListModel<DisplayType> value) {
    displayType = value;
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
    getWatchdogModelEditor().setSelectedItem(null);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    isRngEnabled.setEntity(false);
    rngSourceRandom.setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangeable(true);
    getCdImage().setIsChangeable(false);
    initGraphicsAndDisplayListeners();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayAndGraphics();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getWatchdogModelEditor()) {
            watchdogModelEditor_SelectedItemChanged(sender, args);
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            displayTypeSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getWatchdogModelEditor()) {
            watchdogModelEditor_SelectedItemChanged(sender, args);
        } else if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModelEditor()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangable(true);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayAndGraphics();
            updateMemoryBalloonDevice();
            behavior.updateNumOfIoThreads();
            initUsbPolicy();
            behavior.updateEmulatedMachines();
            behavior.updateCustomCpu();
        } else if (sender == getTemplateWithVersion()) {
            templateWithVersion_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            getBehavior().deactivateInstanceTypeManager(new InstanceTypeManager.ActivatedListener() {

                @Override
                public void activated() {
                    if (getBehavior().getInstanceTypeManager() != null && !getBehavior().basedOnCustomInstanceType()) {
                        getBehavior().getInstanceTypeManager().updateFildsAfterOsChanged();
                    }
                }
            });
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayAndGraphics();
            updateMemoryBalloonDevice();
            initUsbPolicy();
            getBehavior().activateInstanceTypeManager();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayType()) {
            displayTypeSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getGraphicsType()) {
            upgradeGraphicsRelatedModels();
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        } else if (sender == getWatchdogModel()) {
            watchdogModelSelectedItemChanged(sender, args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getIoThreadsEnabled()) {
            behavior.updateNumOfIoThreads();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
            behavior.updateNumaEnabled();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        } else if (sender == getHostCpu()) {
            if (getHostCpu().getEntity() != null && getHostCpu().getEntity()) {
                getCustomCpu().setIsChangeable(false);
                // $NON-NLS-1$
                getCustomCpu().setSelectedItem("");
            } else {
                getCustomCpu().setIsChangeable(true);
            }
        }
    }
}
#end_block

#method_before
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = (getDisplayType().getSelectedItem() != null ? getDisplayType().getSelectedItem().getEntity() : null);
    GraphicsTypes graphicsTypes = getGraphicsType().getSelectedItem();
    if (osType == null || cluster == null || displayType == null || graphicsTypes == null) {
        return;
    }
    getUsbPolicy().setIsChangable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getCompatibilityVersion()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getCompatibilityVersion()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (!graphicsTypes.getBackingGraphicsType().contains(GraphicsType.SPICE)) {
        getUsbPolicy().setIsChangable(false);
    }
    if (getBehavior().basedOnCustomInstanceType()) {
        Collection<UsbPolicy> policies = getUsbPolicy().getItems();
        if (policies.contains(prevSelectedUsbPolicy)) {
            getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
        } else if (policies.size() > 0) {
            getUsbPolicy().setSelectedItem(policies.iterator().next());
        }
    }
}
#method_after
private void initUsbPolicy() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    DisplayType displayType = getDisplayType().getSelectedItem();
    GraphicsTypes graphicsTypes = getGraphicsType().getSelectedItem();
    if (osType == null || cluster == null || displayType == null || graphicsTypes == null) {
        return;
    }
    getUsbPolicy().setIsChangeable(true);
    UsbPolicy prevSelectedUsbPolicy = getUsbPolicy().getSelectedItem();
    if (Version.v3_1.compareTo(cluster.getCompatibilityVersion()) > 0) {
        if (AsyncDataProvider.getInstance().isWindowsOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED));
            getUsbPolicy().setIsChangeable(false);
        }
    }
    if (Version.v3_1.compareTo(cluster.getCompatibilityVersion()) <= 0) {
        if (AsyncDataProvider.getInstance().isLinuxOsType(osType)) {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_NATIVE));
        } else {
            getUsbPolicy().setItems(Arrays.asList(UsbPolicy.DISABLED, UsbPolicy.ENABLED_LEGACY, UsbPolicy.ENABLED_NATIVE));
        }
    }
    if (!graphicsTypes.getBackingGraphicsTypes().contains(GraphicsType.SPICE)) {
        getUsbPolicy().setIsChangeable(false);
    }
    if (getBehavior().basedOnCustomInstanceType()) {
        Collection<UsbPolicy> policies = getUsbPolicy().getItems();
        if (policies.contains(prevSelectedUsbPolicy)) {
            getUsbPolicy().setSelectedItem(prevSelectedUsbPolicy);
        } else if (policies.size() > 0) {
            getUsbPolicy().setSelectedItem(policies.iterator().next());
        }
    }
}
#end_block

#method_before
public void initDisplayModels(List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    DisplayType oldDisplayProtocolOption = null;
    EntityModel<DisplayType> oldDisplayProtocolEntity = null;
    if (getDisplayType().getSelectedItem() != null) {
        oldDisplayProtocolOption = getDisplayType().getSelectedItem().getEntity();
    }
    SortedSet<DisplayType> displayTypes = new TreeSet<DisplayType>();
    for (Pair<GraphicsType, DisplayType> graphicsTypeDisplayTypePair : graphicsAndDisplays) {
        displayTypes.add(graphicsTypeDisplayTypePair.getSecond());
    }
    List<EntityModel<DisplayType>> displayTypeOptions = new ArrayList<EntityModel<DisplayType>>();
    for (DisplayType displayType : displayTypes) {
        EntityModel<DisplayType> displayTypeEntityModel = new EntityModel<DisplayType>(displayType);
        displayTypeEntityModel.setTitle(displayType.name());
        displayTypeOptions.add(displayTypeEntityModel);
        if (oldDisplayProtocolOption == displayTypeEntityModel.getEntity()) {
            oldDisplayProtocolEntity = new EntityModel<DisplayType>(oldDisplayProtocolOption);
        }
    }
    if (displayTypeOptions.contains(oldDisplayProtocolEntity)) {
        getDisplayType().setItems(displayTypeOptions, oldDisplayProtocolEntity);
    } else if (displayTypeOptions.size() > 0) {
        getDisplayType().setItems(displayTypeOptions, displayTypeOptions.iterator().next());
    }
}
#method_after
public void initDisplayModels(List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays) {
    // get supported display types
    Set<DisplayType> displayTypes = new LinkedHashSet<>();
    for (Pair<GraphicsType, DisplayType> graphicsTypeDisplayTypePair : graphicsAndDisplays) {
        displayTypes.add(graphicsTypeDisplayTypePair.getSecond());
    }
    // set items and set selected one
    DisplayType selectedDisplayType = getDisplayType().getSelectedItem();
    if (displayTypes.contains(selectedDisplayType)) {
        getDisplayType().setItems(displayTypes, selectedDisplayType);
    } else if (displayTypes.size() > 0) {
        getDisplayType().setItems(displayTypes, displayTypes.iterator().next());
    }
}
#end_block

#method_before
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.getInstance().isBalloonEnabled(osType, cluster.getCompatibilityVersion());
    getMemoryBalloonDeviceEnabled().setIsChangable(isBalloonEnabled);
    if (getBehavior().basedOnCustomInstanceType()) {
        getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
    }
}
#method_after
private void updateMemoryBalloonDevice() {
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    boolean isBalloonEnabled = AsyncDataProvider.getInstance().isBalloonEnabled(osType, cluster.getCompatibilityVersion());
    getMemoryBalloonDeviceEnabled().setIsChangeable(isBalloonEnabled);
    if (getBehavior().basedOnCustomInstanceType()) {
        getMemoryBalloonDeviceEnabled().setEntity(isBalloonEnabled);
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    GraphicsTypes graphicsTypes = getGraphicsType().getSelectedItem();
    if (graphicsTypes != null) {
        getVncKeyboardLayout().setIsAvailable(graphicsTypes.getBackingGraphicsType().contains(GraphicsType.VNC));
    }
}
#method_after
private void initVncKeyboardLayout() {
    final List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    final ArrayList<String> vncKeyboardLayoutItems = new ArrayList<String>();
    // null value means the global VncKeyboardLayout from vdc_options will be used
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    GraphicsTypes graphicsTypes = getGraphicsType().getSelectedItem();
    if (graphicsTypes != null) {
        getVncKeyboardLayout().setIsAvailable(graphicsTypes.getBackingGraphicsTypes().contains(GraphicsType.VNC));
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
}
#end_block

#method_before
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getCompatibilityVersion();
        final boolean supported = AsyncDataProvider.getInstance().isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#method_after
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getCompatibilityVersion();
        final boolean supported = AsyncDataProvider.getInstance().isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangeable(supported);
    }
}
#end_block

#method_before
public boolean getIsQxlSupported() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = extractSelectedDisplayTypeEntity() == DisplayType.qxl;
    boolean isSpice = getGraphicsType().getSelectedItem() == GraphicsTypes.SPICE;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getCompatibilityVersion()) <= 0;
    return isLinux && isQxl && isSpice && clusterSupportsSinglePci;
}
#method_after
public boolean getIsQxlSupported() {
    // Enable Single PCI only on cluster 3.3 and high and on Linux OS
    boolean isLinux = getIsLinuxOS();
    boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
    boolean isSpice = getGraphicsType().getSelectedItem() == GraphicsTypes.SPICE;
    boolean clusterSupportsSinglePci = getSelectedCluster() != null && Version.v3_3.compareTo(getSelectedCluster().getCompatibilityVersion()) <= 0;
    return isLinux && isQxl && isSpice && clusterSupportsSinglePci;
}
#end_block

#method_before
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = extractSelectedDisplayTypeEntity() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getSelectedCluster().getCompatibilityVersion().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangable(spiceFileTransferToggle);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsType().contains(GraphicsType.SPICE) && AsyncDataProvider.getInstance().isSpiceCopyPasteToggleSupported(getSelectedCluster().getCompatibilityVersion().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangable(spiceCopyPasteToggle);
    }
}
#method_after
private void handleQxlClusterLevel() {
    getBehavior().enableSinglePCI(getIsQxlSupported());
    if (getSelectedCluster() != null) {
        boolean isQxl = getDisplayType().getSelectedItem() == DisplayType.qxl;
        boolean spiceFileTransferToggle = isQxl && AsyncDataProvider.getInstance().isSpiceFileTransferToggleSupported(getSelectedCluster().getCompatibilityVersion().toString());
        if (!spiceFileTransferToggle) {
            handleQxlChangeProhibitionReason(getSpiceFileTransferEnabled(), getSelectedCluster().getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceFileTransferEnabled().setIsChangeable(spiceFileTransferToggle);
        GraphicsTypes selectedGraphics = getGraphicsType().getSelectedItem();
        boolean spiceCopyPasteToggle = selectedGraphics != null && selectedGraphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE) && AsyncDataProvider.getInstance().isSpiceCopyPasteToggleSupported(getSelectedCluster().getCompatibilityVersion().toString());
        if (!spiceCopyPasteToggle) {
            handleQxlChangeProhibitionReason(getSpiceCopyPasteEnabled(), getSelectedCluster().getCompatibilityVersion().toString(), isQxl);
        }
        getSpiceCopyPasteEnabled().setIsChangeable(spiceCopyPasteToggle);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(osType));
    getInitrd_path().setIsChangeable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangeable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangeable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
    getInstanceImages().updateActionsAvailability();
    updateIconAccordingToOs();
}
#end_block

#method_before
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModelEditor() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getInstance().getVmWatchdogTypes(osType, cluster.getCompatibilityVersion(), asyncQuery);
    }
}
#method_after
private void updateWatchdogModels(Integer osType) {
    VDSGroup cluster = getSelectedCluster();
    if (osType != null && cluster != null && getWatchdogModel() != null) {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getBehavior().deactivateInstanceTypeManager();
                updateWatchdogItems((HashSet<VmWatchdogType>) ((VdcQueryReturnValue) returnValue).getReturnValue());
                getBehavior().activateInstanceTypeManager();
            }
        };
        AsyncDataProvider.getInstance().getVmWatchdogTypes(osType, cluster.getCompatibilityVersion(), asyncQuery);
    }
}
#end_block

#method_before
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<String> watchDogModelsStrings = new ArrayList<String>();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModelsStrings.add(vmWatchdogType.toString());
    }
    watchDogModelsStrings.add(0, constants.NoWatchdog());
    getWatchdogModelEditor().setItems(watchDogModelsStrings);
    String old_watchdog_selected_string = getWatchdogModelEditor().getSelectedItem();
    if (watchDogModelsStrings.contains(old_watchdog_selected_string)) {
        getWatchdogModelEditor().setSelectedItem(old_watchdog_selected_string);
    }
}
#method_after
public void updateWatchdogItems(Set<VmWatchdogType> vmWatchdogTypes) {
    List<VmWatchdogType> watchDogModels = new ArrayList<VmWatchdogType>();
    for (VmWatchdogType vmWatchdogType : vmWatchdogTypes) {
        watchDogModels.add(vmWatchdogType);
    }
    watchDogModels.add(0, null);
    VmWatchdogType oldWatchdogSelected = getWatchdogModel().getSelectedItem();
    getWatchdogModel().setItems(watchDogModels);
    if (watchDogModels.contains(oldWatchdogSelected)) {
        getWatchdogModel().setSelectedItem(oldWatchdogSelected);
    }
}
#end_block

#method_before
private void overrideMigrationDowntimeChanged() {
    Boolean entity = getOverrideMigrationDowntime().getEntity();
    getMigrationDowntime().setIsChangable(Boolean.TRUE.equals(entity));
}
#method_after
private void overrideMigrationDowntimeChanged() {
    Boolean entity = getOverrideMigrationDowntime().getEntity();
    getMigrationDowntime().setIsChangeable(Boolean.TRUE.equals(entity));
}
#end_block

#method_before
private void displayTypeSelectedItemChanged(Object sender, EventArgs args) {
    if (extractSelectedDisplayTypeEntity() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    SortedSet<GraphicsTypes> graphicsTypes = new TreeSet<GraphicsTypes>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, cluster.getCompatibilityVersion());
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem().getEntity()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    getGraphicsType().setItems(graphicsTypes);
    upgradeGraphicsRelatedModels();
}
#method_after
private void displayTypeSelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType().getSelectedItem() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    doDisplayTypeChanged();
}
#end_block

#method_before
private void displayTypeSelectedItemChanged(Object sender, EventArgs args) {
    if (extractSelectedDisplayTypeEntity() == null) {
        getBehavior().activateInstanceTypeManager();
        return;
    }
    VDSGroup cluster = getSelectedCluster();
    Integer osType = getOSType().getSelectedItem();
    if (cluster == null || osType == null) {
        return;
    }
    SortedSet<GraphicsTypes> graphicsTypes = new TreeSet<GraphicsTypes>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, cluster.getCompatibilityVersion());
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem().getEntity()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    getGraphicsType().setItems(graphicsTypes);
    upgradeGraphicsRelatedModels();
}
#method_after
protected void displayTypeSelectedItemChanged(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    getGraphicsType().setItems(graphicsTypes);
    upgradeGraphicsRelatedModels();
}
#end_block

#method_before
private void upgradeGraphicsRelatedModels() {
    DisplayType display = extractSelectedDisplayTypeEntity();
    GraphicsTypes graphics = getGraphicsType().getSelectedItem();
    if (display == null || graphics == null) {
        return;
    }
    if (display != DisplayType.qxl || !graphics.getBackingGraphicsType().contains(GraphicsType.SPICE)) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(graphics.getBackingGraphicsType().contains(GraphicsType.SPICE));
    getIsSmartcardEnabled().setIsChangable(graphics.getBackingGraphicsType().contains(GraphicsType.SPICE));
    getVncKeyboardLayout().setIsAvailable(graphics.getBackingGraphicsType().contains(GraphicsType.VNC));
    updateNumOfMonitors();
}
#method_after
private void upgradeGraphicsRelatedModels() {
    DisplayType display = getDisplayType().getSelectedItem();
    GraphicsTypes graphics = getGraphicsType().getSelectedItem();
    if (display == null || graphics == null) {
        return;
    }
    if (display != DisplayType.qxl || !graphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE)) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangeable(graphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE));
    getIsSmartcardEnabled().setIsChangeable(graphics.getBackingGraphicsTypes().contains(GraphicsType.SPICE));
    getVncKeyboardLayout().setIsAvailable(graphics.getBackingGraphicsTypes().contains(GraphicsType.VNC));
    updateNumOfMonitors();
}
#end_block

#method_before
private void updateNumOfMonitors() {
    EntityModel<DisplayType> selectedDisplayType = getDisplayType().getSelectedItem();
    if (selectedDisplayType != null && selectedDisplayType.getEntity() != DisplayType.qxl) {
        getNumOfMonitors().setSelectedItem(1);
        getNumOfMonitors().setIsChangable(false);
    } else {
        getNumOfMonitors().setIsChangable(true);
    }
}
#method_after
private void updateNumOfMonitors() {
    if (getDisplayType().getSelectedItem() == DisplayType.qxl) {
        getNumOfMonitors().setIsChangeable(true);
    } else {
        getNumOfMonitors().setSelectedItem(1);
        getNumOfMonitors().setIsChangeable(false);
    }
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangeable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
public boolean validate(boolean templateWithVersionRequired) {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getName().getIsValid() && getVmId().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#method_after
public boolean validate(boolean templateWithVersionRequired) {
    boolean hwPartValid = validateHwPart();
    getInstanceTypes().setIsValid(true);
    getInstanceTypes().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior().isExistingTemplateBehavior() || getBehavior().isNewTemplateBehavior()) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.getInstance().isWindowsOsType(osType) ? AsyncDataProvider.getInstance().getMaxVmNameLengthWin() : AsyncDataProvider.getInstance().getMaxVmNameLengthNonWin()), isValidTab(TabName.POOL_TAB) ? new PoolNameValidation() : new I18NNameValidation() });
        if (getVmId().getIsAvailable() && !StringHelper.isNullOrEmpty(getVmId().getEntity())) {
            getVmId().validateEntity(new IValidation[] { new GuidValidation() });
        }
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getName().getIsValid() && getVmId().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    }
    if (templateWithVersionRequired) {
        getTemplateWithVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (!(getBehavior().isBlankTemplateBehavior())) {
        setValidTab(TabName.GENERAL_TAB, isValidTab(TabName.GENERAL_TAB) && getDataCenterWithClustersList().getIsValid() && getTemplateWithVersion().getIsValid());
    }
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.HOST_TAB, isValidTab(TabName.HOST_TAB) && getMigrationDowntime().getIsValid());
    boolean diskAliasesValid = getDisksAllocationModel().getIsValid();
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, isValidTab(TabName.RESOURCE_ALLOCATION_TAB) && getCpuSharesAmount().getIsValid() && diskAliasesValid);
    setValidTab(TabName.BOOT_OPTIONS_TAB, getCdImage().getIsValid() && getKernel_path().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    setValidTab(TabName.FIRST_RUN, vmInitIsValid);
    getIcon().validateEntity(new IValidation[] { new IconWithOsDefaultValidation() });
    setValidTab(TabName.ICON_TAB, getIcon().getIsValid());
    boolean isValid = hwPartValid && vmInitIsValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    boolean behaviorValid = behavior.validate();
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    boolean isValid = behaviorValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#method_after
public boolean validateHwPart() {
    resetTabsValidity();
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, customPropertySheetValid);
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    getEmulatedMachine().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_EMULATED_MACHINE_SIZE) });
    getCustomCpu().validateSelectedItem(new IValidation[] { new I18NExtraNameOrNoneValidation(), new LengthValidation(BusinessEntitiesDefinitions.VM_CPU_NAME_SIZE) });
    boolean behaviorValid = behavior.validate();
    setValidTab(TabName.GENERAL_TAB, getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid());
    setValidTab(TabName.INITIAL_RUN_TAB, getTimeZone().getIsValid());
    setValidTab(TabName.CONSOLE_TAB, getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setValidTab(TabName.HOST_TAB, getMigrationDowntime().getIsValid());
    getRngBytes().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE), new RngDevValidation() });
    getRngPeriod().validateEntity(new IValidation[] { new IntegerValidation(0, Integer.MAX_VALUE) });
    setValidTab(TabName.TAB_RNG, getRngBytes().getIsValid() && getRngPeriod().getIsValid());
    // Minimum 'Physical Memory Guaranteed' is 1MB
    validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
    if (!getBehavior().isAnyTemplateBehavior() && getMemSize().getIsValid()) {
        validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
    }
    if (getIoThreadsEnabled().getEntity()) {
        getNumOfIoThreads().validateEntity(new IValidation[] { new NotNullIntegerValidation(1, Integer.MAX_VALUE) });
    }
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, getMinAllocatedMemory().getIsValid() && getNumOfIoThreads().getIsValid());
    setValidTab(TabName.SYSTEM_TAB, getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && getEmulatedMachine().getIsValid() && getCustomCpu().getIsValid());
    boolean isValid = behaviorValid && allTabsValid();
    getValid().setEntity(isValid);
    ValidationCompleteEvent.fire(getEventBus(), this);
    return isValid;
}
#end_block

#method_before
private void resetTabsValidity() {
    setValidTab(TabName.HOST_TAB, true);
    setIsCustomPropertiesTabAvailable(true);
    setValidTab(TabName.TAB_RNG, true);
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, true);
    setValidTab(TabName.BOOT_OPTIONS_TAB, true);
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, true);
    setValidTab(TabName.CONSOLE_TAB, true);
    setValidTab(TabName.INITIAL_RUN_TAB, true);
    setValidTab(TabName.GENERAL_TAB, true);
    getValid().setEntity(true);
}
#method_after
private void resetTabsValidity() {
    setValidTab(TabName.HOST_TAB, true);
    setIsCustomPropertiesTabAvailable(true);
    setValidTab(TabName.TAB_RNG, true);
    setValidTab(TabName.CUSTOM_PROPERTIES_TAB, true);
    setValidTab(TabName.BOOT_OPTIONS_TAB, true);
    setValidTab(TabName.RESOURCE_ALLOCATION_TAB, true);
    setValidTab(TabName.CONSOLE_TAB, true);
    setValidTab(TabName.INITIAL_RUN_TAB, true);
    setValidTab(TabName.GENERAL_TAB, true);
    setValidTab(TabName.ICON_TAB, true);
    getValid().setEntity(true);
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getEditHostCommand().setIsExecutionAllowed(canExecuteCommand(VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    getUpgradeHostCommand().setIsExecutionAllowed(getEntity().isUpdateAvailable() && canExecuteCommand(VdcActionType.UpgradeHost));
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert();
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().isPmEnabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().isPmEnabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presence.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    updateActionAvailability();
    setHasAnyAlert();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSaveNICsConfigCommand()) {
        saveNICsConfig();
    } else if (command == getEditHostCommand()) {
        editHost();
    } else if (command == getGoToEventsCommand()) {
        goToEvents();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (command == getUpgradeHostCommand()) {
        upgrade();
    } else if ("OnUpgrade".equals(command.getName())) {
        // $NON-NLS-1$
        onUpgrade();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getSaveNICsConfigCommand()) {
        saveNICsConfig();
    } else if (command == getEditHostCommand()) {
        editHost();
    } else if (command == getGoToEventsCommand()) {
        goToEvents();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (command == getUpgradeHostCommand()) {
        upgrade();
    }
}
#end_block

#method_before
private void upgrade() {
    if (getWindow() != null) {
        return;
    }
    final VDS host = getEntity();
    if (host.getVdsType() == VDSType.oVirtNode) {
        upgradeOvirtNode(host);
    } else {
        upgradeHost(host);
    }
}
#method_after
private void upgrade() {
    if (getWindow() != null) {
        return;
    }
    final VDS host = getEntity();
    Model model = createUpgradeModel(host);
    model.initialize();
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
    setWindow(model);
}
#end_block

#method_before
private void addTextAndLinkAlert(final ViewDef view, final String text, final UICommand command, final AlertType alertTtpe) {
    // Find the open and close positions of the link within the message:
    // $NON-NLS-1$
    final int openIndex = text.indexOf("<a>");
    // $NON-NLS-1$
    final int closeIndex = text.indexOf("</a>");
    if (openIndex == -1 || closeIndex == -1 || closeIndex < openIndex) {
        return;
    }
    // Extract the text before, inside and after the tags:
    final String beforeText = text.substring(0, openIndex);
    final String betweenText = text.substring(openIndex + 3, closeIndex);
    final String afterText = text.substring(closeIndex + 4);
    // Create a flow panel containing the text and the link:
    final FlowPanel alertPanel = new FlowPanel();
    // Create the label for the text before the tag:
    final Label beforeLabel = new Label(beforeText);
    // $NON-NLS-1$ //$NON-NLS-2$
    beforeLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(beforeLabel);
    // Create the anchor:
    final Anchor betweenAnchor = new Anchor(betweenText);
    // $NON-NLS-1$ //$NON-NLS-2$
    betweenAnchor.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(betweenAnchor);
    // Add a listener to the anchor so that the command is executed when
    // it is clicked:
    betweenAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            command.execute();
        }
    });
    // Create the label for the text after the tag:
    final Label afterLabel = new Label(afterText);
    // $NON-NLS-1$ //$NON-NLS-2$
    afterLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(afterLabel);
    // Add the alert to the view:
    view.addAlert(alertPanel, alertTtpe);
}
#method_after
private void addTextAndLinkAlert(final ViewDef view, final String text, final UICommand command, final AlertType alertType) {
    // Find the open and close positions of the link within the message:
    // $NON-NLS-1$
    final int openIndex = text.indexOf("<a>");
    // $NON-NLS-1$
    final int closeIndex = text.indexOf("</a>");
    if (openIndex == -1 || closeIndex == -1 || closeIndex < openIndex) {
        return;
    }
    // Extract the text before, inside and after the tags:
    final String beforeText = text.substring(0, openIndex);
    final String betweenText = text.substring(openIndex + 3, closeIndex);
    final String afterText = text.substring(closeIndex + 4);
    // Create a flow panel containing the text and the link:
    final FlowPanel alertPanel = new FlowPanel();
    // Create the label for the text before the tag:
    final Label beforeLabel = new Label(beforeText);
    // $NON-NLS-1$ //$NON-NLS-2$
    beforeLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(beforeLabel);
    // Create the anchor:
    final Anchor betweenAnchor = new Anchor(betweenText);
    // $NON-NLS-1$ //$NON-NLS-2$
    betweenAnchor.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(betweenAnchor);
    // Add a listener to the anchor so that the command is executed when
    // it is clicked:
    betweenAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            command.execute();
        }
    });
    // Create the label for the text after the tag:
    final Label afterLabel = new Label(afterText);
    // $NON-NLS-1$ //$NON-NLS-2$
    afterLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(afterLabel);
    // Add the alert to the view:
    view.addAlert(alertPanel, alertType);
}
#end_block

#method_before
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    sourceImageDomainsImageMap = new HashMap<>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<Guid>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#method_after
private Set<Guid> getStorageGuidSet() {
    Set<Guid> destImageDomains = new HashSet<>();
    for (DiskImage diskImage : diskInfoDestinationMap.values()) {
        destImageDomains.add(diskImage.getStorageIds().get(0));
    }
    return destImageDomains;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<>();
        if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
            Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
            // host-specific parameters can be changed by administration role only
            if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
                permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
            }
        } else {
            permissionCheckSubject.add(new PermissionSubject(Guid.SYSTEM, VdcObjectType.System, getActionType().getActionGroup()));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaStorageConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    for (DiskImage disk : getVm().getDiskList()) {
        list.add(new QuotaStorageConsumptionParameter(getQuotaIdForDisk(disk), null, QuotaStorageConsumptionParameter.QuotaAction.CONSUME, disk.getStorageIds().get(0), (double) disk.getSizeInGigabytes()));
    }
    return list;
}
#end_block

#method_before
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<QuotaConsumptionParameter>();
    list.add(new QuotaSanityParameter(getQuotaId(), null));
    return list;
}
#method_after
@Override
public List<QuotaConsumptionParameter> getQuotaVdsConsumptionParameters() {
    List<QuotaConsumptionParameter> list = new ArrayList<>();
    list.add(new QuotaSanityParameter(getQuotaId(), null));
    return list;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    if (getParameters().getVolumeFormat() != null) {
        newImage.setvolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmTemplate);
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    String diskAlias = getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias();
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(diskAlias, StringUtils.defaultString(newImage.getDescription())), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(diskAlias);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    if (getParameters().getVolumeFormat() != null) {
        newImage.setvolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmTemplate);
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    String diskAlias = getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias();
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(diskAlias, StringUtils.defaultString(newImage.getDescription())), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(diskAlias);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmTemplate);
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), StringUtils.defaultString(newImage.getDescription()), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmTemplate);
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    String diskAlias = getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias();
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(diskAlias, StringUtils.defaultString(newImage.getDescription())), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskAlias(diskAlias);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Semaphore(1));
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        clusterLockMap.get(cluster.getId()).acquire();
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.isEmpty()) {
            return null;
        }
        Guid bestHost = selectBestHost(cluster, vm, destHostId, vdsList, policy, parameters);
        getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), 0, 0);
        if (bestHost != null) {
            VfScheduler vfScheduler = Injector.get(VfScheduler.class);
            Map<Guid, String> passthroughVnicToVfMap = vfScheduler.getVnicToVfMap(vm.getId(), bestHost);
            if (passthroughVnicToVfMap != null && !passthroughVnicToVfMap.isEmpty()) {
                markVfsAsUsedByVm(bestHost, vm.getId(), passthroughVnicToVfMap);
            }
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return null;
    } finally {
        // ensuring setting the semaphore permits to 1
        synchronized (clusterLockMap.get(cluster.getId())) {
            clusterLockMap.get(cluster.getId()).drainPermits();
            clusterLockMap.get(cluster.getId()).release();
        }
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#method_after
@OnTimerMethodAnnotation("performHaResevationCheck")
public void performHaResevationCheck() {
    log.debug("HA Reservation check timer entered.");
    List<VDSGroup> clusters = DbFacade.getInstance().getVdsGroupDao().getAll();
    if (clusters != null) {
        HaReservationHandling haReservationHandling = new HaReservationHandling();
        for (VDSGroup cluster : clusters) {
            if (cluster.supportsHaReservation()) {
                List<VDS> returnedFailedHosts = new ArrayList<>();
                boolean clusterHaStatus = haReservationHandling.checkHaReservationStatusForCluster(cluster, returnedFailedHosts);
                if (!clusterHaStatus) {
                    // create Alert using returnedFailedHosts
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    String failedHostsStr = StringUtils.join(Entities.objectNames(returnedFailedHosts), ", ");
                    logable.addCustomValue("Hosts", failedHostsStr);
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION, auditLogDirector);
                    log.info("Cluster '{}' fail to pass HA reservation check.", cluster.getName());
                }
                boolean clusterHaStatusFromPreviousCycle = clusterId2isHaReservationSafe.containsKey(cluster.getId()) ? clusterId2isHaReservationSafe.get(cluster.getId()) : true;
                // Update the status map with the new status
                clusterId2isHaReservationSafe.put(cluster.getId(), clusterHaStatus);
                // Create Alert if the status was changed from false to true
                if (!clusterHaStatusFromPreviousCycle && clusterHaStatus) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setVdsGroupId(cluster.getId());
                    logable.addCustomValue("ClusterName", cluster.getName());
                    AlertDirector.Alert(logable, AuditLogType.CLUSTER_ALERT_HA_RESERVATION_DOWN, auditLogDirector);
                }
            }
        }
    }
    log.debug("HA Reservation check timer finished.");
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<DiskImage> diskImages = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getParameters().getId());
    Map<Guid, DiskImage> diskImagesMap = new HashMap<>();
    // Get active diskImages
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getActive()) {
            diskImage.getSnapshots().add(DiskImage.copyOf(diskImage));
            diskImagesMap.put(diskImage.getId(), diskImage);
        }
    }
    // Update diskImages' snapshots
    for (DiskImage diskImage : diskImages) {
        if (!diskImage.getActive()) {
            DiskImage activeImage = diskImagesMap.get(diskImage.getId());
            if (activeImage != null) {
                activeImage.getSnapshots().add(diskImage);
            }
        }
    }
    getQueryReturnValue().setReturnValue(new ArrayList<>(diskImagesMap.values()));
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(getParameters().getId());
    if (storageDomain.getStorageType().isCinderDomain()) {
        List<DiskImage> diskImages = getDbFacade().getDiskImageDao().getAllForStorageDomain(getParameters().getId());
        getQueryReturnValue().setReturnValue(diskImages);
    } else {
        List<DiskImage> diskImages = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getParameters().getId());
        Map<Guid, DiskImage> diskImagesMap = new HashMap<>();
        // Get active diskImages
        for (DiskImage diskImage : diskImages) {
            if (diskImage.getActive()) {
                diskImage.getSnapshots().add(DiskImage.copyOf(diskImage));
                diskImagesMap.put(diskImage.getId(), diskImage);
            }
        }
        // Update diskImages' snapshots
        for (DiskImage diskImage : diskImages) {
            if (!diskImage.getActive()) {
                DiskImage activeImage = diskImagesMap.get(diskImage.getId());
                if (activeImage != null) {
                    activeImage.getSnapshots().add(diskImage);
                }
            }
        }
        getQueryReturnValue().setReturnValue(new ArrayList<>(diskImagesMap.values()));
    }
}
#end_block

#method_before
protected void log(AuditLogableBase logable, AuditLogType auditLogType) {
    AuditLogDirector.log(logable, auditLogType);
}
#method_after
protected void log(AuditLogableBase logable, AuditLogType auditLogType) {
    new AuditLogDirector().log(logable, auditLogType);
}
#end_block

#method_before
protected void markImagesIllegalIfNotInDb(VM vm, Guid snapshotId) {
    List<DiskImage> imagesInDb = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    // Converts to a map of Id to DiskImage in order to check existence only by Image ID (in case not all
    // image data is written to OVF
    Map<Guid, DiskImage> imagesInDbMap = ImagesHandler.getDiskImagesByIdMap(imagesInDb);
    for (DiskImage fromConfigImg : vm.getImages()) {
        if (fromConfigImg.getDiskStorageType() == Disk.DiskStorageType.IMAGE && !imagesInDbMap.containsKey(fromConfigImg.getImageId())) {
            log.debug("Image '{}' of Disk '{}' cannot be found in database. This image will be returned as ILLEGAL from the query", fromConfigImg.getImageId(), fromConfigImg.getId());
            fromConfigImg.setImageStatus(ImageStatus.ILLEGAL);
        } else {
            // Return image status as appears in DB (needed in case status is ILLEGAL in DB)
            DiskImage imageInDb = imagesInDbMap.get(fromConfigImg.getImageId());
            fromConfigImg.setImageStatus(imageInDb.getImageStatus());
        }
    }
}
#method_after
protected void markImagesIllegalIfNotInDb(VM vm, Guid snapshotId) {
    List<DiskImage> imagesInDb = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    // Converts to a map of Id to DiskImage in order to check existence only by Image ID (in case not all
    // image data is written to OVF
    Map<Guid, DiskImage> imagesInDbMap = ImagesHandler.getDiskImagesByIdMap(imagesInDb);
    for (DiskImage fromConfigImg : vm.getImages()) {
        if (fromConfigImg.getDiskStorageType() == DiskStorageType.IMAGE && !imagesInDbMap.containsKey(fromConfigImg.getImageId())) {
            log.debug("Image '{}' of Disk '{}' cannot be found in database. This image will be returned as ILLEGAL from the query", fromConfigImg.getImageId(), fromConfigImg.getId());
            fromConfigImg.setImageStatus(ImageStatus.ILLEGAL);
        } else {
            // Return image status as appears in DB (needed in case status is ILLEGAL in DB)
            DiskImage imageInDb = imagesInDbMap.get(fromConfigImg.getImageId());
            fromConfigImg.setImageStatus(imageInDb.getImageStatus());
        }
    }
}
#end_block

#method_before
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#method_after
public int removeTaskFromDbByTaskId(final Guid taskId) throws RuntimeException {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().remove(taskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallbackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#end_block

#method_before
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallBackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#method_after
public int removeByVdsmTaskId(final Guid vdsmTaskId) {
    return TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Integer>() {

        @Override
        public Integer runInTransaction() {
            AsyncTask asyncTask = DbFacade.getInstance().getAsyncTaskDao().getByVdsmTaskId(vdsmTaskId);
            int retVal = DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(vdsmTaskId);
            if (asyncTask != null && !Guid.isNullOrEmpty(asyncTask.getCommandId())) {
                CommandEntity cmdEntity = coco.getCommandEntity(asyncTask.getCommandId());
                if (cmdEntity != null && !cmdEntity.isCallbackEnabled()) {
                    coco.removeCommand(asyncTask.getCommandId());
                    if (!coco.hasCommandEntitiesWithRootCommandId(asyncTask.getRootCommandId())) {
                        coco.removeCommand(asyncTask.getRootCommandId());
                    }
                }
            }
            return retVal;
        }
    });
}
#end_block

#method_before
private boolean refreshImageDomain(final StorageDomain storageDomain, List<RepoImage> problematicRepoFileList, final ImageFileType imageType) {
    final RepoFileMetaDataDAO repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
                Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
                List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
                if (repoImages.size() >= totalListSize) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.addCustomValue("imageDomain", storageDomain.getName());
                    logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                    AuditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
                }
                for (RepoImage repoImage : repoImages) {
                    repoImage.setRepoDomainId(storageDomain.getId());
                    repoFileMetaDataDao.addRepoFileMap(repoImage);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private boolean refreshImageDomain(final StorageDomain storageDomain, List<RepoImage> problematicRepoFileList, final ImageFileType imageType) {
    final RepoFileMetaDataDAO repoFileMetaDataDao = repoStorageDom;
    Provider provider = providerDao.get(new Guid(storageDomain.getStorage()));
    final OpenStackImageProviderProxy client = ProviderProxyFactory.getInstance().create(provider);
    Lock syncObject = getSyncObject(storageDomain.getId(), imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                repoFileMetaDataDao.removeRepoDomainFileList(storageDomain.getId(), imageType);
                Integer totalListSize = Config.<Integer>getValue(ConfigValues.GlanceImageTotalListSize);
                List<RepoImage> repoImages = client.getAllImagesAsRepoImages(Config.<Integer>getValue(ConfigValues.GlanceImageListSize), totalListSize);
                if (repoImages.size() >= totalListSize) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.addCustomValue("imageDomain", storageDomain.getName());
                    logable.addCustomValue("imageListSize", String.valueOf(repoImages.size()));
                    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE);
                }
                for (RepoImage repoImage : repoImages) {
                    repoImage.setRepoDomainId(storageDomain.getId());
                    repoFileMetaDataDao.addRepoFileMap(repoImage);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private static long retrieveIsoFileSize(Map.Entry<String, Map<String, Object>> fileStats) {
    try {
        return Long.valueOf((String) fileStats.getValue().get(VdsProperties.size));
    } catch (RuntimeException e) {
        // Illegal number or null are treated as not available,
        // handling exception in UI will be much more complicated.
        log.error("File's '{}' size is illegal number: {}", fileStats.getKey(), e.getMessage());
        log.debug("Exception", e);
        return StorageConstants.SIZE_IS_NOT_AVAILABLE;
    }
}
#method_after
private static Long retrieveIsoFileSize(Map.Entry<String, Map<String, Object>> fileStats) {
    try {
        Object fileSize = fileStats.getValue().get(VdsProperties.size);
        if (fileSize == null) {
            return null;
        }
        return Long.valueOf((String) fileStats.getValue().get(VdsProperties.size));
    } catch (RuntimeException e) {
        // Illegal number or null are treated as not available,
        // handling exception in UI will be much more complicated.
        log.error("File's '{}' size is illegal number: {}", fileStats.getKey(), e.getMessage());
        log.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
private static void addToAuditLogErrorMessage(String problematicRepoFilesList) {
    AuditLogableBase logable = new AuditLogableBase();
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    logable.addCustomValue("imageDomains", problematicRepoFilesList);
    AuditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED);
}
#method_after
private static void addToAuditLogErrorMessage(String problematicRepoFilesList) {
    AuditLogableBase logable = new AuditLogableBase();
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    logable.addCustomValue("imageDomains", problematicRepoFilesList);
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED);
}
#end_block

#method_before
private static void addToAuditLogSuccessMessage(String IsoDomain, String imageType) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("imageDomains", String.format("%s (%s file type)", IsoDomain, imageType));
    AuditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED);
}
#method_after
private static void addToAuditLogSuccessMessage(String IsoDomain, String imageType) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("imageDomains", String.format("%s (%s file type)", IsoDomain, imageType));
    auditLogDirector.log(logable, AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED);
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#end_block

#method_before
protected boolean processImageInIrs() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription()));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setVdsmTaskIds(new ArrayList<Guid>());
        getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
        return true;
    }
    return false;
}
#method_after
protected boolean processImageInIrs() {
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getImageGroupId(), getParameters().getDiskInfo().getSize(), getParameters().getDiskInfo().getVolumeType(), getParameters().getDiskInfo().getVolumeFormat(), getDestinationImageId(), getJsonDiskDescription(getParameters().getDiskInfo().getDiskAlias(), getParameters().getDiskInfo().getDiskDescription())));
    if (vdsReturnValue.getSucceeded()) {
        getParameters().setVdsmTaskIds(new ArrayList<Guid>());
        getParameters().getVdsmTaskIds().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId()));
        getReturnValue().getInternalVdsmTaskIdList().add(getParameters().getVdsmTaskIds().get(0));
        return true;
    }
    return false;
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                markHostDevicesAsUsed();
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    cleanupPassthroughVnics();
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
@Override
public void rerun() {
    setFlow(null);
    super.rerun();
}
#method_after
@Override
public void rerun() {
    cleanupPassthroughVnics();
    setFlow(null);
    // re-acquire the host device lock (if needed) as the canDoAction already expects this
    // lock to be held (originally acquired in 'postConstruct'
    acquireHostDevicesLock();
    super.rerun();
}
#end_block

#method_before
private void warnIfNotAllDisksPermitSnapshots() {
    for (Disk disk : getVm().getDiskMap().values()) {
        if (!disk.isAllowSnapshot()) {
            AuditLogDirector.log(this, AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT);
            break;
        }
    }
}
#method_after
private void warnIfNotAllDisksPermitSnapshots() {
    for (Disk disk : getVm().getDiskMap().values()) {
        if (!disk.isAllowSnapshot()) {
            auditLogDirector.log(this, AuditLogType.USER_RUN_VM_AS_STATELESS_WITH_DISKS_NOT_ALLOWING_SNAPSHOT);
            break;
        }
    }
}
#end_block

#method_before
private void removeVmStatlessImages() {
    runInternalAction(VdcActionType.ProcessDownVm, new IdParameters(getVm().getId()), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#method_after
private void removeVmStatlessImages() {
    runInternalAction(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId(), true), ExecutionHandler.createDefaultContextForTasks(getContext(), getLock()));
    // setting lock to null in order not to release lock twice
    setLock(null);
    setSucceeded(true);
}
#end_block

#method_before
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.info("Running VM with attached cd '{}'", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    initParametersForExternalNetworks();
    initParametersForPassthroughVnics();
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (needsHostDevices && !hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVds())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
    }
    return true;
}
#end_block

#method_before
@Override
protected void runningFailed() {
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#method_after
@Override
protected void runningFailed() {
    cleanupPassthroughVnics();
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && isDiskUsedAsOvfStore() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && isDiskUsedAsOvfStore() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected boolean checkOperationIsCorrect() {
    if (getParameters().getOperation() == ImageOperation.Copy && (getImage().getVmEntityType() == null || !getImage().getVmEntityType().isTemplateType())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_NOT_TEMPLATE_DISK);
    }
    if (getParameters().getOperation() == ImageOperation.Move && getImage().getVmEntityType() != null && getImage().getVmEntityType().isTemplateType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    return true;
}
#method_after
protected boolean checkOperationIsCorrect() {
    if (getParameters().getOperation() == ImageOperation.Move && getImage().getVmEntityType() != null && getImage().getVmEntityType().isTemplateType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    return true;
}
#end_block

#method_before
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving
    if (getParameters().getOperation() == ImageOperation.Move && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    return true;
}
#method_after
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving/copying
    boolean moveOrCopy = getParameters().getOperation() == ImageOperation.Move || getParameters().getOperation() == ImageOperation.Copy;
    if (moveOrCopy && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfNeedToBeOverride() {
    if (getParameters().getOperation() == ImageOperation.Copy && !getParameters().getForceOverride() && getImage().getStorageIds().contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_ALREADY_EXISTS);
    }
    return true;
}
#method_after
protected boolean checkIfNeedToBeOverride() {
    if (isTemplate() && getParameters().getOperation() == ImageOperation.Copy && !getParameters().getForceOverride() && getImage().getStorageIds().contains(getStorageDomain().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), getParameters());
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), getParameters());
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (getParameters().getOperation() == ImageOperation.Copy && !isTemplate()) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(true);
    } else {
        getParameters().setUseCopyCollapse(false);
    }
    getParameters().setDestinationImageId(getImageId());
    getParameters().setImageGroupID(getImageGroupId());
    getParameters().setDestImageGroupId(getImageGroupId());
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    getParameters().setDiskProfileId(getImage().getDiskProfileId());
}
#method_after
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(true);
        if (!isTemplate()) {
            prepareCopyNotTemplate();
        }
    } else {
        getParameters().setUseCopyCollapse(false);
    }
    if (getParameters().getOperation() == ImageOperation.Move || isTemplate()) {
        getParameters().setDestinationImageId(getImageId());
        getParameters().setImageGroupID(getImageGroupId());
        getParameters().setDestImageGroupId(getImageGroupId());
    }
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    getParameters().setDiskProfileId(getImage().getDiskProfileId());
}
#end_block

#method_before
public String getDiskAlias() {
    return getImage().getDiskAlias();
}
#method_after
public String getDiskAlias() {
    return StringUtils.isEmpty(getParameters().getNewAlias()) ? getImage().getDiskAlias() : getParameters().getNewAlias();
}
#end_block

#method_before
@Override
protected void postConstruct() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameters.getVmStaticData().getVmType() == VmType.Desktop);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameters.getVmStaticData().getVmType() == VmType.Desktop);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    // validate NUMA nodes count not more than CPUs
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(diskInfoDestinationMap.values(), true, false, true);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
    }
}
#end_block

#method_before
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHost(getParameters().getVmStaticData().getDedicatedVmForVds());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHost(getParameters().getVmStaticData().getDedicatedVmForVds());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    setIconIds(vmStatic);
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(ImagesHandler.filterDisksBasedOnCinder(templateDisks));
    }
    return true;
}
#end_block

#method_before
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permission> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permission[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permission> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permission templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getRoleId().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getRoleId().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getAdElementId(), templatePermission.getRoleId(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permission[] permsArray = new Permission[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permission(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
private void initCommandsAndReturnValues(ArrayList<VdcReturnValueBase> returnValues) {
    VdcReturnValueBase returnValue;
    for (VdcActionParametersBase parameter : getParameters()) {
        parameter.setMultipleAction(true);
        returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
        if (returnValue == null) {
            CommandBase<?> command = isInternal ? CommandsFactory.createCommand(actionType, parameter, commandContext.clone().withoutCompensationContext()) : CommandsFactory.createCommand(actionType, parameter);
            command.setInternalExecution(isInternal);
            getCommands().add(command);
        } else {
            returnValues.add(returnValue);
        }
    }
}
#method_after
private void initCommandsAndReturnValues(ArrayList<VdcReturnValueBase> returnValues) {
    VdcReturnValueBase returnValue;
    for (VdcActionParametersBase parameter : getParameters()) {
        parameter.setMultipleAction(true);
        returnValue = ExecutionHandler.evaluateCorrelationId(parameter);
        if (returnValue == null) {
            CommandBase<?> command = isInternal ? CommandsFactory.createCommand(actionType, parameter, commandContext != null ? commandContext.clone().withoutCompensationContext() : null) : CommandsFactory.createCommand(actionType, parameter);
            command.setInternalExecution(isInternal);
            getCommands().add(command);
        } else {
            returnValues.add(returnValue);
        }
    }
}
#end_block

#method_before
private void validateQosOverriddenInterfaces() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        // check that the interface has a network attached to it, otherwise QoS settings should be wiped anyway
        if (networkName == null) {
            continue;
        }
        if (iface.isQosOverridden()) {
            if (!hostNetworkQosSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
            }
            HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
            if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
            }
            if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
            }
        }
    }
}
#method_after
private void validateQosOverriddenInterfaces() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        // 2. if QoS isn't overridden - no problem
        if (networkName == null || !iface.isQosOverridden()) {
            continue;
        }
        if (!hostNetworkQosSupported) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
        }
        // next checks are only relevant if non-empty QoS was supplied
        if (iface.getQos() != null && !iface.getQos().isEmpty()) {
            HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
            if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
            }
            if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
            }
        }
    }
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnStorageTypeCheck() {
    // or additional storage types are added, other else-if clauses should be added.
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        return canRemoveDiskBasedOnImageStorageCheck();
    }
    return true;
}
#method_after
private boolean canRemoveDiskBasedOnStorageTypeCheck() {
    // or additional storage types are added, other else-if clauses should be added.
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE || getDisk().getDiskStorageType() == DiskStorageType.CINDER) {
        return canRemoveDiskBasedOnImageStorageCheck();
    }
    return true;
}
#end_block

#method_before
protected DiskDao getDiskDao() {
    return DbFacade.getInstance().getDiskDao();
}
#method_after
public DiskDao getDiskDao() {
    return DbFacade.getInstance().getDiskDao();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
        VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
        if (vdcReturnValue.getSucceeded()) {
            incrementVmsGeneration();
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            setSucceeded(true);
        }
    } else {
        removeLunDisk();
    }
}
#method_after
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, new RemoveDiskParameters(getParameters().getDiskId()), cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, getParameters().getStorageDomainId()));
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            } else if (getDisk().getDiskStorageType() == DiskStorageType.CINDER) {
                return getSucceeded() ? AuditLogType.USER_REMOVE_DISK_INITIATED : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
@Override
protected void postConstruct() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVmInitPassword();
    VmHandler.warnMemorySizeLegal(getParameters().getVmStaticData(), getVdsGroup().getCompatibilityVersion());
    Guid poolId = getPoolId();
    setActionReturnValue(poolId);
    VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
    addVmsToPool(poolId);
    getReturnValue().setCanDoAction(isAddVmsSucceded());
    setSucceeded(isAddVmsSucceded());
    VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
    getCompensationContext().resetCompensation();
}
#method_after
@Override
protected void executeCommand() {
    updateVmInitPassword();
    VmHandler.warnMemorySizeLegal(getParameters().getVmStaticData(), getVdsGroup().getCompatibilityVersion());
    Guid poolId = getPoolId();
    setActionReturnValue(poolId);
    VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
    addVmsToPool(poolId);
    getReturnValue().setCanDoAction(isAddVmsSucceded());
    setSucceeded(isAddVmsSucceded());
    VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
    if (!isVmsAdded())
        onNoVmsAdded(poolId);
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVmAndAttachToPool, buildAddVmAndAttachToPoolParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getCanDoActionMessages().isEmpty()) {
            for (String msg : returnValue.getCanDoActionMessages()) {
                if (!getReturnValue().getCanDoActionMessages().contains(msg)) {
                    getReturnValue().getCanDoActionMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            AuditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#method_after
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVmAndAttachToPool, buildAddVmAndAttachToPoolParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getCanDoActionMessages().isEmpty()) {
            for (String msg : returnValue.getCanDoActionMessages()) {
                if (!getReturnValue().getCanDoActionMessages().contains(msg)) {
                    getReturnValue().getCanDoActionMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            vmsAdded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            auditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#end_block

#method_before
private AddVmAndAttachToPoolParameters buildAddVmAndAttachToPoolParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    AddVmAndAttachToPoolParameters parameters = new AddVmAndAttachToPoolParameters(currVm, poolId, vmName, diskInfoDestinationMap);
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setParentCommand(VdcActionType.AddVmPoolWithVms);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled() != null ? getParameters().isSoundDeviceEnabled() : VmType.Desktop == getParameters().getVmStaticData().getVmType());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmAndAttachToPoolParameters buildAddVmAndAttachToPoolParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmAndAttachToPoolParameters parameters = new AddVmAndAttachToPoolParameters(currVm, poolId, vmName, diskInfoDestinationMap);
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setParentCommand(VdcActionType.AddVmPoolWithVms);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled() != null ? getParameters().isSoundDeviceEnabled() : VmType.Desktop == getParameters().getVmStaticData().getVmType());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
private List<EngineSession> searchSessions() {
    return genericSearch(getDbFacade().getEngineSessionDao(), false);
}
#method_after
private List<UserSession> searchSessions() {
    final List<EngineSession> engineSessions = genericSearch(getDbFacade().getEngineSessionDao(), false);
    return LinqUtils.transformToList(engineSessions, new Function<EngineSession, UserSession>() {

        @Override
        public UserSession eval(EngineSession engineSession) {
            return new UserSession(engineSession);
        }
    });
}
#end_block

#method_before
protected void processVmOnDown() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalActionWithTasksContext(VdcActionType.ProcessDownVm, new IdParameters(getVm().getId()));
        }
    });
}
#method_after
protected void processVmOnDown() {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalActionWithTasksContext(VdcActionType.ProcessDownVm, new ProcessDownVmParameters(getVm().getId()));
        }
    });
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallBackNotified(existingCmdEntity.isCallBackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallBackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallBackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallBackNotified()) {
            cmdExecutor.addToCallBackMap(cmdEntity);
        }
    }
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallbackNotified(existingCmdEntity.isCallbackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallbackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallbackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallbackNotified()) {
            cmdExecutor.addToCallbackMap(cmdEntity);
        }
    }
}
#end_block

#method_before
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, cmdContext);
}
#method_after
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, SubjectEntity... subjectEntities) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, cmdContext, subjectEntities);
}
#end_block

#method_before
private void initChildHierarchy() {
    if (!childHierarchyInitialized) {
        synchronized (LOCK) {
            if (!childHierarchyInitialized) {
                childHierarchy.clear();
                for (CommandEntity cmd : getCommandsWithCallBackEnabled()) {
                    buildCmdHierarchy(cmd);
                }
            }
            childHierarchyInitialized = true;
        }
    }
}
#method_after
private void initChildHierarchy() {
    if (!childHierarchyInitialized) {
        synchronized (LOCK) {
            if (!childHierarchyInitialized) {
                childHierarchy.clear();
                for (CommandEntity cmd : getCommandsWithCallbackEnabled()) {
                    buildCmdHierarchy(cmd);
                }
            }
            childHierarchyInitialized = true;
        }
    }
}
#end_block

#method_before
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static Map<Guid, List<VM>> mapHaVmToHostByCluster(Guid clusterId) {
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllForVdsGroup(clusterId);
    if (vms == null || vms.isEmpty()) {
        log.debug("No VMs available for this cluster with id '{}'", clusterId);
        // return empty map
        return Collections.EMPTY_MAP;
    }
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.isAutoStartup();
        }
    });
    return mapVmToHost(vms);
}
#method_after
public static Map<Guid, List<VM>> mapHaVmToHostByCluster(Guid clusterId) {
    List<VM> vms = DbFacade.getInstance().getVmDao().getAllForVdsGroup(clusterId);
    if (vms == null || vms.isEmpty()) {
        log.debug("No VMs available for this cluster with id '{}'", clusterId);
        // return empty map
        return Collections.emptyMap();
    }
    vms = LinqUtils.filter(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM v) {
            return v.isAutoStartup();
        }
    });
    return mapVmToHost(vms);
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        PmHealthCheckManager.getInstance().initialize();
        // recover from engine failure
        PmHealthCheckManager.getInstance().recover(hosts);
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
        // Initialize Power Management Health Check
        pmHealthCheckManager.initialize();
        // recover from engine failure
        pmHealthCheckManager.recover(hosts);
        // Initialize backup awareness manager
        engineBackupAwarenessManager.initialize();
        CommandCoordinatorUtil.initAsyncTaskManager();
        Injector.get(ResourceManager.class);
        OvfDataUpdater.getInstance().initOvfDataUpdater();
        SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

            @Override
            public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
                MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
                parameters.setInitialHosts(new ArrayList<>(initialHosts));
                Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
            }
        });
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                MacPoolPerDcSingleton.getInstance().initialize();
            }
        });
        StoragePoolStatusHandler.init();
        GlusterJobsManager.init();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        SchedulingManager.getInstance().init();
        SessionDataContainer.getInstance().cleanupEngineSessionsOnStartup();
        hostDeviceManager.init();
        new DwhHeartBeat().init();
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    for (VDS vds : hosts) {
        Integer cores = SlaValidator.getInstance().getEffectiveCpuCores(vds);
        if (cores != null && vm.getNumOfCpus() > cores) {
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_ENOUGH_CORES.toString());
            log.debug("Host '{}' has less cores ({}) than vm cores ({})", vds.getName(), cores, vm.getNumOfCpus());
            continue;
        }
        list.add(vds);
    }
    return list;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    List<VDS> list = new ArrayList<>();
    for (VDS vds : hosts) {
        VDSGroup cluster = getVdsGroupDao().get(vds.getVdsGroupId());
        Integer cores = SlaValidator.getEffectiveCpuCores(vds, cluster != null && cluster.getCountThreadsAsCores());
        if (cores != null && vm.getNumOfCpus() > cores) {
            messages.addMessage(vds.getId(), VdcBllMessages.VAR__DETAIL__NOT_ENOUGH_CORES.toString());
            log.debug("Host '{}' has less cores ({}) than vm cores ({})", vds.getName(), cores, vm.getNumOfCpus());
            continue;
        }
        list.add(vds);
    }
    return list;
}
#end_block

#method_before
public static MultipleActionsRunner createMultipleActionsRunner(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, CommandContext commandContext) {
    MultipleActionsRunner runner;
    switch(actionType) {
        case DeactivateStorageDomainWithOvfUpdate:
            {
                runner = new DeactivateStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case AttachStorageDomainToPool:
            {
                runner = new AttachStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RunVm:
            {
                runner = new RunVMActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case MigrateVm:
            {
                runner = new MigrateVMActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RemoveVmFromPool:
            {
                runner = new RemoveVmFromPoolRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case StartGlusterVolume:
        case StopGlusterVolume:
        case DeleteGlusterVolume:
        case SetGlusterVolumeOption:
        case ResetGlusterVolumeOptions:
        // AddVds is called with multiple actions *only* in case of gluster clusters
        case AddVds:
        case RemoveGlusterServer:
        case EnableGlusterHook:
        case DisableGlusterHook:
            {
                runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RemoveVds:
            {
                if (containsGlusterServer(parameters)) {
                    runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                } else {
                    runner = new MultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                }
                break;
            }
        case PersistentSetupNetworks:
            {
                runner = new ParallelMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case AttachNetworkToVdsGroup:
        case DetachNetworkToVdsGroup:
        case UpdateNetworkOnCluster:
            throw new UnsupportedOperationException("Multiple network attachments/detachments/updates should be run through ManageNetworkClustersCommand!");
        default:
            runner = new MultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
    }
    return runner;
}
#method_after
public static MultipleActionsRunner createMultipleActionsRunner(VdcActionType actionType, ArrayList<VdcActionParametersBase> parameters, boolean isInternal, CommandContext commandContext) {
    MultipleActionsRunner runner;
    switch(actionType) {
        case DeactivateStorageDomainWithOvfUpdate:
            {
                runner = new DeactivateStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case AttachStorageDomainToPool:
            {
                runner = new AttachStorageDomainsMultipleActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RunVm:
            {
                runner = new RunVMActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case MigrateVm:
            {
                runner = new MigrateVMActionRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RemoveVmFromPool:
            {
                runner = new RemoveVmFromPoolRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case StartGlusterVolume:
        case StopGlusterVolume:
        case DeleteGlusterVolume:
        case SetGlusterVolumeOption:
        case ResetGlusterVolumeOptions:
        // AddVds is called with multiple actions *only* in case of gluster clusters
        case AddVds:
        case RemoveGlusterServer:
        case EnableGlusterHook:
        case DisableGlusterHook:
        case DeleteGlusterVolumeSnapshot:
            {
                runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case RemoveVds:
            {
                if (containsGlusterServer(parameters)) {
                    runner = new GlusterMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                } else {
                    runner = new MultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                }
                break;
            }
        case PersistentSetupNetworks:
            {
                runner = new ParallelMultipleActionsRunner(actionType, parameters, commandContext, isInternal);
                break;
            }
        case AttachNetworkToVdsGroup:
        case DetachNetworkToVdsGroup:
        case UpdateNetworkOnCluster:
            throw new UnsupportedOperationException("Multiple network attachments/detachments/updates should be run through ManageNetworkClustersCommand!");
        default:
            runner = new MultipleActionsRunner(actionType, parameters, commandContext, isInternal);
            break;
    }
    return runner;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()), getParameters().getInterface().isPlugged());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getParameters().getInterface().setVmTemplateId(getParameters().getVmTemplateId());
    getParameters().getInterface().setId(Guid.newGuid());
    getParameters().getInterface().setSpeed(VmInterfaceType.forValue(getParameters().getInterface().getType()).getSpeed());
    getVmNicDao().save(getParameters().getInterface());
    VmDeviceUtils.addNetworkInterfaceDevice(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()), getParameters().getInterface().isPlugged(), getParameters().getInterface().isPassthrough());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getVdsGroup().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.isBalloonEnabled(getVmTemplate().getId()), VmDeviceUtils.isSoundDeviceEnabled(getVmTemplate().getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!interfaceNameUnique(interfaces) || !validate(templateExists()) || !validate(linkedToTemplate())) {
        return false;
    }
    VmTemplateHandler.updateDisksFromDb(getVmTemplate());
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        if (!updateVnicForBackwardCompatibility()) {
            return false;
        }
        List<VmNic> interfacesForCheckPciLimit = new ArrayList<>(interfaces);
        interfacesForCheckPciLimit.add(getParameters().getInterface());
        if (!VmCommand.checkPciAndIdeLimit(getVmTemplate().getOsId(), getVdsGroup().getCompatibilityVersion(), getVmTemplate().getNumOfMonitors(), interfacesForCheckPciLimit, new ArrayList<DiskImageBase>(getVmTemplate().getDiskList()), VmDeviceUtils.isVirtioScsiControllerAttached(getVmTemplate().getId()), VmDeviceUtils.hasWatchdog(getVmTemplate().getId()), VmDeviceUtils.isBalloonEnabled(getVmTemplate().getId()), VmDeviceUtils.isSoundDeviceEnabled(getVmTemplate().getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        return validate(nicValidator.linkedOnlyIfSupported()) && validate(nicValidator.isCompatibleWithOs()) && validate(nicValidator.emptyNetworkValid()) && validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId())) && validate(nicValidator.typeMatchesProfile()) && validate(nicValidator.passthroughIsLinked());
    }
    return true;
}
#end_block

#method_before
@Override
protected void postConstruct() {
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setStoragePoolId(parameters.getStoragePoolId());
    imageToDestinationDomainMap = parameters.getImageToDestinationDomainMap();
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    T parameters = getParameters();
    // in the postConstruct phase.
    if (parameters.isImportAsNewEntity() && parameters.getVmId().equals(parameters.getVm().getId())) {
        parameters.getVm().setId(Guid.newGuid());
    }
    setStoragePoolId(parameters.getStoragePoolId());
    imageToDestinationDomainMap = parameters.getImageToDestinationDomainMap();
}
#end_block

#method_before
private static void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getName();
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("FieldName", fieldName);
    logable.addCustomValue("VmName", vmName);
    logable.addCustomValue("FieldValue", fieldValue);
    AuditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#method_after
private void logField(VmStatic vmStaticFromOvf, String fieldName, String fieldValue) {
    String vmName = vmStaticFromOvf.getName();
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("FieldName", fieldName);
    logable.addCustomValue("VmName", vmName);
    logable.addCustomValue("FieldValue", fieldValue);
    auditLogDirector.log(logable, AuditLogType.VM_IMPORT_INFO);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
            if (!cinderDisks.isEmpty() && !addVmTemplateCinderDisks(cinderDisks, srcDeviceIdToTargetDeviceIdMapping)) {
                setSucceeded(false);
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getParameters().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        return failCanDoAction(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM);
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    if (isTemplateVersion() && getBaseTemplate().isBlank()) {
        return failCanDoAction(VdcBllMessages.BLANK_TEMPLATE_CANT_HAVE_SUBTEMPLATES);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isDisksAliasNotEmpty()) {
        return false;
    }
    if (isInstanceType) {
        return true;
    } else {
        return doClusterRelatedChecks();
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#end_block

#method_before
private Guid getVmIdFromImageParameters() {
    return ((CreateImageTemplateParameters) getParameters().getImagesParameters().get(0)).getVmId();
}
#method_after
private Guid getVmIdFromImageParameters() {
    return getParameters().getMasterVm().getId();
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if (getCurrentUser() == null) {
        setCurrentUser(getParameters().getParametersCurrentUser());
    }
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
    }
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if (getCurrentUser() == null) {
        setCurrentUser(getParameters().getParametersCurrentUser());
    }
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<Permission> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permission[permissionsList.size()]));
    }
}
#end_block

#method_before
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permission> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permission vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getAdElementId(), vmPermission.getRoleId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debug("As cluster '{}' supports virt service as well, it's servers will not be synced with glusterfs", cluster.getName());
        return;
    }
    acquireLock(cluster.getId());
    log.debug("Refreshing Gluster Server data for cluster '{}' using server '{}'", cluster.getName(), upServer.getName());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            syncServers(existingServers, fetchedServers);
        }
    } catch (Exception e) {
        log.error("Error while refreshing server data for cluster '{}' from database: {}", cluster.getName(), e.getMessage());
        log.debug("Exception", e);
    } finally {
        releaseLock(cluster.getId());
    }
}
#method_after
private void refreshServerData(VDSGroup cluster, VDS upServer, List<VDS> existingServers) {
    if (cluster.supportsVirtService()) {
        // If the cluster supports virt service as well, we should not be removing any servers from it, even if they
        // have been removed from the Gluster cluster using the Gluster cli, as they could potentially be used for
        // running VMs
        log.debug("As cluster '{}' supports virt service as well, it's servers will not be synced with glusterfs", cluster.getName());
        return;
    }
    acquireLock(cluster.getId());
    log.debug("Refreshing Gluster Server data for cluster '{}' using server '{}'", cluster.getName(), upServer.getName());
    try {
        List<GlusterServerInfo> fetchedServers = fetchServers(cluster, upServer, existingServers);
        if (fetchedServers != null) {
            syncServers(cluster.getId(), existingServers, fetchedServers);
        }
    } catch (Exception e) {
        log.error("Error while refreshing server data for cluster '{}' from database: {}", cluster.getName(), e.getMessage());
        log.debug("Exception", e);
    } finally {
        releaseLock(cluster.getId());
    }
}
#end_block

#method_before
private void syncServers(List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus())) {
            GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
            if (glusterServer == null) {
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#method_after
private void syncServers(Guid clusterId, List<VDS> existingServers, List<GlusterServerInfo> fetchedServers) {
    log.debug("Existing servers list returned '{}' comparing with fetched servers '{}'", existingServers, fetchedServers);
    boolean serverRemoved = false;
    Network glusterNetwork = findGlusterNetwork(clusterId);
    for (VDS server : existingServers) {
        if (isRemovableStatus(server.getStatus())) {
            GlusterServerInfo glusterServer = findGlusterServer(server, fetchedServers);
            if (glusterServer == null) {
                log.info("Server '{}' has been removed directly using the gluster CLI. Removing it from engine as well.", server.getName());
                logUtil.logServerMessage(server, AuditLogType.GLUSTER_SERVER_REMOVED_FROM_CLI);
                try (EngineLock lock = getGlusterUtil().acquireGlusterLockWait(server.getId())) {
                    removeServerFromDb(server);
                    // if last but one server, reset alternate probed address for last server
                    checkAndResetKnownAddress(existingServers, server);
                    // remove the server from resource manager
                    runVdsCommand(VDSCommandType.RemoveVds, new RemoveVdsVDSCommandParameters(server.getId()));
                    serverRemoved = true;
                } catch (Exception e) {
                    log.error("Error while removing server '{}' from database: {}", server.getName(), e.getMessage());
                    log.debug("Exception", e);
                }
            } else if (server.getStatus() == VDSStatus.Up && glusterServer.getStatus() == PeerStatus.DISCONNECTED) {
                // check gluster is running, if down then move the host to Non-Operational
                VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(server.getId()));
                if (!returnValue.getSucceeded()) {
                    setNonOperational(server);
                }
            } else {
                // check if all interfaces with gluster network have been peer probed.
                peerProbeAlternateInterfaces(glusterNetwork, server);
            }
        }
    }
    if (serverRemoved) {
        log.info("Servers detached using gluster CLI is removed from engine after inspecting the Gluster servers" + " list returned '{}' - comparing with db servers '{}'", fetchedServers, existingServers);
    }
}
#end_block

#method_before
@SuppressWarnings("serial")
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (final GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.info("New brick '{}' added to volume '{}' from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.BRICK, fetchedBrick.getQualifiedName());
                    }
                });
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (!Objects.equals(existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder())) {
                log.info("Brick order for brick '{}' changed from '{}' to '{}' because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
        }
    }
}
#method_after
@SuppressWarnings("serial")
private void updateExistingAndNewBricks(GlusterVolumeEntity existingVolume, List<GlusterBrickEntity> fetchedBricks) {
    for (final GlusterBrickEntity fetchedBrick : fetchedBricks) {
        GlusterBrickEntity existingBrick = GlusterCoreUtil.findBrick(existingVolume.getBricks(), fetchedBrick);
        if (existingBrick == null) {
            // adding such servers to engine required manual approval by user, and hence can't be automated.
            if (fetchedBrick.getServerId() != null) {
                log.info("New brick '{}' added to volume '{}' from gluster CLI. Updating engine DB accordingly.", fetchedBrick.getQualifiedName(), existingVolume.getName());
                fetchedBrick.setStatus(existingVolume.isOnline() ? GlusterStatus.UP : GlusterStatus.DOWN);
                getBrickDao().save(fetchedBrick);
                logUtil.logAuditMessage(existingVolume.getClusterId(), existingVolume, null, AuditLogType.GLUSTER_VOLUME_BRICK_ADDED_FROM_CLI, new HashMap<String, String>() {

                    {
                        put(GlusterConstants.BRICK, fetchedBrick.getQualifiedName());
                    }
                });
            }
        } else {
            // brick found. update it if required. Only property that could be different is the brick order
            if (!Objects.equals(existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder())) {
                log.info("Brick order for brick '{}' changed from '{}' to '{}' because of direct CLI operations. Updating engine DB accordingly.", existingBrick.getQualifiedName(), existingBrick.getBrickOrder(), fetchedBrick.getBrickOrder());
                getBrickDao().updateBrickOrder(existingBrick.getId(), fetchedBrick.getBrickOrder());
            }
            // update network id, if different
            if (!Objects.equals(existingBrick.getNetworkId(), fetchedBrick.getNetworkId())) {
                log.info("Network address for brick '{}' detected as  '{}'. Updating engine DB accordingly.", existingBrick.getQualifiedName(), fetchedBrick.getNetworkAddress());
                getBrickDao().updateBrickNetworkId(existingBrick.getId(), fetchedBrick.getNetworkId());
            }
        }
    }
}
#end_block

#method_before
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#method_after
public void refreshVolumeDetails(VDS upServer, GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricksToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToUpdate = new ArrayList<>();
    List<GlusterBrickEntity> brickPropertiesToAdd = new ArrayList<>();
    GlusterVolumeAdvancedDetails volumeAdvancedDetails = getVolumeAdvancedDetails(upServer, volume.getClusterId(), volume.getName());
    if (volumeAdvancedDetails == null) {
        log.error("Error while refreshing brick statuses for volume '{}'. Failed to get volume advanced details ", volume.getName());
        return;
    }
    if (volumeAdvancedDetails.getCapacityInfo() != null) {
        if (volume.getAdvancedDetails().getCapacityInfo() == null) {
            getVolumeDao().addVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        } else {
            getVolumeDao().updateVolumeCapacityInfo(volumeAdvancedDetails.getCapacityInfo());
        }
    }
    Map<Guid, BrickProperties> brickPropertiesMap = getBrickPropertiesMap(volumeAdvancedDetails);
    for (GlusterBrickEntity brick : volume.getBricks()) {
        BrickProperties brickProperties = brickPropertiesMap.get(brick.getId());
        if (brickProperties != null) {
            if (brickProperties.getStatus() != brick.getStatus()) {
                logBrickStatusChange(volume, brick, brickProperties.getStatus());
                brick.setStatus(brickProperties.getStatus());
                bricksToUpdate.add(brick);
            }
            if (brick.getBrickProperties() == null) {
                BrickDetails brickDetails = new BrickDetails();
                brickDetails.setBrickProperties(brickProperties);
                brick.setBrickDetails(brickDetails);
                brickPropertiesToAdd.add(brick);
            } else if (brickProperties.getTotalSize() != brick.getBrickProperties().getTotalSize() || brickProperties.getFreeSize() != brick.getBrickProperties().getFreeSize()) {
                brick.getBrickDetails().setBrickProperties(brickProperties);
                brickPropertiesToUpdate.add(brick);
            }
        }
    }
    if (!brickPropertiesToAdd.isEmpty()) {
        getBrickDao().addBrickProperties(brickPropertiesToAdd);
    }
    if (!brickPropertiesToUpdate.isEmpty()) {
        getBrickDao().updateBrickProperties(brickPropertiesToUpdate);
    }
    if (!bricksToUpdate.isEmpty()) {
        getBrickDao().updateBrickStatuses(bricksToUpdate);
    }
}
#end_block

#method_before
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    return result.getSucceeded() ? (GlusterVolumeAdvancedDetails) result.getReturnValue() : null;
}
#method_after
protected GlusterVolumeAdvancedDetails getVolumeAdvancedDetails(VDS upServer, Guid clusterId, String volumeName) {
    VDSReturnValue result = runVdsCommand(VDSCommandType.GetGlusterVolumeAdvancedDetails, new GlusterVolumeAdvancedDetailsVDSParameters(upServer.getId(), clusterId, volumeName, null, false, true));
    // false. But still we have the brick status details and we can update the brick status without any issue.
    return (GlusterVolumeAdvancedDetails) result.getReturnValue();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(_newMasterStorageDomainId)) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster(true).getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), _newMasterStorageDomainId, domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    isLastMaster = proceedStorageDomainTreatmentByDomainType(getNewMasterStorageDomain(), false);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterStorageDomainId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMasterStorageDomain().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterStorageDomainId(), domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMaster(true);
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.error("Error while trying connect host {} to the needed storage server during the reinitialization" + " of Data Center '{}'", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMasterStorageDomain();
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.error("Error while trying connect host {} to the needed storage server during the reinitialization" + " of Data Center '{}'", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), _newMasterStorageDomainId);
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), _newMasterStorageDomainId, storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), getNewMasterStorageDomainId());
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? _isLastMaster ? AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER : AuditLogType.RECONSTRUCT_MASTER_DONE : AuditLogType.RECONSTRUCT_MASTER_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? isLastMaster ? AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER : AuditLogType.RECONSTRUCT_MASTER_DONE : AuditLogType.RECONSTRUCT_MASTER_FAILED;
}
#end_block

#method_before
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getCompatibilityVersion();
    final Version oldSpVersion = getOldStoragePool().getCompatibilityVersion();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
                getVmStaticDAO().incrementDbGenerationForAllInStoragePool(spId);
            }
            return null;
        }
    });
    if (getOldStoragePool().getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warn("Upgrade process of Storage Pool '{}' has encountered a problem due to following reason: {}", spId, e.getMessage());
            AuditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#method_after
private void updateStoragePoolFormatType() {
    final StoragePool storagePool = getStoragePool();
    final Guid spId = storagePool.getId();
    final Version spVersion = storagePool.getCompatibilityVersion();
    final Version oldSpVersion = getOldStoragePool().getCompatibilityVersion();
    if (oldSpVersion.equals(spVersion)) {
        return;
    }
    final StorageFormatType targetFormat = VersionStorageFormatUtil.getPreferredForVersion(spVersion, getMasterDomain() == null ? null : getMasterDomain().getStorageType());
    storagePool.setStoragePoolFormatType(targetFormat);
    TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getStoragePoolDAO().updatePartial(storagePool);
            updateMemberDomainsFormat(targetFormat);
            if (FeatureSupported.ovfStoreOnAnyDomain(spVersion)) {
                getVmStaticDAO().incrementDbGenerationForAllInStoragePool(spId);
            }
            return null;
        }
    });
    if (getOldStoragePool().getStatus() == StoragePoolStatus.Up) {
        try {
            // No need to worry about "reupgrading" as VDSM will silently ignore
            // the request.
            runVdsCommand(VDSCommandType.UpgradeStoragePool, new UpgradeStoragePoolVDSCommandParameters(spId, targetFormat));
        } catch (VdcBLLException e) {
            log.warn("Upgrade process of Storage Pool '{}' has encountered a problem due to following reason: {}", spId, e.getMessage());
            auditLogDirector.log(this, AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS);
        }
    }
    runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), new ArrayList<Guid>());
}
#end_block

#method_before
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.add(res.getMessage().toString());
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), false, false, true);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(VdcBllMessages.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#method_after
public static boolean isVmTemplateImagesReady(VmTemplate vmTemplate, Guid storageDomainId, List<String> reasons, boolean checkImagesExists, boolean checkLocked, boolean checkIllegal, boolean checkStorageDomain, List<DiskImage> providedVmtImages) {
    boolean returnValue = true;
    List<DiskImage> vmtImages = providedVmtImages;
    if (checkStorageDomain) {
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(DbFacade.getInstance().getStorageDomainDao().getForStoragePool(storageDomainId, vmTemplate.getStoragePoolId()));
        ValidationResult res = storageDomainValidator.isDomainExistAndActive();
        returnValue = res.isValid();
        if (!returnValue) {
            reasons.add(res.getMessage().toString());
            reasons.addAll(res.getVariableReplacements());
        }
    }
    if (returnValue && checkImagesExists) {
        if (vmtImages == null) {
            vmtImages = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(vmTemplate.getId()), false, false, true);
        }
        if (vmtImages.size() > 0 && !ImagesHandler.isImagesExists(vmtImages, vmtImages.get(0).getStoragePoolId())) {
            reasons.add(VdcBllMessages.TEMPLATE_IMAGE_NOT_EXIST.toString());
            returnValue = false;
        }
    }
    if (returnValue && checkLocked) {
        if (vmTemplate.getStatus() == VmTemplateStatus.Locked) {
            returnValue = false;
        } else {
            if (vmtImages != null) {
                for (DiskImage image : vmtImages) {
                    if (image.getImageStatus() == ImageStatus.LOCKED) {
                        returnValue = false;
                        break;
                    }
                }
            }
        }
        if (!returnValue) {
            reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED.toString());
        }
    }
    if (returnValue && checkIllegal && (vmTemplate.getStatus() == VmTemplateStatus.Illegal)) {
        returnValue = false;
        reasons.add(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_ILLEGAL.toString());
    }
    return returnValue;
}
#end_block

#method_before
protected void updateWatchdog(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(templateId));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() != null) {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setVm(false);
                parameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
                parameters.setId(templateId);
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setVm(false);
            watchdogParameters.setInstanceType(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE);
            watchdogParameters.setId(templateId);
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#method_after
protected void updateWatchdog(Guid templateId) {
    // do not update if this flag is not set
    if (getParameters().isUpdateWatchdog()) {
        VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(templateId));
        List<VmWatchdog> watchdogs = query.getReturnValue();
        if (watchdogs.isEmpty()) {
            if (getParameters().getWatchdog() != null) {
                WatchdogParameters parameters = new WatchdogParameters();
                parameters.setVm(false);
                parameters.setClusterIndependent(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE || isBlankTemplate());
                parameters.setId(templateId);
                parameters.setAction(getParameters().getWatchdog().getAction());
                parameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.AddWatchdog, parameters, cloneContextAndDetachFromParent());
            }
        } else {
            WatchdogParameters watchdogParameters = new WatchdogParameters();
            watchdogParameters.setVm(false);
            watchdogParameters.setClusterIndependent(getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE || isBlankTemplate());
            watchdogParameters.setId(templateId);
            if (getParameters().getWatchdog() == null) {
                // there is a watchdog in the vm, there should not be any, so let's delete
                runInternalAction(VdcActionType.RemoveWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            } else {
                // there is a watchdog in the vm, we have to update.
                watchdogParameters.setAction(getParameters().getWatchdog().getAction());
                watchdogParameters.setModel(getParameters().getWatchdog().getModel());
                runInternalAction(VdcActionType.UpdateWatchdog, watchdogParameters, cloneContextAndDetachFromParent());
            }
        }
    }
}
#end_block

#method_before
protected void alertIfFencingDisabled() {
    if (!getVdsGroup().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = new AuditLogableBase();
        alb.setVdsGroupId(getVdsGroup().getId());
        alb.setRepeatable(true);
        AuditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#method_after
protected void alertIfFencingDisabled() {
    if (!getVdsGroup().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = new AuditLogableBase();
        alb.setVdsGroupId(getVdsGroup().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#end_block

#method_before
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUN_storage_server_connection_map, String>() {

                    @Override
                    public String eval(LUN_storage_server_connection_map a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.info("The lun with id '{}' was reported as problematic", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#method_after
@Override
public boolean isConnectSucceeded(final Map<String, String> returnValue, List<StorageServerConnections> connections) {
    boolean result = true;
    List<String> failedConnectionsList = LinqUtils.filter(returnValue.keySet(), new Predicate<String>() {

        @Override
        public boolean eval(String a) {
            return !"0".equals(returnValue.get(a));
        }
    });
    for (String failedConnection : failedConnectionsList) {
        List<LUNs> failedLuns = DbFacade.getInstance().getLunDao().getAllForStorageServerConnection(failedConnection);
        if (!failedLuns.isEmpty()) {
            for (LUNs lun : failedLuns) {
                /**
                 * TODO: check if LUNs in the same pool.
                 */
                List<String> strings = LinqUtils.transformToList(DbFacade.getInstance().getStorageServerConnectionLunMapDao().getAll(lun.getLUN_id()), new Function<LUNStorageServerConnectionMap, String>() {

                    @Override
                    public String eval(LUNStorageServerConnectionMap a) {
                        return a.getstorage_server_connection();
                    }
                });
                if (CollectionUtils.subtract(strings, failedConnectionsList).size() == 0) {
                    // At case of failure the appropriate log message will be
                    // added
                    log.info("The lun with id '{}' was reported as problematic", lun.getphysical_volume_id());
                    for (String connectionFailed : failedConnectionsList) {
                        String connectionField = addToAuditLogErrorMessage(connectionFailed, returnValue.get(connectionFailed), connections, lun);
                        printLog(log, connectionField, returnValue.get(connectionFailed));
                    }
                    return false;
                }
            }
        } else {
            result = false;
            printLog(log, failedConnection, returnValue.get(failedConnection));
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if (isAddedToStoragePool) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDAO().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVdsGroup().setArchitecture(getArchitecture());
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    checkMaxMemoryOverCommitValue();
    if (!Objects.equals(oldGroup.getCompatibilityVersion(), getParameters().getVdsGroup().getCompatibilityVersion())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>getValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
        // create default CPU profile for cluster that is being upgraded.
        // and set all attached vms and templates with cpu profile
        Guid clusterId = getParameters().getVdsGroupId();
        if (!FeatureSupported.cpuQoS(oldGroup.getCompatibilityVersion()) && FeatureSupported.cpuQoS(getParameters().getVdsGroup().getCompatibilityVersion()) && getCpuProfileDao().getAllForCluster(clusterId).isEmpty()) {
            CpuProfile cpuProfile = CpuProfileHelper.createCpuProfile(clusterId, getParameters().getVdsGroup().getName());
            getCpuProfileDao().save(cpuProfile);
            getVmStaticDAO().updateVmCpuProfileIdForClusterId(clusterId, cpuProfile.getId());
        }
    } else if (oldGroup.getArchitecture() != getVdsGroup().getArchitecture()) {
        // if architecture was changed, emulated machines must be updated when adding new host.
        // At this point the cluster is empty and have changed CPU name
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        getParameters().getVdsGroup().setEmulatedMachine(null);
    }
    if (getParameters().isForceResetEmulatedMachine()) {
        getParameters().getVdsGroup().setDetectEmulatedMachine(true);
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    addOrUpdateAddtionalClusterFeatures();
    if (isAddedToStoragePool) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = runInternalAction(VdcActionType.AddVdsSpmId, parameters, cloneContextAndDetachFromParent());
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        getNetworkClusterDAO().save(managementNetworkCluster);
    }
    alertIfFencingDisabled();
    setSucceeded(true);
}
#end_block

#method_before
private NetworkCluster createManagementNetworkCluster(Network managementNetwork) {
    final NetworkCluster networkCluster = new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true, true);
    return networkCluster;
}
#method_after
private NetworkCluster createManagementNetworkCluster(Network managementNetwork) {
    final NetworkCluster networkCluster = new NetworkCluster(getVdsGroup().getId(), managementNetwork.getId(), NetworkStatus.OPERATIONAL, true, true, true, true, false);
    return networkCluster;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getCompatibilityVersion().compareTo(storagePool.getCompatibilityVersion()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(VdcBllMessages.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    return result;
}
#end_block

#method_before
private boolean validateManagementNetworkAttachement() {
    final Network managementNetwork = getDefaultManagementNetworkFinder().findDefaultManagementNetwork(getVdsGroup().getStoragePoolId());
    if (managementNetwork == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DEFAULT_MANAGEMENT_NETWORK_NOT_FOUND);
        return false;
    }
    managementNetworkCluster = createManagementNetworkCluster(managementNetwork);
    final UpdateClusterNetworkClusterValidator networkClusterValidator = createManagementNetworkClusterValidator();
    return validate(networkClusterValidator.managementNetworkChange());
}
#method_after
private boolean validateManagementNetworkAttachement() {
    final Network managementNetwork;
    final Guid managementNetworkId = getParameters().getManagementNetworkId();
    if (managementNetworkId == null) {
        managementNetwork = getDefaultManagementNetworkFinder().findDefaultManagementNetwork(getVdsGroup().getStoragePoolId());
        if (managementNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DEFAULT_MANAGEMENT_NETWORK_NOT_FOUND);
            return false;
        }
    } else {
        managementNetwork = getNetworkDAO().get(managementNetworkId);
        if (managementNetwork == null) {
            addCanDoActionMessage(VdcBllMessages.NETWORK_NOT_EXISTS);
            return false;
        }
    }
    managementNetworkCluster = createManagementNetworkCluster(managementNetwork);
    final UpdateClusterNetworkClusterValidator networkClusterValidator = createManagementNetworkClusterValidator();
    return validate(networkClusterValidator.managementNetworkChange());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    if (hosts == null || hosts.isEmpty()) {
        return null;
    }
    List<VDS> toRemoveHostList = new ArrayList<>();
    List<VmNetworkInterface> vmNICs = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
    Guid clusterId = hosts.get(0).getVdsGroupId();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(clusterId);
    Map<String, Network> networksByName = Entities.entitiesByName(clusterNetworks);
    Map<Guid, List<String>> hostNics = getInterfaceDAO().getHostNetworksByCluster(clusterId);
    Network displayNetwork = NetworkUtils.getDisplayNetwork(clusterNetworks);
    Map<Guid, VdsNetworkInterface> hostDisplayNics = getDisplayNics(displayNetwork);
    for (VDS host : hosts) {
        ValidationResult result = validateRequiredNetworksAvailable(host, vm, vmNICs, displayNetwork, networksByName, hostNics.get(host.getId()), hostDisplayNics.get(host.getId()));
        if (!result.isValid()) {
            toRemoveHostList.add(host);
            messages.addMessages(host.getId(), result.getVariableReplacements());
            messages.addMessage(host.getId(), result.getMessage().name());
        }
    }
    hosts.removeAll(toRemoveHostList);
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    if (hosts == null || hosts.isEmpty()) {
        return null;
    }
    List<VDS> toRemoveHostList = new ArrayList<>();
    List<VmNetworkInterface> vmNICs = getVmNetworkInterfaceDao().getAllForVm(vm.getId());
    Guid clusterId = hosts.get(0).getVdsGroupId();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(clusterId);
    Map<String, Network> networksByName = Entities.entitiesByName(clusterNetworks);
    Map<Guid, List<String>> hostNics = getInterfaceDAO().getHostNetworksByCluster(clusterId);
    Network displayNetwork = NetworkUtils.getDisplayNetwork(clusterNetworks);
    Map<Guid, VdsNetworkInterface> hostDisplayNics = getDisplayNics(displayNetwork);
    for (VDS host : hosts) {
        ValidationResult result = validateRequiredNetworksAvailable(host, vm, vmNICs, displayNetwork, networksByName, hostNics.get(host.getId()), hostDisplayNics.get(host.getId()));
        if (result.isValid()) {
            result = validatePassthroughVnics(vm.getId(), host, vmNICs);
        }
        if (!result.isValid()) {
            toRemoveHostList.add(host);
            messages.addMessages(host.getId(), result.getVariableReplacements());
            messages.addMessage(host.getId(), result.getMessage().name());
        }
    }
    hosts.removeAll(toRemoveHostList);
    return hosts;
}
#end_block

#method_before
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (!networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.warn("host {} is missing networks required by VM nics {}", vds.getName(), nics);
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#method_after
private ValidationResult validateRequiredNetworksAvailable(VDS vds, VM vm, List<VmNetworkInterface> vmNICs, Network displayNetwork, Map<String, Network> networksByName, List<String> hostNetworks, VdsNetworkInterface displayNic) {
    List<String> missingIfs = new ArrayList<>();
    boolean onlyRequiredNetworks = Config.<Boolean>getValue(ConfigValues.OnlyRequiredNetworksMandatoryForVdsSelection);
    for (final VmNetworkInterface vmIf : vmNICs) {
        boolean found = false;
        boolean skipNetworkExistenceCheckForVnicPassthrough = vmIf.isPassthrough();
        if (vmIf.getNetworkName() == null) {
            found = true;
        } else {
            for (String networkName : hostNetworks) {
                if (skipNetworkExistenceCheckForVnicPassthrough || !networkRequiredOnVds(vmIf, networksByName, onlyRequiredNetworks) || StringUtils.equals(vmIf.getNetworkName(), networkName)) {
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            missingIfs.add(vmIf.getNetworkName());
        }
    }
    if (!missingIfs.isEmpty()) {
        String nics = StringUtils.join(missingIfs, ", ");
        log.warn("host {} is missing networks required by VM nics {}", vds.getName(), nics);
        return new ValidationResult(VdcBllMessages.VAR__DETAIL__NETWORK_MISSING, String.format("$networkNames %1$s", nics));
    }
    return validateDisplayNetworkAvailability(vds, onlyRequiredNetworks, displayNic, displayNetwork);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.EMPTY_LIST, VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#method_after
private void createNextRunSnapshot() {
    // first remove existing snapshot
    Snapshot runSnap = getSnapshotDao().get(getVmId(), Snapshot.SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        getSnapshotDao().remove(runSnap.getId());
    }
    VM vm = new VM();
    vm.setStaticData(getParameters().getVmStaticData());
    // create new snapshot with new configuration
    new SnapshotsManager().addSnapshot(Guid.newGuid(), "Next Run configuration snapshot", Snapshot.SnapshotStatus.OK, Snapshot.SnapshotType.NEXT_RUN, vm, true, StringUtils.EMPTY, Collections.<DiskImage>emptyList(), VmDeviceUtils.getVmDevicesForNextRun(getVm(), getParameters()), getCompensationContext());
}
#end_block

#method_before
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        AuditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
        }
    }
}
#end_block

#method_before
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (isVirtioScsiEnabled()) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        final boolean isDedicatedVmForVdsChanged = !(getVm().getDedicatedVmForVds() == null ? getParameters().getVmStaticData().getDedicatedVmForVds() == null : getVm().getDedicatedVmForVds().equals(getParameters().getVmStaticData().getDedicatedVmForVds()));
        final boolean isCpuPinningChanged = !(getVm().getCpuPinning() == null ? getParameters().getVmStaticData().getCpuPinning() == null : getVm().getCpuPinning().equals(getParameters().getVmStaticData().getCpuPinning()));
        if (isDedicatedVmForVdsChanged || isCpuPinningChanged) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        if (isDedicatedVmForVdsChanged() || isCpuPinningChanged()) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        getVmDynamicDao().clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        getDowntime();
        getVmDynamicDao().clearMigratingToVds(getVmId());
        updateVmAfterMigrationToDifferentCluster();
    } finally {
        super.runningSucceded();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getCompatibilityVersion());
    }
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    UpdateVmTemplate();
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!isInstanceType() && !isBlankTemplate()) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getCompatibilityVersion());
    }
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    List<Guid> oldIconIds = Collections.emptyList();
    if (isTemplate()) {
        oldIconIds = IconUtils.updateVmIcon(mOldTemplate, getVmTemplate(), getParameters().getVmLargeIcon());
    }
    updateVmTemplate();
    IconUtils.removeUnusedIcons(oldIconIds);
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateVmsOfInstanceType() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        return;
    }
    // get vms from db
    List<VM> vmsToUpdate = getVmDAO().getVmsListByInstanceType(getVmTemplateId());
    for (VM vm : vmsToUpdate) {
        VmManagementParametersBase params = new VmManagementParametersBase(vm);
        params.setApplyChangesLater(true);
        runInternalAction(VdcActionType.UpdateVm, params);
    }
}
#method_after
private void updateVmsOfInstanceType() {
    if (!isInstanceType()) {
        return;
    }
    // get vms from db
    List<VM> vmsToUpdate = getVmDAO().getVmsListByInstanceType(getVmTemplateId());
    for (VM vm : vmsToUpdate) {
        VmManagementParametersBase params = new VmManagementParametersBase(vm);
        params.setApplyChangesLater(true);
        runInternalAction(VdcActionType.UpdateVm, params);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    if (getVdsGroup() == null) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (getVdsGroup() == null) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null && getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null && !isInstanceType() && !isBlankTemplate()) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean isQuotaDependant() {
    if (getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return false;
    }
    return super.isQuotaDependant();
}
#method_after
@Override
protected boolean isQuotaDependant() {
    if (isInstanceType() || isBlankTemplate()) {
        return false;
    }
    return super.isQuotaDependant();
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVdsGroup().getCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVdsGroup().getCompatibilityVersion()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    SpmStopOnIrsVDSCommandParameters params = new SpmStopOnIrsVDSCommandParameters(getStoragePoolForVds().getId(), getParameters().getPreferredSPMId());
    if (runVdsCommand(VDSCommandType.SpmStopOnIrs, params).getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.USER_FORCE_SELECTED_SPM);
    } else {
        AuditLogDirector.log(this, AuditLogType.USER_FORCE_SELECTED_SPM_STOP_FAILED);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    SpmStopOnIrsVDSCommandParameters params = new SpmStopOnIrsVDSCommandParameters(getStoragePoolForVds().getId(), getParameters().getPreferredSPMId());
    if (runVdsCommand(VDSCommandType.SpmStopOnIrs, params).getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.USER_FORCE_SELECTED_SPM);
    } else {
        auditLogDirector.log(this, AuditLogType.USER_FORCE_SELECTED_SPM_STOP_FAILED);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            map.setStatus(StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                calcStoragePoolStatusByDomainsStatus();
            }
            return null;
        }
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        activateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    // Master domain must not go through the Activating status.
    changeStorageDomainStatusInTransaction(map, (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) ? StorageDomainStatus.Locked : StorageDomainStatus.Activating);
    freeLock();
    log.info("ActivateStorage Domain. Before Connect all hosts to pool. Time: {}", new Date());
    List<Pair<Guid, Boolean>> hostsConnectionResults = connectHostsInUpToDomainStorageServer();
    syncStorageDomainInfo(hostsConnectionResults);
    runVdsCommand(VDSCommandType.ActivateStorageDomain, new ActivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId()));
    log.info("ActivateStorage Domain. After Connect all hosts to pool. Time: {}", new Date());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            map.setStatus(StorageDomainStatus.Active);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                calcStoragePoolStatusByDomainsStatus();
            }
            return null;
        }
    });
    refreshAllVdssInPool();
    log.info("ActivateStorage Domain. After change storage pool status in vds. Time: {}", new Date());
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
        IsoDomainListSyncronizer.getInstance().refresheIsoDomainWhenActivateDomain(getStorageDomain().getId(), getStoragePool().getId());
    }
    setSucceeded(true);
}
#end_block

#method_before
private void refreshAllVdssInPool() {
    final List<Guid> vdsIdsToSetNonOperational = new ArrayList<>();
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
            return null;
        }
    });
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", getStorageDomainName());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
    }
}
#method_after
private void refreshAllVdssInPool() {
    final List<Guid> vdsIdsToSetNonOperational = new ArrayList<>();
    getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            runSynchronizeOperation(new RefreshPoolSingleAsyncOperationFactory(), vdsIdsToSetNonOperational);
            return null;
        }
    });
    for (Guid vdsId : vdsIdsToSetNonOperational) {
        Map<String, String> customLogValues = Collections.singletonMap("StorageDomainNames", getStorageDomainName());
        SetNonOperationalVdsParameters tempVar = new SetNonOperationalVdsParameters(vdsId, STORAGE_DOMAIN_UNREACHABLE, customLogValues);
        tempVar.setStorageDomainId(getStorageDomain().getId());
        tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        runInternalAction(VdcActionType.SetNonOperationalVds, tempVar, ExecutionHandler.createInternalJobContext(getContext()));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#end_block

#method_before
private void removeTemplateFromDb() {
    removeNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
}
#method_after
private void removeTemplateFromDb() {
    removeNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
    vmIconDao.removeIfUnused(getVmTemplate().getSmallIconId());
    vmIconDao.removeIfUnused(getVmTemplate().getLargeIconId());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<LUNs> luns = getLunsForVgId(getVgId());
    List<LUNs> nonDummyLuns = new ArrayList<>(luns.size());
    StorageType storageType = getStorageType(luns);
    Map<String, LUNs> lunsFromDeviceMap = getLunsFromDeviceMap(storageType);
    for (LUNs lun : luns) {
        // Filter dummy luns
        if (lun.getLUN_id().startsWith(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX)) {
            continue;
        }
        nonDummyLuns.add(lun);
        // Update LUN's connections
        for (LUN_storage_server_connection_map map : getLunConnections(lun.getLUN_id())) {
            addConnection(lun, getConnection(map.getstorage_server_connection()));
        }
        // Update LUN's 'PathsDictionary' by 'lunsFromDeviceList'
        LUNs lunFromDeviceList = lunsFromDeviceMap.get(lun.getLUN_id());
        if (lunFromDeviceList != null) {
            lun.setPathsDictionary(lunFromDeviceList.getPathsDictionary());
        }
    }
    setReturnValue(nonDummyLuns);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<LUNs> luns = getLunsForVgId(getVgId());
    List<LUNs> nonDummyLuns = new ArrayList<>(luns.size());
    StorageType storageType = getStorageType(luns);
    Map<String, LUNs> lunsFromDeviceMap = getLunsFromDeviceMap(storageType);
    for (LUNs lun : luns) {
        // Filter dummy luns
        if (lun.getLUN_id().startsWith(BusinessEntitiesDefinitions.DUMMY_LUN_ID_PREFIX)) {
            continue;
        }
        nonDummyLuns.add(lun);
        // Update LUN's connections
        for (LUNStorageServerConnectionMap map : getLunConnections(lun.getLUN_id())) {
            addConnection(lun, getConnection(map.getstorage_server_connection()));
        }
        // Update LUN's 'PathsDictionary' by 'lunsFromDeviceList'
        LUNs lunFromDeviceList = lunsFromDeviceMap.get(lun.getLUN_id());
        if (lunFromDeviceList != null) {
            lun.setPathsDictionary(lunFromDeviceList.getPathsDictionary());
        }
    }
    setReturnValue(nonDummyLuns);
}
#end_block

#method_before
private StorageType getStorageType(List<LUNs> luns) {
    StorageType storageType = null;
    if (!luns.isEmpty()) {
        LUNs lun = luns.get(0);
        List<LUN_storage_server_connection_map> lunConnections = getLunConnections(lun.getLUN_id());
        if (!lunConnections.isEmpty()) {
            StorageServerConnections connection = getConnection(lunConnections.get(0).getstorage_server_connection());
            storageType = connection.getstorage_type();
        } else {
            storageType = StorageType.FCP;
        }
    }
    return storageType;
}
#method_after
private StorageType getStorageType(List<LUNs> luns) {
    StorageType storageType = null;
    if (!luns.isEmpty()) {
        LUNs lun = luns.get(0);
        List<LUNStorageServerConnectionMap> lunConnections = getLunConnections(lun.getLUN_id());
        if (!lunConnections.isEmpty()) {
            StorageServerConnections connection = getConnection(lunConnections.get(0).getstorage_server_connection());
            storageType = connection.getstorage_type();
        } else {
            storageType = StorageType.FCP;
        }
    }
    return storageType;
}
#end_block

#method_before
protected List<LUN_storage_server_connection_map> getLunConnections(String lunId) {
    return getDbFacade().getStorageServerConnectionLunMapDao().getAll(lunId);
}
#method_after
protected List<LUNStorageServerConnectionMap> getLunConnections(String lunId) {
    return getDbFacade().getStorageServerConnectionLunMapDao().getAll(lunId);
}
#end_block

#method_before
public static CommandContext createInternalJobContext(EngineLock lock) {
    return modifyContextForIntenralJob(new CommandContext(new EngineContext()), lock);
}
#method_after
public static CommandContext createInternalJobContext(EngineLock lock) {
    return modifyContextForInternalJob(new CommandContext(new EngineContext()), lock);
}
#end_block

#method_before
public static CommandContext createInternalJobContext(CommandContext commandContext, EngineLock lock) {
    return modifyContextForIntenralJob(commandContext.clone(), lock);
}
#method_after
public static CommandContext createInternalJobContext(CommandContext commandContext, EngineLock lock) {
    return modifyContextForInternalJob(commandContext.clone(), lock);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    return updateBrickServerNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isReplicatedType()) {
        if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isStripedType()) {
        if (getParameters().getStripeCount() > getGlusterVolume().getStripeCount() + 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_STRIPE_COUNT_MORE_THAN_ONE);
        } else if (getParameters().getStripeCount() < getGlusterVolume().getStripeCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_STRIPE_COUNT);
        }
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    if (getGlusterVolume().getVolumeType().isDistributedDispersedType()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_ADD_BRICK_TO_DISTRIBUTED_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    return updateBrickServerAndInterfaceNames(getParameters().getBricks(), true) && validateDuplicateBricks(getParameters().getBricks());
}
#end_block

#method_before
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    vm.setVmtName(null);
    Snapshot activeSnapshot = getDbFacade().getSnapshotDao().get(getDbFacade().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    try {
        updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
    } catch (VdcBLLException e) {
        log.error("Updating VM OVF in export domain failed.", e);
        AuditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED_UPDATING_OVF);
    }
}
#method_after
private void endCopyCollapseOperations(VM vm) {
    vm.setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    vm.setVmtName(null);
    Snapshot activeSnapshot = getDbFacade().getSnapshotDao().get(getDbFacade().getSnapshotDao().getId(vm.getId(), SnapshotType.ACTIVE));
    vm.setSnapshots(Arrays.asList(activeSnapshot));
    try {
        updateCopyVmInSpm(getVm().getStoragePoolId(), vm, getParameters().getStorageDomainId());
    } catch (VdcBLLException e) {
        log.error("Updating VM OVF in export domain failed.", e);
        auditLogDirector.log(this, AuditLogType.IMPORTEXPORT_IMPORT_VM_FAILED_UPDATING_OVF);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    getVmTemplate().setVdsGroupId(getParameters().getVdsGroupId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVds(null);
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    VmHandler.updateImportedVmUsbPolicy(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        image_storage_domain_map map = BaseImagesCommand.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!DbFacade.getInstance().getBaseDiskDao().exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            DbFacade.getInstance().getBaseDiskDao().save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setactual_size(image.getActualSizeInBytes());
        DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#method_after
protected void addVmTemplateToDb() {
    getVmTemplate().setVdsGroupId(getParameters().getVdsGroupId());
    // if "run on host" field points to a non existent vds (in the current cluster) -> remove field and continue
    if (!VmHandler.validateDedicatedVdsExistOnSameCluster(getVmTemplate(), null)) {
        getVmTemplate().setDedicatedVmForVds(null);
    }
    getVmTemplate().setStatus(VmTemplateStatus.Locked);
    getVmTemplate().setQuotaId(getParameters().getQuotaId());
    VmHandler.updateImportedVmUsbPolicy(getVmTemplate());
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    int count = 1;
    for (DiskImage image : getImages()) {
        image.setActive(true);
        ImageStorageDomainMap map = BaseImagesCommand.saveImage(image);
        getCompensationContext().snapshotNewEntity(image.getImage());
        getCompensationContext().snapshotNewEntity(map);
        if (!DbFacade.getInstance().getBaseDiskDao().exists(image.getId())) {
            image.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(image, getVmTemplateName(), count));
            count++;
            DbFacade.getInstance().getBaseDiskDao().save(image);
            getCompensationContext().snapshotNewEntity(image);
        }
        DiskImageDynamic diskDynamic = new DiskImageDynamic();
        diskDynamic.setId(image.getImageId());
        diskDynamic.setactual_size(image.getActualSizeInBytes());
        DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
        getCompensationContext().snapshotNewEntity(diskDynamic);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            synchronized (instance) {
                log.info("Power Management Health Check started.");
                active = true;
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.isPmEnabled()) {
                        pmHealthCheck(host);
                    }
                }
                log.info("Power Management Health Check completed.");
            }
        } finally {
            active = false;
        }
    }
}
#method_after
@OnTimerMethodAnnotation("pmHealthCheck")
public void pmHealthCheck() {
    // skip PM health check if previous operation is not completed yet
    if (!active) {
        try {
            synchronized (this) {
                log.info("Power Management Health Check started.");
                active = true;
                List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
                for (VDS host : hosts) {
                    if (host.isPmEnabled()) {
                        pmHealthCheck(host);
                    }
                }
                log.info("Power Management Health Check completed.");
            }
        } finally {
            active = false;
        }
    }
}
#end_block

#method_before
private void addAlert(Guid hostId, AuditLogType auditMessage) {
    AlertDirector.AddVdsAlert(hostId, auditMessage);
}
#method_after
private void addAlert(Guid hostId, AuditLogType auditMessage) {
    AlertDirector.AddVdsAlert(hostId, auditMessage, auditLogDirector);
}
#end_block

#method_before
private boolean isHealthy(FenceAgent agent, VDS host) {
    return new FenceExecutor(host).fence(FenceActionType.STATUS, agent).getSucceeded();
}
#method_after
private boolean isHealthy(FenceAgent agent, VDS host) {
    return new HostFenceActionExecutor(host).getFenceAgentStatus(agent).getStatus() == Status.SUCCESS;
}
#end_block

#method_before
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId(), FenceActionType.STATUS));
        VDSFenceReturnValue returnValue = new FenceExecutor(host).checkHostStatus();
        if (FenceExecutor.isStatusOff(returnValue)) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#method_after
public void startHosts(List<VDS> hostWithPMInStatusReboot) {
    for (VDS host : hostWithPMInStatusReboot) {
        RestartVdsCommand<FenceVdsActionParameters> restartVdsCommand = new RestartVdsCommand<>(new FenceVdsActionParameters(host.getId()));
        if (new HostFenceActionExecutor(host).isHostPoweredOff()) {
            VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.RestartVds, restartVdsCommand.getParameters());
            if (retValue != null && retValue.getSucceeded()) {
                log.info("Host '{}' was started successfully by PM Health Check Manager", host.getName());
            } else {
                log.info("PM Health Check Manager failed to start Host '{}'", host.getName());
            }
        }
    }
}
#end_block

#method_before
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        final FenceVdsActionParameters params = new FenceVdsActionParameters(host.getId(), FenceActionType.RESTART);
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, params, ExecutionHandler.createInternalJobContext());
            }
        });
    }
}
#method_after
private void executeNotRespondingTreatment(List<VDS> hosts) {
    for (VDS host : hosts) {
        final FenceVdsActionParameters params = new FenceVdsActionParameters(host.getId());
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                Backend.getInstance().runInternalAction(VdcActionType.VdsNotRespondingTreatment, params, ExecutionHandler.createInternalJobContext());
            }
        });
    }
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, isBalloonEnabled(params));
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null, false);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(entity, isBalloonEnabled(params));
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
        updateVirtioScsiController(entity.getId(), params.isVirtioScsiEnabled());
    }
}
#end_block

#method_before
public static void addSmartcardDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, new SmartcardSpecParams(), true, false, null);
}
#method_after
public static void addSmartcardDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SMARTCARD, VmDeviceType.SMARTCARD, new SmartcardSpecParams(), true, false, null, false);
}
#end_block

#method_before
private static void addConsoleDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, new HashMap<String, Object>(), true, false, null);
}
#method_after
private static void addConsoleDevice(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONSOLE, VmDeviceType.CONSOLE, new HashMap<String, Object>(), true, false, null, false);
}
#end_block

#method_before
private static void addVirtioScsiController(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, new HashMap<String, Object>(), true, false, null);
}
#method_after
private static void addVirtioScsiController(Guid vmId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, new HashMap<String, Object>(), true, false, null, false);
}
#end_block

#method_before
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = osRepository.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
    }
}
#method_after
public static void updateAudioDevice(VmBase oldVm, VmBase newVmBase, Version compatibilityVersion, Boolean isSoundDeviceEnabled) {
    boolean removeDevice = false;
    boolean createDevice = false;
    Guid vmId = oldVm.getId();
    boolean osChanged = oldVm.getOsId() != newVmBase.getOsId();
    List<VmDevice> list = dbFacade.getVmDeviceDao().getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.SOUND);
    // recreate device only if previously existed and os has changed
    if (isSoundDeviceEnabled == null) {
        if (!list.isEmpty() && osChanged) {
            removeDevice = createDevice = true;
        }
    } else {
        // if soundeDevice disabled or os changed, and device exist, remove
        removeDevice = (!isSoundDeviceEnabled || osChanged) && !list.isEmpty();
        // if soundDevice enabled and missing or os changed, create
        createDevice = isSoundDeviceEnabled && (list.isEmpty() || osChanged);
    }
    if (removeDevice) {
        removeNumberOfDevices(list, list.size());
    }
    if (createDevice) {
        String soundDevice = osRepository.getSoundDevice(newVmBase.getOsId(), compatibilityVersion);
        addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null, false);
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            addSoundCard(vmBase, cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM vm, VmBase vmBase, boolean isVm, List<VmDevice> devicesDataToUse, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping, boolean soundDeviceEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    Guid id;
    if (graphicsToSkip == null) {
        graphicsToSkip = new HashSet<>();
    }
    String isoPath = vmBase.getIsoPath();
    // indicates that VM should have CD either from its own (iso_path) or from the snapshot it was cloned from.
    boolean shouldHaveCD = StringUtils.isNotEmpty(isoPath);
    // indicates if VM has already a non empty CD in DB
    boolean hasAlreadyCD = (!(dbFacade.getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(vmBase.getId(), VmDeviceGeneralType.DISK, VmDeviceType.CDROM.getName())).isEmpty());
    boolean addCD = (!hasAlreadyCD && shouldHaveCD);
    boolean hasSoundDevice = false;
    boolean hasAlreadyConsoleDevice = false;
    boolean hasVirtioScsiController = false;
    VDSGroup cluster = vmBase.getVdsGroupId() != null ? DbFacade.getInstance().getVdsGroupDao().get(vmBase.getVdsGroupId()) : null;
    for (VmDevice device : devicesDataToUse) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        id = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        if (srcId.equals(Guid.Empty)) {
            // add CD if not exists
            if (addCD) {
                setCdPath(specParams, "", isoPath);
                addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, specParams, true, true, null, false);
                hasAlreadyCD = true;
                addCD = false;
            }
            // updating USB slots
            updateUSBSlots(null, vmBase);
            // add mem balloon if defined
            updateMemoryBalloon(vmBase, isBalloonEnabled);
        }
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                        id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    // check here is source VM had CD (Vm from snapshot)
                    String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                    shouldHaveCD = (!StringUtils.isEmpty(srcCdPath) || shouldHaveCD);
                    if (!hasAlreadyCD && shouldHaveCD) {
                        setCdPath(specParams, srcCdPath, isoPath);
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToTargetDeviceIdMapping.containsKey(device.getDeviceId())) {
                    id = srcDeviceIdToTargetDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsiController = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (isVm) {
                    // to the new VMStatic params
                    continue;
                } else {
                    specParams.putAll(getMemExpr(vmBase.getNumOfMonitors(), vmBase.getSingleQxlPci()));
                }
                break;
            case BALLOON:
                specParams.put(VdsProperties.Model, VdsProperties.Virtio);
                break;
            case SMARTCARD:
                specParams = new SmartcardSpecParams();
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasVmRngDevice(dstId)) {
                    // don't copy rng device if we already have it
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                hasAlreadyConsoleDevice = true;
                if (!isConsoleEnabled) {
                    continue;
                }
                break;
            case SOUND:
                hasSoundDevice = true;
                if (!soundDeviceEnabled) {
                    continue;
                }
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasVmGraphicsDeviceOfType(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(id, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    // if VM does not has CD, add an empty CD
    if (!shouldHaveCD) {
        addEmptyCD(dstId);
    }
    // if source doesnt have sound device and requested, add it
    if (soundDeviceEnabled && !hasSoundDevice) {
        if (isVm) {
            addSoundCard(vm.getStaticData(), vm.getVdsGroupCompatibilityVersion());
        } else {
            addSoundCard(vmBase, cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasAlreadyConsoleDevice) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsiController) {
        addVirtioScsiController(dstId);
    }
    if (isVm) {
        // update devices boot order
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
        int numOfMonitors = getNumOfMonitors(vm);
        // create Video device. Multiple if display type is spice
        for (int i = 0; i < numOfMonitors; i++) {
            addVideoDevice(vmBase);
        }
    }
}
#end_block

#method_before
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = osRepository.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null);
}
#method_after
private static void addSoundCard(VmBase vmBase, Version vdsGroupCompatibilityVersion) {
    String soundDevice = osRepository.getSoundDevice(vmBase.getOsId(), vdsGroupCompatibilityVersion);
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vmBase.getId()), VmDeviceGeneralType.SOUND, VmDeviceType.getSoundDeviceType(soundDevice), new HashMap<String, Object>(), true, true, null, false);
}
#end_block

#method_before
private static void addVideoDevice(VmBase vm) {
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vm.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null);
}
#method_after
private static void addVideoDevice(VmBase vm) {
    addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.VIDEO, vm.getDefaultDisplayType().getDefaultVmDeviceType(), getMemExpr(vm.getNumOfMonitors(), vm.getSingleQxlPci()), true, true, null, false);
}
#end_block

#method_before
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, null);
}
#method_after
public static VmDevice addNetworkInterfaceDevice(VmDeviceId id, boolean plugged, boolean hostDev) {
    return addManagedDevice(id, VmDeviceGeneralType.INTERFACE, hostDev ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, Collections.<String, Object>emptyMap(), plugged, false, null, false);
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean plugged, Boolean readOnly, String address, Map<String, String> customProp) {
    VmDevice managedDevice = addManagedDevice(id, type, device, specParams, plugged, readOnly, customProp);
    if (StringUtils.isNotBlank(address)) {
        managedDevice.setAddress(address);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean plugged, Boolean readOnly, String address, Map<String, String> customProp) {
    VmDevice managedDevice = addManagedDevice(id, type, device, specParams, plugged, readOnly, customProp, false);
    if (StringUtils.isNotBlank(address)) {
        managedDevice.setAddress(address);
    }
    return managedDevice;
}
#end_block

#method_before
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = dbFacade.getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#method_after
public static VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType type, VmDeviceType device, Map<String, Object> specParams, boolean is_plugged, Boolean isReadOnly, Map<String, String> customProp, boolean isUsingScsiReservation) {
    VmDevice managedDevice = new VmDevice(id, type, device.getName(), "", 0, specParams, true, is_plugged, isReadOnly, "", customProp, null, null, isUsingScsiReservation);
    dao.save(managedDevice);
    // If we add Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (type == VmDeviceGeneralType.DISK || type == VmDeviceGeneralType.INTERFACE) {
        // recalculate boot sequence
        VmBase vmBase = dbFacade.getVmStaticDao().get(id.getVmId());
        updateBootOrderInVmDeviceAndStoreToDB(vmBase);
    }
    return managedDevice;
}
#end_block

#method_before
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#method_after
private static <T extends VmBase> void addImportedInterfaces(T entity, List<VmDevice> vmDeviceToUpdate) {
    final Guid id = entity.getId();
    for (VmNic iface : entity.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addManagedDevice(new VmDeviceId(deviceId, id), VmDeviceGeneralType.INTERFACE, iface.isPassthrough() ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, null, true, false, getAddress(entity, id), null);
        VmDevice exportedDevice = entity.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            entity.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateVmDevice(entity, vmDevice, deviceId, vmDeviceToUpdate);
    }
}
#end_block

#method_before
private static void addUsbSlots(VmBase vm, int numOfSlots) {
    for (int index = 1; index <= numOfSlots; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, getUsbSlotSpecParams(), true, false, null);
    }
}
#method_after
private static void addUsbSlots(VmBase vm, int numOfSlots) {
    for (int index = 1; index <= numOfSlots; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.REDIR, VmDeviceType.SPICEVMC, getUsbSlotSpecParams(), true, false, null, false);
    }
}
#end_block

#method_before
private static void addUsbControllers(VmBase vm, int numOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numOfControllers; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false, null);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false, null);
        }
    }
}
#method_after
private static void addUsbControllers(VmBase vm, int numOfControllers) {
    // For each controller we need to create one EHCI and companion UHCI controllers
    for (int index = 0; index < numOfControllers; index++) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(EHCI_MODEL, 1, index), true, false, null, false);
        for (int companionIndex = 1; companionIndex <= COMPANION_USB_CONTROLLERS; companionIndex++) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.USB, getUsbControllerSpecParams(UHCI_MODEL, companionIndex, index), true, false, null, false);
        }
    }
}
#end_block

#method_before
private static void addEmptyCD(Guid dstId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, Collections.<String, Object>singletonMap(VdsProperties.Path, ""), true, true, null);
}
#method_after
private static void addEmptyCD(Guid dstId) {
    VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), dstId), VmDeviceGeneralType.DISK, VmDeviceType.CDROM, Collections.<String, Object>singletonMap(VdsProperties.Path, ""), true, true, null, false);
}
#end_block

#method_before
public static void updateMemoryBalloon(Guid id, boolean shouldHaveBalloon) {
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), id), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(id, VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#method_after
public static void updateMemoryBalloon(Guid id, boolean shouldHaveBalloon) {
    boolean hasBalloon = dao.isMemBalloonEnabled(id);
    if (hasBalloon != shouldHaveBalloon) {
        if (!hasBalloon && shouldHaveBalloon) {
            // add a balloon device
            Map<String, Object> specParams = new HashMap<>();
            specParams.put(VdsProperties.Model, VdsProperties.Virtio);
            addManagedDevice(new VmDeviceId(Guid.newGuid(), id), VmDeviceGeneralType.BALLOON, VmDeviceType.MEMBALLOON, specParams, true, true, null, false);
        } else {
            // remove the balloon device
            List<VmDevice> list = DbFacade.getInstance().getVmDeviceDao().getVmDeviceByVmIdAndType(id, VmDeviceGeneralType.BALLOON);
            removeNumberOfDevices(list, 1);
        }
    }
}
#end_block

#method_before
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return VmDeviceCommonUtils.isDisk(vmDevice) || VmDeviceCommonUtils.isBridge(vmDevice);
}
#method_after
private static boolean isDiskOrInterface(VmDevice vmDevice) {
    return VmDeviceCommonUtils.isDisk(vmDevice) || VmDeviceCommonUtils.isNetwork(vmDevice);
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, String device, boolean deviceEnabled) {
    List<VmDevice> vmDevices = device != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceType, device) : dao.getVmDeviceByVmIdAndType(vmId, deviceType);
    return deviceEnabled == vmDevices.isEmpty();
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceGeneralType, String deviceTypeName, boolean deviceEnabled) {
    List<VmDevice> vmDevices = deviceTypeName != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceGeneralType, deviceTypeName) : dao.getVmDeviceByVmIdAndType(vmId, deviceGeneralType);
    return deviceEnabled == vmDevices.isEmpty();
}
#end_block

#method_before
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceType, boolean deviceEnabled) {
    return vmDeviceChanged(vmId, deviceType, null, deviceEnabled);
}
#method_after
public static boolean vmDeviceChanged(Guid vmId, VmDeviceGeneralType deviceGeneralType, String deviceTypeName, VmDevice device) {
    List<VmDevice> vmDevices = deviceTypeName != null ? dao.getVmDeviceByVmIdTypeAndDevice(vmId, deviceGeneralType, deviceTypeName) : dao.getVmDeviceByVmIdAndType(vmId, deviceGeneralType);
    if (device == null)
        return !vmDevices.isEmpty();
    if (// && device != null
    vmDevices.isEmpty())
        return true;
    if (device.getSpecParams() != null) {
        // if device.getSpecParams() == null, it is not used for comparison
        for (VmDevice vmDevice : vmDevices) {
            if (!vmDevice.getSpecParams().equals(device.getSpecParams())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (Pair<EditableDeviceOnVmStatusField, Boolean> pair : fieldList) {
        final EditableDeviceOnVmStatusField field = pair.getFirst();
        Boolean isEnabled = pair.getSecond();
        if (Boolean.TRUE.equals(isEnabled)) {
            VmDevice device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), field.generalType(), field.type().getName(), "", 0, new HashMap<String, Object>(), true, true, field.isReadOnly(), "", null, null, null);
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            vmManagedDeviceMap.remove(getVmDeviceIdByName(vmManagedDeviceMap, field.generalType(), field.type().getName()));
        }
    }
    return vmManagedDeviceMap;
}
#method_after
public static Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    VmDeviceUtils.setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, new HashMap<String, Object>(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            vmManagedDeviceMap.remove(getVmDeviceIdByName(vmManagedDeviceMap, update.getGeneralType(), update.getType().getName()));
        }
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
protected DiskDao getDiskDao() {
    return getDbFacade().getDiskDao();
}
#method_after
public DiskDao getDiskDao() {
    return getDbFacade().getDiskDao();
}
#end_block

#method_before
public List<Permissions> asPermissionList() {
    List<Permissions> res = new ArrayList<>();
    for (PermissionWithUniqueKeyEquals permission : this) {
        res.add(permission.asPermission());
    }
    return res;
}
#method_after
public List<Permission> asPermissionList() {
    List<Permission> res = new ArrayList<>();
    for (PermissionWithUniqueKeyEquals permission : this) {
        res.add(permission.asPermission());
    }
    return res;
}
#end_block

#method_before
public Permissions asPermission() {
    return new Permissions(getad_element_id(), getrole_id(), getObjectId(), getObjectType());
}
#method_after
public Permission asPermission() {
    return new Permission(getAdElementId(), getRoleId(), getObjectId(), getObjectType());
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((getad_element_id() == null) ? 0 : getad_element_id().hashCode());
    result = prime * result + ((getObjectId() == null) ? 0 : getObjectId().hashCode());
    result = prime * result + ((getrole_id() == null) ? 0 : getrole_id().hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((getAdElementId() == null) ? 0 : getAdElementId().hashCode());
    result = prime * result + ((getObjectId() == null) ? 0 : getObjectId().hashCode());
    result = prime * result + ((getRoleId() == null) ? 0 : getRoleId().hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Permissions other = (Permissions) obj;
    return Objects.equals(getad_element_id(), other.getad_element_id()) && Objects.equals(getrole_id(), other.getrole_id()) && Objects.equals(getObjectId(), other.getObjectId());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    Permission other = (Permission) obj;
    return Objects.equals(getAdElementId(), other.getAdElementId()) && Objects.equals(getRoleId(), other.getRoleId()) && Objects.equals(getObjectId(), other.getObjectId());
}
#end_block

#method_before
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (getBaseDiskDao().exists(diskImage.getId())) {
            getBaseDiskDao().update(diskImage);
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (getDiskImageDao().getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                ImagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new image_storage_domain_map(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            ImagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#method_after
protected void synchronizeDisksFromSnapshot(Guid vmId, Guid snapshotId, Guid activeSnapshotId, List<DiskImage> disksFromSnapshot, String vmName) {
    List<Guid> diskIdsFromSnapshot = new ArrayList<>();
    // Sync disks that exist or existed in the snapshot.
    int count = 1;
    for (DiskImage diskImage : disksFromSnapshot) {
        diskIdsFromSnapshot.add(diskImage.getId());
        if (getBaseDiskDao().exists(diskImage.getId())) {
            getBaseDiskDao().update(diskImage);
        } else {
            // If can't find the image, insert it as illegal so that it can't be used and make the device unplugged.
            if (getDiskImageDao().getSnapshotById(diskImage.getImageId()) == null) {
                diskImage.setImageStatus(ImageStatus.ILLEGAL);
                diskImage.setVmSnapshotId(activeSnapshotId);
                ImagesHandler.addImage(diskImage, true, (diskImage.getStorageIds() == null) ? null : new ImageStorageDomainMap(diskImage.getImageId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId(), diskImage.getDiskProfileId()));
            }
            ImagesHandler.addDiskToVm(diskImage, vmId);
        }
        diskImage.setDiskAlias(ImagesHandler.getSuggestedDiskAlias(diskImage, vmName, count));
        count++;
    }
    removeDisksNotInSnapshot(vmId, diskIdsFromSnapshot);
}
#end_block

#method_before
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
public static void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        AuditLogDirector.log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#method_after
public static void warnMemorySizeLegal(VmBase vm, Version clusterVersion) {
    if (!VmValidationUtils.isMemorySizeLegal(vm.getOsId(), vm.getMemSizeMb(), clusterVersion)) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vm.getId());
        logable.addCustomValue("VmName", vm.getName());
        logable.addCustomValue("VmMemInMb", String.valueOf(vm.getMemSizeMb()));
        logable.addCustomValue("VmMinMemInMb", String.valueOf(VmValidationUtils.getMinMemorySizeInMb(vm.getOsId(), clusterVersion)));
        logable.addCustomValue("VmMaxMemInMb", String.valueOf(VmValidationUtils.getMaxMemorySizeInMb(vm.getOsId(), clusterVersion)));
        new AuditLogDirector().log(logable, AuditLogType.VM_MEMORY_NOT_IN_RECOMMENDED_RANGE);
    }
}
#end_block

#method_before
public static List<Pair<EditableDeviceOnVmStatusField, Boolean>> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<Pair<EditableDeviceOnVmStatusField, Boolean>> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        Boolean isEnabled = null;
        try {
            isEnabled = (Boolean) field.get(objectWithEditableDeviceFields);
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler:: isUpdateValidForVmDevices: Reflection error");
            log.debug("Original exception was:", e);
        }
        // if device type is set to unknown, search by general type only
        // because some devices has more than one type, like sound can be ac97/ich6
        String device = null;
        if (annotation.type() != VmDeviceType.UNKNOWN) {
            device = annotation.type().getName();
        }
        if (isEnabled == null || !VmDeviceUtils.vmDeviceChanged(vmId, annotation.generalType(), device, isEnabled)) {
            continue;
        }
        if (!VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            fieldList.add(new Pair<>(annotation, isEnabled));
        }
    }
    return fieldList;
}
#method_after
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value == null) {
            // preserve current configuration
            } else if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof VmManagementParametersBase.Optional) {
                VmManagementParametersBase.Optional<?> optional = (VmManagementParametersBase.Optional<?>) value;
                if (optional.isUpdate()) {
                    addDeviceUpdateOnNextRun(vmId, annotation, null, optional.getValue(), fieldList);
                }
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    initHostKdumpDetectionStatus();
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSGroup vdsGroup = getVdsGroup();
    boolean initSucceeded = true;
    initHostKdumpDetectionStatus();
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (vdsGroup.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && vdsGroup.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && vdsGroup.supportsGlusterService()) {
        initSucceeded = initGlusterHost();
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        auditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
private void processFence() {
    FenceExecutor executor = new FenceExecutor(getVds());
    vdsProxyFound = new FenceProxyLocator(getVds()).isProxyHostAvailable();
    if (getVds().isPmEnabled() && vdsProxyFound) {
        VDSFenceReturnValue returnValue = executor.checkHostStatus();
        fenceSucceeded = returnValue.getSucceeded();
        fenceStatusReturnValue = (FenceStatusReturnValue) returnValue.getReturnValue();
    }
}
#method_after
private void processFence() {
    vdsProxyFound = new FenceProxyLocator(getVds()).isProxyHostAvailable();
    if (getVds().isPmEnabled() && vdsProxyFound) {
        HostFenceActionExecutor executor = new HostFenceActionExecutor(getVds());
        fenceStatusResult = executor.fence(FenceActionType.STATUS);
        fenceSucceeded = fenceStatusResult.getStatus() == Status.SUCCESS;
    }
}
#end_block

#method_before
private EventResult connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    return result;
}
#method_after
private EventResult connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = eventQueue.submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    return result;
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomain(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown, storagePool);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDAO().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDAO().getStorageDomain(storagePoolId, StorageDomainType.Master);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (VdcBLLException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != VdcBllErrors.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown, storagePool);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (getVdsGroup().supportsVirtService()) {
        if (!connectPoolSucceeded) {
            type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
        } else if (getVds().isPmEnabled() && fenceSucceeded) {
            type = AuditLogType.VDS_FENCE_STATUS;
        } else if (getVds().isPmEnabled() && !fenceSucceeded) {
            type = AuditLogType.VDS_FENCE_STATUS_FAILED;
        }
        // PM alerts
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        if (getVds().isPmEnabled()) {
            if (!vdsProxyFound) {
                logable.addCustomValue("Reason", AuditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST));
                AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED);
            } else if (!fenceStatusReturnValue.getIsSucceeded()) {
                logable.addCustomValue("Reason", fenceStatusReturnValue.getMessage());
                AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED);
            }
        } else {
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED);
        }
    }
    if (type == AuditLogType.UNASSIGNED && getVdsGroup().supportsGlusterService()) {
        if (!glusterHostUuidFound) {
            type = AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        } else if (!glusterPeerListSucceeded) {
            type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
        } else if (!glusterPeerProbeSucceeded) {
            type = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        }
    }
    return type;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    AuditLogType type = AuditLogType.UNASSIGNED;
    if (getVdsGroup().supportsVirtService()) {
        if (!connectPoolSucceeded) {
            type = AuditLogType.CONNECT_STORAGE_POOL_FAILED;
        } else if (getVds().isPmEnabled() && fenceSucceeded) {
            type = AuditLogType.VDS_FENCE_STATUS;
        } else if (getVds().isPmEnabled() && !fenceSucceeded) {
            type = AuditLogType.VDS_FENCE_STATUS_FAILED;
        }
        // PM alerts
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        if (getVds().isPmEnabled()) {
            if (!vdsProxyFound) {
                logable.addCustomValue("Reason", auditLogDirector.getMessage(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST));
                AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, auditLogDirector);
            } else if (!fenceSucceeded) {
                logable.addCustomValue("Reason", fenceStatusResult.getMessage());
                AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, auditLogDirector);
            }
        } else {
            AlertDirector.Alert(logable, AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, auditLogDirector);
        }
    }
    if (type == AuditLogType.UNASSIGNED && getVdsGroup().supportsGlusterService()) {
        if (!glusterHostUuidFound) {
            type = AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        } else if (!glusterPeerListSucceeded) {
            type = AuditLogType.GLUSTER_SERVERS_LIST_FAILED;
        } else if (!glusterPeerProbeSucceeded) {
            type = AuditLogType.GLUSTER_SERVER_ADD_FAILED;
        }
    }
    return type;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogableBase logable = new AuditLogableBase(upServerId);
        logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
        AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#method_after
@SuppressWarnings("unchecked")
private List<GlusterServerInfo> getGlusterPeers(Guid upServerId) {
    List<GlusterServerInfo> glusterServers = new ArrayList<>();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServerId));
    if (!returnValue.getSucceeded()) {
        getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
        getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
        AuditLogableBase logable = new AuditLogableBase(upServerId);
        logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
        auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVERS_LIST_FAILED);
        glusterPeerListSucceeded = false;
    } else {
        glusterServers = (List<GlusterServerInfo>) returnValue.getReturnValue();
    }
    return glusterServers;
}
#end_block

#method_before
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            AuditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", getVds().getHostName(), e.getMessage());
        log.debug("Exception", e);
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#method_after
private boolean glusterPeerProbe(Guid upServerId, String newServerName) {
    try {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterServer, new AddGlusterServerVDSParameters(upServerId, newServerName));
        if (!returnValue.getSucceeded()) {
            getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
            getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
            AuditLogableBase logable = new AuditLogableBase(getVdsId());
            logable.updateCallStackFromThrowable(returnValue.getExceptionObject());
            auditLogDirector.log(logable, AuditLogType.GLUSTER_SERVER_ADD_FAILED);
            glusterPeerProbeSucceeded = false;
        }
        return returnValue.getSucceeded();
    } catch (Exception e) {
        log.error("Could not peer probe the gluster server '{}': {}", getVds().getHostName(), e.getMessage());
        log.debug("Exception", e);
        glusterPeerProbeSucceeded = false;
        return false;
    }
}
#end_block

#method_before
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    getDbFacade().getVdsKdumpStatusDao().remove(getVdsId());
    if (getVds().isPmEnabled() && getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        AuditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#method_after
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    getDbFacade().getVdsKdumpStatusDao().remove(getVdsId());
    if (getVds().isPmEnabled() && getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        auditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#end_block

#method_before
@Override
protected void postConstruct() {
    super.postConstruct();
    T parameters = getParameters();
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
    Version clusterVersion = getVdsGroup() == null ? null : getVdsGroup().getCompatibilityVersion();
    VmStatic staticData = getVm() == null ? null : getVm().getStaticData();
    ImportUtils.updateGraphicsDevices(staticData, clusterVersion);
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    super.postConstruct();
    T parameters = getParameters();
    setVmId(parameters.getContainerId());
    setVm(parameters.getVm());
    setVdsGroupId(parameters.getVdsGroupId());
    if (parameters.getVm() != null && getVm().getDiskMap() != null) {
        imageList = new ArrayList<>();
        for (Disk disk : getVm().getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                imageList.add((DiskImage) disk);
            }
        }
    }
    ensureDomainMap(imageList, parameters.getDestDomainId());
    Version clusterVersion = getVdsGroup() == null ? null : getVdsGroup().getCompatibilityVersion();
    VmStatic staticData = getVm() == null ? null : getVm().getStaticData();
    ImportUtils.updateGraphicsDevices(staticData, clusterVersion);
}
#end_block

#method_before
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVmId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<>(Arrays.asList(getSourceDomainId(image))));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#method_after
protected boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    Set<Guid> destGuids = new HashSet<>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (!isImagesAlreadyOnTarget() && getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    if (isImagesAlreadyOnTarget() && getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_UNREGISTERED_NOT_COLLAPSED);
    }
    if (!isImagesAlreadyOnTarget()) {
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
        if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        }
        VM vm = getVmFromExportDomain(getParameters().getVmId());
        if (vm == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND_ON_EXPORT_DOMAIN);
        }
        // At this point we should work with the VM that was read from
        // the OVF because the VM from the parameters may lack images
        setVmFromExportDomain(vm);
    }
    if (!validateImages(domainsMap)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#method_after
@SuppressWarnings("unchecked")
protected List<VM> getVmsFromExportDomain() {
    VdcQueryReturnValue qRetVal = runInternalQuery(VdcQueryType.GetVmsFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    return (List<VM>) (qRetVal.getSucceeded() ? qRetVal.getReturnValue() : Collections.emptyList());
}
#end_block

#method_before
@Override
protected Snapshot getActiveSnapshot() {
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (snapshot.getType() == SnapshotType.ACTIVE)
            return snapshot;
    }
    log.warn("VM '{}' doesn't have active snapshot in export domain", getVmId());
    return null;
}
#method_after
@Override
protected Snapshot getActiveSnapshot() {
    Snapshot activeSnapshot = VmHandler.getActiveSnapshot(getVm());
    if (activeSnapshot == null) {
        log.warn("VM '{}' doesn't have active snapshot in export domain", getVmId());
    }
    return activeSnapshot;
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_IMPORT_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterBrickValidator brickValidator = new GlusterBrickValidator();
    return validate(brickValidator.canRemoveBrick(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount(), true));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOVE_BRICK_FROM_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    if (getGlusterVolume().getVolumeType().isDispersedType()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOVE_BRICK_FROM_DISTRIBUTED_DISPERSE_VOLUME_NOT_SUPPORTED);
    }
    GlusterBrickValidator brickValidator = new GlusterBrickValidator();
    return validate(brickValidator.canRemoveBrick(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount(), true));
}
#end_block

#method_before
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getNumOfCpus();
    VDS dedicatedVds = null;
    // can not check if no dedicated vds was configured
    if (vmStatic.getDedicatedVmForVds() != null) {
        dedicatedVds = getVds(vmStatic.getDedicatedVmForVds());
    } else {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_WITH_UNDEFINED_HOST);
    }
    Collection<Integer> onlinePcpus = new HashSet<>();
    if (dedicatedVds.getOnlineCpus() != null) {
        String[] onlinePcpusStr = dedicatedVds.getOnlineCpus().split(",");
        for (String Pcpu : onlinePcpusStr) {
            onlinePcpus.add(Integer.parseInt(Pcpu));
        }
    }
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxvCPU) {
            // ERROR maps to a non existent vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST);
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more then one definition for the same vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION);
        }
        Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return failCanDoAction(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return failCanDoAction(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU);
        }
    }
    return true;
}
#method_after
public boolean isCpuPinningValid(final String cpuPinning, VmStatic vmStatic) {
    if (StringUtils.isEmpty(cpuPinning)) {
        return true;
    }
    if (!cpuPinningPattern.matcher(cpuPinning).matches()) {
        // ERROR bad syntax
        addCanDoActionMessage(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        return false;
    }
    HashSet<Integer> vcpus = new HashSet<>();
    String[] rules = cpuPinning.split("_");
    int maxvCPU = vmStatic.getNumOfCpus();
    VDS dedicatedVds = null;
    // can not check if no dedicated vds was configured
    if (vmStatic.getDedicatedVmForVds() != null) {
        dedicatedVds = getVds(vmStatic.getDedicatedVmForVds());
    } else {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_PINNED_TO_CPU_WITH_UNDEFINED_HOST);
    }
    Collection<Integer> onlinePcpus = new HashSet<>();
    if (dedicatedVds.getOnlineCpus() != null) {
        String[] onlinePcpusStr = dedicatedVds.getOnlineCpus().split(",");
        for (String Pcpu : onlinePcpusStr) {
            onlinePcpus.add(Integer.parseInt(Pcpu));
        }
    }
    for (String rule : rules) {
        // [0] vcpu, [1] pcpu
        String[] splitRule = rule.split("#");
        int currVcpu = Integer.parseInt(splitRule[0]);
        if (currVcpu >= maxvCPU) {
            // ERROR maps to a non existent vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_VCPU_DOES_NOT_EXIST);
        }
        if (!vcpus.add(currVcpu)) {
            // ERROR contains more than one definition for the same vcpu
            return failCanDoAction(VdcBllMessages.VM_PINNING_DUPLICATE_DEFINITION);
        }
        Collection<Integer> currPcpus = parsePCpuPinningNumbers(splitRule[1]);
        if (currPcpus == null) {
            return failCanDoAction(VdcBllMessages.VM_PINNING_FORMAT_INVALID);
        }
        if (currPcpus.size() == 0) {
            // definition of pcpus is no cpu, e.g 0#1,^1
            return failCanDoAction(VdcBllMessages.VM_PINNING_PINNED_TO_NO_CPU);
        }
    }
    return true;
}
#end_block

#method_before
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getBalloonDevices(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
    }
}
#method_after
protected void updateParametersVmFromInstanceType() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setAutoStartup(instanceType.isAutoStartup());
        if (FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
            vmStatic.setMigrationSupport(instanceType.getMigrationSupport());
        }
        if (FeatureSupported.isIoThreadsSupported(getVdsGroup().getCompatibilityVersion())) {
            vmStatic.setNumOfIoThreads(instanceType.getNumOfIoThreads());
        }
        vmStatic.setMigrationDowntime(instanceType.getMigrationDowntime());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        List<VmDevice> vmDevices = VmDeviceUtils.getBalloonDevices(instanceType.getId());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        if (vmDevices.isEmpty()) {
            getParameters().setBalloonEnabled(false);
        } else if (osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
            getParameters().setBalloonEnabled(true);
        }
    }
}
#end_block

#method_before
public void createManagementNetworkIfRequired() {
    if (host == null) {
        return;
    }
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    final Network managementNetwork = managementNetworkUtil.getManagementNetwork(host.getVdsGroupId());
    final String managementNetworkName = managementNetwork.getName();
    if (managementNetworkName.equals(host.getActiveNic())) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetworkName, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        nic.setNetworkName(managementNetworkName);
        configureManagementNetwork(createSetupNetworkParams(interfaces));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
public void createManagementNetworkIfRequired() {
    if (host == null) {
        return;
    }
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    final Network managementNetwork = managementNetworkUtil.getManagementNetwork(host.getVdsGroupId());
    final String managementNetworkName = managementNetwork.getName();
    if (managementNetworkName.equals(host.getActiveNic())) {
        log.info("The management network '{}' is already configured on host '{}'", managementNetworkName, host.getName());
        return;
    }
    if (!FeatureSupported.setupManagementNetwork(host.getVdsGroupCompatibilityVersion())) {
        log.warn("Cluster of host '{}' does not support normalize management network feature", host.getName());
        return;
    }
    VdsNetworkInterface nic = findNicToSetupManagementNetwork();
    if (nic == null) {
        return;
    }
    List<VdsNetworkInterface> interfaces = filterBondsWithoutSlaves(host.getInterfaces());
    if (interfaces.contains(nic)) {
        nic.setNetworkName(managementNetworkName);
        configureManagementNetwork(createSetupNetworkParams(interfaces));
    } else {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    if (StringUtils.isEmpty(host.getActiveNic())) {
        log.warn("No interface was reported as lastClientInterface by host '{}' capabilities. " + "There will be no attempt to create the management network on the host.", host.getName());
        return null;
    }
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("The lastClientInterface '{}' of host '{}' is not a valid interface for the management network." + " If the interface is a bridge, it should be torn-down manually.", host.getActiveNic(), host.getName());
        throw new NetworkConfiguratorException(String.format("lastClientIface %s is not a valid interface for management network", host.getActiveNic()));
    }
    final Network managementNetwork = getManagementNetworkUtil().getManagementNetwork(host.getVdsGroupId());
    if (managementNetwork.getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(managementNetwork, nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(managementNetwork.getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        AuditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#method_after
private VdsNetworkInterface findNicToSetupManagementNetwork() {
    if (StringUtils.isEmpty(host.getActiveNic())) {
        log.warn("No interface was reported as lastClientInterface by host '{}' capabilities. " + "There will be no attempt to create the management network on the host.", host.getName());
        return null;
    }
    VdsNetworkInterface nic = Entities.entitiesByName(host.getInterfaces()).get(host.getActiveNic());
    if (nic == null) {
        log.warn("The lastClientInterface '{}' of host '{}' is not a valid interface for the management network." + " If the interface is a bridge, it should be torn-down manually.", host.getActiveNic(), host.getName());
        throw new NetworkConfiguratorException(String.format("lastClientIface %s is not a valid interface for management network", host.getActiveNic()));
    }
    final Network managementNetwork = getManagementNetworkUtil().getManagementNetwork(host.getVdsGroupId());
    if (managementNetwork.getName().equals(nic.getNetworkName())) {
        return null;
    }
    if (!nicHasValidVlanId(managementNetwork, nic)) {
        final AuditLogableBase event = createEvent();
        event.addCustomValue("VlanId", resolveVlanId(nic.getVlanId()));
        event.addCustomValue("MgmtVlanId", resolveVlanId(managementNetwork.getVlanId()));
        event.addCustomValue("InterfaceName", nic.getName());
        auditLogDirector.log(event, AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
    return nic;
}
#end_block

#method_before
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            AuditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        AuditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#method_after
private void configureManagementNetwork(SetupNetworksParameters parameters) {
    VdcReturnValueBase retVal = getBackend().runInternalAction(VdcActionType.SetupNetworks, parameters, cloneContextAndDetachFromParent());
    if (retVal.getSucceeded()) {
        retVal = getBackend().runInternalAction(VdcActionType.CommitNetworkChanges, new VdsActionParameters(parameters.getVdsId()), cloneContextAndDetachFromParent());
        if (!retVal.getSucceeded()) {
            auditLogDirector.log(createEvent(), AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, NETWORK_CONFIG_LOG_ERR);
            throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
        }
    } else {
        auditLogDirector.log(createEvent(), AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, NETWORK_CONFIG_LOG_ERR);
        throw new NetworkConfiguratorException(MANAGEMENET_NETWORK_CONFIG_ERR);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVmStaticData().getVmtGuid())) {
        return failCanDoAction(VdcBllMessages.VM_POOL_CANNOT_CREATE_FROM_BLANK_TEMPLATE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getParameters().getVmStaticData().getVmtGuid())) {
        return failCanDoAction(VdcBllMessages.VM_POOL_CANNOT_CREATE_FROM_BLANK_TEMPLATE);
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected Guid getPoolId() {
    VmPool vmPool = getVmPool();
    getDbFacade().getVmPoolDao().save(vmPool);
    return vmPool.getVmPoolId();
}
#method_after
@Override
protected Guid getPoolId() {
    VmPool vmPool = getVmPool();
    getVmPoolDAO().save(vmPool);
    return vmPool.getVmPoolId();
}
#end_block

#method_before
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    List<Guid> childCommandIds = CommandCoordinatorUtil.getChildCommandIds(getCommandId());
    if (childCommandIds.size() != getParameters().getChildCommands().size()) {
        // Upon recovery or after invoking a new child command, our map may be missing an entry
        for (Guid id : childCommandIds) {
            if (!getParameters().getChildCommands().containsValue(id)) {
                getParameters().getChildCommands().put(getParameters().getCommandStep(), id);
                break;
            }
        }
    }
    Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (!cmdEntity.isCallBackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    }
}
#method_after
public void proceedCommandExecution() {
    // Steps are executed such that:
    // a) all logic before the command runs is idempotent
    // b) the command is the last action in the step
    // This allows for recovery after a crash at any point during command execution.
    log.debug("Proceeding with execution of RemoveSnapshotSingleDiskLiveCommand");
    if (getParameters().getCommandStep() == null) {
        getParameters().setCommandStep(getInitialMergeStepForImage(getParameters().getImageId()));
        getParameters().setChildCommands(new HashMap<RemoveSnapshotSingleDiskLiveStep, Guid>());
    }
    // Upon recovery or after invoking a new child command, our map may be missing an entry
    syncChildCommandList();
    Guid currentChildId = getCurrentChildId();
    VdcReturnValueBase vdcReturnValue = null;
    if (currentChildId != null) {
        switch(CommandCoordinatorUtil.getCommandStatus(currentChildId)) {
            case ACTIVE:
            case NOT_STARTED:
                log.info("Waiting on Live Merge command step '{}' to complete", getParameters().getCommandStep());
                return;
            case SUCCEEDED:
                CommandEntity cmdEntity = CommandCoordinatorUtil.getCommandEntity(currentChildId);
                if (!cmdEntity.isCallbackNotified()) {
                    log.info("Waiting on Live Merge command step '{}' to finalize", getParameters().getCommandStep());
                    return;
                }
                vdcReturnValue = CommandCoordinatorUtil.getCommandReturnValue(currentChildId);
                if (vdcReturnValue != null && vdcReturnValue.getSucceeded()) {
                    log.debug("Child command '{}' succeeded", getParameters().getCommandStep());
                    getParameters().setCommandStep(getParameters().getNextCommandStep());
                    break;
                } else {
                    log.error("Child command '{}' failed: {}", getParameters().getCommandStep(), (vdcReturnValue != null ? vdcReturnValue.getExecuteFailedMessages() : "null return value"));
                    setCommandStatus(CommandStatus.FAILED);
                    return;
                }
            case FAILED:
            case FAILED_RESTARTED:
                log.error("Failed child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
            case UNKNOWN:
                log.error("Unknown child command status for step '{}'", getParameters().getCommandStep());
                setCommandStatus(CommandStatus.FAILED);
                return;
        }
    }
    log.info("Executing Live Merge command step '{}'", getParameters().getCommandStep());
    Pair<VdcActionType, ? extends VdcActionParametersBase> nextCommand = null;
    switch(getParameters().getCommandStep()) {
        case MERGE:
            nextCommand = new Pair<>(VdcActionType.Merge, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.MERGE_STATUS);
            break;
        case MERGE_STATUS:
            getParameters().setMergeCommandComplete(true);
            nextCommand = new Pair<>(VdcActionType.MergeStatus, buildMergeParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE);
            break;
        case DESTROY_IMAGE:
            if (vdcReturnValue != null) {
                getParameters().setMergeStatusReturnValue((MergeStatusReturnValue) vdcReturnValue.getActionReturnValue());
            } else if (getParameters().getMergeStatusReturnValue() == null) {
                // If the images were already merged, just add the orphaned image
                getParameters().setMergeStatusReturnValue(synthesizeMergeStatusReturnValue());
            }
            nextCommand = new Pair<>(VdcActionType.DestroyImage, buildDestroyImageParameters());
            getParameters().setNextCommandStep(RemoveSnapshotSingleDiskLiveStep.COMPLETE);
            break;
        case COMPLETE:
            getParameters().setDestroyImageCommandComplete(true);
            setCommandStatus(CommandStatus.SUCCEEDED);
            break;
    }
    persistCommand(getParameters().getParentCommand(), true);
    if (nextCommand != null) {
        CommandCoordinatorUtil.executeAsyncCommand(nextCommand.getFirst(), nextCommand.getSecond(), cloneContextAndDetachFromParent());
    // Add the child, but wait, it's a race!  child will start, task may spawn, get polled, and we won't have the child id
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
                CommandCoordinatorUtil.getCommandEntity(currentChildId).setCallBackNotified(true);
            }
        }
    } else {
        setSucceeded(true);
    }
}
#method_after
@Override
protected void endSuccessfully() {
    // endAction so that upon SPM task completion the status is propagated to the proper command.
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        syncChildCommandList();
        Guid currentChildId = getCurrentChildId();
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
                CommandCoordinatorUtil.getCommandEntity(currentChildId).setCallbackNotified(true);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        Guid currentChildId = getParameters().getChildCommands().get(getParameters().getCommandStep());
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                command.getParameters().setTaskGroupSuccess(false);
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
            }
        }
    } else {
        setSucceeded(true);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // See comment in endSuccessfully() for an explanation of this redirection
    if (getParameters().getCommandStep() == RemoveSnapshotSingleDiskLiveStep.DESTROY_IMAGE) {
        syncChildCommandList();
        Guid currentChildId = getCurrentChildId();
        if (!Guid.isNullOrEmpty(currentChildId)) {
            CommandBase<?> command = CommandCoordinatorUtil.retrieveCommand(currentChildId);
            if (command != null) {
                command.getParameters().setTaskGroupSuccess(false);
                Backend.getInstance().endAction(VdcActionType.DestroyImage, command.getParameters(), cloneContextAndDetachFromParent());
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public CommandCallBack getCallback() {
    return new RemoveSnapshotSingleDiskLiveCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new RemoveSnapshotSingleDiskLiveCommandCallback();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (volumeNameExists(volume.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
        addCanDoActionMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    return validateBricks(volume);
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VDSGroup cluster = getVdsGroup();
    if (cluster == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (volume.getVolumeType().isDispersedType()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CREATION_OF_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    if (volume.getVolumeType().isDistributedDispersedType()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CREATION_OF_DISTRIBUTED_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    if (volumeNameExists(volume.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
        addCanDoActionMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (!validate(createVolumeValidator().isForceCreateVolumeAllowed(getVdsGroup().getCompatibilityVersion(), getParameters().isForce()))) {
        return false;
    }
    return validateBricks(volume);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    if (volume.getTransportTypes() == null || volume.getTransportTypes().isEmpty()) {
        volume.addTransportType(TransportType.TCP);
    }
    // GLUSTER access protocol is enabled by default
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    if (!volume.getAccessProtocols().contains(AccessProtocol.NFS)) {
        volume.disableNFS();
    }
    if (volume.getAccessProtocols().contains(AccessProtocol.CIFS)) {
        volume.enableCifs();
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(upServer.getId(), volume, upServer.getVdsGroupCompatibilityVersion(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    setVolumeType(createdVolume);
    setBrickOrder(createdVolume.getBricks());
    addVolumeToDb(createdVolume);
    // If we log successful volume creation at the end of this command,
    // the messages from SetGlusterVolumeOptionCommand appear first,
    // making it look like options were set before volume was created.
    // Hence we explicitly log the volume creation before setting the options.
    AuditLogDirector.log(this, AuditLogType.GLUSTER_VOLUME_CREATE);
    // And don't log it at the end
    setCommandShouldBeLogged(false);
    // set all options of the volume
    setVolumeOptions(createdVolume);
    getReturnValue().setActionReturnValue(createdVolume.getId());
}
#method_after
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    if (volume.getTransportTypes() == null || volume.getTransportTypes().isEmpty()) {
        volume.addTransportType(TransportType.TCP);
    }
    // GLUSTER access protocol is enabled by default
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    if (!volume.getAccessProtocols().contains(AccessProtocol.NFS)) {
        volume.disableNFS();
    }
    if (volume.getAccessProtocols().contains(AccessProtocol.CIFS)) {
        volume.enableCifs();
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(upServer.getId(), volume, upServer.getVdsGroupCompatibilityVersion(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    setVolumeType(createdVolume);
    setBrickOrder(createdVolume.getBricks());
    addVolumeToDb(createdVolume);
    // If we log successful volume creation at the end of this command,
    // the messages from SetGlusterVolumeOptionCommand appear first,
    // making it look like options were set before volume was created.
    // Hence we explicitly log the volume creation before setting the options.
    auditLogDirector.log(this, AuditLogType.GLUSTER_VOLUME_CREATE);
    // And don't log it at the end
    setCommandShouldBeLogged(false);
    // set all options of the volume
    setVolumeOptions(createdVolume);
    getReturnValue().setActionReturnValue(createdVolume.getId());
}
#end_block

#method_before
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    int brickCount = bricks.size();
    int replicaCount = volume.getReplicaCount();
    int stripeCount = volume.getStripeCount();
    if (volume.getVolumeType().isReplicatedType() && replicaCount < 2) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_2);
        return false;
    }
    if (volume.getVolumeType().isStripedType() && stripeCount < 4) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_4);
        return false;
    }
    switch(volume.getVolumeType()) {
        case REPLICATE:
            if (brickCount != replicaCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (brickCount < replicaCount || Math.IEEEremainder(brickCount, replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_REPLICATE);
                return false;
            }
            break;
        case STRIPE:
            if (brickCount != stripeCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (brickCount <= stripeCount || Math.IEEEremainder(brickCount, stripeCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPE);
                return false;
            }
            break;
        case STRIPED_REPLICATE:
            if (Math.IEEEremainder(brickCount, stripeCount * replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPED_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPED_REPLICATE:
            if (brickCount <= stripeCount * replicaCount || Math.IEEEremainder(brickCount, stripeCount * replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPED_REPLICATE);
                return false;
            }
            break;
        default:
            break;
    }
    return updateBrickServerNames(bricks, true) && validateDuplicateBricks(bricks);
}
#method_after
private boolean validateBricks(GlusterVolumeEntity volume) {
    List<GlusterBrickEntity> bricks = volume.getBricks();
    if (bricks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    int brickCount = bricks.size();
    int replicaCount = volume.getReplicaCount();
    int stripeCount = volume.getStripeCount();
    if (volume.getVolumeType().isReplicatedType() && replicaCount < 2) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_REPLICA_COUNT_MIN_2);
        return false;
    }
    if (volume.getVolumeType().isStripedType() && stripeCount < 4) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STRIPE_COUNT_MIN_4);
        return false;
    }
    switch(volume.getVolumeType()) {
        case REPLICATE:
            if (brickCount != replicaCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_REPLICATE:
            if (brickCount < replicaCount || Math.IEEEremainder(brickCount, replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_REPLICATE);
                return false;
            }
            break;
        case STRIPE:
            if (brickCount != stripeCount) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPE:
            if (brickCount <= stripeCount || Math.IEEEremainder(brickCount, stripeCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPE);
                return false;
            }
            break;
        case STRIPED_REPLICATE:
            if (Math.IEEEremainder(brickCount, stripeCount * replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_STRIPED_REPLICATE);
                return false;
            }
            break;
        case DISTRIBUTED_STRIPED_REPLICATE:
            if (brickCount <= stripeCount * replicaCount || Math.IEEEremainder(brickCount, stripeCount * replicaCount) != 0) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INVALID_BRICK_COUNT_FOR_DISTRIBUTED_STRIPED_REPLICATE);
                return false;
            }
            break;
        default:
            break;
    }
    return updateBrickServerAndInterfaceNames(bricks, true) && validateDuplicateBricks(bricks);
}
#end_block

#method_before
@Override
public void run() {
    ExternalSchedulerDiscoveryResult discoveryResult = ExternalSchedulerFactory.getInstance().runDiscover();
    if (discoveryResult != null) {
        updateDB(discoveryResult);
        log.info("PolicyUnits updated");
    } else {
        AuditLogableBase loggable = new AuditLogableBase();
        AuditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        markAllExternalPoliciesAsDisabled();
        log.warn("Discovery returned empty result, disabled external policy units");
    }
}
#method_after
@Override
public void run() {
    ExternalSchedulerDiscoveryResult discoveryResult = ExternalSchedulerFactory.getInstance().runDiscover();
    if (discoveryResult != null) {
        updateDB(discoveryResult);
        log.info("PolicyUnits updated");
    } else {
        AuditLogableBase loggable = new AuditLogableBase();
        new AuditLogDirector().log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        markAllExternalPoliciesAsDisabled();
        log.warn("Discovery returned empty result, disabled external policy units");
    }
}
#end_block

#method_before
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<Permissions> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
    }
}
#method_after
private void copyQuotaPermissions() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    List<Permission> vmPermissions = getDbFacade().getPermissionDao().getAllForEntity(getParameters().getQuotaId(), getEngineSessionSeqId(), false);
    for (Permission vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getAdElementId(), vmPermission.getRoleId(), getQuotaId(), vmPermission.getObjectType());
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permission> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permission[permissionsList.size()]));
    }
}
#end_block

#method_before
public String getVdcObjectName() {
    Permissions perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#method_after
public String getVdcObjectName() {
    Permission perms = getParameters().getPermission();
    return getDbFacade().getEntityNameByIdAndType(perms.getObjectId(), perms.getObjectType());
}
#end_block

#method_before
public String getRoleName() {
    Role role = getRoleDao().get(getParameters().getPermission().getrole_id());
    return role == null ? null : role.getName();
}
#method_after
public String getRoleName() {
    Role role = getRoleDao().get(getParameters().getPermission().getRoleId());
    return role == null ? null : role.getName();
}
#end_block

#method_before
public void initUserAndGroupData() {
    if (dbUser == null) {
        dbUser = getDbUserDAO().get(getParameters().getPermission().getad_element_id());
    }
    if (dbUser == null && dbGroup == null) {
        dbGroup = getAdGroupDAO().get(getParameters().getPermission().getad_element_id());
    }
}
#method_after
public void initUserAndGroupData() {
    if (dbUser == null) {
        dbUser = getDbUserDAO().get(getParameters().getPermission().getAdElementId());
    }
    if (dbUser == null && dbGroup == null) {
        dbGroup = getAdGroupDAO().get(getParameters().getPermission().getAdElementId());
    }
}
#end_block

#method_before
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    Permissions permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#method_after
// TODO - this code is shared with addPermissionCommand - check if
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<>();
    Permission permission = getParameters().getPermission();
    permissionList.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
private void glusterHostRemove() {
    if (clusterHasMultipleHosts() && !hasVolumeBricksOnServer()) {
        try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVdsGroupId())) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().getHostName(), getParameters().isForceAction()));
            // If the host is already removed Cluster using Gluster CLI then we can setSucceeded to true.
            setSucceeded(returnValue.getSucceeded() || VdcBllErrors.GlusterHostIsNotPartOfCluster == returnValue.getVdsError().getCode());
            if (!getSucceeded()) {
                if (returnValue.getVdsError().getCode() == VdcBllErrors.GlusterHostRemoveFailedException) {
                    List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer);
                    if (glusterServers != null) {
                        if (!GlusterUtil.getInstance().isHostExists(glusterServers, getVds())) {
                            setSucceeded(true);
                            return;
                        }
                    }
                }
                getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
                return;
            }
        }
    }
}
#method_after
private void glusterHostRemove() {
    if (clusterHasMultipleHosts() && !hasVolumeBricksOnServer()) {
        try (EngineLock lock = GlusterUtil.getInstance().acquireGlusterLockWait(getVdsGroupId())) {
            VDSReturnValue returnValue = runVdsCommand(VDSCommandType.RemoveGlusterServer, new RemoveGlusterServerVDSParameters(upServer.getId(), getVds().getHostName(), getParameters().isForceAction()));
            // If the host is already removed Cluster using Gluster CLI then we can setSucceeded to true.
            setSucceeded(returnValue.getSucceeded() || VdcBllErrors.GlusterHostIsNotPartOfCluster == returnValue.getVdsError().getCode());
            if (!getSucceeded()) {
                if (returnValue.getVdsError().getCode() == VdcBllErrors.GlusterHostRemoveFailedException) {
                    List<GlusterServerInfo> glusterServers = getGlusterPeers(upServer);
                    if (glusterServers != null) {
                        if (!GlusterUtil.getInstance().isHostExists(glusterServers, getVds())) {
                            setSucceeded(true);
                        }
                    }
                }
                if (!getSucceeded()) {
                    getReturnValue().getFault().setError(returnValue.getVdsError().getCode());
                    getReturnValue().getFault().setMessage(returnValue.getVdsError().getMessage());
                    errorType = AuditLogType.GLUSTER_SERVER_REMOVE_FAILED;
                    return;
                }
            }
            // if last but one host in cluster, update the last host's known addresses
            if (getClusterUtils().getServerCount(getVdsGroupId()) == 2) {
                removeOtherKnowAddressesForGlusterServer(upServer.getId());
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().get(getStorageDomainId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(getStorageDomainId());
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDisksByStorageDomainId, new IdQueryParameters(getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
public CommandCallBack getCallback() {
    return new MergeStatusCommandCallback();
}
#method_after
@Override
public CommandCallback getCallback() {
    return new MergeStatusCommandCallback();
}
#end_block

#method_before
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#method_after
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, Guid diskProfileId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = ImagesHandler.cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage, diskProfileId, getVmSnapshotId(), diskInfoDestinationMap != null ? diskInfoDestinationMap.get(diskImage.getId()) : null);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#end_block

#method_before
protected List<PermissionSubject> getPermissionList(AuditLog event) {
    List<PermissionSubject> permissionList = new ArrayList<>();
    if (event.getStorageDomainId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getStorageDomainId().toString()), VdcObjectType.Storage, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getStoragePoolId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getStoragePoolId().toString()), VdcObjectType.StoragePool, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getUserId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getUserId().toString()), VdcObjectType.User, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVdsGroupId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVdsGroupId().toString()), VdcObjectType.VdsGroups, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVmId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVmId().toString()), VdcObjectType.VM, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVmTemplateId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVmTemplateId().toString()), VdcObjectType.VmTemplate, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (permissionList.isEmpty()) {
        // Global Event
        permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    return permissionList;
}
#method_after
protected List<PermissionSubject> getPermissionList(AuditLog event) {
    List<PermissionSubject> permissionList = new ArrayList<>();
    if (event.getStorageDomainId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getStorageDomainId().toString()), VdcObjectType.Storage, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getStoragePoolId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getStoragePoolId().toString()), VdcObjectType.StoragePool, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getUserId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getUserId().toString()), VdcObjectType.User, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVdsGroupId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVdsGroupId().toString()), VdcObjectType.VdsGroups, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVmId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVmId().toString()), VdcObjectType.VM, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVmTemplateId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVmTemplateId().toString()), VdcObjectType.VmTemplate, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (event.getVdsId() != null) {
        permissionList.add(new PermissionSubject(new Guid(event.getVdsId().toString()), VdcObjectType.VDS, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    if (permissionList.isEmpty()) {
        // Global Event
        permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.INJECT_EXTERNAL_EVENTS));
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDisk() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addCanDoActionMessageVariable("diskAliases", getDiskAlias());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDAO().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (isImageExclusiveLockNeeded() && getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getDisk() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addCanDoActionMessageVariable("diskAliases", getDiskAlias());
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Arrays.asList((DiskImage) getDisk()));
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDAO().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (isImageExclusiveLockNeeded() && getVm().isRunningOrPaused()) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GetDiskAlignmentVDSCommandParameters parameters;
    AuditLogDirector.log(this, AuditLogType.DISK_ALIGNMENT_SCAN_START);
    acquireExclusiveDiskDbLocks();
    // Live scan is not supported yet, this might become: getVm().getId()
    Guid vmId = Guid.Empty;
    if (getDiskType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        GetDiskImageAlignmentVDSCommandParameters imageParameters = new GetDiskImageAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        imageParameters.setPoolId(getStoragePoolId());
        imageParameters.setDomainId(diskImage.getStorageIds().get(0));
        imageParameters.setImageGroupId(diskImage.getimage_group_id());
        imageParameters.setImageId(diskImage.getImageId());
        parameters = imageParameters;
    } else if (getDiskType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) getDisk();
        GetDiskLunAlignmentVDSCommandParameters lunParameters = new GetDiskLunAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        lunParameters.setLunId(lunDisk.getLun().getLUN_id());
        parameters = lunParameters;
    } else {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Unknown DiskStorageType: " + getDiskType().toString() + " Disk id: " + getDisk().getId().toString());
    }
    Boolean isDiskAligned = (Boolean) runVdsCommand(VDSCommandType.GetDiskAlignment, parameters).getReturnValue();
    getDisk().setAlignment(isDiskAligned ? DiskAlignment.Aligned : DiskAlignment.Misaligned);
    getDisk().setLastAlignmentScan(new Date());
    getBaseDiskDao().update(getDisk());
    setSucceeded(true);
    releaseExclusiveDiskDbLocks();
}
#method_after
@Override
protected void executeCommand() {
    GetDiskAlignmentVDSCommandParameters parameters;
    auditLogDirector.log(this, AuditLogType.DISK_ALIGNMENT_SCAN_START);
    acquireExclusiveDiskDbLocks();
    // Live scan is not supported yet, this might become: getVm().getId()
    Guid vmId = Guid.Empty;
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        GetDiskImageAlignmentVDSCommandParameters imageParameters = new GetDiskImageAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        imageParameters.setPoolId(getStoragePoolId());
        imageParameters.setDomainId(diskImage.getStorageIds().get(0));
        imageParameters.setImageGroupId(diskImage.getimage_group_id());
        imageParameters.setImageId(diskImage.getImageId());
        parameters = imageParameters;
    } else if (getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) getDisk();
        GetDiskLunAlignmentVDSCommandParameters lunParameters = new GetDiskLunAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        lunParameters.setLunId(lunDisk.getLun().getLUN_id());
        parameters = lunParameters;
    } else {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Unknown DiskStorageType: " + getDiskStorageType().toString() + " Disk id: " + getDisk().getId().toString());
    }
    Boolean isDiskAligned = (Boolean) runVdsCommand(VDSCommandType.GetDiskAlignment, parameters).getReturnValue();
    getDisk().setAlignment(isDiskAligned ? DiskAlignment.Aligned : DiskAlignment.Misaligned);
    getDisk().setLastAlignmentScan(new Date());
    getBaseDiskDao().update(getDisk());
    setSucceeded(true);
    releaseExclusiveDiskDbLocks();
}
#end_block

#method_before
protected boolean isImageExclusiveLockNeeded() {
    /* In case the volume format is RAW (same as a direct LUN) the exclusive image
         * lock is not needed since the alignment scan can run without any interference
         * by a concurrent running VM.
         */
    return (getDiskType() == DiskStorageType.IMAGE && ((DiskImage) getDisk()).getVolumeFormat() != VolumeFormat.RAW);
}
#method_after
protected boolean isImageExclusiveLockNeeded() {
    /* In case the volume format is RAW (same as a direct LUN) the exclusive image
         * lock is not needed since the alignment scan can run without any interference
         * by a concurrent running VM.
         */
    return (getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) getDisk()).getVolumeFormat() != VolumeFormat.RAW);
}
#end_block

#method_before
public static BackendInternal getInstance() {
    return EjbUtils.findBean(BeanType.BACKEND, BeanProxyType.LOCAL);
}
#method_after
public static BackendInternal getInstance() {
    return Injector.get(BackendInternal.class);
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    _resourceManger = new VDSBrokerFrontendImpl();
    CpuFlagsManagerHandler.initDictionaries();
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    _vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(SessionDataContainer.getInstance(), "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    int vmPoolMonitorIntervalInMinutes = Config.<Integer>getValue(ConfigValues.VmPoolMonitorIntervalInMinutes);
    poolMonitoringJobId = SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(new VmPoolMonitor(), "managePrestartedVmsInAllVmPools", new Class[] {}, new Object[] {}, vmPoolMonitorIntervalInMinutes, vmPoolMonitorIntervalInMinutes, TimeUnit.MINUTES);
    int autoStartVmsRunnerIntervalInSeconds = Config.<Integer>getValue(ConfigValues.AutoStartVmsRunnerIntervalInSeconds);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(AutoStartVmsRunner.getInstance(), "startFailedAutoStartVms", new Class[] {}, new Object[] {}, autoStartVmsRunnerIntervalInSeconds, autoStartVmsRunnerIntervalInSeconds, TimeUnit.SECONDS);
    int quotaCacheIntervalInMinutes = Config.<Integer>getValue(ConfigValues.QuotaCacheIntervalInMinutes);
    SchedulerUtilQuartzImpl.getInstance().scheduleAFixedDelayJob(QuotaManager.getInstance(), "updateQuotaCache", new Class[] {}, new Object[] {}, 1, quotaCacheIntervalInMinutes, TimeUnit.MINUTES);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
            setVmId(vmToAttach);
            Permissions perm = new Permissions(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParameters permParams = new PermissionsOperationsParameters(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = runInternalAction(VdcActionType.AddPermission, permParams, cloneContext().withoutExecutionContext().withoutLock());
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
            }
        } else {
            log.info("No free Vms in pool '{}'. Cannot allocate for user '{}'", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setParentParameters(getParameters());
        runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        ExecutionContext runVmContext = createRunVmContext();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withoutLock().withCompensationContext(null));
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // no need to start, just return it
        setActionReturnValue(vmToAttach);
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    getParameters().setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
    initUser();
    boolean isPrestartedVm = false;
    Guid vmToAttach;
    synchronized (_lockObject) {
        vmToAttach = getPrestartedVmToAttach(getParameters().getVmPoolId());
        if (!Guid.Empty.equals(vmToAttach)) {
            isPrestartedVm = true;
        } else {
            vmToAttach = getNonPrestartedVmToAttach(getParameters().getVmPoolId());
        }
        if (!Guid.Empty.equals(vmToAttach)) {
            getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
            setVmId(vmToAttach);
            Permission perm = new Permission(getAdUserId(), PredefinedRoles.ENGINE_USER.getId(), vmToAttach, VdcObjectType.VM);
            PermissionsOperationsParameters permParams = new PermissionsOperationsParameters(perm);
            permParams.setShouldBeLogged(false);
            permParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
            VdcReturnValueBase vdcReturnValueFromAddPerm = runInternalAction(VdcActionType.AddPermission, permParams, cloneContext().withoutExecutionContext().withoutLock());
            if (!vdcReturnValueFromAddPerm.getSucceeded()) {
                log.info("Failed to give user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
                setActionReturnValue(vdcReturnValueFromAddPerm);
                return;
            } else {
                log.info("Succeeded giving user '{}' permission to Vm '{}'", getAdUserId(), vmToAttach);
            }
        } else {
            log.info("No free Vms in pool '{}'. Cannot allocate for user '{}'", getVmPoolId(), getAdUserId());
            throw new VdcBLLException(VdcBllErrors.NO_FREE_VM_IN_POOL);
        }
    }
    // Only when using a Vm that is not prestarted do we need to run the vm
    if (!isPrestartedVm) {
        setVm(getVmDAO().get(vmToAttach));
        RunVmParams runVmParams = new RunVmParams(vmToAttach);
        runVmParams.setSessionId(getParameters().getSessionId());
        runVmParams.setParentParameters(getParameters());
        runVmParams.setEntityInfo(new EntityInfo(VdcObjectType.VM, vmToAttach));
        runVmParams.setParentCommand(VdcActionType.AttachUserToVmFromPoolAndRun);
        runVmParams.setRunAsStateless(true);
        ExecutionContext runVmContext = createRunVmContext();
        VdcReturnValueBase vdcReturnValue = runInternalAction(VdcActionType.RunVm, runVmParams, cloneContext().withExecutionContext(runVmContext).withoutLock().withCompensationContext(null));
        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
        setSucceeded(vdcReturnValue.getSucceeded());
        setActionReturnValue(vmToAttach);
        getReturnValue().getVdsmTaskIdList().addAll(getReturnValue().getInternalVdsmTaskIdList());
    } else {
        // no need to start, just return it
        setActionReturnValue(vmToAttach);
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!Guid.Empty.equals(getAdUserId())) {
        Permissions perm = DbFacade.getInstance().getPermissionDao().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDao().remove(perm.getId());
        }
    }
}
#method_after
protected void detachUserFromVmFromPool() {
    // Detach user from vm from pool:
    if (!Guid.Empty.equals(getAdUserId())) {
        Permission perm = DbFacade.getInstance().getPermissionDao().getForRoleAndAdElementAndObject(PredefinedRoles.ENGINE_USER.getId(), getAdUserId(), getVmId());
        if (perm != null) {
            DbFacade.getInstance().getPermissionDao().remove(perm.getId());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVds().getStatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        if (getVds().getHighlyAvailableIsConfigured()) {
            SetHaMaintenanceModeVDSCommandParameters params = new SetHaMaintenanceModeVDSCommandParameters(getVds(), HaMaintenanceMode.LOCAL, true);
            if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, params).getSucceeded()) {
                haMaintenanceFailed = true;
                // HA maintenance failure is fatal only if the Hosted Engine vm is running on this host
                if (isHostedEngineOnVds()) {
                    setSucceeded(false);
                    return;
                }
            }
        }
        setSucceeded(migrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getStatus() == VDSStatus.NonResponsive || getVds().getStatus() == VDSStatus.Connecting || getVds().getStatus() == VDSStatus.Down) {
            runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), VDSStatus.Maintenance));
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getVds().getStatus() == VDSStatus.Maintenance) {
        // nothing to do
        setSucceeded(true);
    } else {
        orderListOfRunningVmsOnVds(getVdsId());
        if (getVds().getHighlyAvailableIsConfigured()) {
            SetHaMaintenanceModeVDSCommandParameters params = new SetHaMaintenanceModeVDSCommandParameters(getVds(), HaMaintenanceMode.LOCAL, true);
            if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, params).getSucceeded()) {
                haMaintenanceFailed = true;
                // HA maintenance failure is fatal only if the Hosted Engine vm is running on this host
                if (isHostedEngineOnVds()) {
                    setSucceeded(false);
                    return;
                }
            }
        }
        setSucceeded(migrateAllVms(getExecutionContext()));
        // if non responsive move directly to maintenance
        if (getVds().getStatus() == VDSStatus.NonResponsive || getVds().getStatus() == VDSStatus.Connecting || getVds().getStatus() == VDSStatus.Down) {
            setVdsStatus(VDSStatus.Maintenance);
        }
    }
    // as the migration(s) is a step of this job, so this job must not be cleaned yet
    if (isVmsExist()) {
        ExecutionHandler.setAsyncJob(getExecutionContext(), true);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Currently this only supports importing images and does not work with luns.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("storageType", getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExist())) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("domainId", getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        addCanDoActionMessageVariable("domainId", getParameters().getStorageDomainId());
        addCanDoActionMessageVariable("domainType", getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Currently this only supports importing DiskImages or CinderDisks and does not work with LunDisks.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE && getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.CINDER) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("storageType", getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExist())) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("domainId", getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain() && !(getStorageDomain().getStorageDomainType() == StorageDomainType.Volume)) {
        addCanDoActionMessageVariable("domainId", getParameters().getStorageDomainId());
        addCanDoActionMessageVariable("domainType", getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (getParameters().getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && !setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final DiskImage newDiskImage = getParameters().getDiskImage();
    newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
    ArrayList<Guid> storageIds = new ArrayList<>();
    storageIds.add(getParameters().getStorageDomainId());
    newDiskImage.setStorageIds(storageIds);
    addDiskImageToDb(newDiskImage, getCompensationContext());
    getReturnValue().setActionReturnValue(newDiskImage.getId());
    getReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE) {
        final DiskImage newDiskImage = getParameters().getDiskImage();
        newDiskImage.setDiskAlias(ImagesHandler.getDiskAliasWithDefault(newDiskImage, generateDefaultAliasForRegiteredDisk(Calendar.getInstance())));
        ArrayList<Guid> storageIds = new ArrayList<>();
        storageIds.add(getParameters().getStorageDomainId());
        newDiskImage.setStorageIds(storageIds);
        addDiskImageToDb(newDiskImage, getCompensationContext());
        getReturnValue().setActionReturnValue(newDiskImage.getId());
        getReturnValue().setSucceeded(true);
    } else if (getParameters().getDiskImage().getDiskStorageType() == DiskStorageType.CINDER) {
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.RegisterCinderDisk, new RegisterCinderDiskParameters((CinderDisk) getParameters().getDiskImage(), getParameters().getStorageDomainId()));
        setReturnValue(returnValue);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<VDS> vdsList = getDbFacade().getVdsDao().getAllForNetwork(getParameters().getId());
    List<VdsNetworkInterface> vdsNetworkInterfaceList = getDbFacade().getInterfaceDao().getVdsInterfacesByNetworkId(getParameters().getId());
    final Map<Guid, VDS> vdsById = Entities.businessEntitiesById(vdsList);
    List<PairQueryable<VdsNetworkInterface, VDS>> vdsInterfaceVdsPairs = new ArrayList<>();
    for (VdsNetworkInterface vdsNetworkInterface : vdsNetworkInterfaceList) {
        vdsInterfaceVdsPairs.add(new PairQueryable<>(vdsNetworkInterface, vdsById.get(vdsNetworkInterface.getVdsId())));
    }
    getQueryReturnValue().setReturnValue(vdsInterfaceVdsPairs);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<VDS> vdsList = getVdsDao().getAllForNetwork(getParameters().getId());
    List<VdsNetworkInterface> vdsNetworkInterfaceList = getInterfaceDao().getVdsInterfacesByNetworkId(getParameters().getId());
    final Map<Guid, VDS> vdsById = Entities.businessEntitiesById(vdsList);
    List<PairQueryable<VdsNetworkInterface, VDS>> vdsInterfaceVdsPairs = new ArrayList<>();
    Network network = getNetworkDao().get(getParameters().getId());
    HostNetworkQos qos = getHostNetworkQosDao().get(network.getQosId());
    for (final VdsNetworkInterface vdsNetworkInterface : vdsNetworkInterfaceList) {
        vdsInterfaceVdsPairs.add(new PairQueryable<>(vdsNetworkInterface, vdsById.get(vdsNetworkInterface.getVdsId())));
        VdsNetworkInterface.NetworkImplementationDetails vdsInterfaceNetworkImplementationDetails = NetworkUtils.calculateNetworkImplementationDetails(network, qos, vdsNetworkInterface);
        vdsNetworkInterface.setNetworkImplementationDetails(vdsInterfaceNetworkImplementationDetails);
    }
    getQueryReturnValue().setReturnValue(vdsInterfaceVdsPairs);
}
#end_block

#method_before
private void updateAuditLog(AuditLogType auditLogType, Long imageSizeInGigabytes) {
    addCustomValue("DiskAlias", getImage().getDiskAlias());
    addCustomValue("NewSize", String.valueOf(imageSizeInGigabytes));
    AuditLogDirector.log(this, auditLogType);
}
#method_after
private void updateAuditLog(AuditLogType auditLogType, Long imageSizeInGigabytes) {
    addCustomValue("DiskAlias", getImage().getDiskAlias());
    addCustomValue("NewSize", String.valueOf(imageSizeInGigabytes));
    auditLogDirector.log(this, auditLogType);
}
#end_block

#method_before
private void updateAuditLogFailedToUpdateVM(String vmName) {
    addCustomValue("VmName", vmName);
    AuditLogDirector.log(this, AuditLogType.USER_EXTEND_DISK_SIZE_UPDATE_VM_FAILURE);
}
#method_after
private void updateAuditLogFailedToUpdateVM(String vmName) {
    addCustomValue("VmName", vmName);
    auditLogDirector.log(this, AuditLogType.USER_EXTEND_DISK_SIZE_UPDATE_VM_FAILURE);
}
#end_block

#method_before
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion());
}
#method_after
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), cluster.getId());
}
#end_block

#method_before
public Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> getEligibilityPredicates(final GlusterVolumeEntity masterVolume) {
    Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> eligibilityPredicates = new HashMap<>();
    final List<Guid> existingSessionSlavesIds = getSessionSlaveVolumeIds();
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_BE_UP, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getStatus() == GlusterStatus.UP;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_AND_MASTER_VOLUMES_SHOULD_NOT_BE_IN_SAME_CLUSTER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !masterVolume.getClusterId().equals(slaveVolume.getClusterId());
        }
    });
    final Predicate<GlusterVolumeEntity> nonNullSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullSlaveSizePredicate);
    final Predicate<GlusterVolumeEntity> nonNullMasterSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return masterVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.MASTER_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullMasterSizePredicate);
    Predicate<GlusterVolumeEntity> masterSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            boolean eligible = nonNullSlaveSizePredicate.eval(slaveVolume) && nonNullMasterSizePredicate.eval(masterVolume);
            if (eligible) {
                eligible = slaveVolume.getAdvancedDetails().getCapacityInfo().getTotalSize() >= masterVolume.getAdvancedDetails().getCapacityInfo().getTotalSize();
            }
            return eligible;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_SHOULD_BE_GREATER_THAN_MASTER_VOLUME_SIZE, masterSlaveSizePredicate);
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_NOT_BE_SLAVE_OF_ANOTHER_GEO_REP_SESSION, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !existingSessionSlavesIds.contains(slaveVolume.getId());
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_CLUSTER_AND_MASTER_CLUSTER_COMPATIBILITY_VERSIONS_DO_NOT_MATCH, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            VdsGroupDAO vdsGroupDao = getVdsGroupDao();
            Version slaveCompatibilityVersion = vdsGroupDao.get(slaveVolume.getClusterId()).getCompatibilityVersion();
            Version masterCompatibilityVersion = vdsGroupDao.get(masterVolume.getClusterId()).getCompatibilityVersion();
            return masterCompatibilityVersion.equals(slaveCompatibilityVersion);
        }
    });
    return eligibilityPredicates;
}
#method_after
public Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> getEligibilityPredicates(final GlusterVolumeEntity masterVolume) {
    Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> eligibilityPredicates = new HashMap<>();
    final List<Guid> existingSessionSlavesIds = getSessionSlaveVolumeIds();
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_BE_UP, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getStatus() == GlusterStatus.UP;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_AND_MASTER_VOLUMES_SHOULD_NOT_BE_IN_SAME_CLUSTER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !masterVolume.getClusterId().equals(slaveVolume.getClusterId());
        }
    });
    final Predicate<GlusterVolumeEntity> nonNullSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullSlaveSizePredicate);
    final Predicate<GlusterVolumeEntity> nonNullMasterSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return masterVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.MASTER_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullMasterSizePredicate);
    Predicate<GlusterVolumeEntity> masterSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            boolean eligible = nonNullSlaveSizePredicate.eval(slaveVolume) && nonNullMasterSizePredicate.eval(masterVolume);
            if (eligible) {
                eligible = slaveVolume.getAdvancedDetails().getCapacityInfo().getTotalSize() >= masterVolume.getAdvancedDetails().getCapacityInfo().getTotalSize();
            }
            return eligible;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_SHOULD_BE_GREATER_THAN_MASTER_VOLUME_SIZE, masterSlaveSizePredicate);
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_NOT_BE_SLAVE_OF_ANOTHER_GEO_REP_SESSION, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !existingSessionSlavesIds.contains(slaveVolume.getId());
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_CLUSTER_AND_MASTER_CLUSTER_COMPATIBILITY_VERSIONS_DO_NOT_MATCH, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            VdsGroupDAO vdsGroupDao = getVdsGroupDao();
            Version slaveCompatibilityVersion = vdsGroupDao.get(slaveVolume.getClusterId()).getCompatibilityVersion();
            Version masterCompatibilityVersion = vdsGroupDao.get(masterVolume.getClusterId()).getCompatibilityVersion();
            return masterCompatibilityVersion.equals(slaveCompatibilityVersion);
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.NO_UP_SLAVE_SERVER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            Guid slaveUpserverId = getUpServerId(slaveVolume.getClusterId());
            if (slaveUpserverId == null) {
                return false;
            }
            return true;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_TO_BE_EMPTY, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            Guid slaveUpserverId = getUpServerId(slaveVolume.getClusterId());
            if (slaveUpserverId == null) {
                return false;
            }
            return checkEmptyGlusterVolume(slaveUpserverId, slaveVolume.getName());
        }
    });
    return eligibilityPredicates;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getVmNicDao().update(getParameters().getInterface());
    VmDevice vmDevice = getDbFacade().getVmDeviceDao().get(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()));
    vmDevice.setIsPlugged(getParameters().getInterface().isPlugged());
    getDbFacade().getVmDeviceDao().update(vmDevice);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getVmNicDao().update(getParameters().getInterface());
    VmDevice vmDevice = getDbFacade().getVmDeviceDao().get(new VmDeviceId(getParameters().getInterface().getId(), getParameters().getVmTemplateId()));
    vmDevice.setIsPlugged(getParameters().getInterface().isPlugged());
    vmDevice.setDevice(getParameters().getInterface().isPassthrough() ? VmDeviceType.HOST_DEVICE.getName() : VmDeviceType.BRIDGE.getName());
    getDbFacade().getVmDeviceDao().update(vmDevice);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        if (!validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId()))) {
            return false;
        }
        if (!checkPciAndIdeLimit(oldIface, new ArrayList<>(interfaces), clusterCompatibilityVersion)) {
            return false;
        }
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!validate(linkedToTemplate())) {
        return false;
    }
    List<VmNic> interfaces = getVmNicDao().getAllForTemplate(getParameters().getVmTemplateId());
    if (!validate(templateExists())) {
        return false;
    }
    // Interface oldIface = interfaces.First(i => i.id ==
    // AddVmInterfaceParameters.Interface.id);
    VmNic oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getParameters().getInterface().getId());
        }
    });
    if (oldIface == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!updateVnicForBackwardCompatibility(oldIface)) {
        return false;
    }
    // not relevant for instance types - will be checked when a VM will be created out of it
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        Version clusterCompatibilityVersion = getVdsGroup().getCompatibilityVersion();
        VmNicValidator nicValidator = new VmNicValidator(getParameters().getInterface(), clusterCompatibilityVersion, getVmTemplate().getOsId());
        if (!validate(nicValidator.linkedOnlyIfSupported()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.profileValid(getVmTemplate().getVdsGroupId())) || !validate(nicValidator.typeMatchesProfile()) || !validate(nicValidator.passthroughIsLinked())) {
            return false;
        }
        if (!checkPciAndIdeLimit(oldIface, new ArrayList<>(interfaces), clusterCompatibilityVersion)) {
            return false;
        }
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !interfaceNameUnique(interfaces)) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Create a dummy lun
    LUNs dummyLun = createDummyLun();
    // Create storage server connection mapping
    LUN_storage_server_connection_map connectionMapRecord = new LUN_storage_server_connection_map(dummyLun.getLUN_id(), getParameters().getStorageConnectionId());
    List<StorageServerConnections> connectionsForDomain;
    if (getLunDao().get(dummyLun.getLUN_id()) == null) {
        getLunDao().save(dummyLun);
        // Save connection maps when creating the dummy lun for the first time
        connectionsForDomain = getStorageServerConnectionDAO().getAllForDomain(getStorageDomainId());
        for (StorageServerConnections connection : connectionsForDomain) {
            saveConnection(new LUN_storage_server_connection_map(dummyLun.getLUN_id(), connection.getid()));
        }
    }
    // Save new connection map
    saveConnection(connectionMapRecord);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // Create a dummy lun
    LUNs dummyLun = createDummyLun();
    // Create storage server connection mapping
    LUNStorageServerConnectionMap connectionMapRecord = new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), getParameters().getStorageConnectionId());
    List<StorageServerConnections> connectionsForDomain;
    if (getLunDao().get(dummyLun.getLUN_id()) == null) {
        getLunDao().save(dummyLun);
        // Save connection maps when creating the dummy lun for the first time
        connectionsForDomain = getStorageServerConnectionDAO().getAllForDomain(getStorageDomainId());
        for (StorageServerConnections connection : connectionsForDomain) {
            saveConnection(new LUNStorageServerConnectionMap(dummyLun.getLUN_id(), connection.getid()));
        }
    }
    // Save new connection map
    saveConnection(connectionMapRecord);
    setSucceeded(true);
}
#end_block

#method_before
private void saveConnection(LUN_storage_server_connection_map connectionMapRecord) {
    if (getStorageServerConnectionLunMapDao().get(connectionMapRecord.getId()) == null) {
        getStorageServerConnectionLunMapDao().save(connectionMapRecord);
    }
}
#method_after
private void saveConnection(LUNStorageServerConnectionMap connectionMapRecord) {
    if (getStorageServerConnectionLunMapDao().get(connectionMapRecord.getId()) == null) {
        getStorageServerConnectionLunMapDao().save(connectionMapRecord);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || getCommandEntityDao().getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    proceedStorageDomainTreatmentByDomainType(false);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), _newMasterStorageDomainId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDAO().get(getStoragePool().getSpmVdsId());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, _newMasterStorageDomainId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (!Guid.Empty.equals(_newMasterStorageDomainId)) {
                StoragePoolIsoMap mapOfNewMaster = getNewMaster(false).getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    final boolean isLastMaster;
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        newMaster = electNewMaster();
        isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
    } else {
        newMaster = null;
        isLastMaster = false;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    if (isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDAO().get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        getEventQueue().submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        AuditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#method_after
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        auditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#end_block

#method_before
protected void proceedStorageDomainTreatmentByDomainType(final boolean duringReconstruct) {
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        final StorageDomain newMaster = getNewMaster(duringReconstruct);
        if (newMaster != null) {
            newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
            _newMasterStorageDomainId = newMaster.getId();
            if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                        getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                        newMaster.setStorageDomainType(StorageDomainType.Master);
                        if (!duringReconstruct) {
                            newMasterMap.setStatus(StorageDomainStatus.Unknown);
                            getCompensationContext().snapshotEntityStatus(newMasterMap);
                            newMaster.setStatus(StorageDomainStatus.Locked);
                            getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                        }
                        updateStorageDomainStaticData(newMaster.getStorageStaticData());
                        getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                        getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                        updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
            } else {
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
            }
            updateStoragePoolMasterDomainVersionInDiffTransaction();
        } else {
            _isLastMaster = true;
        }
    }
}
#method_after
protected boolean proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster == null) {
        return true;
    }
    newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
    if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                newMaster.setStorageDomainType(StorageDomainType.Master);
                if (lockNewMaster) {
                    newMasterMap.setStatus(StorageDomainStatus.Unknown);
                    getCompensationContext().snapshotEntityStatus(newMasterMap);
                    newMaster.setStatus(StorageDomainStatus.Locked);
                    getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                }
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
                getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    } else {
        updateStorageDomainStaticData(newMaster.getStorageStaticData());
    }
    updateStoragePoolMasterDomainVersionInDiffTransaction();
    return false;
}
#end_block

#method_before
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<StorageServerConnections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.addCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.addCustomValue("ErrorMessage", translatedError);
    AuditLogDirector.log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#method_after
protected String addToAuditLogErrorMessage(String connection, String errorCode, List<StorageServerConnections> connections, LUNs lun) {
    AuditLogableBase logable = new AuditLogableBase();
    String connectionField = getConnectionDescription(connections, connection) + (lun == null ? "" : " (LUN " + lun.getLUN_id() + ")");
    logable.addCustomValue("Connection", connectionField);
    // Get translated error by error code ,if no translation found (should not happened) ,
    // will set the error code instead.
    String translatedError = getTranslatedStorageError(errorCode);
    logable.addCustomValue("ErrorMessage", translatedError);
    new AuditLogDirector().log(logable, AuditLogType.STORAGE_DOMAIN_ERROR);
    return connectionField;
}
#end_block

#method_before
protected int calcEvenDistributionScore(VDS vds, VM vm, boolean countThreadsAsCores) {
    int score = MaxSchedulerWeight - 1;
    Integer effectiveCpuCores = SlaValidator.getEffectiveCpuCores(vds, countThreadsAsCores);
    if (effectiveCpuCores != null && vds.getUsageCpuPercent() != null && vds.getPendingVcpusCount() != null) {
        // round the result and adding one to avoid zero
        score = Math.min((int) Math.round(calcDistributeMetric(vds, vm, effectiveCpuCores)) + 1, MaxSchedulerWeight);
    }
    return score;
}
#method_after
protected int calcEvenDistributionScore(VDS vds, VM vm, boolean countThreadsAsCores) {
    int score = MaxSchedulerWeight - 1;
    Integer effectiveCpuCores = SlaValidator.getEffectiveCpuCores(vds, countThreadsAsCores);
    if (effectiveCpuCores != null && vds.getUsageCpuPercent() != null && vds.getPendingVcpusCount() != null) {
        // round the result and adding one to avoid zero
        score = Math.min((int) Math.round(calcDistributeMetric(vds, vm, effectiveCpuCores)) + 1, MaxSchedulerWeight);
    }
    // TODO Each 100 MB of free memory is equal to 1% of free CPU
    score -= vds.getMaxSchedulingMemory() / 100;
    return score;
}
#end_block

#method_before
private void auditLogOvfLoadError(String machineName, String errorMessage) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("ImportedVmName", machineName);
    logable.addCustomValue("ErrorMessage", errorMessage);
    AuditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_VM);
}
#method_after
private void auditLogOvfLoadError(String machineName, String errorMessage) {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("ImportedVmName", machineName);
    logable.addCustomValue("ErrorMessage", errorMessage);
    auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_FAILED_TO_IMPORT_VM);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.findMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getCompatibilityVersion()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.findMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getCompatibilityVersion()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (getTargetCluster().supportsVirtService() && !StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (!isDetachedSourceCluster() && !isSameManagementNetwork()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MANAGEMENT_NETWORK_CANNOT_BE_CHANGED);
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getCompatibilityVersion()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getCompatibilityVersion())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (VdcBLLException e) {
        AuditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#method_after
private void configureNetworks() {
    ChangeClusterParametersBuilder builder = new ChangeClusterParametersBuilder(getContext());
    final PersistentSetupNetworksParameters params;
    try {
        params = builder.buildParameters(getVdsId(), getSourceCluster().getId(), getTargetCluster().getId());
    } catch (VdcBLLException e) {
        auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.CONFIGURE_NETWORK_BY_LABELS_WHEN_CHANGING_CLUSTER_FAILED);
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            runInternalAction(VdcActionType.PersistentSetupNetworks, params, cloneContextAndDetachFromParent());
        }
    });
}
#end_block

#method_before
public PersistentSetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDAO().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    PersistentSetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> targetNetworksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    Map<String, List<Network>> sourceNetworksByLabel = getClusterNetworksByLabel(getNetworkDAO().getAllForCluster(sourceClusterId));
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(sourceNetworksByLabel, targetClusterNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic);
    }
    return params;
}
#method_after
public PersistentSetupNetworksParameters buildParameters(Guid hostId, Guid sourceClusterId, Guid targetClusterId) {
    List<Network> targetClusterNetworks = getNetworkDao().getAllForCluster(targetClusterId);
    Map<String, Network> targetClusterNetworksByName = Entities.entitiesByName(targetClusterNetworks);
    PersistentSetupNetworksParameters params = createSetupNetworksParameters(hostId);
    Map<String, VdsNetworkInterface> nicsByNetwork = Entities.hostInterfacesByNetworkName(params.getInterfaces());
    Map<String, List<Network>> targetNetworksByLabel = getClusterNetworksByLabel(targetClusterNetworks);
    Map<String, List<Network>> sourceNetworksByLabel = getClusterNetworksByLabel(getNetworkDao().getAllForCluster(sourceClusterId));
    List<VdsNetworkInterface> hostNics = new ArrayList<>(params.getInterfaces());
    // Detect which networks should be added and which should be removed
    for (VdsNetworkInterface nic : hostNics) {
        adjustNetworksByLabel(sourceNetworksByLabel, targetClusterNetworksByName, targetNetworksByLabel, params, nicsByNetwork, nic);
    }
    return params;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    Disk diskInfo = getParameters().getDiskInfo();
    if (diskInfo.getDiskStorageType() == DiskStorageType.IMAGE || diskInfo.getDiskStorageType() == DiskStorageType.CINDER) {
        getDiskImageInfo().setDiskSnapshot(false);
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    } else if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm())) {
        return failCanDoAction(VdcBllMessages.CANNOT_ADD_FLOATING_DISK_WITH_PLUG_VM_SET);
    }
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    if (!validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface())) {
        return false;
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        if (!checkIfImageDiskCanBeAdded(vm, diskValidator)) {
            return false;
        }
        return setAndValidateDiskProfiles();
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded(diskValidator);
    }
    if (DiskStorageType.CINDER == getParameters().getDiskInfo().getDiskStorageType()) {
        CinderDisk cinderDisk = (CinderDisk) getParameters().getDiskInfo();
        cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(getStorageDomainId())));
        StorageDomainValidator storageDomainValidator = createStorageDomainValidator();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisk);
        return validate(storageDomainValidator.isDomainExistAndActive()) && validate(cinderDisksValidator.validateCinderDiskLimits());
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null && !validate(diskValidator.isLunDiskVisible(lun, getVds()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null && !validate(diskValidator.isLunDiskVisible(lun, getVds()))) {
        return false;
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getParameters().getDiskInfo().setId(Guid.newGuid());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        createDiskBasedOnImage();
    } else {
        createDiskBasedOnLun();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    getParameters().getDiskInfo().setId(Guid.newGuid());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getDiskInfo().getId()));
    ImagesHandler.setDiskAlias(getParameters().getDiskInfo(), getVm());
    switch(getParameters().getDiskInfo().getDiskStorageType()) {
        case IMAGE:
            createDiskBasedOnImage();
            break;
        case LUN:
            createDiskBasedOnLun();
            break;
        case CINDER:
            createDiskBasedOnCinder();
            break;
    }
}
#end_block

#method_before
private void createDiskBasedOnLun() {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null);
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
private boolean shouldDiskBePlugged() {
    return getVm().getStatus() == VMStatus.Down && !Boolean.FALSE.equals(getParameters().getPlugDiskToVm());
}
#method_after
protected boolean shouldDiskBePlugged() {
    return getVm().getStatus() == VMStatus.Down && !Boolean.FALSE.equals(getParameters().getPlugDiskToVm());
}
#end_block

#method_before
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(VmDeviceUtils.addManagedDevice(new VmDeviceId(getParameters().getDiskInfo().getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, shouldDiskBePlugged(), Boolean.TRUE.equals(getParameters().getDiskInfo().getReadOnly()), null));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#method_after
private void createDiskBasedOnImage() {
    if (!getParameters().getDiskInfo().isWipeAfterDeleteSet()) {
        getParameters().getDiskInfo().setWipeAfterDelete(getStorageDomain().getWipeAfterDelete());
    }
    // create from blank template, create new vm snapshot id
    AddImageFromScratchParameters parameters = new AddImageFromScratchParameters(Guid.Empty, getParameters().getVmId(), getDiskImageInfo());
    parameters.setQuotaId(getQuotaId());
    parameters.setDiskProfileId(getDiskImageInfo().getDiskProfileId());
    parameters.setDiskAlias(getDiskAlias());
    parameters.setShouldRemainIllegalOnFailedExecution(getParameters().isShouldRemainIllegalOnFailedExecution());
    parameters.setStorageDomainId(getStorageDomainId());
    if (isExecutedAsChildCommand()) {
        parameters.setParentCommand(getParameters().getParentCommand());
        parameters.setParentParameters(getParameters().getParentParameters());
    } else {
        parameters.setParentCommand(VdcActionType.AddDisk);
        parameters.setParentParameters(getParameters());
    }
    parameters.setEntityInfo(getParameters().getEntityInfo());
    parameters.setStoragePoolId(getStorageDomain().getStoragePoolId());
    if (getVm() != null) {
        setVmSnapshotIdForDisk(parameters);
    }
    VdcReturnValueBase tmpRetValue = runInternalActionWithTasksContext(VdcActionType.AddImageFromScratch, parameters, getLock());
    // Setting lock to null because the lock is released in the child command
    setLock(null);
    ArrayList<Guid> taskList = isExecutedAsChildCommand() ? getReturnValue().getInternalVdsmTaskIdList() : getReturnValue().getVdsmTaskIdList();
    taskList.addAll(tmpRetValue.getInternalVdsmTaskIdList());
    if (getVm() != null) {
        getCompensationContext().snapshotNewEntity(addManagedDeviceForDisk(getParameters().getDiskInfo().getId()));
        getCompensationContext().stateChanged();
    }
    if (tmpRetValue.getActionReturnValue() != null) {
        DiskImage diskImage = (DiskImage) tmpRetValue.getActionReturnValue();
        addDiskPermissions(diskImage);
        getReturnValue().setActionReturnValue(diskImage.getId());
    }
    getReturnValue().setFault(tmpRetValue.getFault());
    setSucceeded(tmpRetValue.getSucceeded());
}
#end_block

#method_before
private void addDiskPermissions(Disk disk) {
    if (getCurrentUser() != null) {
        Permissions perms = new Permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), disk.getId(), VdcObjectType.Disk);
        MultiLevelAdministrationHandler.addPermission(perms);
    }
}
#method_after
private void addDiskPermissions(Disk disk) {
    if (getCurrentUser() != null) {
        Permission perms = new Permission(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), disk.getId(), VdcObjectType.Disk);
        MultiLevelAdministrationHandler.addPermission(perms);
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getParameters().getDiskInfo().getDiskStorageType() == DiskStorageType.IMAGE) {
                return getExecuteAuditLogTypeValue(getSucceeded());
            } else {
                return getEndSuccessAuditLogTypeValue(getSucceeded());
            }
        case END_SUCCESS:
            return getEndSuccessAuditLogTypeValue(getSucceeded());
        default:
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isDiskStorageTypeRequiresExecuteState()) {
                return getExecuteAuditLogTypeValue(getSucceeded());
            } else {
                return getEndSuccessAuditLogTypeValue(getSucceeded());
            }
        case END_SUCCESS:
            return getEndSuccessAuditLogTypeValue(getSucceeded());
        default:
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
    }
}
#end_block

#method_before
private AuditLogType getEndSuccessAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
        }
    }
}
#method_after
protected AuditLogType getEndSuccessAuditLogTypeValue(boolean successful) {
    boolean isVmNameExist = StringUtils.isNotEmpty(getVmName());
    if (successful) {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_SUCCESS;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_SUCCESS;
        }
    } else {
        if (isVmNameExist) {
            return AuditLogType.USER_ADD_DISK_TO_VM_FINISHED_FAILURE;
        } else {
            return AuditLogType.USER_ADD_DISK_FINISHED_FAILURE;
        }
    }
}
#end_block

#method_before
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(getVmId(), getParameters().getDiskInfo().getId());
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            AuditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#method_after
private void plugDiskToVmIfNeeded() {
    if (Boolean.TRUE.equals(getParameters().getPlugDiskToVm()) && getVm() != null && getVm().getStatus() != VMStatus.Down) {
        HotPlugDiskToVmParameters params = new HotPlugDiskToVmParameters(getVmId(), getParameters().getDiskInfo().getId());
        params.setShouldBeLogged(false);
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.HotPlugDiskToVm, params);
        if (!returnValue.getSucceeded()) {
            auditLogDirector.log(this, AuditLogType.USER_FAILED_HOTPLUG_DISK);
        }
    }
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, Guid vmId) {
    addDiskImage(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()), vmId);
}
#method_after
public static void addDiskImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap, Guid vmId) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDiskToVmIfNotExists(image, vmId);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#method_after
public static void addDiskImageWithNoVmDevice(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    try {
        addImage(image, active, imageStorageDomainMap);
        addDisk(image);
    } catch (RuntimeException ex) {
        log.error("Failed adding new disk image and related entities to db: {}", ex.getMessage());
        log.debug("Exception", ex);
        throw new VdcBLLException(VdcBllErrors.DB, ex);
    }
}
#end_block

#method_before
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#method_after
public static void addDiskImageWithNoVmDevice(DiskImage image) {
    addDiskImageWithNoVmDevice(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()));
}
#end_block

#method_before
public static void addDiskImage(DiskImage image, Guid vmId) {
    addDiskImage(image, image.getActive(), new image_storage_domain_map(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()), vmId);
}
#method_after
public static void addDiskImage(DiskImage image, Guid vmId) {
    addDiskImage(image, image.getActive(), new ImageStorageDomainMap(image.getImageId(), image.getStorageIds().get(0), image.getQuotaId(), image.getDiskProfileId()), vmId);
}
#end_block

#method_before
public static void addImage(DiskImage image, boolean active, image_storage_domain_map imageStorageDomainMap) {
    image.setActive(active);
    DbFacade.getInstance().getImageDao().save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setactual_size(image.getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    if (imageStorageDomainMap != null) {
        DbFacade.getInstance().getImageStorageDomainMapDao().save(imageStorageDomainMap);
    }
}
#method_after
public static void addImage(DiskImage image, boolean active, ImageStorageDomainMap imageStorageDomainMap) {
    image.setActive(active);
    DbFacade.getInstance().getImageDao().save(image.getImage());
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(image.getImageId());
    diskDynamic.setactual_size(image.getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    if (imageStorageDomainMap != null) {
        DbFacade.getInstance().getImageStorageDomainMapDao().save(imageStorageDomainMap);
    }
}
#end_block

#method_before
public static void addDiskToVm(BaseDisk disk, Guid vmId) {
    DbFacade.getInstance().getBaseDiskDao().save(disk);
    VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, true, false, null);
}
#method_after
public static void addDiskToVm(BaseDisk disk, Guid vmId) {
    DbFacade.getInstance().getBaseDiskDao().save(disk);
    VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, true, false, null, false);
}
#end_block

#method_before
private Disk getDiskImageByDiskId(Guid diskId) {
    Disk disk = getDiskDao().get(diskId);
    if (disk != null && disk.getDiskStorageType() == Disk.DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) disk;
        if (!diskImagesMap.containsKey(diskImage.getImageId())) {
            diskImagesMap.put(diskImage.getImageId(), (DiskImage) disk);
        }
    }
    return disk;
}
#method_after
private Disk getDiskImageByDiskId(Guid diskId) {
    Disk disk = getDiskDao().get(diskId);
    if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) disk;
        if (!diskImagesMap.containsKey(diskImage.getImageId())) {
            diskImagesMap.put(diskImage.getImageId(), (DiskImage) disk);
        }
    }
    return disk;
}
#end_block

#method_before
private void sleepOnReboot(final VDSStatus status) {
    int sleepTimeInSec = Config.<Integer>getValue(ConfigValues.ServerRebootTimeout);
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepTimeInSec);
    ThreadUtils.sleep(sleepTimeInSec * 1000);
    runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), status));
}
#method_after
private void sleepOnReboot(final VDSStatus status) {
    int sleepTimeInSec = Config.<Integer>getValue(ConfigValues.ServerRebootTimeout);
    log.info("Waiting {} seconds, for server to finish reboot process.", sleepTimeInSec);
    ThreadUtils.sleep(sleepTimeInSec * 1000);
    setVdsStatus(status);
}
#end_block

#method_before
private void Alert(AuditLogType logType, String operation) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    AlertDirector.Alert(alert, logType);
}
#method_after
private void Alert(AuditLogType logType, String operation) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    AlertDirector.Alert(alert, logType, auditLogDirector);
}
#end_block

#method_before
private void Alert(AuditLogType logType, String operation, Throwable throwable) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    alert.updateCallStackFromThrowable(throwable);
    AlertDirector.Alert(alert, logType);
}
#method_after
private void Alert(AuditLogType logType, String operation, Throwable throwable) {
    AuditLogableBase alert = new AuditLogableBase();
    alert.setVdsId(getVds().getId());
    String op = (operation == null) ? getActionType().name() : operation;
    alert.addCustomValue("Operation", op);
    alert.updateCallStackFromThrowable(throwable);
    AlertDirector.Alert(alert, logType, auditLogDirector);
}
#end_block

#method_before
protected void testVdsPowerManagementStatus(VdsStatic vdsStatic) {
    if (vdsStatic.isPmEnabled()) {
        PmHealthCheckManager.getInstance().pmHealthCheck(vdsStatic.getId());
    }
}
#method_after
protected void testVdsPowerManagementStatus(VdsStatic vdsStatic) {
    if (vdsStatic.isPmEnabled()) {
        pmHealthCheckManager.pmHealthCheck(vdsStatic.getId());
    }
}
#end_block

#method_before
protected void logSettingVmToDown(Guid vdsId, Guid vmId) {
    AuditLogableBase logable = new AuditLogableBase(vdsId, vmId);
    AuditLogDirector.log(logable, AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE);
}
#method_after
protected void logSettingVmToDown(Guid vdsId, Guid vmId) {
    AuditLogableBase logable = new AuditLogableBase(vdsId, vmId);
    auditLogDirector.log(logable, AuditLogType.VM_WAS_SET_DOWN_DUE_TO_HOST_REBOOT_OR_MANUAL_FENCE);
}
#end_block

#method_before
protected void setVdsStatus(VDSStatus status) {
    runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), status));
}
#method_after
protected VDSReturnValue setVdsStatus(VDSStatus status) {
    SetVdsStatusVDSCommandParameters parameters = new SetVdsStatusVDSCommandParameters(getVdsId(), status);
    return invokeSetHostStatus(parameters);
}
#end_block

#method_before
protected void setVdsStatus(VDSStatus status) {
    runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(getVdsId(), status));
}
#method_after
protected VDSReturnValue setVdsStatus(VDSStatus status, NonOperationalReason reason) {
    SetVdsStatusVDSCommandParameters parameters = new SetVdsStatusVDSCommandParameters(getVdsId(), status, reason);
    return invokeSetHostStatus(parameters);
}
#end_block

#method_before
private void logMemorySavingFailed() {
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE);
}
#method_after
private void logMemorySavingFailed() {
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    auditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_NO_MEMORY_FAILURE);
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}", e.getMessage());
    log.debug("Exception", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warn("Could not perform live snapshot due to error, VM will still be configured to the new created" + " snapshot: {}", e.getMessage());
    log.debug("Exception", e);
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    auditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null);
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            AuditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#method_after
@Override
protected void endVmCommand() {
    initializeObjectState();
    if (getParameters().getTaskGroupSuccess()) {
        getSnapshotDao().remove(getParameters().getSnapshotId());
    } else {
        List<String> failedToRemoveDisks = new ArrayList<>();
        Snapshot snapshot = getSnapshotDao().get(getParameters().getSnapshotId());
        for (VdcActionParametersBase parameters : getParameters().getImagesParameters()) {
            ImagesContainterParametersBase imagesParams = (parameters instanceof ImagesContainterParametersBase ? (ImagesContainterParametersBase) parameters : null);
            if (imagesParams == null) {
                // instances of ImagesContainterParametersBase objects.
                continue;
            }
            if (imagesParams.getTaskGroupSuccess()) {
                snapshot = ImagesHandler.prepareSnapshotConfigWithoutImageSingleImage(snapshot, imagesParams.getImageId());
            } else {
                log.error("Could not delete image '{}' from snapshot '{}'", imagesParams.getImageId(), getParameters().getSnapshotId());
                DiskImage diskImage = getDiskImageDao().getSnapshotById(imagesParams.getImageId());
                failedToRemoveDisks.add(diskImage.getDiskAlias());
            }
        }
        // Remove memory volume and update the dao.
        // Note: on failure, we can treat memory volume deletion as deleting an image
        // and remove it from the snapshot entity (rollback isn't applicable).
        snapshot.setMemoryVolume("");
        getSnapshotDao().update(snapshot);
        if (!failedToRemoveDisks.isEmpty()) {
            addCustomValue("DiskAliases", StringUtils.join(failedToRemoveDisks, ", "));
            auditLogDirector.log(this, AuditLogType.USER_REMOVE_SNAPSHOT_FINISHED_FAILURE_PARTIAL_SNAPSHOT);
        }
        getSnapshotDao().updateStatus(getParameters().getSnapshotId(), SnapshotStatus.OK);
    }
    super.endVmCommand();
}
#end_block

#method_before
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), true, false, true);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    return validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal());
}
#method_after
protected boolean validateImages() {
    List<DiskImage> imagesToValidate = ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), true, false, true);
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(imagesToValidate);
    return validate(diskImagesValidator.diskImagesNotLocked()) && (getVm().isQualifiedForLiveSnapshotMerge() || validate(diskImagesValidator.diskImagesNotIllegal()));
}
#end_block

#method_before
@Override
public CommandCallBack getCallback() {
    return getVm().isQualifiedForLiveSnapshotMerge() ? new RemoveSnapshotCommandCallback() : null;
}
#method_after
@Override
public CommandCallback getCallback() {
    return getVm().isQualifiedForLiveSnapshotMerge() ? new RemoveSnapshotCommandCallback() : null;
}
#end_block

#method_before
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes((-1) * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    for (SPMTask task : _tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                AuditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.stopTask(true);
            } else {
                AuditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.clearAsyncTask(true);
            }
        }
    }
}
#method_after
private void cleanZombieTasks() {
    long maxTime = DateTime.getNow().addMinutes((-1) * Config.<Integer>getValue(ConfigValues.AsyncTaskZombieTaskLifeInMinutes)).getTime();
    for (SPMTask task : _tasks.values()) {
        if (task.getParameters().getDbAsyncTask().getStartTime().getTime() < maxTime) {
            AuditLogableBase logable = new AuditLogableBase();
            logable.addCustomValue("CommandName", task.getParameters().getDbAsyncTask().getActionType().toString());
            logable.addCustomValue("Date", task.getParameters().getDbAsyncTask().getStartTime().toString());
            // status
            if (task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.finished && task.getLastTaskStatus().getStatus() != AsyncTaskStatusEnum.unknown) {
                // mark it as a zombie task, Will result in failure of the command
                task.setZombieTask(true);
                auditLogDirector.log(logable, AuditLogType.TASK_STOPPING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Stopping async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.stopTask(true);
            } else {
                auditLogDirector.log(logable, AuditLogType.TASK_CLEARING_ASYNC_TASK);
                log.info("Cleaning zombie tasks: Clearing async task '{}' that started at '{}'", task.getParameters().getDbAsyncTask().getActionType(), task.getParameters().getDbAsyncTask().getStartTime());
                task.clearAsyncTask(true);
            }
        }
    }
}
#end_block

#method_before
private void addTextAndLinkAlert(final ViewDef view, final String text, final UICommand command, final AlertType alertTtpe) {
    // Find the open and close positions of the link within the message:
    // $NON-NLS-1$
    final int openIndex = text.indexOf("<a>");
    // $NON-NLS-1$
    final int closeIndex = text.indexOf("</a>");
    if (openIndex == -1 || closeIndex == -1 || closeIndex < openIndex) {
        return;
    }
    // Extract the text before, inside and after the tags:
    final String beforeText = text.substring(0, openIndex);
    final String betweenText = text.substring(openIndex + 3, closeIndex);
    final String afterText = text.substring(closeIndex + 4);
    // Create a flow panel containing the text and the link:
    final FlowPanel alertPanel = new FlowPanel();
    // Create the label for the text before the tag:
    final Label beforeLabel = new Label(beforeText);
    // $NON-NLS-1$ //$NON-NLS-2$
    beforeLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(beforeLabel);
    // Create the anchor:
    final Anchor betweenAnchor = new Anchor(betweenText);
    // $NON-NLS-1$ //$NON-NLS-2$
    betweenAnchor.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(betweenAnchor);
    // Add a listener to the anchor so that the command is executed when
    // it is clicked:
    betweenAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            command.execute();
        }
    });
    // Create the label for the text after the tag:
    final Label afterLabel = new Label(afterText);
    // $NON-NLS-1$ //$NON-NLS-2$
    afterLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(afterLabel);
    // Add the alert to the view:
    view.addAlert(alertPanel, alertTtpe);
}
#method_after
private void addTextAndLinkAlert(final ViewDef view, final String text, final UICommand command, final AlertType alertType) {
    // Find the open and close positions of the link within the message:
    // $NON-NLS-1$
    final int openIndex = text.indexOf("<a>");
    // $NON-NLS-1$
    final int closeIndex = text.indexOf("</a>");
    if (openIndex == -1 || closeIndex == -1 || closeIndex < openIndex) {
        return;
    }
    // Extract the text before, inside and after the tags:
    final String beforeText = text.substring(0, openIndex);
    final String betweenText = text.substring(openIndex + 3, closeIndex);
    final String afterText = text.substring(closeIndex + 4);
    // Create a flow panel containing the text and the link:
    final FlowPanel alertPanel = new FlowPanel();
    // Create the label for the text before the tag:
    final Label beforeLabel = new Label(beforeText);
    // $NON-NLS-1$ //$NON-NLS-2$
    beforeLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(beforeLabel);
    // Create the anchor:
    final Anchor betweenAnchor = new Anchor(betweenText);
    // $NON-NLS-1$ //$NON-NLS-2$
    betweenAnchor.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(betweenAnchor);
    // Add a listener to the anchor so that the command is executed when
    // it is clicked:
    betweenAnchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            command.execute();
        }
    });
    // Create the label for the text after the tag:
    final Label afterLabel = new Label(afterText);
    // $NON-NLS-1$ //$NON-NLS-2$
    afterLabel.getElement().getStyle().setProperty("display", "inline");
    alertPanel.add(afterLabel);
    // Add the alert to the view:
    view.addAlert(alertPanel, alertType);
}
#end_block

#method_before
private void postInitTemplate(List<VmTemplate> templates) {
    List<VmTemplate> baseWithoutBlank = filterOutBlank(keepBaseTemplates(templates));
    if (baseWithoutBlank.isEmpty()) {
        // it is not allowed to create sub-templates of Blank template
        getModel().getIsSubTemplate().setEntity(false);
        getModel().getIsSubTemplate().setIsChangeable(false, constants.someNonDefaultTemplateHasToExistFirst());
        return;
    }
    getModel().getIsSubTemplate().setEntity(false);
    getModel().getIsSubTemplate().setIsChangeable(true);
    VmTemplate currentTemplate = Linq.firstOrDefault(templates, new Linq.TemplatePredicate(vm.getVmtGuid()));
    getModel().getBaseTemplate().setItems(baseWithoutBlank);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(baseWithoutBlank, new Linq.TemplatePredicate(currentTemplate.getBaseTemplateId())));
}
#method_after
private void postInitTemplate(List<VmTemplate> templates) {
    List<VmTemplate> baseWithoutBlank = filterOutBlank(keepBaseTemplates(templates));
    getModel().getIsSubTemplate().setEntity(false);
    if (baseWithoutBlank.isEmpty()) {
        // it is not allowed to create sub-templates of Blank template
        getModel().getIsSubTemplate().setIsChangeable(false, constants.someNonDefaultTemplateHasToExistFirst());
        return;
    }
    getModel().getIsSubTemplate().setIsChangeable(true);
    VmTemplate currentTemplate = Linq.firstOrDefault(templates, new Linq.TemplatePredicate(vm.getVmtGuid()));
    getModel().getBaseTemplate().setItems(baseWithoutBlank);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(baseWithoutBlank, new Linq.TemplatePredicate(currentTemplate.getBaseTemplateId())));
}
#end_block

#method_before
private List<VmTemplate> filterOutBlank(List<VmTemplate> templates) {
    final ArrayList<VmTemplate> result = new ArrayList<>();
    for (VmTemplate template : templates) {
        if (!template.isBlank()) {
            result.add(template);
        }
    }
    return result;
}
#method_after
private List<VmTemplate> filterOutBlank(List<VmTemplate> templates) {
    final List<VmTemplate> result = new ArrayList<>();
    for (VmTemplate template : templates) {
        if (!template.isBlank()) {
            result.add(template);
        }
    }
    return result;
}
#end_block

#method_before
private void initTemplates(List<VmTemplate> templates) {
    List<VmTemplate> rootTemplates = keepBaseTemplates(templates);
    // Filter templates list (include only templates that belong to the selected datacenter)
    List<VmTemplate> templatesList = new ArrayList<>();
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool selectedDataCenter = dataCenterWithCluster.getDataCenter();
    Guid selectedDataCenterId = selectedDataCenter.getId();
    if (selectedDataCenterId == null) {
        return;
    }
    for (VmTemplate template : rootTemplates) {
        Guid datacenterId = template.getStoragePoolId() == null ? Guid.Empty : template.getStoragePoolId();
        if (!template.isBlank() && selectedDataCenterId.equals(datacenterId) && template.getStatus() == VmTemplateStatus.OK) {
            templatesList.add(template);
        }
    }
    Collections.sort(templatesList, new NameableComparator());
    List<VmTemplate> filteredTemplates = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesList, dataCenterWithCluster.getCluster().getArchitecture());
    if (filteredTemplates.isEmpty()) {
        // it is not allowed to create sub-templates of Blank template
        getModel().getIsSubTemplate().setEntity(false);
        getModel().getIsSubTemplate().setIsChangeable(false, constants.someNonDefaultTemplateHasToExistFirst());
        return;
    }
    getModel().getIsSubTemplate().setEntity(false);
    getModel().getIsSubTemplate().setIsChangeable(true);
    VmTemplate currentTemplate = Linq.firstOrDefault(templates, new Linq.TemplatePredicate(getVm().getVmtGuid()));
    getModel().getBaseTemplate().setItems(filteredTemplates);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(filteredTemplates, new Linq.TemplatePredicate(currentTemplate.getBaseTemplateId())));
}
#method_after
private void initTemplates(List<VmTemplate> templates) {
    List<VmTemplate> rootTemplates = keepBaseTemplates(templates);
    // Filter templates list (include only templates that belong to the selected datacenter)
    List<VmTemplate> templatesList = new ArrayList<>();
    DataCenterWithCluster dataCenterWithCluster = getModel().getDataCenterWithClustersList().getSelectedItem();
    StoragePool selectedDataCenter = dataCenterWithCluster.getDataCenter();
    Guid selectedDataCenterId = selectedDataCenter.getId();
    if (selectedDataCenterId == null) {
        return;
    }
    for (VmTemplate template : rootTemplates) {
        Guid datacenterId = template.getStoragePoolId() == null ? Guid.Empty : template.getStoragePoolId();
        if (!template.isBlank() && selectedDataCenterId.equals(datacenterId) && template.getStatus() == VmTemplateStatus.OK) {
            templatesList.add(template);
        }
    }
    Collections.sort(templatesList, new NameableComparator());
    List<VmTemplate> filteredTemplates = AsyncDataProvider.getInstance().filterTemplatesByArchitecture(templatesList, dataCenterWithCluster.getCluster().getArchitecture());
    getModel().getIsSubTemplate().setEntity(false);
    if (filteredTemplates.isEmpty()) {
        // it is not allowed to create sub-templates of Blank template
        getModel().getIsSubTemplate().setIsChangeable(false, constants.someNonDefaultTemplateHasToExistFirst());
        return;
    }
    getModel().getIsSubTemplate().setIsChangeable(true);
    VmTemplate currentTemplate = Linq.firstOrDefault(templates, new Linq.TemplatePredicate(getVm().getVmtGuid()));
    getModel().getBaseTemplate().setItems(filteredTemplates);
    getModel().getBaseTemplate().setSelectedItem(Linq.firstOrDefault(filteredTemplates, new Linq.TemplatePredicate(currentTemplate.getBaseTemplateId())));
}
#end_block

#method_before
private void refreshSnapshotsInCluster(VDSGroup cluster) {
    if (!supportsGlusterSnapshotFeature(cluster)) {
        return;
    }
    final VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.info("No UP server found in cluster '{}' for snapshot monitoring", cluster.getName());
        return;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeSnapshotInfo, new GlusterVolumeSnapshotVDSParameters(upServer.getId(), cluster.getId(), null));
    if (returnValue.getSucceeded()) {
        addOrUpdateSnapshots(cluster.getId(), (ArrayList<GlusterVolumeSnapshotEntity>) returnValue.getReturnValue());
    } else {
        log.error("VDS Error {}", returnValue.getVdsError().getMessage());
        log.debug("VDS Error {}", returnValue.getVdsError());
    }
}
#method_after
private void refreshSnapshotsInCluster(VDSGroup cluster) {
    if (!supportsGlusterSnapshotFeature(cluster)) {
        return;
    }
    final VDS upServer = getClusterUtils().getRandomUpServer(cluster.getId());
    if (upServer == null) {
        log.info("No UP server found in cluster '{}' for snapshot monitoring", cluster.getName());
        return;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeSnapshotInfo, new GlusterVolumeSnapshotVDSParameters(upServer.getId(), cluster.getId(), null));
    if (returnValue.getSucceeded()) {
        addOrUpdateSnapshots(cluster.getId(), (ArrayList<GlusterVolumeSnapshotEntity>) returnValue.getReturnValue());
        // check if the snapshot soft limit reached for a volume and alert
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(cluster.getId());
        for (final GlusterVolumeEntity volume : volumes) {
            // check if the snapshot soft limit reached for the volume and alert
            getGlusterUtil().alertVolumeSnapshotSoftLimitReached(volume);
            // Check and remove soft limit alert for the volume.
            // It might have fallen below the soft limit as part of deletions of snapshots
            getGlusterUtil().checkAndRemoveVolumeSnapshotSoftLimitAlert(volume);
        }
    } else {
        log.error("VDS Error {}", returnValue.getVdsError().getMessage());
        log.debug("VDS Error {}", returnValue.getVdsError());
    }
}
#end_block

#method_before
private boolean supportsGlusterSnapshotFeature(VDSGroup cluster) {
    return cluster.supportsGlusterService() && (GlusterFeatureSupported.glusterSnapshot(cluster.getCompatibilityVersion()) || getClusterUtils().isFeatureSupportedAsAdditionalFeature(cluster.getId(), ClusterUtils.FEATURE_GLUSTER_SNAPSHOT));
}
#method_after
private boolean supportsGlusterSnapshotFeature(VDSGroup cluster) {
    return cluster.supportsGlusterService() && getGlusterUtil().isGlusterSnapshotSupported(cluster.getCompatibilityVersion(), cluster.getId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!GlusterFeatureSupported.glusterSnapshot(getVdsGroup().getCompatibilityVersion()) && !ClusterUtils.getInstance().isFeatureSupportedAsAdditionalFeature(getVdsGroup().getId(), ClusterUtils.FEATURE_GLUSTER_SNAPSHOT)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_SNAPSHOT_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (!getGlusterUtil().isGlusterSnapshotSupported(getVdsGroup().getCompatibilityVersion(), getVdsGroup().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_SNAPSHOT_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getClusterId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!GlusterFeatureSupported.glusterSnapshot(getVdsGroup().getCompatibilityVersion()) && !ClusterUtils.getInstance().isFeatureSupportedAsAdditionalFeature(getVdsGroup().getId(), ClusterUtils.FEATURE_GLUSTER_SNAPSHOT)) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_SNAPSHOT_NOT_SUPPORTED);
    }
    if (getParameters().getConfigParams() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_CONFIG_PARAMS_IS_EMPTY);
        return false;
    }
    for (GlusterVolumeSnapshotConfig param : getParameters().getConfigParams()) {
        if (StringUtils.isEmpty(param.getParamValue())) {
            addCustomValue("snapshotConfigParam", param.getParamName());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_CONFIG_PARAM_VALUE_IS_EMPTY);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getClusterId() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!getGlusterUtil().isGlusterSnapshotSupported(getVdsGroup().getCompatibilityVersion(), getVdsGroup().getId())) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VOLUME_SNAPSHOT_NOT_SUPPORTED);
    }
    if (getParameters().getConfigParams() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_CONFIG_PARAMS_IS_EMPTY);
        return false;
    }
    for (GlusterVolumeSnapshotConfig param : getParameters().getConfigParams()) {
        if (StringUtils.isEmpty(param.getParamValue())) {
            addCustomValue("snapshotConfigParam", param.getParamName());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SNAPSHOT_CONFIG_PARAM_VALUE_IS_EMPTY);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && (GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion()) || getClusterUtils().isFeatureSupportedAsAdditionalFeature(cluster.getId(), ClusterUtils.FEATURE_GLUSTER_BRICK_MANAGEMENT));
}
#method_after
private boolean supportsGlusterDiskProvisioning(VDSGroup cluster) {
    return cluster.supportsGlusterService() && getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), cluster.getId());
}
#end_block

#method_before
private boolean supportsGlusterGeoRepFeature(VDSGroup cluster) {
    return cluster.supportsGlusterService() && (GlusterFeatureSupported.glusterGeoReplication(cluster.getCompatibilityVersion()) || getClusterUtils().isFeatureSupportedAsAdditionalFeature(cluster.getId(), ClusterUtils.FEATURE_GLUSTER_GEO_REPLICATION));
}
#method_after
private boolean supportsGlusterGeoRepFeature(VDSGroup cluster) {
    return cluster.supportsGlusterService() && getGlusterUtil().isGlusterGeoReplicationSupported(cluster.getCompatibilityVersion(), cluster.getId());
}
#end_block

#method_before
@Before
public void init() {
    syncJob = Mockito.spy(GlusterSnapshotSyncJob.getInstance());
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(volumeDao).when(syncJob).getGlusterVolumeDao();
    doReturn(snapshotDao).when(syncJob).getGlusterVolumeSnapshotDao();
    doReturn(snapshotConfigDao).when(syncJob).getGlusterVolumeSnapshotConfigDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(getVolumes()).when(volumeDao).getByClusterId(argThat(validClusterId()));
    doReturn(getVolume(CLUSTER_ID_1, VOLUME_ID_1, VOLUME_NAME_1)).when(volumeDao).getByName(argThat(validClusterId()), argThat(validVolumeName()));
    doReturn(getServer()).when(clusterUtils).getRandomUpServer(any(Guid.class));
    when(clusterUtils.isFeatureSupportedAsAdditionalFeature(any(Guid.class), anyString())).thenReturn(false);
    doReturn(engineLock).when(syncJob).acquireVolumeSnapshotLock(any(Guid.class));
}
#method_after
@Before
public void init() {
    syncJob = Mockito.spy(GlusterSnapshotSyncJob.getInstance());
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(volumeDao).when(syncJob).getGlusterVolumeDao();
    doReturn(snapshotDao).when(syncJob).getGlusterVolumeSnapshotDao();
    doReturn(snapshotConfigDao).when(syncJob).getGlusterVolumeSnapshotConfigDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(glusterUtil).when(syncJob).getGlusterUtil();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(getVolumes()).when(volumeDao).getByClusterId(argThat(validClusterId()));
    doReturn(getVolume(CLUSTER_ID_1, VOLUME_ID_1, VOLUME_NAME_1)).when(volumeDao).getByName(argThat(validClusterId()), argThat(validVolumeName()));
    doReturn(getServer()).when(clusterUtils).getRandomUpServer(any(Guid.class));
    when(glusterUtil.isGlusterSnapshotSupported(eq(Version.v3_4), any(Guid.class))).thenReturn(false);
    when(glusterUtil.isGlusterSnapshotSupported(eq(Version.v3_5), any(Guid.class))).thenReturn(true);
    doReturn(engineLock).when(syncJob).acquireVolumeSnapshotLock(any(Guid.class));
    doNothing().when(glusterUtil).alertVolumeSnapshotSoftLimitReached(any(GlusterVolumeEntity.class));
    doNothing().when(glusterUtil).checkAndRemoveVolumeSnapshotSoftLimitAlert(any(GlusterVolumeEntity.class));
}
#end_block

#method_before
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(storageDeviceDao).when(syncJob).getStorageDeviceDao();
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(vdsDao).when(syncJob).getVdsDao();
    doReturn(getAllUpServers()).when(clusterUtils).getAllUpServers(CLUSTER_GUID_3_6);
    when(clusterUtils.isFeatureSupportedAsAdditionalFeature(any(Guid.class), anyString())).thenReturn(false);
    doReturn(getStorageDevices(HOST_ID_WITH_NEW_DEVICES)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_NEW_DEVICES);
    doReturn(getStorageDevices(HOST_ID_WITH_DEVICES_CHANGED)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_DEVICES_CHANGED);
    doReturn(getStorageDevices(HOST_ID_WITH_DEVICES_DELETED)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_DEVICES_DELETED);
}
#method_after
@Before
public void init() {
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(storageDeviceDao).when(syncJob).getStorageDeviceDao();
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(glusterUtil).when(syncJob).getGlusterUtil();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(vdsDao).when(syncJob).getVdsDao();
    doReturn(getAllUpServers()).when(clusterUtils).getAllUpServers(CLUSTER_GUID_3_6);
    when(glusterUtil.isGlusterBrickProvisioningSupported(eq(Version.v3_5), eq(CLUSTER_GUID_3_5))).thenReturn(false);
    when(glusterUtil.isGlusterBrickProvisioningSupported(eq(Version.v3_6), eq(CLUSTER_GUID_3_6))).thenReturn(true);
    doReturn(getStorageDevices(HOST_ID_WITH_NEW_DEVICES)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_NEW_DEVICES);
    doReturn(getStorageDevices(HOST_ID_WITH_DEVICES_CHANGED)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_DEVICES_CHANGED);
    doReturn(getStorageDevices(HOST_ID_WITH_DEVICES_DELETED)).when(storageDeviceDao).getStorageDevicesInHost(HOST_ID_WITH_DEVICES_DELETED);
}
#end_block

#method_before
private Object getStorageDevicesVDSReturnVal(Guid hostId) {
    VDSReturnValue vdsRetValue = new VDSReturnValue();
    vdsRetValue.setSucceeded(true);
    if (HOST_ID_WITH_NEW_DEVICES.equals(hostId)) {
        vdsRetValue.setReturnValue(Arrays.asList(getStorageDevice("sda", null), getStorageDevice("sdb", null), getStorageDevice("sdc", null)));
    } else if (HOST_ID_WITH_DEVICES_CHANGED.equals(hostId)) {
        List<StorageDevice> devices = new ArrayList<StorageDevice>();
        devices.add(getStorageDevice("device-without-anychange", DEVICE_WITHOUT_ANYCHANGE));
        devices.add(getStorageDevice("new-device-with-name-change", DEVICE_WITH_NAME_CHANGE));
        StorageDevice device = getStorageDevice("device-with-change", DEVICE_WITH_CHANGE);
        device.setMountPoint("/temp-mount");
        device.setFsType("XFS");
        device.setSize(12345678L);
        devices.add(device);
        device = getStorageDevice("device-with-devuuid-but-name-changed-1", DEVICE_WITH_DEVUUID_BUT_NAME_CHANGED);
        device.setDevUuid("123456");
        devices.add(device);
        devices.add(getStorageDevice("device-with-devuuid-but-name-changed", null));
        vdsRetValue.setReturnValue(devices);
    } else {
        vdsRetValue.setReturnValue(Collections.EMPTY_LIST);
    }
    return vdsRetValue;
}
#method_after
private Object getStorageDevicesVDSReturnVal(Guid hostId) {
    VDSReturnValue vdsRetValue = new VDSReturnValue();
    vdsRetValue.setSucceeded(true);
    if (HOST_ID_WITH_NEW_DEVICES.equals(hostId)) {
        vdsRetValue.setReturnValue(Arrays.asList(getStorageDevice("sda", null), getStorageDevice("sdb", null), getStorageDevice("sdc", null)));
    } else if (HOST_ID_WITH_DEVICES_CHANGED.equals(hostId)) {
        List<StorageDevice> devices = new ArrayList<StorageDevice>();
        devices.add(getStorageDevice("device-without-anychange", DEVICE_WITHOUT_ANYCHANGE));
        devices.add(getStorageDevice("new-device-with-name-change", DEVICE_WITH_NAME_CHANGE));
        StorageDevice device = getStorageDevice("device-with-change", DEVICE_WITH_CHANGE);
        device.setMountPoint("/temp-mount");
        device.setFsType("XFS");
        device.setSize(12345678L);
        devices.add(device);
        device = getStorageDevice("device-with-devuuid-but-name-changed-1", DEVICE_WITH_DEVUUID_BUT_NAME_CHANGED);
        device.setDevUuid("123456");
        devices.add(device);
        devices.add(getStorageDevice("device-with-devuuid-but-name-changed", null));
        vdsRetValue.setReturnValue(devices);
    } else {
        vdsRetValue.setReturnValue(Collections.emptyList());
    }
    return vdsRetValue;
}
#end_block

#method_before
private void prepareMocks() {
    doReturn(volume).when(volumeDao).getById(masterVolumeId);
    doReturn(GlusterStatus.UP).when(volume).getStatus();
    doReturn(vdsGroup).when(command).getVdsGroup();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsDao).when(command).getVdsDAO();
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(geoRepDao).when(command).getGeoRepDao();
    doReturn(vds).when(command).getUpServer();
    doReturn(VDSStatus.Up).when(vds).getStatus();
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.isFeatureSupportedAsAdditionalFeature(any(Guid.class), anyString())).thenReturn(false);
}
#method_after
private void prepareMocks() {
    doReturn(volume).when(volumeDao).getById(masterVolumeId);
    doReturn(GlusterStatus.UP).when(volume).getStatus();
    doReturn(vdsGroup).when(command).getVdsGroup();
    doReturn(vdsGroupDao).when(command).getVdsGroupDAO();
    doReturn(vdsDao).when(command).getVdsDAO();
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(geoRepDao).when(command).getGeoRepDao();
    doReturn(vds).when(command).getUpServer();
    doReturn(VDSStatus.Up).when(vds).getStatus();
    doReturn(glusterUtil).when(command).getGlusterUtil();
    when(glusterUtil.isGlusterGeoReplicationSupported(eq(SUPPORTED_VERSION), any(Guid.class))).thenReturn(true);
    when(glusterUtil.isGlusterGeoReplicationSupported(eq(NOT_SUPPORTED_VERSION), any(Guid.class))).thenReturn(false);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion()) && !getClusterUtils().isFeatureSupportedAsAdditionalFeature(getVdsGroup().getId(), ClusterUtils.FEATURE_GLUSTER_BRICK_MANAGEMENT))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!ObjectUtils.objectsEqual(deviceType, device.getDevType())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addCanDoActionMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    if (!validate(validator.isUp())) {
        return false;
    }
    String deviceType;
    if (getParameters().getDisks() == null || getParameters().getDisks().isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DEVICE_REQUIRED);
        return false;
    } else {
        deviceType = getParameters().getDisks().get(0).getDevType();
    }
    for (StorageDevice device : getParameters().getDisks()) {
        // for performance reasons.
        if (!ObjectUtils.objectsEqual(deviceType, device.getDevType())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DIFFERENT_STORAGE_DEVICE_TYPES_SELECTED);
            return false;
        }
        // Ensure that device is not already used by some other brick or LVM.
        if (!device.getCanCreateBrick()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DEVICE_IS_ALREADY_IN_USE);
            addCanDoActionMessageVariable("storageDevice", device.getName());
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Before
public void init() {
    syncJob = Mockito.spy(GlusterGeoRepSyncJob.getInstance());
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(vdsDao).when(syncJob).getVdsDao();
    doReturn(geoRepDao).when(syncJob).getGeoRepDao();
    doReturn(volumeDao).when(syncJob).getVolumeDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(getVolume()).when(volumeDao).getByName(any(Guid.class), any(String.class));
    doReturn(getVolume()).when(volumeDao).getById(any(Guid.class));
    doReturn(getServer()).when(clusterUtils).getRandomUpServer(any(Guid.class));
    when(clusterUtils.isFeatureSupportedAsAdditionalFeature(any(Guid.class), anyString())).thenReturn(false);
    doReturn(getMockLock()).when(syncJob).acquireGeoRepSessionLock(any(Guid.class));
    doReturn(getSessions(2, true)).when(geoRepDao).getGeoRepSessionsInCluster(CLUSTER_GUIDS[1]);
}
#method_after
@Before
public void init() {
    syncJob = Mockito.spy(GlusterGeoRepSyncJob.getInstance());
    MockitoAnnotations.initMocks(this);
    syncJob.setLogUtil(logUtil);
    doReturn(clusterDao).when(syncJob).getClusterDao();
    doReturn(vdsDao).when(syncJob).getVdsDao();
    doReturn(geoRepDao).when(syncJob).getGeoRepDao();
    doReturn(volumeDao).when(syncJob).getVolumeDao();
    doReturn(clusterUtils).when(syncJob).getClusterUtils();
    doReturn(getClusters()).when(clusterDao).getAll();
    doReturn(getVolume()).when(volumeDao).getByName(any(Guid.class), any(String.class));
    doReturn(getVolume()).when(volumeDao).getById(any(Guid.class));
    doReturn(getServer()).when(clusterUtils).getRandomUpServer(any(Guid.class));
    doReturn(glusterUtil).when(syncJob).getGlusterUtil();
    when(glusterUtil.isGlusterGeoReplicationSupported(eq(Version.v3_5), any(Guid.class))).thenReturn(true);
    when(glusterUtil.isGlusterGeoReplicationSupported(eq(Version.v3_4), any(Guid.class))).thenReturn(false);
    doReturn(getMockLock()).when(syncJob).acquireGeoRepSessionLock(any(Guid.class));
    doReturn(getSessions(2, true)).when(geoRepDao).getGeoRepSessionsInCluster(CLUSTER_GUIDS[1]);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!GlusterFeatureSupported.glusterGeoReplication(getVdsGroup().getCompatibilityVersion()) && !getClusterUtils().isFeatureSupportedAsAdditionalFeature(getVdsGroup().getId(), ClusterUtils.FEATURE_GLUSTER_GEO_REPLICATION)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEO_REP_NOT_SUPPORTED);
    }
    slaveHost = getSlaveHost();
    if (slaveHost == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (slaveHost.getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP, String.format("$%1$s %2$s", "VdsName", slaveHost.getName()));
    }
    slaveVolume = getSlaveVolume();
    if (slaveVolume == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID);
    }
    if (slaveVolume.getStatus() != GlusterStatus.UP) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    if (!areAllRemoteServersUp()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_REMOTE_HOSTS_ARE_NOT_ACCESSIBLE);
    }
    GlusterGeoRepSession geoRepSession = getGeoRepDao().getGeoRepSession(getGlusterVolumeId(), slaveHost.getId(), getParameters().getSlaveVolumeName());
    if (geoRepSession != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_GEOREP_SESSION_ALREADY_CREATED);
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!getGlusterUtil().isGlusterGeoReplicationSupported(getVdsGroup().getCompatibilityVersion(), getVdsGroup().getId())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GEO_REP_NOT_SUPPORTED);
    }
    slaveHost = getSlaveHost();
    if (slaveHost == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NOT_EXIST);
    }
    if (slaveHost.getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SERVER_STATUS_NOT_UP, String.format("$%1$s %2$s", "VdsName", slaveHost.getName()));
    }
    slaveVolume = getSlaveVolume();
    if (slaveVolume == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID);
    }
    if (slaveVolume.getStatus() != GlusterStatus.UP) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
    }
    if (!areAllRemoteServersUp()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_REMOTE_HOSTS_ARE_NOT_ACCESSIBLE);
    }
    GlusterGeoRepSession geoRepSession = getGeoRepDao().getGeoRepSession(getGlusterVolumeId(), slaveHost.getId(), getParameters().getSlaveVolumeName());
    if (geoRepSession != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_GEOREP_SESSION_ALREADY_CREATED);
    }
    return super.canDoAction();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || !GlusterFeatureSupported.glusterBrickProvisioning(cluster.getCompatibilityVersion()) && !ClusterUtils.getInstance().isFeatureSupportedAsAdditionalFeature(getVdsGroup().getId(), ClusterUtils.FEATURE_GLUSTER_BRICK_MANAGEMENT)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    return validate(validator.isUp());
}
#method_after
@Override
protected boolean canDoAction() {
    VDSGroup cluster = getVdsGroup();
    if (!cluster.supportsGlusterService() || (!getGlusterUtil().isGlusterBrickProvisioningSupported(cluster.getCompatibilityVersion(), getVdsGroup().getId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_PROVISIONING_NOT_SUPPORTED_BY_CLUSTER);
    }
    VdsValidator validator = new VdsValidator(getVds());
    return validate(validator.isUp());
}
#end_block

#method_before
@Test
public void canDoActionFailsForNoStorageDevice() {
    cmd = spy(new CreateBrickCommand(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.Raid0, null, null, Collections.EMPTY_LIST)));
    prepareMocks(cmd, VDSStatus.Up);
    assertFalse(cmd.canDoAction());
}
#method_after
@Test
public void canDoActionFailsForNoStorageDevice() {
    cmd = spy(new CreateBrickCommand(new CreateBrickParameters(HOST_ID, "brick1", "/gluster-bricks/brick1", RaidType.Raid0, null, null, Collections.<StorageDevice>emptyList())));
    prepareMocks(cmd, VDSStatus.Up);
    assertFalse(cmd.canDoAction());
}
#end_block

#method_before
protected <T extends CreateBrickCommand> void prepareMocks(T command, VDSStatus status) {
    when(command.getVdsGroup()).thenReturn(vdsGroup);
    doReturn(vds).when(command).getVds();
    doReturn(status).when(vds).getStatus();
    mockIsGlusterEnabled(true);
    doReturn(clusterUtils).when(command).getClusterUtils();
    when(clusterUtils.isFeatureSupportedAsAdditionalFeature(any(Guid.class), anyString())).thenReturn(false);
    mockCompatibilityVersion(Version.v3_6);
}
#method_after
protected <T extends CreateBrickCommand> void prepareMocks(T command, VDSStatus status) {
    when(command.getVdsGroup()).thenReturn(vdsGroup);
    doReturn(vds).when(command).getVds();
    doReturn(status).when(vds).getStatus();
    mockIsGlusterEnabled(true);
    doReturn(glusterUtil).when(command).getGlusterUtil();
    when(glusterUtil.isGlusterBrickProvisioningSupported(eq(Version.v3_6), any(Guid.class))).thenReturn(true);
    when(glusterUtil.isGlusterBrickProvisioningSupported(eq(Version.v3_5), any(Guid.class))).thenReturn(false);
    mockCompatibilityVersion(Version.v3_6);
}
#end_block

#method_before
private Long parseSafeLong(Map<String, Object> innerMap, String key) {
    return innerMap.containsKey(key) && StringUtils.isNumeric(key) ? Long.parseLong(innerMap.get(key).toString()) : null;
}
#method_after
private Long parseSafeLong(Map<String, Object> innerMap, String key) {
    return innerMap.containsKey(key) && StringUtils.isNumeric(innerMap.get(key).toString()) ? Long.parseLong(innerMap.get(key).toString()) : null;
}
#end_block

#method_before
@Override
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap) {
    GlusterGeoRepSessionDetails details = super.getSessionDetails(innerMap);
    if (details != null) {
        Long dataOpsPending = parseSafeLong(innerMap, DATA);
        Long metaOpsPending = parseSafeLong(innerMap, META);
        Long entryOpsPending = parseSafeLong(innerMap, ENTRY);
        Long failures = parseSafeLong(innerMap, FAILURES);
        details.setDataOpsPending(dataOpsPending);
        details.setMetaOpsPending(metaOpsPending);
        details.setEntryOpsPending(entryOpsPending);
        details.setFailures(failures);
        if (innerMap.containsKey(CHECK_POINT_COMPLETED)) {
            details.setCheckpointCompleted(Boolean.valueOf(innerMap.get(CHECK_POINT_COMPLETED).toString()));
        }
        String timezone = (innerMap.containsKey(TIMEZONE)) ? innerMap.get(TIMEZONE).toString() : null;
        if (timezone != null) {
            String lastSynced = (innerMap.containsKey(LAST_SYNCED)) ? innerMap.get(LAST_SYNCED).toString() : null;
            String checkPointTime = (innerMap.containsKey(CHECK_POINT_TIME)) ? innerMap.get(CHECK_POINT_TIME).toString() : null;
            String checkPointCompletionTime = (innerMap.containsKey(CHECK_POINT_COMPLETION_TIME)) ? innerMap.get(CHECK_POINT_COMPLETION_TIME).toString() : null;
            DateFormat format = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
            format.setTimeZone(TimeZone.getTimeZone(timezone));
            try {
                details.setLastSyncedAt(format.parse(lastSynced));
                details.setCheckPointCompletedAt(format.parse(checkPointCompletionTime));
                details.setCheckPointTime(format.parse(checkPointTime));
            } catch (ParseException e) {
                log.info("Error populating date fields for georep details for session '{}' of brick '{}' : {}", details.getSlaveHostName(), details.getMasterBrickId(), e.getMessage());
                log.debug("Exception", e);
            }
        }
    }
    geoRepDetails.add(details);
    return details;
}
#method_after
@Override
protected GlusterGeoRepSessionDetails getSessionDetails(Map<String, Object> innerMap) {
    GlusterGeoRepSessionDetails details = super.getSessionDetails(innerMap);
    if (details != null) {
        Long dataOpsPending = parseSafeLong(innerMap, DATA);
        Long metaOpsPending = parseSafeLong(innerMap, META);
        Long entryOpsPending = parseSafeLong(innerMap, ENTRY);
        Long failures = parseSafeLong(innerMap, FAILURES);
        details.setDataOpsPending(dataOpsPending);
        details.setMetaOpsPending(metaOpsPending);
        details.setEntryOpsPending(entryOpsPending);
        details.setFailures(failures);
        if (innerMap.containsKey(CHECK_POINT_COMPLETED)) {
            details.setCheckpointCompleted(Boolean.valueOf(innerMap.get(CHECK_POINT_COMPLETED).toString()));
        }
        String timezone = (innerMap.containsKey(TIMEZONE)) ? innerMap.get(TIMEZONE).toString() : null;
        Long lastSynced = parseSafeLong(innerMap, LAST_SYNCED);
        Long checkPointTime = parseSafeLong(innerMap, CHECK_POINT_TIME);
        Long checkPointCompletionTime = parseSafeLong(innerMap, CHECK_POINT_COMPLETION_TIME);
        details.setLastSyncedAt(lastSynced != null ? new Date(lastSynced * 1000L) : null);
        details.setCheckPointCompletedAt(checkPointCompletionTime != null ? new Date(checkPointCompletionTime * 1000L) : null);
        details.setCheckPointTime(checkPointTime != null ? new Date(checkPointTime * 1000L) : null);
    }
    geoRepDetails.add(details);
    return details;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    return (obj != null) && (obj instanceof GlusterGeoRepSessionDetails) && Objects.equals(getSessionId(), ((GlusterGeoRepSessionDetails) obj).getSessionId()) && Objects.equals(getMasterBrickId(), ((GlusterGeoRepSessionDetails) obj).getMasterBrickId()) && Objects.equals(getSlaveNodeUuid(), ((GlusterGeoRepSessionDetails) obj).getSlaveNodeUuid()) && Objects.equals(getSlaveHostName(), ((GlusterGeoRepSessionDetails) obj).getSlaveHostName()) && Objects.equals(getStatus(), ((GlusterGeoRepSessionDetails) obj).getStatus()) && Objects.equals(getCheckPointStatus(), ((GlusterGeoRepSessionDetails) obj).getCheckPointStatus()) && Objects.equals(getCrawlStatus(), ((GlusterGeoRepSessionDetails) obj).getCrawlStatus()) && Objects.equals(getDataOpsPending(), ((GlusterGeoRepSessionDetails) obj).getDataOpsPending()) && Objects.equals(getMetaOpsPending(), ((GlusterGeoRepSessionDetails) obj).getMetaOpsPending()) && Objects.equals(getEntryOpsPending(), ((GlusterGeoRepSessionDetails) obj).getEntryOpsPending()) && Objects.equals(getCheckPointCompletedAt(), ((GlusterGeoRepSessionDetails) obj).getCheckPointCompletedAt()) && Objects.equals(getCheckPointTime(), ((GlusterGeoRepSessionDetails) obj).getCheckPointTime()) && Objects.equals(getLastSyncedAt(), ((GlusterGeoRepSessionDetails) obj).getLastSyncedAt()) && Objects.equals(getUpdatedAt(), ((GlusterGeoRepSessionDetails) obj).getUpdatedAt()) && Objects.equals(getFailures(), ((GlusterGeoRepSessionDetails) obj).getFailures()) && isCheckpointCompleted() == ((GlusterGeoRepSessionDetails) obj).isCheckpointCompleted();
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj == null || !(obj instanceof GlusterGeoRepSessionDetails)) {
        return false;
    }
    GlusterGeoRepSessionDetails geoRep = (GlusterGeoRepSessionDetails) obj;
    return Objects.equals(getSessionId(), geoRep.getSessionId()) && Objects.equals(getMasterBrickId(), geoRep.getMasterBrickId()) && Objects.equals(getSlaveNodeUuid(), geoRep.getSlaveNodeUuid()) && Objects.equals(getSlaveHostName(), geoRep.getSlaveHostName()) && Objects.equals(getStatus(), geoRep.getStatus()) && Objects.equals(getCheckPointStatus(), geoRep.getCheckPointStatus()) && Objects.equals(getCrawlStatus(), geoRep.getCrawlStatus()) && Objects.equals(getDataOpsPending(), geoRep.getDataOpsPending()) && Objects.equals(getMetaOpsPending(), geoRep.getMetaOpsPending()) && Objects.equals(getEntryOpsPending(), geoRep.getEntryOpsPending()) && Objects.equals(getCheckPointCompletedAt(), geoRep.getCheckPointCompletedAt()) && Objects.equals(getCheckPointTime(), geoRep.getCheckPointTime()) && Objects.equals(getLastSyncedAt(), geoRep.getLastSyncedAt()) && Objects.equals(getUpdatedAt(), geoRep.getUpdatedAt()) && Objects.equals(getFailures(), geoRep.getFailures()) && isCheckpointCompleted() == geoRep.isCheckpointCompleted();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM vm = vmDao.get(getParameters().getId());
    if (vm == null || vm.getVmFQDN() == null) {
        getQueryReturnValue().setReturnValue(Collections.<Erratum>emptyList());
        return;
    }
    Provider<?> provider = providerDao.get(vm.getProviderId());
    if (provider != null) {
        HostProviderProxy proxy = (HostProviderProxy) ProviderProxyFactory.getInstance().create(provider);
        getQueryReturnValue().setReturnValue(proxy.getErrataForHost(vm.getVmFQDN()));
    } else {
        getQueryReturnValue().setReturnValue(Collections.<Erratum>emptyList());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    VM vm = vmDao.get(getParameters().getId());
    if (vm == null || vm.getVmHost() == null) {
        getQueryReturnValue().setReturnValue(Collections.<Erratum>emptyList());
        return;
    }
    Provider<?> provider = providerDao.get(vm.getProviderId());
    if (provider != null) {
        HostProviderProxy proxy = (HostProviderProxy) ProviderProxyFactory.getInstance().create(provider);
        getQueryReturnValue().setReturnValue(proxy.getErrataForHost(vm.getVmHost()));
    } else {
        getQueryReturnValue().setReturnValue(Collections.<Erratum>emptyList());
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VM vm = vmDao.get(getParameters().getId());
    if (vm == null || vm.getProviderId() == null) {
        return;
    }
    Provider<?> provider = providerDao.get(vm.getProviderId());
    if (provider != null) {
        HostProviderProxy proxy = (HostProviderProxy) ProviderProxyFactory.getInstance().create(provider);
        getQueryReturnValue().setReturnValue(proxy.getErratumForHost(vm.getVmFQDN(), getParameters().getErratumId()));
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    VM vm = vmDao.get(getParameters().getId());
    if (vm == null || vm.getVmHost() == null || vm.getProviderId() == null) {
        return;
    }
    Provider<?> provider = providerDao.get(vm.getProviderId());
    if (provider != null) {
        HostProviderProxy proxy = (HostProviderProxy) ProviderProxyFactory.getInstance().create(provider);
        getQueryReturnValue().setReturnValue(proxy.getErratumForHost(vm.getVmHost(), getParameters().getErratumId()));
    }
}
#end_block

#method_before
@Override
public Response add(OpenStackVolumeProvider provider) {
    validateParameters(provider, "name");
    StoragePool storagePool = provider.isSetDataCenter() ? getStoragePool(provider.getDataCenter()) : new StoragePool();
    provider.setDataCenter(DataCenterMapper.map(storagePool, null));
    return performCreate(VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(OpenStackVolumeProvider provider) {
    validateParameters(provider, "name");
    if (provider.isSetDataCenter()) {
        StoragePool storagePool = getStoragePool(provider.getDataCenter());
        provider.setDataCenter(DataCenterMapper.map(storagePool, null));
    }
    return performCreate(VdcActionType.AddProvider, new ProviderParameters(map(provider)), new QueryIdResolver<Guid>(VdcQueryType.GetProviderById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume != null && volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    // Validate the scheduling dates (start and end by dates)
    Date currentDate = new Date();
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    if (schedule.getRecurrence() != null && schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN) {
        if (convertedStartDate != null && convertedStartDate.compareTo(currentDate) < 0) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_START_DATE_BEFORE_CURRENT_DATE);
        }
        if (schedule.getEndByDate() != null) {
            if (convertedEndByDate.compareTo(currentDate) < 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_END_BY_DATE_BEFORE_CURRENT_DATE);
            }
            if (convertedStartDate != null && convertedEndByDate.compareTo(convertedStartDate) <= 0) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_END_BY_DATE_BEFORE_START_DATE);
            }
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume != null && volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    // Validate the scheduling dates (start and end by dates)
    Date convertedStartDate = getGlusterUtil().convertDate(schedule.getStartDate(), schedule.getTimeZone());
    Date convertedEndByDate = getGlusterUtil().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    if (schedule.getRecurrence() != null && schedule.getRecurrence() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN && schedule.getEndByDate() != null && convertedStartDate != null && convertedEndByDate.compareTo(convertedStartDate) <= 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_END_BY_DATE_BEFORE_START_DATE);
    }
    return true;
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) {
    final GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId));
    if (volume == null) {
        log.error("Error while creating volume snapshot. Volume is null.");
        return;
    }
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volume.getClusterId());
    snapshot.setVolumeId(volume.getId());
    snapshot.setSnapshotName(snapshotNamePrefix);
    snapshot.setDescription(description);
    VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotParameters(snapshot, force));
    if (!returnValue.getSucceeded()) {
        log.error("Error while creating snapshot for volume '{}': {}", volume.getName(), returnValue.getExecuteFailedMessages().toString());
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, new HashMap<String, String>() {

            {
                put(GlusterConstants.VOLUME_SNAPSHOT_NAME, snapshot.getSnapshotName());
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    }
    // Check if next schedule available, and if not delete the scheduling details from DB
    GlusterVolumeSnapshotSchedule schedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(volume.getId());
    Date endDate = GlusterUtil.getInstance().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    if (endDate.compareTo(new Date()) < 0) {
        getGlusterVolumeSnapshotScheduleDao().removeByVolumeId(volume.getId());
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_DELETED, new HashMap<String, String>() {

            {
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer(String serverId, String volumeId, String snapshotNamePrefix, String description, boolean force) {
    final GlusterVolumeEntity volume = getGlusterVolumeDao().getById(new Guid(volumeId));
    if (volume == null) {
        log.error("Error while creating volume snapshot. Volume is null.");
        return;
    }
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volume.getClusterId());
    snapshot.setVolumeId(volume.getId());
    snapshot.setSnapshotName(snapshotNamePrefix);
    snapshot.setDescription(description);
    VdcReturnValueBase returnValue = getBackend().runInternalAction(VdcActionType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotParameters(snapshot, force));
    if (!returnValue.getSucceeded()) {
        log.error("Error while creating snapshot for volume '{}': {}", volume.getName(), returnValue.getExecuteFailedMessages().toString());
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, new HashMap<String, String>() {

            {
                put(GlusterConstants.VOLUME_SNAPSHOT_NAME, snapshot.getSnapshotName());
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    }
    // Check if next schedule available, and if not delete the scheduling details from DB
    GlusterVolumeSnapshotSchedule schedule = getGlusterVolumeSnapshotScheduleDao().getByVolumeId(volume.getId());
    Date endDate = GlusterUtil.getInstance().convertDate(schedule.getEndByDate(), schedule.getTimeZone());
    if (endDate.before(new Date())) {
        getGlusterVolumeSnapshotScheduleDao().removeByVolumeId(volume.getId());
        logUtil.logAuditMessage(volume.getClusterId(), volume, null, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SCHEDULE_DELETED, new HashMap<String, String>() {

            {
                put(GlusterConstants.VOLUME_NAME, volume.getName());
            }
        });
    }
}
#end_block

#method_before
void addDiskList(DisksAllocationModel model) {
    diskListPanel.clear();
    int diskIndex = 0;
    for (final DiskModel diskModel : model.getDisks()) {
        DisksAllocationItemView disksAllocationItemView = new DisksAllocationItemView(constants);
        disksAllocationItemView.edit(diskModel);
        disksAllocationItemView.updateStyles(showQuota);
        disksAllocationItemView.setIsAliasChangeable(model.getIsAliasChangable());
        disksAllocationItemView.setElementId(// $NON-NLS-1$
        ElementIdUtils.createElementId(elementId, "disk" + (diskIndex++)));
        diskListPanel.add(disksAllocationItemView);
    }
}
#method_after
void addDiskList(DisksAllocationModel model) {
    diskListPanel.clear();
    int diskIndex = 0;
    for (final DiskModel diskModel : model.getDisks()) {
        DisksAllocationItemView disksAllocationItemView = new DisksAllocationItemView();
        disksAllocationItemView.edit(diskModel);
        disksAllocationItemView.updateStyles(showQuota);
        disksAllocationItemView.setIsAliasChangeable(model.getIsAliasChangable());
        disksAllocationItemView.setElementId(// $NON-NLS-1$
        ElementIdUtils.createElementId(elementId, "disk" + (diskIndex++)));
        diskListPanel.add(disksAllocationItemView);
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getVmId().setIsAvailable(true);
    loadDataCenters();
    initPriority(0);
    getModel().getVmInitModel().init(null);
    instanceTypeManager = new NewVmInstanceTypeManager(getModel());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getVmType().setIsChangeable(true);
    getModel().getVmId().setIsAvailable(true);
    loadDataCenters();
    initPriority(0);
    getModel().getVmInitModel().init(null);
    instanceTypeManager = new NewVmInstanceTypeManager(getModel());
}
#end_block

#method_before
private void selectedTemplateChanged(final VmTemplate template) {
    // Copy VM parameters from template.
    buildModel(template, new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
            doChangeDefautlHost(template.getDedicatedVmForVds());
            getModel().getIsStateless().setEntity(template.isStateless());
            boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
            getModel().getCdImage().setIsChangable(hasCd);
            getModel().getCdAttached().setEntity(hasCd);
            if (hasCd) {
                getModel().getCdImage().setSelectedItem(template.getIsoPath());
            }
            updateTimeZone(template.getTimeZone());
            if (!template.getId().equals(Guid.Empty)) {
                getModel().getStorageDomain().setIsChangable(true);
                getModel().getProvisioning().setIsChangable(true);
                getModel().getVmType().setSelectedItem(template.getVmType());
                getModel().getCopyPermissions().setIsAvailable(true);
                getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
                initDisks();
                updateRngDevice(template.getId());
            } else {
                getModel().getStorageDomain().setIsChangable(false);
                getModel().getProvisioning().setIsChangable(false);
                getModel().setIsDisksAvailable(false);
                getModel().getCopyPermissions().setIsAvailable(false);
                getModel().setDisks(null);
            }
            initStorageDomains();
            InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
            int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
            // do not update if specified on template or instance type
            if (template.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
                updateMinAllocatedMemory();
            }
            updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
            getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
            getModel().getVmInitModel().init(template);
            getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
            if (getModel().getSelectedCluster() != null) {
                updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
            }
        }
    });
}
#method_after
private void selectedTemplateChanged(final VmTemplate template) {
    // Copy VM parameters from template.
    buildModel(template, new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

        @Override
        public void finished(VmBase source, UnitVmModel destination) {
            setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
            doChangeDefautlHost(template.getDedicatedVmForVds());
            getModel().getIsStateless().setEntity(template.isStateless());
            getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
            boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
            getModel().getCdImage().setIsChangeable(hasCd);
            getModel().getCdAttached().setEntity(hasCd);
            if (hasCd) {
                getModel().getCdImage().setSelectedItem(template.getIsoPath());
            }
            updateTimeZone(template.getTimeZone());
            if (!template.getId().equals(Guid.Empty)) {
                getModel().getStorageDomain().setIsChangeable(true);
                getModel().getProvisioning().setIsChangeable(true);
                getModel().getCopyPermissions().setIsAvailable(true);
                initDisks();
            } else {
                getModel().getStorageDomain().setIsChangeable(false);
                getModel().getProvisioning().setIsChangeable(false);
                getModel().setIsDisksAvailable(false);
                getModel().getCopyPermissions().setIsAvailable(false);
                getModel().setDisks(null);
            }
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            getModel().getVmType().setSelectedItem(template.getVmType());
            updateRngDevice(template.getId());
            initStorageDomains();
            InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
            int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
            // do not update if specified on template or instance type
            if (template.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
                updateMinAllocatedMemory();
            }
            updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
            getModel().getCustomPropertySheet().deserialize(template.getCustomProperties());
            getModel().getVmInitModel().init(template);
            getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
            if (getModel().getSelectedCluster() != null) {
                updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), template.getCpuProfileId());
            }
        }
    });
}
#end_block

#method_before
@Override
public void provisioning_SelectedItemChanged() {
    boolean provisioning = getModel().getProvisioning().getEntity();
    getModel().getProvisioningThin_IsSelected().setEntity(!provisioning);
    getModel().getProvisioningClone_IsSelected().setEntity(provisioning);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatChangable(provisioning);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    initStorageDomains();
}
#method_after
@Override
public void provisioning_SelectedItemChanged() {
    boolean provisioning = getModel().getProvisioning().getEntity();
    getModel().getProvisioningThin_IsSelected().setEntity(!provisioning);
    getModel().getProvisioningClone_IsSelected().setEntity(provisioning);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeTypeChangable(provisioning);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    initStorageDomains();
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem() == null ? null : getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    Integer osType = getModel().getOSType().getSelectedItem();
    if ((template != null || !basedOnCustomInstanceType()) && osType != null) {
        Guid id = basedOnCustomInstanceType() ? template.getId() : getModel().getInstanceTypes().getSelectedItem().getId();
        updateVirtioScsiEnabledWithoutDetach(id, osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    super.oSType_SelectedItemChanged();
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem() == null ? null : getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    Integer osType = getModel().getOSType().getSelectedItem();
    if ((template != null || !basedOnCustomInstanceType()) && osType != null) {
        Guid id = basedOnCustomInstanceType() ? template.getId() : getModel().getInstanceTypes().getSelectedItem().getId();
        updateVirtioScsiEnabledWithoutDetach(id, osType);
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                postDataCentersLoaded(dataCenters);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }), true, false);
    getModel().getSpiceProxyEnabled().setEntity(false);
    getModel().getSpiceProxy().setIsChangable(false);
    getModel().getSpiceProxyEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getModel().getSpiceProxy().setIsChangable(getModel().getSpiceProxyEnabled().getEntity());
        }
    });
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getIsSoundcardEnabled().setIsChangeable(true);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(false);
    getModel().getDisksAllocationModel().setIsAliasChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(false);
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            final List<StoragePool> dataCenters = new ArrayList<StoragePool>();
            for (StoragePool a : (ArrayList<StoragePool>) returnValue) {
                if (a.getStatus() == StoragePoolStatus.Up) {
                    dataCenters.add(a);
                }
            }
            if (!dataCenters.isEmpty()) {
                postDataCentersLoaded(dataCenters);
            } else {
                getModel().disableEditing(ConstantsManager.getInstance().getConstants().notAvailableWithNoUpDC());
            }
        }
    }), true, false);
    getModel().getSpiceProxyEnabled().setEntity(false);
    getModel().getSpiceProxy().setIsChangeable(false);
    getModel().getSpiceProxyEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getModel().getSpiceProxy().setIsChangeable(getModel().getSpiceProxyEnabled().getEntity());
        }
    });
}
#end_block

#method_before
protected void setupWindowModelFrom(final VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        buildModel(vmBase, new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

            @Override
            public void finished(VmBase source, UnitVmModel destination) {
                setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
                getModel().getVmType().setSelectedItem(vmBase.getVmType());
                getModel().getIsRunAndPause().setEntity(false);
                boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
                getModel().getCdImage().setIsChangable(hasCd);
                getModel().getCdAttached().setEntity(hasCd);
                if (hasCd) {
                    getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
                }
                updateTimeZone(vmBase.getTimeZone());
                if (!vmBase.getId().equals(Guid.Empty)) {
                    getModel().getStorageDomain().setIsChangable(true);
                    initDisks();
                } else {
                    getModel().getStorageDomain().setIsChangable(false);
                    getModel().setIsDisksAvailable(false);
                    getModel().setDisks(null);
                }
                getModel().getProvisioning().setEntity(false);
                initStorageDomains();
                InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
                int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
                // do not update if specified on template or instance type
                if (vmBase.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
                    updateMinAllocatedMemory();
                }
                getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
                getModel().getVmInitModel().init(vmBase);
                getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
                if (getModel().getSelectedCluster() != null) {
                    updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), vmBase.getCpuProfileId());
                }
            }
        });
    }
}
#method_after
protected void setupWindowModelFrom(final VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        buildModel(vmBase, new BuilderExecutor.BuilderExecutionFinished<VmBase, UnitVmModel>() {

            @Override
            public void finished(VmBase source, UnitVmModel destination) {
                setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
                getModel().getVmType().setSelectedItem(vmBase.getVmType());
                getModel().getIsRunAndPause().setEntity(false);
                boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
                getModel().getCdImage().setIsChangeable(hasCd);
                getModel().getCdAttached().setEntity(hasCd);
                if (hasCd) {
                    getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
                }
                updateTimeZone(vmBase.getTimeZone());
                if (!vmBase.getId().equals(Guid.Empty)) {
                    getModel().getStorageDomain().setIsChangeable(true);
                    initDisks();
                } else {
                    getModel().getStorageDomain().setIsChangeable(false);
                    getModel().setIsDisksAvailable(false);
                    getModel().setDisks(null);
                }
                getModel().getProvisioning().setEntity(false);
                initStorageDomains();
                InstanceType selectedInstanceType = getModel().getInstanceTypes().getSelectedItem();
                int instanceTypeMinAllocatedMemory = selectedInstanceType != null ? selectedInstanceType.getMinAllocatedMem() : 0;
                // do not update if specified on template or instance type
                if (vmBase.getMinAllocatedMem() == 0 && instanceTypeMinAllocatedMemory == 0) {
                    updateMinAllocatedMemory();
                }
                getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
                getModel().getVmInitModel().init(vmBase);
                getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
                if (getModel().getSelectedCluster() != null) {
                    updateCpuProfile(getModel().getSelectedCluster().getId(), getClusterCompatibilityVersion(), vmBase.getCpuProfileId());
                }
            }
        });
    }
}
#end_block

#method_before
@Override
public void oSType_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem() == null ? null : getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    Integer osType = getModel().getOSType().getSelectedItem();
    if ((template != null || !basedOnCustomInstanceType()) && osType != null) {
        Guid id = basedOnCustomInstanceType() ? template.getId() : getModel().getInstanceTypes().getSelectedItem().getId();
        updateVirtioScsiEnabledWithoutDetach(id, osType);
    }
}
#method_after
@Override
public void oSType_SelectedItemChanged() {
    super.oSType_SelectedItemChanged();
    VmTemplate template = getModel().getTemplateWithVersion().getSelectedItem() == null ? null : getModel().getTemplateWithVersion().getSelectedItem().getTemplateVersion();
    Integer osType = getModel().getOSType().getSelectedItem();
    if ((template != null || !basedOnCustomInstanceType()) && osType != null) {
        Guid id = basedOnCustomInstanceType() ? template.getId() : getModel().getInstanceTypes().getSelectedItem().getId();
        updateVirtioScsiEnabledWithoutDetach(id, osType);
    }
}
#end_block

#method_before
@Override
public void templateWithVersion_SelectedItemChanged() {
    super.templateWithVersion_SelectedItemChanged();
    // $NON-NLS-1$
    getModel().getName().setEntity("");
    // $NON-NLS-1$
    getModel().getDescription().setEntity("");
    // $NON-NLS-1$
    getModel().getComment().setEntity("");
    getModel().getProvisioning().setEntity(true);
    getModel().getProvisioning().setIsAvailable(true);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangable(true);
    getModel().getVmId().setEntity("");
    initDisks();
    initStorageDomains();
}
#method_after
@Override
public void templateWithVersion_SelectedItemChanged() {
    super.templateWithVersion_SelectedItemChanged();
    // $NON-NLS-1$
    getModel().getName().setEntity("");
    // $NON-NLS-1$
    getModel().getDescription().setEntity("");
    // $NON-NLS-1$
    getModel().getComment().setEntity("");
    getModel().getProvisioning().setEntity(true);
    getModel().getProvisioning().setIsAvailable(true);
    getModel().getProvisioning().setIsChangeable(false);
    getModel().getVmId().setIsAvailable(true);
    getModel().getVmId().setIsChangeable(true);
    getModel().getVmId().setEntity("");
    initDisks();
    initStorageDomains();
}
#end_block

#method_before
@Override
public void initDisks() {
    ArrayList<DiskModel> disks = new ArrayList<DiskModel>();
    for (DiskImage diskImage : vm.getDiskList()) {
        disks.add(Linq.diskToModel(diskImage));
    }
    getModel().setDisks(disks);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeFormatChangable(true);
    updateIsDisksAvailable();
}
#method_after
@Override
public void initDisks() {
    ArrayList<DiskModel> disks = new ArrayList<DiskModel>();
    for (DiskImage diskImage : vm.getDiskList()) {
        disks.add(Linq.diskToModel(diskImage));
    }
    getModel().setDisks(disks);
    getModel().getDisksAllocationModel().setIsVolumeTypeAvailable(true);
    getModel().getDisksAllocationModel().setIsVolumeTypeChangable(true);
    updateIsDisksAvailable();
}
#end_block

#method_before
@Override
protected void onPropertyChanged(PropertyChangedEventArgs e) {
    super.onPropertyChanged(e);
    if (// $NON-NLS-1$ //$NON-NLS-2$
    e.propertyName.equals("Disks") || e.propertyName.equals("VolumeFormat")) {
        updateStorageDomainsAvailability();
        updateQuotaAvailability();
    }
}
#method_after
@Override
protected void onPropertyChanged(PropertyChangedEventArgs e) {
    super.onPropertyChanged(e);
    if (// $NON-NLS-1$
    e.propertyName.equals("Disks") || e.propertyName.equals(VOLUME_TYPE)) {
        updateStorageDomainsAvailability();
        updateQuotaAvailability();
    }
}
#end_block

#method_before
private void updateStorageDomainsAvailability() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        diskModel.getSourceStorageDomain().setIsAvailable(isSourceStorageDomainAvailable);
        diskModel.getSourceStorageDomainName().setIsAvailable(isSourceStorageDomainNameAvailable);
        diskModel.getVolumeType().setIsAvailable(isVolumeTypeAvailable);
        diskModel.getVolumeType().setIsChangable(isVolumeFormatChangable);
        diskModel.getAlias().setIsChangable(isAliasChangable);
    }
}
#method_after
private void updateStorageDomainsAvailability() {
    if (disks == null) {
        return;
    }
    for (DiskModel diskModel : disks) {
        diskModel.getSourceStorageDomain().setIsAvailable(isSourceStorageDomainAvailable);
        diskModel.getSourceStorageDomainName().setIsAvailable(isSourceStorageDomainNameAvailable);
        diskModel.getVolumeType().setIsAvailable(isVolumeTypeAvailable);
        diskModel.getVolumeType().setIsChangeable(isVolumeTypeChangable);
        diskModel.getAlias().setIsChangeable(isAliasChangable);
    }
}
#end_block

#method_before
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof VmManagementParametersBase.Optional) {
                VmManagementParametersBase.Optional<?> optional = (VmManagementParametersBase.Optional<?>) value;
                if (optional.isUpdate()) {
                    addDeviceUpdateOnNextRun(vmId, annotation, null, optional.getValue(), fieldList);
                }
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#method_after
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value == null) {
            // preserve current configuration
            } else if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof VmManagementParametersBase.Optional) {
                VmManagementParametersBase.Optional<?> optional = (VmManagementParametersBase.Optional<?>) value;
                if (optional.isUpdate()) {
                    addDeviceUpdateOnNextRun(vmId, annotation, null, optional.getValue(), fieldList);
                }
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#end_block

#method_before
private void postDoUpdateManagedFieldsFrom(VmBase vmBase) {
    if (isNextRunConfigurationExists()) {
        deactivate();
        getModel().getIsSoundcardEnabled().setEntity(isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.SOUND.getName()));
        getModel().getIsConsoleDeviceEnabled().setEntity(isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.CONSOLE.getName()));
        Set<GraphicsType> graphicsTypeSet = new HashSet<>();
        for (GraphicsType graphicsType : GraphicsType.values()) {
            if (isVmDeviceExists(vmBase.getManagedDeviceMap(), graphicsType.getCorrespondingDeviceType().getName())) {
                graphicsTypeSet.add(graphicsType);
            }
        }
        getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypeSet));
        activate();
    }
    updateWatchdog(vmBase, true);
}
#method_after
private void postDoUpdateManagedFieldsFrom(VmBase vmBase) {
    if (isNextRunConfigurationExists()) {
        deactivate();
        getModel().getIsSoundcardEnabled().setEntity(VmDeviceCommonUtils.isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.SOUND.getName()));
        getModel().getIsConsoleDeviceEnabled().setEntity(VmDeviceCommonUtils.isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.CONSOLE.getName()));
        Set<GraphicsType> graphicsTypeSet = new HashSet<>();
        for (GraphicsType graphicsType : GraphicsType.values()) {
            if (VmDeviceCommonUtils.isVmDeviceExists(vmBase.getManagedDeviceMap(), graphicsType.getCorrespondingDeviceType().getName())) {
                graphicsTypeSet.add(graphicsType);
            }
        }
        getModel().getGraphicsType().setSelectedItem(UnitVmModel.GraphicsTypes.fromGraphicsTypes(graphicsTypeSet));
        activate();
    }
    updateWatchdog(vmBase, true);
}
#end_block

#method_before
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#method_after
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#end_block

#method_before
private void updateVirtioScsi(VmBase vmBase) {
    if (isNextRunConfigurationExists()) {
        getModel().getIsVirtioScsiEnabled().setEntity(isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.VIRTIOSCSI.getName()));
        model.stopProgress();
        return;
    }
    virtioScsiUtil.updateVirtioScsiEnabled(vmBase.getId(), getModel().getOSType().getSelectedItem(), new VirtioScsiUtil.VirtioScasiEnablingFinished() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
            model.stopProgress();
            instanceTypeAttachDetachManager.manageInstanceType(model.getInstanceTypes().getSelectedItem());
        }
    });
}
#method_after
private void updateVirtioScsi(VmBase vmBase) {
    if (isNextRunConfigurationExists()) {
        getModel().getIsVirtioScsiEnabled().setEntity(VmDeviceCommonUtils.isVmDeviceExists(vmBase.getManagedDeviceMap(), VmDeviceType.VIRTIOSCSI.getName()));
        model.stopProgress();
        return;
    }
    virtioScsiUtil.updateVirtioScsiEnabled(vmBase.getId(), getModel().getOSType().getSelectedItem(), new VirtioScsiUtil.VirtioScasiEnablingFinished() {

        @Override
        public void beforeUpdates() {
            deactivate();
        }

        @Override
        public void afterUpdates() {
            activate();
            model.stopProgress();
            instanceTypeAttachDetachManager.manageInstanceType(model.getInstanceTypes().getSelectedItem());
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Currently this only supports importing images and does not work with luns.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE && getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.CINDER) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("storageType", getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExist())) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("domainId", getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain() && !(getStorageDomain().getStorageDomainType() == StorageDomainType.Volume)) {
        addCanDoActionMessageVariable("domainId", getParameters().getStorageDomainId());
        addCanDoActionMessageVariable("domainType", getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (getParameters().getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && !setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Currently this only supports importing DiskImages or CinderDisks and does not work with LunDisks.
    if (getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.IMAGE && getParameters().getDiskImage().getDiskStorageType() != DiskStorageType.CINDER) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("storageType", getParameters().getDiskImage().getDiskStorageType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_DISK_STORAGE_TYPE);
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExist())) {
        addCanDoActionMessageVariable("diskId", getParameters().getDiskImage().getId());
        addCanDoActionMessageVariable("domainId", getStorageDomainId());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_UNAVAILABLE);
        return false;
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain() && !(getStorageDomain().getStorageDomainType() == StorageDomainType.Volume)) {
        addCanDoActionMessageVariable("domainId", getParameters().getStorageDomainId());
        addCanDoActionMessageVariable("domainType", getStorageDomain().getStorageDomainType());
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED);
        return false;
    }
    if (getParameters().getDiskImage().getDiskStorageType() == DiskStorageType.IMAGE && !setAndValidateDiskProfiles()) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (groupHostsAndVms == null ? 0 : groupHostsAndVms.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    result = prime * result + (gluster37Support == null ? 0 : gluster37Support.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (compatVersion == null ? 0 : compatVersion.hashCode());
    result = prime * result + (compatibilityVersion == null ? 0 : compatibilityVersion.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (description == null ? 0 : description.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (countThreadsAsCores ? 1231 : 1237);
    result = prime * result + (migrateOnError == null ? 0 : migrateOnError.hashCode());
    result = prime * result + (name == null ? 0 : name.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugepages ? 1231 : 1237);
    result = prime * result + (virtService ? 1231 : 1237);
    result = prime * result + (glusterService ? 1231 : 1237);
    result = prime * result + (tunnelMigration ? 1231 : 1237);
    result = prime * result + (emulatedMachine == null ? 0 : emulatedMachine.hashCode());
    result = prime * result + (trustedService ? 1231 : 1237);
    result = prime * result + (haReservation ? 1231 : 1237);
    result = prime * result + (clusterPolicyName == null ? 0 : clusterPolicyName.hashCode());
    result = prime * result + (clusterPolicyProperties == null ? 0 : clusterPolicyProperties.hashCode());
    result = prime * result + (requiredRngSources == null ? 0 : requiredRngSources.hashCode());
    result = prime * result + (enableKsm ? 1231 : 1237);
    result = prime * result + (enableBallooning ? 1231 : 1237);
    result = prime * result + (optimizationType == null ? 0 : optimizationType.hashCode());
    result = prime * result + (serialNumberPolicy == null ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + (customSerialNumber == null ? 0 : customSerialNumber.hashCode());
    result = prime * result + (fencingPolicy == null ? 0 : fencingPolicy.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + (glusterTunedProfile == null ? 0 : glusterTunedProfile.hashCode());
    result = prime * result + (addtionalFeaturesSupported == null ? 0 : addtionalFeaturesSupported.hashCode());
    result = prime * result + (maintenanceReasonRequired ? 1231 : 1237);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(groupHostsAndVms, other.groupHostsAndVms) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired) && ObjectUtils.objectsEqual(gluster37Support, other.gluster37Support);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDSGroup)) {
        return false;
    }
    VDSGroup other = (VDSGroup) obj;
    // cause all kinds of havoc in the UI when clusters are refreshed.
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(compatVersion, other.compatVersion) && ObjectUtils.objectsEqual(compatibilityVersion, other.compatibilityVersion) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(description, other.description) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && countThreadsAsCores == other.countThreadsAsCores && migrateOnError == other.migrateOnError && ObjectUtils.objectsEqual(name, other.name) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && transparentHugepages == other.transparentHugepages && virtService == other.virtService && glusterService == other.glusterService && tunnelMigration == other.tunnelMigration && ObjectUtils.objectsEqual(emulatedMachine, other.emulatedMachine) && trustedService == other.trustedService && haReservation == other.haReservation && ObjectUtils.objectsEqual(clusterPolicyId, other.clusterPolicyId) && ObjectUtils.objectsEqual(clusterPolicyName, other.clusterPolicyName) && ObjectUtils.objectsEqual(clusterPolicyProperties, other.clusterPolicyProperties) && enableKsm == other.enableKsm && enableBallooning == other.enableBallooning && detectEmulatedMachine == other.detectEmulatedMachine && optimizationType == other.optimizationType) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && ObjectUtils.objectsEqual(requiredRngSources, other.requiredRngSources) && ObjectUtils.objectsEqual(fencingPolicy, other.fencingPolicy) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(glusterTunedProfile, other.glusterTunedProfile) && ObjectUtils.objectsEqual(maintenanceReasonRequired, other.maintenanceReasonRequired) && ObjectUtils.objectsEqual(addtionalFeaturesSupported, other.addtionalFeaturesSupported);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (vdsStatic == null ? 0 : vdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (imagesLastCheck == null ? 0 : imagesLastCheck.hashCode());
    result = prime * result + (imagesLastDelay == null ? 0 : imagesLastDelay.hashCode());
    result = prime * result + (interfaces == null ? 0 : interfaces.hashCode());
    result = prime * result + (networks == null ? 0 : networks.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (vdsStatic == null ? 0 : vdsStatic.hashCode());
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (spmStatus == null ? 0 : spmStatus.hashCode());
    result = prime * result + (imagesLastCheck == null ? 0 : imagesLastCheck.hashCode());
    result = prime * result + (imagesLastDelay == null ? 0 : imagesLastDelay.hashCode());
    result = prime * result + (interfaces == null ? 0 : interfaces.hashCode());
    result = prime * result + (networkNames == null ? 0 : networkNames.hashCode());
    result = prime * result + maxVdsMemoryOverCommit;
    result = prime * result + (privateDomains == null ? 0 : privateDomains.hashCode());
    result = prime * result + (vdsSpmId == null ? 0 : vdsSpmId.hashCode());
    result = prime * result + (storagePoolId == null ? 0 : storagePoolId.hashCode());
    result = prime * result + (storagePoolName == null ? 0 : storagePoolName.hashCode());
    result = prime * result + (vdsGroupCompatibilityVersion == null ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + (vdsGroupCpuName == null ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + (vdsGroupDescription == null ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + (vdsGroupName == null ? 0 : vdsGroupName.hashCode());
    result = prime * result + (vdsGroupVirtService == null ? 0 : vdsGroupVirtService.hashCode());
    result = prime * result + (vdsGroupGlusterService == null ? 0 : vdsGroupGlusterService.hashCode());
    result = prime * result + (balloonEnabled ? 0 : 1);
    result = prime * result + (countThreadsAsCores ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(vdsStatic, other.vdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(imagesLastCheck, other.imagesLastCheck) && ObjectUtils.objectsEqual(imagesLastDelay, other.imagesLastDelay) && ObjectUtils.objectsEqual(interfaces, other.interfaces) && ObjectUtils.objectsEqual(networks, other.networks) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VDS)) {
        return false;
    }
    VDS other = (VDS) obj;
    return (ObjectUtils.objectsEqual(vdsStatic, other.vdsStatic) && ObjectUtils.objectsEqual(cpuName, other.cpuName) && spmStatus == other.spmStatus && ObjectUtils.objectsEqual(imagesLastCheck, other.imagesLastCheck) && ObjectUtils.objectsEqual(imagesLastDelay, other.imagesLastDelay) && ObjectUtils.objectsEqual(interfaces, other.interfaces) && ObjectUtils.objectsEqual(networkNames, other.networkNames) && maxVdsMemoryOverCommit == other.maxVdsMemoryOverCommit && balloonEnabled == other.balloonEnabled && ObjectUtils.objectsEqual(privateDomains, other.privateDomains) && ObjectUtils.objectsEqual(vdsSpmId, other.vdsSpmId) && ObjectUtils.objectsEqual(storagePoolId, other.storagePoolId) && ObjectUtils.objectsEqual(storagePoolName, other.storagePoolName) && ObjectUtils.objectsEqual(vdsGroupCompatibilityVersion, other.vdsGroupCompatibilityVersion) && ObjectUtils.objectsEqual(vdsGroupCpuName, other.vdsGroupCpuName) && ObjectUtils.objectsEqual(vdsGroupDescription, other.vdsGroupDescription) && ObjectUtils.objectsEqual(vdsGroupName, other.vdsGroupName) && ObjectUtils.objectsEqual(vdsGroupVirtService, other.vdsGroupVirtService) && ObjectUtils.objectsEqual(vdsGroupGlusterService, other.vdsGroupGlusterService));
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setProtocol(getProtocol());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setOnlineCpus(getOnlineCpus());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setPmEnabled(isPmEnabled());
    vds.setPmKdumpDetection(isPmKdumpDetection());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    vds.setBalloonEnabled(isBalloonEnabled());
    vds.setNumaNodeList(getNumaNodeList());
    vds.setAutoNumaBalancing(getAutoNumaBalancing());
    vds.setFenceAgents(getFenceAgents());
    vds.setVdsGroupCompatibilityVersion(getVdsGroupCompatibilityVersion());
    vds.setUpdateAvailable(isUpdateAvailable());
    return vds;
}
#end_block

#method_before
public void setVdsName(String value) {
    vdsStatic.setVdsName(value);
}
#method_after
public void setVdsName(String value) {
    vdsStatic.setName(value);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (supportedClusterVersionsSet == null ? 0 : supportedClusterVersionsSet.hashCode());
    result = prime * result + (supportedEngineVersionsSet == null ? 0 : supportedEngineVersionsSet.hashCode());
    result = prime * result + (buildName == null ? 0 : buildName.hashCode());
    result = prime * result + (cpuCores == null ? 0 : cpuCores.hashCode());
    result = prime * result + (cpuThreads == null ? 0 : cpuThreads.hashCode());
    result = prime * result + (cpuFlags == null ? 0 : cpuFlags.hashCode());
    result = prime * result + (cpuModel == null ? 0 : cpuModel.hashCode());
    result = prime * result + (cpuSockets == null ? 0 : cpuSockets.hashCode());
    result = prime * result + (cpuSpeedMh == null ? 0 : cpuSpeedMh.hashCode());
    result = prime * result + (onlineCpus == null ? 0 : onlineCpus.hashCode());
    result = prime * result + (guestOverhead == null ? 0 : guestOverhead.hashCode());
    result = prime * result + (hooksStr == null ? 0 : hooksStr.hashCode());
    result = prime * result + (hostOs == null ? 0 : hostOs.hashCode());
    result = prime * result + (iScsiInitiatorName == null ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + (ifTotalSpeed == null ? 0 : ifTotalSpeed.hashCode());
    result = prime * result + (kernelVersion == null ? 0 : kernelVersion.hashCode());
    result = prime * result + (kvmEnabled == null ? 0 : kvmEnabled.hashCode());
    result = prime * result + (kvmVersion == null ? 0 : kvmVersion.hashCode());
    result = prime * result + (libvirtVersion == null ? 0 : libvirtVersion.hashCode());
    result = prime * result + (rpmVersion == null ? 0 : rpmVersion.hashCode());
    result = prime * result + (memCommited == null ? 0 : memCommited.hashCode());
    result = prime * result + (netConfigDirty == null ? 0 : netConfigDirty.hashCode());
    result = prime * result + (nonOperationalReason == null ? 0 : nonOperationalReason.hashCode());
    result = prime * result + (pendingVcpusCount == null ? 0 : pendingVcpusCount.hashCode());
    result = prime * result + (pendingVmemSize == null ? 0 : pendingVmemSize.hashCode());
    result = prime * result + (physicalMemMb == null ? 0 : physicalMemMb.hashCode());
    result = prime * result + (previousStatus == null ? 0 : previousStatus.hashCode());
    result = prime * result + (reservedMem == null ? 0 : reservedMem.hashCode());
    result = prime * result + (softwareVersion == null ? 0 : softwareVersion.hashCode());
    result = prime * result + (spiceVersion == null ? 0 : spiceVersion.hashCode());
    result = prime * result + (glusterVersion == null ? 0 : glusterVersion.hashCode());
    result = prime * result + (status == null ? 0 : status.hashCode());
    result = prime * result + (supportedClusterLevels == null ? 0 : supportedClusterLevels.hashCode());
    result = prime * result + (supportedEngines == null ? 0 : supportedEngines.hashCode());
    result = prime * result + (transparentHugePagesState == null ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + (versionName == null ? 0 : versionName.hashCode());
    result = prime * result + (vmActive == null ? 0 : vmActive.hashCode());
    result = prime * result + vmCount;
    result = prime * result + (supportedRngSources == null ? 0 : supportedRngSources.hashCode());
    result = prime * result + (vmMigrating == null ? 0 : vmMigrating.hashCode());
    result = prime * result + incomingMigrations;
    result = prime * result + outgoingMigrations;
    result = prime * result + (vmsCoresCount == null ? 0 : vmsCoresCount.hashCode());
    result = prime * result + (hwManufacturer == null ? 0 : hwManufacturer.hashCode());
    result = prime * result + (hwProductName == null ? 0 : hwProductName.hashCode());
    result = prime * result + (hwVersion == null ? 0 : hwVersion.hashCode());
    result = prime * result + (hwSerialNumber == null ? 0 : hwSerialNumber.hashCode());
    result = prime * result + (hwUUID == null ? 0 : hwUUID.hashCode());
    result = prime * result + (hwFamily == null ? 0 : hwFamily.hashCode());
    result = prime * result + (HBAs == null ? 0 : HBAs.hashCode());
    result = prime * result + (powerManagementControlledByPolicy ? 0 : 1);
    result = prime * result + (kdumpStatus == null ? 0 : kdumpStatus.hashCode());
    result = prime * result + (selinuxEnforceMode == null ? 0 : selinuxEnforceMode.hashCode());
    result = prime * result + (numaNodeList == null ? 0 : numaNodeList.hashCode());
    result = prime * result + autoNumaBalancing.getValue();
    result = prime * result + (numaSupport ? 0 : 1);
    result = prime * result + (liveSnapshotSupport ? 0 : 1);
    result = prime * result + (liveMergeSupport ? 0 : 1);
    result = prime * result + (maintenanceReason == null ? 0 : maintenanceReason.hashCode());
    result = prime * result + (gluster37Support == null ? 0 : gluster37Support.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (id == null ? 0 : id.hashCode());
    result = prime * result + (supportedClusterVersionsSet == null ? 0 : supportedClusterVersionsSet.hashCode());
    result = prime * result + (supportedEngineVersionsSet == null ? 0 : supportedEngineVersionsSet.hashCode());
    result = prime * result + (buildName == null ? 0 : buildName.hashCode());
    result = prime * result + (cpuCores == null ? 0 : cpuCores.hashCode());
    result = prime * result + (cpuThreads == null ? 0 : cpuThreads.hashCode());
    result = prime * result + (cpuFlags == null ? 0 : cpuFlags.hashCode());
    result = prime * result + (cpuModel == null ? 0 : cpuModel.hashCode());
    result = prime * result + (cpuSockets == null ? 0 : cpuSockets.hashCode());
    result = prime * result + (cpuSpeedMh == null ? 0 : cpuSpeedMh.hashCode());
    result = prime * result + (onlineCpus == null ? 0 : onlineCpus.hashCode());
    result = prime * result + (guestOverhead == null ? 0 : guestOverhead.hashCode());
    result = prime * result + (hooksStr == null ? 0 : hooksStr.hashCode());
    result = prime * result + (hostOs == null ? 0 : hostOs.hashCode());
    result = prime * result + (iScsiInitiatorName == null ? 0 : iScsiInitiatorName.hashCode());
    result = prime * result + (ifTotalSpeed == null ? 0 : ifTotalSpeed.hashCode());
    result = prime * result + (kernelVersion == null ? 0 : kernelVersion.hashCode());
    result = prime * result + (kvmEnabled == null ? 0 : kvmEnabled.hashCode());
    result = prime * result + (kvmVersion == null ? 0 : kvmVersion.hashCode());
    result = prime * result + (libvirtVersion == null ? 0 : libvirtVersion.hashCode());
    result = prime * result + (rpmVersion == null ? 0 : rpmVersion.hashCode());
    result = prime * result + (memCommited == null ? 0 : memCommited.hashCode());
    result = prime * result + (netConfigDirty == null ? 0 : netConfigDirty.hashCode());
    result = prime * result + (nonOperationalReason == null ? 0 : nonOperationalReason.hashCode());
    result = prime * result + (pendingVcpusCount == null ? 0 : pendingVcpusCount.hashCode());
    result = prime * result + (pendingVmemSize == null ? 0 : pendingVmemSize.hashCode());
    result = prime * result + (physicalMemMb == null ? 0 : physicalMemMb.hashCode());
    result = prime * result + (previousStatus == null ? 0 : previousStatus.hashCode());
    result = prime * result + (reservedMem == null ? 0 : reservedMem.hashCode());
    result = prime * result + (softwareVersion == null ? 0 : softwareVersion.hashCode());
    result = prime * result + (spiceVersion == null ? 0 : spiceVersion.hashCode());
    result = prime * result + (glusterVersion == null ? 0 : glusterVersion.hashCode());
    result = prime * result + (status == null ? 0 : status.hashCode());
    result = prime * result + (supportedClusterLevels == null ? 0 : supportedClusterLevels.hashCode());
    result = prime * result + (supportedEngines == null ? 0 : supportedEngines.hashCode());
    result = prime * result + (transparentHugePagesState == null ? 0 : transparentHugePagesState.hashCode());
    result = prime * result + (versionName == null ? 0 : versionName.hashCode());
    result = prime * result + (vmActive == null ? 0 : vmActive.hashCode());
    result = prime * result + vmCount;
    result = prime * result + (supportedRngSources == null ? 0 : supportedRngSources.hashCode());
    result = prime * result + (vmMigrating == null ? 0 : vmMigrating.hashCode());
    result = prime * result + incomingMigrations;
    result = prime * result + outgoingMigrations;
    result = prime * result + (vmsCoresCount == null ? 0 : vmsCoresCount.hashCode());
    result = prime * result + (hwManufacturer == null ? 0 : hwManufacturer.hashCode());
    result = prime * result + (hwProductName == null ? 0 : hwProductName.hashCode());
    result = prime * result + (hwVersion == null ? 0 : hwVersion.hashCode());
    result = prime * result + (hwSerialNumber == null ? 0 : hwSerialNumber.hashCode());
    result = prime * result + (hwUUID == null ? 0 : hwUUID.hashCode());
    result = prime * result + (hwFamily == null ? 0 : hwFamily.hashCode());
    result = prime * result + (HBAs == null ? 0 : HBAs.hashCode());
    result = prime * result + (powerManagementControlledByPolicy ? 0 : 1);
    result = prime * result + (kdumpStatus == null ? 0 : kdumpStatus.hashCode());
    result = prime * result + (selinuxEnforceMode == null ? 0 : selinuxEnforceMode.hashCode());
    result = prime * result + (numaNodeList == null ? 0 : numaNodeList.hashCode());
    result = prime * result + autoNumaBalancing.getValue();
    result = prime * result + (numaSupport ? 0 : 1);
    result = prime * result + (liveSnapshotSupport ? 0 : 1);
    result = prime * result + (liveMergeSupport ? 0 : 1);
    result = prime * result + (additionalFeatures == null ? 0 : additionalFeatures.hashCode());
    result = prime * result + (maintenanceReason == null ? 0 : maintenanceReason.hashCode());
    result = prime * result + (updateAvailable ? 0 : 1);
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(getSupportedClusterVersionsSet(), other.getSupportedClusterVersionsSet()) && ObjectUtils.objectsEqual(supportedEngineVersionsSet, other.supportedEngineVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpuCores, other.cpuCores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpuFlags, other.cpuFlags) && ObjectUtils.objectsEqual(cpuModel, other.cpuModel) && ObjectUtils.objectsEqual(cpuSockets, other.cpuSockets) && ObjectUtils.objectsEqual(cpuSpeedMh, other.cpuSpeedMh) && ObjectUtils.objectsEqual(onlineCpus, other.onlineCpus) && ObjectUtils.objectsEqual(guestOverhead, other.guestOverhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(hostOs, other.hostOs) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(ifTotalSpeed, other.ifTotalSpeed) && ObjectUtils.objectsEqual(kernelVersion, other.kernelVersion) && ObjectUtils.objectsEqual(kvmEnabled, other.kvmEnabled) && ObjectUtils.objectsEqual(kvmVersion, other.kvmVersion) && ObjectUtils.objectsEqual(libvirtVersion, other.libvirtVersion) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(memCommited, other.memCommited) && ObjectUtils.objectsEqual(netConfigDirty, other.netConfigDirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pendingVcpusCount, other.pendingVcpusCount) && ObjectUtils.objectsEqual(pendingVmemSize, other.pendingVmemSize) && ObjectUtils.objectsEqual(physicalMemMb, other.physicalMemMb) && previousStatus == other.previousStatus && ObjectUtils.objectsEqual(reservedMem, other.reservedMem) && ObjectUtils.objectsEqual(getSoftwareVersion(), other.getSoftwareVersion()) && ObjectUtils.objectsEqual(spiceVersion, other.spiceVersion) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supportedClusterLevels, other.supportedClusterLevels) && ObjectUtils.objectsEqual(supportedEngines, other.supportedEngines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vmActive, other.vmActive) && vmCount == other.vmCount && ObjectUtils.objectsEqual(vmMigrating, other.vmMigrating) && incomingMigrations == other.incomingMigrations && outgoingMigrations == other.outgoingMigrations && ObjectUtils.objectsEqual(vmsCoresCount, other.vmsCoresCount) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && ObjectUtils.objectsEqual(selinuxEnforceMode, other.selinuxEnforceMode) && ObjectUtils.objectsEqual(numaNodeList, other.numaNodeList) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && ObjectUtils.objectsEqual(supportedRngSources, other.supportedRngSources) && liveSnapshotSupport == other.liveSnapshotSupport && liveMergeSupport == other.liveMergeSupport && ObjectUtils.objectsEqual(maintenanceReason, other.maintenanceReason) && ObjectUtils.objectsEqual(gluster37Support, other.gluster37Support);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(getSupportedClusterVersionsSet(), other.getSupportedClusterVersionsSet()) && ObjectUtils.objectsEqual(supportedEngineVersionsSet, other.supportedEngineVersionsSet) && ObjectUtils.objectsEqual(buildName, other.buildName) && ObjectUtils.objectsEqual(cpuCores, other.cpuCores) && ObjectUtils.objectsEqual(cpuThreads, other.cpuThreads) && ObjectUtils.objectsEqual(cpuFlags, other.cpuFlags) && ObjectUtils.objectsEqual(cpuModel, other.cpuModel) && ObjectUtils.objectsEqual(cpuSockets, other.cpuSockets) && ObjectUtils.objectsEqual(cpuSpeedMh, other.cpuSpeedMh) && ObjectUtils.objectsEqual(onlineCpus, other.onlineCpus) && ObjectUtils.objectsEqual(guestOverhead, other.guestOverhead) && ObjectUtils.objectsEqual(hooksStr, other.hooksStr) && ObjectUtils.objectsEqual(hostOs, other.hostOs) && ObjectUtils.objectsEqual(iScsiInitiatorName, other.iScsiInitiatorName) && ObjectUtils.objectsEqual(ifTotalSpeed, other.ifTotalSpeed) && ObjectUtils.objectsEqual(kernelVersion, other.kernelVersion) && ObjectUtils.objectsEqual(kvmEnabled, other.kvmEnabled) && ObjectUtils.objectsEqual(kvmVersion, other.kvmVersion) && ObjectUtils.objectsEqual(libvirtVersion, other.libvirtVersion) && ObjectUtils.objectsEqual(rpmVersion, other.rpmVersion) && ObjectUtils.objectsEqual(memCommited, other.memCommited) && ObjectUtils.objectsEqual(netConfigDirty, other.netConfigDirty) && nonOperationalReason == other.nonOperationalReason && ObjectUtils.objectsEqual(pendingVcpusCount, other.pendingVcpusCount) && ObjectUtils.objectsEqual(pendingVmemSize, other.pendingVmemSize) && ObjectUtils.objectsEqual(physicalMemMb, other.physicalMemMb) && previousStatus == other.previousStatus && ObjectUtils.objectsEqual(reservedMem, other.reservedMem) && ObjectUtils.objectsEqual(getSoftwareVersion(), other.getSoftwareVersion()) && ObjectUtils.objectsEqual(spiceVersion, other.spiceVersion) && ObjectUtils.objectsEqual(glusterVersion, other.glusterVersion) && status == other.status && ObjectUtils.objectsEqual(supportedClusterLevels, other.supportedClusterLevels) && ObjectUtils.objectsEqual(supportedEngines, other.supportedEngines) && transparentHugePagesState == other.transparentHugePagesState && ObjectUtils.objectsEqual(versionName, other.versionName) && ObjectUtils.objectsEqual(vmActive, other.vmActive) && vmCount == other.vmCount && ObjectUtils.objectsEqual(vmMigrating, other.vmMigrating) && incomingMigrations == other.incomingMigrations && outgoingMigrations == other.outgoingMigrations && ObjectUtils.objectsEqual(vmsCoresCount, other.vmsCoresCount) && ObjectUtils.objectsEqual(hwManufacturer, other.hwManufacturer) && ObjectUtils.objectsEqual(hwProductName, other.hwProductName) && ObjectUtils.objectsEqual(hwVersion, other.hwVersion) && ObjectUtils.objectsEqual(hwSerialNumber, other.hwSerialNumber) && ObjectUtils.objectsEqual(hwUUID, other.hwUUID) && ObjectUtils.objectsEqual(hwFamily, other.hwFamily) && ObjectUtils.objectsEqual(HBAs, other.HBAs) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && ObjectUtils.objectsEqual(selinuxEnforceMode, other.selinuxEnforceMode) && ObjectUtils.objectsEqual(numaNodeList, other.numaNodeList) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport) && ObjectUtils.objectsEqual(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && ObjectUtils.objectsEqual(supportedRngSources, other.supportedRngSources) && liveSnapshotSupport == other.liveSnapshotSupport && liveMergeSupport == other.liveMergeSupport && ObjectUtils.objectsEqual(maintenanceReason, other.maintenanceReason) && updateAvailable == other.updateAvailable && ObjectUtils.objectsEqual(additionalFeatures, other.additionalFeatures);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_EXISTS:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL;
        case RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER;
        case MIXING_RHEL_VERSIONS_IN_CLUSTER:
            return AuditLogType.MIXING_RHEL_VERSIONS_IN_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        case GLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.GLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    for (Entry<String, String> e : getParameters().getCustomLogValues().entrySet()) {
        addCustomValue(e.getKey(), e.getValue());
    }
    switch(getParameters().getNonOperationalReason()) {
        case NETWORK_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
        case STORAGE_DOMAIN_UNREACHABLE:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN : AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED;
        case TIMEOUT_RECOVERING_FROM_CRASH:
            return AuditLogType.VDS_RECOVER_FAILED;
        case KVM_NOT_RUNNING:
            return AuditLogType.VDS_RUN_IN_NO_KVM_MODE;
        case VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER;
        case CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED;
        case VM_NETWORK_IS_BRIDGELESS:
            return AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS;
        case GLUSTER_COMMAND_FAILED:
            return AuditLogType.GLUSTER_COMMAND_FAILED;
        case GLUSTER_HOST_UUID_NOT_FOUND:
            return AuditLogType.GLUSTER_HOST_UUID_NOT_FOUND;
        case GLUSTER_HOST_UUID_ALREADY_EXISTS:
            return AuditLogType.GLUSTER_HOST_UUID_ALREADY_EXISTS;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER;
        case EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL:
            return AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER_LEVEL;
        case RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER:
            return AuditLogType.RNG_SOURCES_INCOMPATIBLE_WITH_CLUSTER;
        case MIXING_RHEL_VERSIONS_IN_CLUSTER:
            return AuditLogType.MIXING_RHEL_VERSIONS_IN_CLUSTER;
        case UNTRUSTED:
            return AuditLogType.VDS_UNTRUSTED;
        case HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER:
            return AuditLogType.HOST_FEATURES_INCOMPATIBILE_WITH_CLUSTER;
        default:
            return (getSucceeded()) ? AuditLogType.VDS_SET_NONOPERATIONAL : AuditLogType.VDS_SET_NONOPERATIONAL_FAILED;
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(AssignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    if (RpmVersionUtils.compareRpmParts(vds.getGlusterVersion().getMajor() + "." + vds.getGlusterVersion().getMinor(), "3.7") >= 0) {
        vds.setGluster37Support(true);
    } else {
        vds.setGluster37Support(false);
    }
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    updateNumaNodesData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setOnlineCpus(AssignStringValue(xmlRpcStruct, VdsProperties.online_cpus));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    setRngSupportedSourcesToVds(vds, xmlRpcStruct);
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    vds.setKdumpStatus(KdumpStatus.valueOfNumber(AssignIntValue(xmlRpcStruct, VdsProperties.KDUMP_STATUS)));
    Map<String, Object> selinux = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.selinux);
    if (selinux != null) {
        vds.setSELinuxEnforceMode(AssignIntValue(selinux, VdsProperties.selinux_mode));
    } else {
        vds.setSELinuxEnforceMode(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveSnapshotSupport)) {
        vds.setLiveSnapshotSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveSnapshotSupport));
    } else {
        // for backward compatibility's sake
        vds.setLiveSnapshotSupport(true);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.liveMergeSupport)) {
        vds.setLiveMergeSupport(AssignBoolValue(xmlRpcStruct, VdsProperties.liveMergeSupport));
    } else {
        vds.setLiveMergeSupport(false);
    }
    updateAdditionalFeatures(vds, xmlRpcStruct);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface, statsBuilder.isTotalStatsReported());
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface, boolean totalStatsReported) {
    Double receiveRate = iface.getStatistics().getReceiveRate();
    Double transmitRate = iface.getStatistics().getTransmitRate();
    /**
     * TODO: only needed if rate reported by vdsm (in which case can't be null) - remove in 4.0 and turn
     * NetworkStatisticsBuilder.truncatePercentage() private
     */
    if (!totalStatsReported) {
        receiveRate = NetworkStatisticsBuilder.truncatePercentage(receiveRate);
        transmitRate = NetworkStatisticsBuilder.truncatePercentage(transmitRate);
    }
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static String AssignStringValueFromArray(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        String[] arr = (String[]) ((input.get(name) instanceof String[]) ? input.get(name) : null);
        if (arr == null) {
            Object[] arr2 = (Object[]) ((input.get(name) instanceof Object[]) ? input.get(name) : null);
            if (arr2 != null) {
                arr = new String[arr2.length];
                for (int i = 0; i < arr2.length; i++) arr[i] = arr2[i].toString();
            }
        }
        if (arr != null) {
            return StringUtils.join(arr, ',');
        }
    }
    return null;
}
#method_after
private static String AssignStringValueFromArray(Map<String, Object> input, String name) {
    String[] arr = AssignStringArrayValue(input, name);
    if (arr != null) {
        return StringUtils.join(arr, ',');
    }
    return null;
}
#end_block

#method_before
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#method_after
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                    // Don't process this
                    continue;
                }
                if (appString == null) {
                    // Note: app cannot be null here anymore
                    log.warn("Failed to convert app: [" + app.getClass().getName() + "] is not a string");
                    // Don't process this
                    continue;
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> networkProperties = entry.getValue();
            String networkName = entry.getKey();
            if (networkProperties != null) {
                String interfaceName = (String) networkProperties.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(networkProperties);
                HostNetworkQos qos = new HostNetworkQosMapper(networkProperties).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : networkProperties;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(networkProperties, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(Network network, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", network.getName());
    return logable;
}
#method_after
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct, Map<String, Object> network) {
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion())) {
        VdsNetworkInterface iface = null;
        String interfaceName = (String) network.get(VdsProperties.INTERFACE);
        if (interfaceName != null) {
            iface = vdsInterfaces.get(interfaceName);
            if (iface == null) {
                Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
                if (bridges != null && bridges.containsKey(interfaceName)) {
                    interfaces.addAll(findBridgedNetworkInterfaces((Map<String, Object>) bridges.get(interfaceName), vdsInterfaces));
                }
            } else {
                interfaces.add(iface);
            }
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(network, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Object> bridgeProperties) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridgeProperties != null) {
            interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iStats.setVdsId(vds.getId());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                iface.setAddress((String) bond.get("addr"));
                iface.setSubnet((String) bond.get("netmask"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                if (StringUtils.isNotBlank((String) bond.get(VdsProperties.MTU))) {
                    iface.setMtu(Integer.parseInt((String) bond.get(VdsProperties.MTU)));
                }
                Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                if (config != null && config.get("BONDING_OPTS") != null) {
                    iface.setBondOptions(config.get("BONDING_OPTS").toString());
                }
                addBootProtocol(config, vds, iface);
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    bondOptions = bondProperties.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bondProperties.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    bond.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            String vlanDeviceName = entry.getKey();
            iface.setName(vlanDeviceName);
            iface.setVdsId(vds.getId());
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.MTU))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.MTU)));
            }
            iStats.setVdsId(vds.getId());
            addBootProtocol((Map<String, Object>) vlan.get("cfg"), vds, iface);
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface vlan = new Vlan();
            updateCommonInterfaceData(vlan, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlanProperties = entry.getValue();
            if (vlanProperties.get(VdsProperties.VLAN_ID) != null && vlanProperties.get(VdsProperties.BASE_INTERFACE) != null) {
                vlan.setVlanId((Integer) vlanProperties.get(VdsProperties.VLAN_ID));
                vlan.setBaseInterface((String) vlanProperties.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                vlan.setVlanId(Integer.parseInt(vlanId));
                vlan.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(vlan);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            updateNetworkInterfaceDataFromHost(iface, vds, (Map<String, Object>) entry.getValue());
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface nic = new Nic();
            updateCommonInterfaceData(nic, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    nic.setSpeed((Integer) speed);
                }
                nic.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    nic.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(nic);
        }
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> cfg, VDS host, VdsNetworkInterface iface) {
    NetworkBootProtocol bootproto = NetworkBootProtocol.NONE;
    if (cfg != null) {
        String bootProtocol = (String) cfg.get("BOOTPROTO");
        if (bootProtocol != null) {
            if (bootProtocol.toLowerCase().equals("dhcp")) {
                bootproto = NetworkBootProtocol.DHCP;
            } else if (bootProtocol.toLowerCase().equals("none") || bootProtocol.toLowerCase().equals("static")) {
                if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
                    bootproto = NetworkBootProtocol.STATIC_IP;
                }
            }
        } else if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
            bootproto = NetworkBootProtocol.STATIC_IP;
        }
        if (bootproto == NetworkBootProtocol.STATIC_IP) {
            String gateway = (String) cfg.get(VdsProperties.GATEWAY);
            if (StringUtils.isNotEmpty(gateway)) {
                setGatewayIfNecessary(iface, host, gateway.toString());
            }
        }
    }
    iface.setBootProtocol(bootproto);
}
#method_after
private static void addBootProtocol(Map<String, Object> entry, VDS host, VdsNetworkInterface iface) {
    BootProtocolResolver resolver = FeatureSupported.cfgEntriesDeprecated(host.getVdsGroupCompatibilityVersion()) ? new NoCfgBootProtocolResolver(entry, iface, host) : new CfgBootProtocolResolver(entry, iface, host);
    resolver.resolve();
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
public static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrDefault(dataCenters, new DataCenterPredicate(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    ClusterModel clusterModel = new ClusterModel();
    clusterModel.init(false);
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    clusterModel.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("new_cluster");
    clusterModel.setIsNew(true);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterListModel<Void> clModel = (ClusterListModel<Void>) model;
            ClusterModel cModel = (ClusterModel) clModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            // Strict data center as neccessary.
            if (clModel.getSystemTreeSelectedItem() != null && clModel.getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
                SystemTreeItemModel treeSelectedItem = clModel.getSystemTreeSelectedItem();
                SystemTreeItemModel treeSelectedDc = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, treeSelectedItem);
                StoragePool selectDataCenter = (StoragePool) treeSelectedDc.getEntity();
                final StoragePool selectedDataCenter = Linq.firstOrDefault(dataCenters, new DataCenterPredicate(selectDataCenter.getId()));
                cModel.getDataCenter().setItems(dataCenters, selectedDataCenter);
                cModel.getDataCenter().setIsChangeable(false);
            } else {
                cModel.getDataCenter().setItems(dataCenters, Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", clModel);
            cModel.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clModel);
            cModel.getCommands().add(tempVar2);
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    clusterModel.getEnableHaReservation().setEntity(cluster.supportsHaReservation());
    clusterModel.getEnableOptionalReason().setEntity(cluster.isOptionalReasonRequired());
    clusterModel.getEnableHostMaintenanceReason().setEntity(cluster.isMaintenanceReasonRequired());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    clusterModel.setHelpTag(HelpTag.edit_cluster);
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangeable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangeable(true);
    clusterModel.getEnableKsm().setEntity(cluster.isEnableKsm());
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    clusterModel.getArchitecture().setSelectedItem(cluster.getArchitecture());
    clusterModel.getSerialNumberPolicy().setSelectedSerialNumberPolicy(cluster.getSerialNumberPolicy());
    clusterModel.getSerialNumberPolicy().getCustomSerialNumber().setEntity(cluster.getCustomSerialNumber());
    clusterModel.getAutoConverge().setSelectedItem(cluster.getAutoConverge());
    clusterModel.getMigrateCompressed().setSelectedItem(cluster.getMigrateCompressed());
    clusterModel.getGlusterTunedProfile().setSelectedItem(cluster.getGlusterTunedProfile());
    clusterModel.getGlusterTunedProfile().setIsChangeable(cluster.getGroupHostsAndVms().getHosts() == 0);
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangeable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangeable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangeable(false);
    }
    clusterModel.getOptimizeForSpeed().setEntity(OptimizationType.OPTIMIZE_FOR_SPEED == cluster.getOptimizationType());
    clusterModel.getAllowOverbooking().setEntity(OptimizationType.ALLOW_OVERBOOKING == cluster.getOptimizationType());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangeable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangeable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getInstance().getVolumeList(asyncQuery, cluster.getName());
            if (cluster.getGroupHostsAndVms().getVms() > 0) {
                clusterModel.getEnableOvirtService().setIsChangeable(false);
                if (!isVirtGlusterAllowed) {
                    clusterModel.getEnableGlusterService().setIsChangeable(false);
                }
            }
            if (cluster.getGroupHostsAndVms().getHosts() > 0) {
                clusterModel.getEnableTrustedService().setIsChangeable(false);
                clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
            }
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangeable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnSave", this);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    cluster.setGluster37Support(model.getSupportGluster37Features().getEntity());
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#method_after
private void onSaveInternalWithModel(final ClusterModel model) {
    VDSGroup cluster = model.getIsNew() ? new VDSGroup() : (VDSGroup) Cloner.clone(getSelectedItem());
    Version version = model.getVersion().getSelectedItem();
    cluster.setName(model.getName().getEntity());
    cluster.setDescription(model.getDescription().getEntity());
    cluster.setComment(model.getComment().getEntity());
    cluster.setStoragePoolId(model.getDataCenter().getSelectedItem().getId());
    if (model.getCPU().getSelectedItem() != null) {
        cluster.setCpuName(model.getCPU().getSelectedItem().getCpuName());
    }
    cluster.setMaxVdsMemoryOverCommit(model.getMemoryOverCommit());
    cluster.setCountThreadsAsCores(Boolean.TRUE.equals(model.getVersionSupportsCpuThreads().getEntity()) && Boolean.TRUE.equals(model.getCountThreadsAsCores().getEntity()));
    cluster.setEnableKsm(Boolean.TRUE.equals(model.getEnableKsm().getEntity()));
    cluster.setEnableBallooning(Boolean.TRUE.equals(model.getEnableBallooning().getEntity()) && version.compareTo(Version.v3_3) >= 0);
    // $NON-NLS-1$
    cluster.setTransparentHugepages(version.compareTo(new Version("3.0")) >= 0);
    cluster.setCompatibilityVersion(version);
    cluster.setMigrateOnError(model.getMigrateOnErrorOption());
    cluster.setVirtService(model.getEnableOvirtService().getEntity());
    cluster.setGlusterService(model.getEnableGlusterService().getEntity());
    for (AdditionalFeature feature : model.getAdditionalClusterFeatures().getSelectedItem()) {
        cluster.getAddtionalFeaturesSupported().add(new SupportedAdditionalClusterFeature(cluster.getId(), true, feature));
    }
    cluster.setTrustedService(model.getEnableTrustedService().getEntity());
    cluster.setHaReservation(model.getEnableHaReservation().getEntity());
    cluster.setOptionalReasonRequired(model.getEnableOptionalReason().getEntity());
    cluster.setMaintenanceReasonRequired(model.getEnableHostMaintenanceReason().getEntity());
    cluster.setClusterPolicyId(model.getClusterPolicy().getSelectedItem().getId());
    cluster.setClusterPolicyProperties(KeyValueModel.convertProperties(model.getCustomPropertySheet().serialize()));
    if (model.getOptimizeForSpeed().getEntity()) {
        cluster.setOptimizationType(OptimizationType.OPTIMIZE_FOR_SPEED);
    } else if (model.getAllowOverbooking().getEntity()) {
        cluster.setOptimizationType(OptimizationType.ALLOW_OVERBOOKING);
    } else {
        cluster.setOptimizationType(OptimizationType.NONE);
    }
    if (model.getCPU().getSelectedItem() == null) {
        cluster.setArchitecture(model.getArchitecture().getSelectedItem());
    } else {
        cluster.setArchitecture(null);
    }
    if (model.getSpiceProxyEnabled().getEntity()) {
        cluster.setSpiceProxy(model.getSpiceProxy().getEntity());
    }
    cluster.getFencingPolicy().setFencingEnabled(model.getFencingEnabledModel().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfSDActive(model.getSkipFencingIfSDActiveEnabled().getEntity());
    cluster.getFencingPolicy().setSkipFencingIfConnectivityBroken(model.getSkipFencingIfConnectivityBrokenEnabled().getEntity());
    cluster.getFencingPolicy().setHostsWithBrokenConnectivityThreshold(model.getHostsWithBrokenConnectivityThreshold().getSelectedItem().intValue());
    cluster.setSerialNumberPolicy(model.getSerialNumberPolicy().getSelectedSerialNumberPolicy());
    cluster.setCustomSerialNumber(model.getSerialNumberPolicy().getCustomSerialNumber().getEntity());
    cluster.setAutoConverge(model.getAutoConverge().getSelectedItem());
    cluster.setMigrateCompressed(model.getMigrateCompressed().getSelectedItem());
    cluster.setGlusterTunedProfile(model.getGlusterTunedProfile().getSelectedItem());
    cluster.getRequiredRngSources().clear();
    if (Boolean.TRUE.equals(model.getRngRandomSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.RANDOM);
    }
    if (Boolean.TRUE.equals(model.getRngHwrngSourceRequired().getEntity())) {
        cluster.getRequiredRngSources().add(VmRngDevice.Source.HWRNG);
    }
    model.startProgress(null);
    final Network managementNetwork = model.getManagementNetwork().getSelectedItem();
    final ManagementNetworkOnClusterOperationParameters clusterOperationParameters = new ManagementNetworkOnClusterOperationParameters(cluster, managementNetwork.getId());
    final VdcActionType actionType = model.getIsNew() ? VdcActionType.AddVdsGroup : VdcActionType.UpdateVdsGroup;
    Frontend.getInstance().runAction(actionType, clusterOperationParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ClusterListModel<Void> localModel = (ClusterListModel<Void>) result.getState();
            if (model.getIsImportGlusterConfiguration().getEntity()) {
                localModel.postOnSaveInternalWithImport(result.getReturnValue());
            } else {
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }
    }, this);
}
#end_block

#method_before
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    getEditCommand().setIsExecutionAllowed(getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getRemoveCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    getResetEmulatedMachineCommand().setIsExecutionAllowed(getSelectedItems() != null && getSelectedItems().size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster));
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getResetEmulatedMachineCommand()) {
        resetEmulatedMachine();
    } else if ("OnResetClusterEmulatedMachine".equals(command.getName())) {
        // $NON-NLS-1$
        onResetClusterEmulatedMachine();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuThreads".equals(command.getName())) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    "OnSaveConfirmCpuLevel".equals(command.getName())) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    "OnSaveInternal".equals(command.getName())) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnSaveHosts".equals(command.getName())) {
        onSaveHosts();
    }
}
#end_block

#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetContainerStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetContainerStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetContainerStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetContainerStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableHaReservationEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableOptionalReasonEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableHostMaintenanceReasonEditor.setContentWidgetContainerStyleName(style.fullWidth());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetContainerStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetContainerStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetContainerStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetContainerStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableHaReservationEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableOptionalReasonEditor.setContentWidgetContainerStyleName(style.fullWidth());
    enableHostMaintenanceReasonEditor.setContentWidgetContainerStyleName(style.fullWidth());
    additionalFeaturesExpanderContent.setStyleName(style.additionalFeaturesExpanderContent());
}
#end_block

#method_before
private void localize() {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    managementNetworkEditor.setLabel(constants.managementNetworkLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    supportGluster37FeaturesEditor.setLabel(constants.supportGluster37FeaturesLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    enableHostMaintenanceReasonEditor.setLabel(constants.clusterPolicyEnableHostMaintenanceReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#method_after
private void localize() {
    generalTab.setLabel(constants.clusterPopupGeneralTabLabel());
    dataCenterEditor.setLabel(constants.clusterPopupDataCenterLabel());
    nameEditor.setLabel(constants.clusterPopupNameLabel());
    descriptionEditor.setLabel(constants.clusterPopupDescriptionLabel());
    commentEditor.setLabel(constants.commentLabel());
    managementNetworkEditor.setLabel(constants.managementNetworkLabel());
    cpuEditor.setLabel(constants.clusterPopupCPUTypeLabel());
    architectureEditor.setLabel(constants.clusterPopupArchitectureLabel());
    versionEditor.setLabel(constants.clusterPopupVersionLabel());
    enableOvirtServiceEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    enableOvirtServiceOptionEditor.setLabel(constants.clusterEnableOvirtServiceLabel());
    enableGlusterServiceOptionEditor.setLabel(constants.clusterEnableGlusterServiceLabel());
    glusterTunedProfileEditor.setLabel(constants.glusterTunedProfileLabel());
    importGlusterConfigurationEditor.setLabel(constants.clusterImportGlusterConfigurationLabel());
    importGlusterExplanationLabel.setText(constants.clusterImportGlusterConfigurationExplanationLabel());
    glusterHostAddressEditor.setLabel(constants.hostPopupHostAddressLabel());
    glusterHostFingerprintEditor.setLabel(constants.hostPopupHostFingerprintLabel());
    glusterHostPasswordEditor.setLabel(constants.hostPopupPasswordLabel());
    additionalFeaturesExpander.setTitleWhenCollapsed(constants.addtionalClusterFeaturesTitle());
    additionalFeaturesExpander.setTitleWhenExpanded(constants.addtionalClusterFeaturesTitle());
    rngLabel.setText(constants.requiredRngSources());
    rngRandomSourceRequired.setLabel(constants.rngSourceRandom());
    rngHwrngSourceRequired.setLabel(constants.rngSourceHwrng());
    optimizationTab.setLabel(constants.clusterPopupOptimizationTabLabel());
    memoryOptimizationPanelTitle.setText(constants.clusterPopupMemoryOptimizationPanelTitle());
    optimizationNoneEditor.setLabel(constants.clusterPopupOptimizationNoneLabel());
    cpuThreadsPanelTitle.setText(constants.clusterPopupCpuThreadsPanelTitle());
    countThreadsAsCoresEditor.setLabel(constants.clusterPopupCountThreadsAsCoresLabel());
    resiliencePolicyTab.setLabel(constants.clusterPopupResiliencePolicyTabLabel());
    migrateOnErrorOption_YESEditor.setLabel(constants.clusterPopupMigrateOnError_YesLabel());
    migrateOnErrorOption_HA_ONLYEditor.setLabel(constants.clusterPopupMigrateOnError_HaLabel());
    migrateOnErrorOption_NOEditor.setLabel(constants.clusterPopupMigrateOnError_NoLabel());
    clusterPolicyTab.setLabel(constants.clusterPopupClusterPolicyTabLabel());
    additionPropsPanelTitle.setText(constants.clusterPolicyAdditionalPropsPanelTitle());
    enableTrustedServiceEditor.setLabel(constants.clusterPolicyEnableTrustedServiceLabel());
    enableHaReservationEditor.setLabel(constants.clusterPolicyEnableHaReservationLabel());
    enableOptionalReasonEditor.setLabel(constants.clusterPolicyEnableReasonLabel());
    enableHostMaintenanceReasonEditor.setLabel(constants.clusterPolicyEnableHostMaintenanceReasonLabel());
    clusterPolicyEditor.setLabel(constants.clusterPolicySelectPolicyLabel());
    enableKsm.setLabel(constants.enableKsmLabel());
    enableBallooning.setLabel(constants.enableBallooningLabel());
    schedulerOptimizationPanelTitle.setText(constants.schedulerOptimizationPanelLabel());
    optimizeForUtilizationEditor.setLabel(constants.optimizeForUtilizationLabel());
    optimizeForSpeedEditor.setLabel(constants.optimizeForSpeedLabel());
    guarantyResourcesEditor.setLabel(constants.guarantyResourcesLabel());
    allowOverbookingEditor.setLabel(constants.allowOverbookingLabel());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    consoleTab.setLabel(constants.consoleTabLabel());
    fencingPolicyTab.setLabel(constants.fencingPolicyTabLabel());
    fencingEnabledCheckBox.setLabel(constants.fencingEnabled());
    skipFencingIfSDActiveCheckBox.setLabel(constants.skipFencingIfSDActive());
    skipFencingIfConnectivityBrokenCheckBox.setLabel(constants.skipFencingWhenConnectivityBroken());
    hostsWithBrokenConnectivityThresholdEditor.setLabel(constants.hostsWithBrokenConnectivityThresholdLabel());
}
#end_block

#method_before
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHostMaintenanceReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    fencingEnabledCheckBox.getContentWidgetContainer().setWidth("150px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("450px");
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfConnectivityBrokenCheckBox.getContentWidgetContainer().setWidth("420px");
}
#method_after
private void initCheckBoxEditors() {
    importGlusterConfigurationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    countThreadsAsCoresEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableTrustedServiceEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHaReservationEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableOptionalReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableHostMaintenanceReasonEditor = new EntityModelCheckBoxEditor(Align.RIGHT);
    enableKsm = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableKsm.getContentWidgetContainer().setWidth("350px");
    enableBallooning = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    enableBallooning.getContentWidgetContainer().setWidth("350px");
    rngRandomSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    rngHwrngSourceRequired = new EntityModelCheckBoxEditor(Align.RIGHT);
    fencingEnabledCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    fencingEnabledCheckBox.getContentWidgetContainer().setWidth("150px");
    skipFencingIfSDActiveCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfSDActiveCheckBox.getContentWidgetContainer().setWidth("450px");
    skipFencingIfConnectivityBrokenCheckBox = new EntityModelCheckBoxEditor(Align.RIGHT);
    // $NON-NLS-1$
    skipFencingIfConnectivityBrokenCheckBox.getContentWidgetContainer().setWidth("420px");
    additionalFeaturesEditor = new ListModelCheckBoxGroup<>(new AbstractRenderer<AdditionalFeature>() {

        @Override
        public String render(AdditionalFeature feature) {
            return feature.getDescription();
        }
    });
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.getInstance().isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.getInstance().isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
    object.getAdditionalClusterFeatures().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            List<List<AdditionalFeature>> items = (List<List<AdditionalFeature>>) object.getAdditionalClusterFeatures().getItems();
            // Hide the fields if there is no feature to show
            additionalFeaturesExpander.setVisible(!items.get(0).isEmpty());
            additionalFeaturesExpanderContent.setVisible(!items.get(0).isEmpty());
        }
    });
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSupportGluster37Features(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getSupportGluster37Features().setIsAvailable(getVersion().getSelectedItem().equals(Version.v3_5));
                getSupportGluster37Features().setIsChangable(!isEdit);
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                getSupportGluster37Features().setIsAvailable(false);
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setEnableOptionalReason(new EntityModel<Boolean>(false));
    getEnableOptionalReason().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setEnableHostMaintenanceReason(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    setGlusterTunedProfile(new ListModel<String>());
    AsyncDataProvider.getInstance().getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setAdditionalClusterFeatures(new ListModel<List<AdditionalFeature>>());
    List<List<AdditionalFeature>> additionalFeatures = new ArrayList<List<AdditionalFeature>>();
    additionalFeatures.add(Collections.<AdditionalFeature>emptyList());
    getAdditionalClusterFeatures().setItems(additionalFeatures, null);
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangeable(false);
    setFencingEnabledModel(new EntityModel<Boolean>());
    getFencingEnabledModel().setEntity(true);
    getFencingEnabledModel().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateFencingPolicyContent(getVersion() == null ? null : getVersion().getSelectedItem());
        }
    });
    setSkipFencingIfSDActiveEnabled(new EntityModel<Boolean>());
    getSkipFencingIfSDActiveEnabled().setEntity(true);
    setSkipFencingIfConnectivityBrokenEnabled(new EntityModel<Boolean>());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(true);
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    setAutoConverge(new ListModel<Boolean>());
    getAutoConverge().setItems(Arrays.asList(null, true, false));
    setMigrateCompressed(new ListModel<Boolean>());
    getMigrateCompressed().setItems(Arrays.asList(null, true, false));
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangeable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            } else {
                getEnableTrustedService().setIsChangeable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngRandomSourceRequired(new EntityModel<Boolean>());
    getRngRandomSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setRngHwrngSourceRequired(new EntityModel<Boolean>());
    getRngHwrngSourceRequired().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            refreshAdditionalClusterFeaturesList();
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangeable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangeable(true);
                } else {
                    getEnableTrustedService().setIsChangeable(false);
                }
            }
            getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
            if (getEnableGlusterService().getEntity()) {
                initTunedProfiles();
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangeable(false);
            } else {
                getEnableGlusterService().setIsChangeable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    getGlusterTunedProfile().setIsAvailable(getEnableGlusterService().getEntity());
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel<Boolean> tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel<Boolean> tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getInstance().getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel<Boolean>(AsyncDataProvider.getInstance().getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getInstance().getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangeable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangeable(!entity);
            }
        });
    }
    setHostsWithBrokenConnectivityThreshold(new ListModel<Integer>());
    getHostsWithBrokenConnectivityThreshold().setIsAvailable(true);
    getHostsWithBrokenConnectivityThreshold().getSelectedItemChangedEvent().addListener(this);
    initHostsWithBrokenConnectivityThreshold();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangeable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getInstance().getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getInstance().getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setArchitecture(new ListModel<ArchitectureType>());
    getArchitecture().setIsAvailable(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    setManagementNetwork(new ListModel<Network>());
    if (isEdit && !isClusterDetached()) {
        getManagementNetwork().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().prohibitManagementNetworkChangeInEditClusterInfoMessage());
        getManagementNetwork().setIsChangeable(false);
    }
    setCPU(new FilteredListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    getRngRandomSourceRequired().setEntity(false);
    getRngHwrngSourceRequired().setEntity(false);
    setValidTab(TabName.GENERAL_TAB, true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
private void initSpiceProxy() {
    String proxy = getEntity().getSpiceProxy();
    boolean isProxyAvailable = !StringHelper.isNullOrEmpty(proxy);
    getSpiceProxyEnabled().setEntity(isProxyAvailable);
    getSpiceProxy().setIsChangable(isProxyAvailable);
    getSpiceProxy().setEntity(proxy);
}
#method_after
private void initSpiceProxy() {
    String proxy = getEntity().getSpiceProxy();
    boolean isProxyAvailable = !StringHelper.isNullOrEmpty(proxy);
    getSpiceProxyEnabled().setEntity(isProxyAvailable);
    getSpiceProxy().setIsChangeable(isProxyAvailable);
    getSpiceProxy().setEntity(proxy);
}
#end_block

#method_before
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel<String>());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || (getGlusterHostAddress().getEntity()).trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint(getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel<String>());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel<String>());
    setIsImportGlusterConfiguration(new EntityModel<Boolean>());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangable(true);
                getGlusterHostPassword().setIsChangable(true);
            } else {
                getGlusterHostAddress().setIsChangable(false);
                getGlusterHostPassword().setIsChangable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#method_after
private void initImportCluster(boolean isEdit) {
    setGlusterHostAddress(new EntityModel<String>());
    getGlusterHostAddress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            setIsFingerprintVerified(false);
            if (getGlusterHostAddress().getEntity() == null || (getGlusterHostAddress().getEntity()).trim().length() == 0) {
                // $NON-NLS-1$
                getGlusterHostFingerprint().setEntity("");
                return;
            }
            fetchFingerprint(getGlusterHostAddress().getEntity());
        }
    });
    setGlusterHostFingerprint(new EntityModel<String>());
    // $NON-NLS-1$
    getGlusterHostFingerprint().setEntity("");
    setIsFingerprintVerified(false);
    setGlusterHostPassword(new EntityModel<String>());
    setIsImportGlusterConfiguration(new EntityModel<Boolean>());
    getIsImportGlusterConfiguration().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (getIsImportGlusterConfiguration().getEntity() != null && getIsImportGlusterConfiguration().getEntity()) {
                getGlusterHostAddress().setIsChangeable(true);
                getGlusterHostPassword().setIsChangeable(true);
            } else {
                getGlusterHostAddress().setIsChangeable(false);
                getGlusterHostPassword().setIsChangeable(false);
            }
        }
    });
    getIsImportGlusterConfiguration().setIsAvailable(false);
    getGlusterHostAddress().setIsAvailable(false);
    getGlusterHostFingerprint().setIsAvailable(false);
    getGlusterHostPassword().setIsAvailable(false);
    getIsImportGlusterConfiguration().setEntity(false);
}
#end_block

#method_before
private void postInit() {
    getDescription().setEntity(getEntity().getDescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getMaxVdsMemoryOverCommit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            final Guid dataCenterId = clusterModel.getEntity().getStoragePoolId();
            for (StoragePool dataCenter : dataCenters) {
                if (dataCenterId != null && dataCenter.getId().equals(dataCenterId)) {
                    clusterModel.getDataCenter().setSelectedItem(dataCenter);
                    break;
                }
            }
            final StoragePool selectedDataCenter = clusterModel.getDataCenter().getSelectedItem();
            clusterModel.getDataCenter().setIsChangable(selectedDataCenter == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
            if (!clusterModel.getManagementNetwork().getIsChangable()) {
                loadCurrentClusterManagementNetwork();
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#method_after
private void postInit() {
    getDescription().setEntity(getEntity().getDescription());
    getComment().setEntity(getEntity().getComment());
    initSpiceProxy();
    getFencingEnabledModel().setEntity(getEntity().getFencingPolicy().isFencingEnabled());
    getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
    getSkipFencingIfConnectivityBrokenEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfConnectivityBroken());
    getHostsWithBrokenConnectivityThreshold().setSelectedItem(getEntity().getFencingPolicy().getHostsWithBrokenConnectivityThreshold());
    setMemoryOverCommit(getEntity().getMaxVdsMemoryOverCommit());
    getCountThreadsAsCores().setEntity(getEntity().getCountThreadsAsCores());
    getEnableBallooning().setEntity(getEntity().isEnableBallooning());
    getEnableKsm().setEntity(getEntity().isEnableKsm());
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            List<StoragePool> dataCenters = (List<StoragePool>) result;
            clusterModel.getDataCenter().setItems(dataCenters);
            clusterModel.getDataCenter().setSelectedItem(null);
            final Guid dataCenterId = clusterModel.getEntity().getStoragePoolId();
            for (StoragePool dataCenter : dataCenters) {
                if (dataCenterId != null && dataCenter.getId().equals(dataCenterId)) {
                    clusterModel.getDataCenter().setSelectedItem(dataCenter);
                    break;
                }
            }
            final StoragePool selectedDataCenter = clusterModel.getDataCenter().getSelectedItem();
            clusterModel.getDataCenter().setIsChangeable(selectedDataCenter == null);
            clusterModel.setMigrateOnErrorOption(clusterModel.getEntity().getMigrateOnError());
            if (!clusterModel.getManagementNetwork().getIsChangable()) {
                loadCurrentClusterManagementNetwork();
            }
        }
    };
    AsyncDataProvider.getInstance().getDataCenterList(_asyncQuery);
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        } else if (sender == getArchitecture()) {
            architectureSelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        } else if (sender == getArchitecture()) {
            architectureSelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangeable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    if (getEnableGlusterService().getEntity() == Boolean.TRUE) {
        getSupportGluster37Features().setIsAvailable(getVersion().getSelectedItem().equals(Version.v3_5));
        getSupportGluster37Features().setIsChangable(!getIsEdit());
    }
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
    updateMigrationOptions();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getCompatibilityVersion();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.getInstance().isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getInstance().getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangeable(version.compareTo(Version.v3_3) >= 0);
    setRngSourcesCheckboxes(version);
    updateFencingPolicyContent(version);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangeable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
    updateMigrationOptions();
    refreshAdditionalClusterFeaturesList();
}
#end_block

#method_before
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsChangable(rngSupported);
    getRngHwrngSourceRequired().setIsChangable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
        getRngRandomSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
        getRngHwrngSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
    }
}
#method_after
private void setRngSourcesCheckboxes(Version ver) {
    boolean rngSupported = isRngSupportedForClusterVersion(ver);
    getRngRandomSourceRequired().setIsChangeable(rngSupported);
    getRngHwrngSourceRequired().setIsChangeable(rngSupported);
    String defaultRequiredRngSourcesCsv = defaultClusterRngSourcesCsv(ver);
    if (rngSupported) {
        getRngRandomSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.RANDOM.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.RANDOM));
        getRngHwrngSourceRequired().setEntity(getIsNew() ? defaultRequiredRngSourcesCsv.contains(VmRngDevice.Source.HWRNG.name().toLowerCase()) : getEntity().getRequiredRngSources().contains(VmRngDevice.Source.HWRNG));
    } else {
        // reset
        getRngRandomSourceRequired().setEntity(false);
        getRngHwrngSourceRequired().setEntity(false);
        getRngRandomSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
        getRngHwrngSourceRequired().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().rngNotSupportedByClusterCV());
    }
}
#end_block

#method_before
private void updateFencingPolicyContent(Version ver) {
    // skipFencingIfConnectivityBroken option is enabled when fencing is enabled for all cluster versions
    getSkipFencingIfConnectivityBrokenEnabled().setIsChangable(getFencingEnabledModel().getEntity());
    getHostsWithBrokenConnectivityThreshold().setIsChangable(getFencingEnabledModel().getEntity());
    if (ver == null) {
        if (!getFencingEnabledModel().getEntity()) {
            // fencing is disabled and cluster version not selected yet, so disable skipFencingIfSDActive
            getSkipFencingIfSDActiveEnabled().setIsChangable(false);
        }
    } else {
        // skipFencingIfSDActive is enabled for supported cluster level if fencing is not disabled
        boolean supported = AsyncDataProvider.getInstance().isSkipFencingIfSDActiveSupported(ver.getValue());
        getSkipFencingIfSDActiveEnabled().setIsChangable(supported && getFencingEnabledModel().getEntity());
        if (supported) {
            if (getEntity() == null) {
                // this can happen when creating new cluster and cluster dialog is shown
                getSkipFencingIfSDActiveEnabled().setEntity(true);
            } else {
                getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
            }
        } else {
            getSkipFencingIfSDActiveEnabled().setEntity(false);
        }
    }
}
#method_after
private void updateFencingPolicyContent(Version ver) {
    // skipFencingIfConnectivityBroken option is enabled when fencing is enabled for all cluster versions
    getSkipFencingIfConnectivityBrokenEnabled().setIsChangeable(getFencingEnabledModel().getEntity());
    getHostsWithBrokenConnectivityThreshold().setIsChangeable(getFencingEnabledModel().getEntity());
    if (ver == null) {
        if (!getFencingEnabledModel().getEntity()) {
            // fencing is disabled and cluster version not selected yet, so disable skipFencingIfSDActive
            getSkipFencingIfSDActiveEnabled().setIsChangeable(false);
        }
    } else {
        // skipFencingIfSDActive is enabled for supported cluster level if fencing is not disabled
        boolean supported = AsyncDataProvider.getInstance().isSkipFencingIfSDActiveSupported(ver.getValue());
        getSkipFencingIfSDActiveEnabled().setIsChangeable(supported && getFencingEnabledModel().getEntity());
        if (supported) {
            if (getEntity() == null) {
                // this can happen when creating new cluster and cluster dialog is shown
                getSkipFencingIfSDActiveEnabled().setEntity(true);
            } else {
                getSkipFencingIfSDActiveEnabled().setEntity(getEntity().getFencingPolicy().isSkipFencingIfSDActive());
            }
        } else {
            getSkipFencingIfSDActiveEnabled().setEntity(false);
        }
    }
}
#end_block

#method_before
@Override
public void setValue(List<T> value, boolean fireEvents) {
    List<T> selectedItems = getValue();
    if (value == selectedItems || (selectedItems != null && selectedItems.equals(value))) {
        return;
    }
    clearAllSelections();
    if (value == null) {
        return;
    }
    for (T currentvalue : value) {
        if (checkBoxes.containsKey(currentvalue)) {
            checkBoxes.get(currentvalue).setValue(true);
        }
    }
    if (fireEvents) {
        ValueChangeEvent.fire(this, value);
    }
}
#method_after
@Override
public void setValue(List<T> value, boolean fireEvents) {
    List<T> selectedItems = getValue();
    if (value == selectedItems || (selectedItems != null && value != null && ListUtils.listsEqual(selectedItems, value))) {
        return;
    }
    clearAllSelections();
    if (value == null) {
        return;
    }
    for (T currentvalue : value) {
        if (checkBoxes.containsKey(currentvalue)) {
            checkBoxes.get(currentvalue).setValue(true);
        }
    }
    if (fireEvents) {
        ValueChangeEvent.fire(this, value);
    }
}
#end_block

#method_before
private void showCheckBoxes(List<T> seletedItems) {
    for (Entry<T, CheckBox> currentEntry : checkBoxes.entrySet()) {
        wrapperPanel.add(currentEntry.getValue());
        if (seletedItems.contains(currentEntry.getKey())) {
            currentEntry.getValue().setValue(true, false);
        }
    }
}
#method_after
private void showCheckBoxes(List<T> seletedItems) {
    for (Entry<T, CheckBox> currentEntry : checkBoxes.entrySet()) {
        wrapperPanel.add(currentEntry.getValue());
        if (seletedItems.contains(currentEntry.getKey())) {
            currentEntry.getValue().setValue(true);
        }
    }
}
#end_block

#method_before
public void checkAndRemoveVolumeSnapshotSoftLimitAlert(final GlusterVolumeEntity volume) {
    if (!GlusterDBUtils.getInstance().isSoftLimitReached(volume.getId())) {
        AlertDirector.RemoveVolumeAlert(volume.getId(), AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED);
    }
}
#method_after
public void checkAndRemoveVolumeSnapshotSoftLimitAlert(final GlusterVolumeEntity volume) {
    if (!GlusterDBUtils.getInstance().isSoftLimitReached(volume.getId())) {
        AlertDirector.removeVolumeAlert(volume.getId(), AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED);
    }
}
#end_block

#method_before
public boolean isSoftLimitReached(Guid volumeId) {
    GlusterVolumeEntity volume = getGlusterVolumeDao().getById(volumeId);
    if (volume != null) {
        GlusterVolumeSnapshotConfig config = getGlusterVolumeSnapshotConfigDao().getConfigByClusterIdAndName(volume.getClusterId(), "snap-max-soft-limit");
        if (config != null) {
            // remove the % sign in the last
            String configValue = config.getParamValue().substring(0, config.getParamValue().length() - 1);
            int snapMaxSoftLimitPcnt = Integer.parseInt(configValue);
            int snapshotCount = volume.getSnapshotsCount();
            int snapMaxLimit = volume.getSnapMaxLimit();
            return snapshotCount >= (snapMaxLimit * snapMaxSoftLimitPcnt) / 100;
        }
    }
    return false;
}
#method_after
public boolean isSoftLimitReached(Guid volumeId) {
    GlusterVolumeEntity volume = getGlusterVolumeDao().getById(volumeId);
    if (volume != null) {
        GlusterVolumeSnapshotConfig config = getGlusterVolumeSnapshotConfigDao().getConfigByClusterIdAndName(volume.getClusterId(), "snap-max-soft-limit");
        if (config != null) {
            // remove the % sign in the last
            String configValue = StringUtils.removeEnd(config.getParamValue(), "%");
            int snapMaxSoftLimitPcnt = Integer.parseInt(configValue);
            int snapshotCount = volume.getSnapshotsCount();
            int snapMaxLimit = volume.getSnapMaxLimit();
            return snapshotCount >= (snapMaxLimit * snapMaxSoftLimitPcnt) / 100;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public List<AuditLog> getAllWithQuery(String query) {
    return jdbcTemplate.query(query, auditLogRowMapper);
}
#method_after
@Override
public List<AuditLog> getAllWithQuery(String query) {
    return getJdbcTemplate().query(query, auditLogRowMapper);
}
#end_block

#method_before
@Override
public int getTimeToWaitForNextPmOp(String vdsName, String event) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_name", vdsName).addValue("event", event).addValue("wait_for_sec", Config.getValue(ConfigValues.FenceQuietTimeBetweenOperationsInSec));
    Map<String, Object> dbResults = new SimpleJdbcCall(jdbcTemplate).withFunctionName("get_seconds_to_wait_before_pm_operation").execute(parameterSource);
    String resultKey = DbFacade.getInstance().getDbEngineDialect().getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Integer) dbResults.get(resultKey)).intValue() : 0;
}
#method_after
@Override
public int getTimeToWaitForNextPmOp(String vdsName, String event) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_name", vdsName).addValue("event", event).addValue("wait_for_sec", Config.getValue(ConfigValues.FenceQuietTimeBetweenOperationsInSec));
    Map<String, Object> dbResults = new SimpleJdbcCall(getJdbcTemplate()).withFunctionName("get_seconds_to_wait_before_pm_operation").execute(parameterSource);
    String resultKey = dbEngineDialect.getFunctionReturnKey();
    return dbResults.get(resultKey) != null ? ((Integer) dbResults.get(resultKey)).intValue() : 0;
}
#end_block

#method_before
private boolean pauseAndCreateSnapshotForGeoRepSessions() {
    if (georepSessions != null && georepSessions.size() > 0) {
        for (GlusterGeoRepSession session : georepSessions) {
            if (session.getStatus() != GeoRepSessionStatus.PAUSED) {
                final GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
                if (slaveVolume == null) {
                    // Continue to other geo-rep sessions and pause them for snapshot purpose
                    continue;
                }
                VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
                if (slaveUpServer == null) {
                    handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, "No up server found in slave cluster of geo-rep session");
                    setSucceeded(false);
                    return false;
                }
                // Pause the geo-rep session and create snapshot for remote volume
                VdcReturnValueBase sessionPauseRetVal = null;
                try (EngineLock lock = acquireEngineLock(slaveVolume.getId(), LockingGroup.GLUSTER_SNAPSHOT)) {
                    sessionPauseRetVal = runInternalAction(VdcActionType.PauseGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
                }
                if (sessionPauseRetVal != null && !sessionPauseRetVal.getSucceeded()) {
                    handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_PAUSE_FAILED, sessionPauseRetVal.getExecuteFailedMessages());
                    setSucceeded(false);
                    return false;
                } else {
                    // check if the snapshot soft limit reached for the volume and alert
                    getGlusterUtil().alertVolumeSnapshotSoftLimitReached(slaveVolume);
                    // Create snapshot for slave volume
                    VDSReturnValue snapCreationRetVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(slaveUpServer.getId(), session.getSlaveVolumeName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
                    if (!snapCreationRetVal.getSucceeded()) {
                        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, snapCreationRetVal.getVdsError().getMessage());
                        setSucceeded(false);
                        return false;
                    } else {
                        // Persist the snapshot details
                        GlusterVolumeSnapshotEntity slaveVolumeSnapshot = (GlusterVolumeSnapshotEntity) snapCreationRetVal.getReturnValue();
                        slaveVolumeSnapshot.setClusterId(slaveVolume.getClusterId());
                        slaveVolumeSnapshot.setVolumeId(slaveVolume.getId());
                        slaveVolumeSnapshot.setDescription(snapshot.getDescription());
                        slaveVolumeSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
                        getDbFacade().getGlusterVolumeSnapshotDao().save(slaveVolumeSnapshot);
                        // check if the snapshot soft limit reached now for the volume and alert
                        getGlusterUtil().alertVolumeSnapshotSoftLimitReached(slaveVolume);
                    }
                }
            }
        }
    }
    return true;
}
#method_after
private boolean pauseAndCreateSnapshotForGeoRepSessions() {
    if (georepSessions != null && georepSessions.size() > 0) {
        for (GlusterGeoRepSession session : georepSessions) {
            if (session.getStatus() != GeoRepSessionStatus.PAUSED) {
                final GlusterVolumeEntity slaveVolume = getDbFacade().getGlusterVolumeDao().getById(session.getSlaveVolumeId());
                if (slaveVolume == null) {
                    // Continue to other geo-rep sessions and pause them for snapshot purpose
                    continue;
                }
                VDS slaveUpServer = ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId());
                if (slaveUpServer == null) {
                    handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, "No up server found in slave cluster of geo-rep session");
                    setSucceeded(false);
                    return false;
                }
                // Pause the geo-rep session and create snapshot for remote volume
                VdcReturnValueBase sessionPauseRetVal = null;
                try (EngineLock lock = acquireEngineLock(slaveVolume.getId(), LockingGroup.GLUSTER_SNAPSHOT)) {
                    sessionPauseRetVal = runInternalAction(VdcActionType.PauseGlusterVolumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(getGlusterVolumeId(), session.getId()));
                }
                if (sessionPauseRetVal != null && !sessionPauseRetVal.getSucceeded()) {
                    handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_PAUSE_FAILED, sessionPauseRetVal.getExecuteFailedMessages());
                    setSucceeded(false);
                    return false;
                } else {
                    // Create snapshot for slave volume
                    VDSReturnValue snapCreationRetVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(slaveUpServer.getId(), session.getSlaveVolumeName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
                    if (!snapCreationRetVal.getSucceeded()) {
                        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, snapCreationRetVal.getVdsError().getMessage());
                        setSucceeded(false);
                        return false;
                    } else {
                        // Persist the snapshot details
                        GlusterVolumeSnapshotEntity slaveVolumeSnapshot = (GlusterVolumeSnapshotEntity) snapCreationRetVal.getReturnValue();
                        slaveVolumeSnapshot.setClusterId(slaveVolume.getClusterId());
                        slaveVolumeSnapshot.setVolumeId(slaveVolume.getId());
                        slaveVolumeSnapshot.setDescription(snapshot.getDescription());
                        slaveVolumeSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
                        getDbFacade().getGlusterVolumeSnapshotDao().save(slaveVolumeSnapshot);
                        // check if the snapshot soft limit reached now for the volume and alert
                        getGlusterUtil().alertVolumeSnapshotSoftLimitReached(slaveVolume);
                    }
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    // Pause geo-rep sessions and create snapshot for slave volumes
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            return pauseAndCreateSnapshotForGeoRepSessions();
        }
    });
    if (!tranRetVal) {
        return;
    }
    // check if the snapshot soft limit reached for the volume and alert
    getGlusterUtil().alertVolumeSnapshotSoftLimitReached(getGlusterVolume());
    // Create snapshot for the master volume
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(upServer.getId(), volume.getName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
    setSucceeded(retVal.getSucceeded());
    if (!retVal.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, retVal.getVdsError().getMessage());
    } else {
        GlusterVolumeSnapshotEntity createdSnapshot = (GlusterVolumeSnapshotEntity) retVal.getReturnValue();
        createdSnapshot.setClusterId(snapshot.getClusterId());
        createdSnapshot.setVolumeId(snapshot.getVolumeId());
        createdSnapshot.setDescription(snapshot.getDescription());
        createdSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
        getDbFacade().getGlusterVolumeSnapshotDao().save(createdSnapshot);
        // check if the snapshot soft limit reached now for the volume and alert
        getGlusterUtil().alertVolumeSnapshotSoftLimitReached(getGlusterVolume());
    }
    // Resume the snapshot sessions
    List<GlusterGeoRepSession> updatedGeoRepSessions = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (updatedGeoRepSessions != null && updatedGeoRepSessions.size() > 0) {
        for (GlusterGeoRepSession session : updatedGeoRepSessions) {
            if (session.getStatus() == GeoRepSessionStatus.PAUSED) {
                try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
                    VdcReturnValueBase sessionResumeRetVal = runInternalAction(VdcActionType.ResumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(volume.getId(), session.getId()));
                    if (!sessionResumeRetVal.getSucceeded()) {
                        handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_RESUME_FAILED, sessionResumeRetVal.getExecuteFailedMessages());
                        setSucceeded(false);
                        return;
                    }
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    // Pause geo-rep sessions and create snapshot for slave volumes
    Boolean tranRetVal = TransactionSupport.executeInNewTransaction(new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            return pauseAndCreateSnapshotForGeoRepSessions();
        }
    });
    if (!tranRetVal) {
        return;
    }
    // Create snapshot for the master volume
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.CreateGlusterVolumeSnapshot, new CreateGlusterVolumeSnapshotVDSParameters(upServer.getId(), volume.getName(), snapshot.getSnapshotName(), snapshot.getDescription(), force));
    setSucceeded(retVal.getSucceeded());
    if (!retVal.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_CREATE_FAILED, retVal.getVdsError().getMessage());
    } else {
        GlusterVolumeSnapshotEntity createdSnapshot = (GlusterVolumeSnapshotEntity) retVal.getReturnValue();
        createdSnapshot.setClusterId(snapshot.getClusterId());
        createdSnapshot.setVolumeId(snapshot.getVolumeId());
        createdSnapshot.setDescription(snapshot.getDescription());
        createdSnapshot.setStatus(GlusterSnapshotStatus.DEACTIVATED);
        getDbFacade().getGlusterVolumeSnapshotDao().save(createdSnapshot);
        addCustomValue(GlusterConstants.VOLUME_SNAPSHOT_NAME, createdSnapshot.getSnapshotName());
        // check if the snapshot soft limit reached now for the volume and alert
        getGlusterUtil().alertVolumeSnapshotSoftLimitReached(getGlusterVolume());
    }
    // Resume the snapshot sessions
    List<GlusterGeoRepSession> updatedGeoRepSessions = getDbFacade().getGlusterGeoRepDao().getGeoRepSessions(volume.getId());
    if (updatedGeoRepSessions != null && updatedGeoRepSessions.size() > 0) {
        for (GlusterGeoRepSession session : updatedGeoRepSessions) {
            if (session.getStatus() == GeoRepSessionStatus.PAUSED) {
                try (EngineLock lock = acquireGeoRepSessionLock(session.getId())) {
                    VdcReturnValueBase sessionResumeRetVal = runInternalAction(VdcActionType.ResumeGeoRepSession, new GlusterVolumeGeoRepSessionParameters(volume.getId(), session.getId()));
                    if (!sessionResumeRetVal.getSucceeded()) {
                        handleVdsErrors(AuditLogType.GLUSTER_VOLUME_GEO_REP_RESUME_FAILED, sessionResumeRetVal.getExecuteFailedMessages());
                        setSucceeded(false);
                        return;
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void testRemoveAllForVds() throws Exception {
    dao.removeAllForVds(VDS_ID, true);
    List<AuditLog> result = dao.getAll(null, false);
    assertEquals(6, result.size());
}
#method_after
@Test
public void testRemoveAllForVds() throws Exception {
    dao.removeAllForVds(VDS_ID, true);
    List<AuditLog> result = dao.getAll(null, false);
    assertEquals(7, result.size());
}
#end_block

#method_before
private int getAlertCount(AuditLog entry, List<AuditLog> results) {
    int count = 0;
    if (results != null) {
        for (AuditLog al : results) {
            if (al.getSeverity() == entry.getSeverity() && al.getVdsId().equals(entry.getVdsId()) && al.getLogType() == entry.getLogType()) {
                count++;
            }
        }
    }
    return count;
}
#method_after
private int getAlertCount(AuditLog entry, List<AuditLog> results) {
    int count = 0;
    if (results != null) {
        for (AuditLog al : results) {
            if (al.getSeverity() == entry.getSeverity() && al.getVdsId() != null && al.getVdsId().equals(entry.getVdsId()) && al.getLogType() == entry.getLogType()) {
                count++;
            }
        }
    }
    return count;
}
#end_block

#method_before
@Test
public void testRemoveAllOfTypeForVolume() {
    List<AuditLog> entries = dao.getByVolumeIdAndType(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    assertEquals(1, entries.size());
    dao.removeAllOfTypeForVolume(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    List<AuditLog> entries1 = dao.getByVolumeIdAndType(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    assertEquals(1, entries1.size());
    assertEquals(entries1.get(0).getLogType(), AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED);
}
#method_after
@Test
public void testRemoveAllOfTypeForVolume() {
    List<AuditLog> entries = dao.getByVolumeIdAndType(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    assertEquals(1, entries.size());
    dao.removeAllOfTypeForVolume(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    List<AuditLog> entries1 = dao.getByVolumeIdAndType(GLUSTER_VOLUME_ID, AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED.getValue());
    assertEquals(1, entries1.size());
    assertEquals(AuditLogType.GLUSTER_VOLUME_SNAPSHOT_SOFT_LIMIT_REACHED, entries1.get(0).getLogType());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.Disk>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    QueryIdResolver<Guid> resolver = new QueryIdResolver<Guid>(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class);
    DiskStatisticalQuery query = new DiskStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<Disk, org.ovirt.engine.core.common.businessentities.storage.Disk>(entityType, guid, query));
}
#end_block

#method_before
@Override
public Response copy(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = asGuid(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(imageId, sourceStorageDomainId, storageDomainId, ImageOperation.Copy);
    params.setImageGroupID(asGuid(disk.getId()));
    if (action.isSetName() && !StringUtils.isEmpty(action.getName())) {
        params.setNewAlias(action.getName());
    }
    return doAction(VdcActionType.MoveOrCopyDisk, params, action);
}
#method_after
@Override
public Response copy(Action action) {
    validateParameters(action, "storageDomain.id|name");
    Guid storageDomainId = getStorageDomainId(action);
    Disk disk = get();
    Guid imageId = asGuid(disk.getImageId());
    Guid sourceStorageDomainId = getSourceStorageDomainId(disk);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(imageId, sourceStorageDomainId, storageDomainId, ImageOperation.Copy);
    params.setImageGroupID(asGuid(disk.getId()));
    Disk actionDisk = action.getDisk();
    if (actionDisk != null) {
        String name = actionDisk.getName();
        String alias = actionDisk.getAlias();
        if (name != null && !StringUtils.isEmpty(name)) {
            params.setNewAlias(name);
        } else if (alias != null && !StringUtils.isEmpty(alias)) {
            params.setNewAlias(alias);
        }
    }
    return doAction(VdcActionType.MoveOrCopyDisk, params, action);
}
#end_block

#method_before
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.Disk entity) {
    // Populate the references to the VMs that are using this disk:
    List<org.ovirt.engine.core.common.businessentities.VM> vms = new ArrayList<>(1);
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVmsByDiskGuid, new IdQueryParameters(entity.getId()));
    if (result.getSucceeded()) {
        Map<Boolean, List<org.ovirt.engine.core.common.businessentities.VM>> map = result.getReturnValue();
        if (MapUtils.isNotEmpty(map)) {
            for (List<org.ovirt.engine.core.common.businessentities.VM> list : map.values()) {
                vms.addAll(list);
            }
        }
    }
    if (CollectionUtils.isNotEmpty(vms)) {
        VMs modelVms = new VMs();
        for (org.ovirt.engine.core.common.businessentities.VM vm : vms) {
            VM modelVm = new VM();
            modelVm.setId(vm.getId().toString());
            modelVms.getVMs().add(modelVm);
        }
        model.setVms(modelVms);
    }
    return model;
}
#method_after
@Override
protected Disk doPopulate(Disk model, org.ovirt.engine.core.common.businessentities.storage.Disk entity) {
    // Populate the references to the VMs that are using this disk:
    List<org.ovirt.engine.core.common.businessentities.VM> vms = new ArrayList<>(1);
    VdcQueryReturnValue result = runQuery(VdcQueryType.GetVmsByDiskGuid, new IdQueryParameters(entity.getId()));
    if (result.getSucceeded()) {
        Map<Boolean, List<org.ovirt.engine.core.common.businessentities.VM>> map = result.getReturnValue();
        if (MapUtils.isNotEmpty(map)) {
            for (List<org.ovirt.engine.core.common.businessentities.VM> list : map.values()) {
                vms.addAll(list);
            }
        }
    }
    if (CollectionUtils.isNotEmpty(vms)) {
        VMs modelVms = new VMs();
        for (org.ovirt.engine.core.common.businessentities.VM vm : vms) {
            VM modelVm = new VM();
            modelVm.setId(vm.getId().toString());
            modelVms.getVMs().add(modelVm);
        }
        model.setVms(modelVms);
    }
    return model;
}
#end_block

#method_before
private void setDetailList(final HostInterfaceListModel hostInterfaceListModel, final HostHardwareGeneralModel hostHardwareGeneralModel, final HostHooksListModel hostHooksListModel, final PermissionListModel<VDS> permissionListModel) {
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    List<HasEntity<VDS>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(hostHardwareGeneralModel);
    list.add(getHostVmListModel());
    list.add(hostInterfaceListModel);
    list.add(getHostEventListModel());
    list.add(hostHooksListModel);
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(getGlusterStorageDeviceListModel());
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final HostInterfaceListModel hostInterfaceListModel, final HostHardwareGeneralModel hostHardwareGeneralModel, final HostHooksListModel hostHooksListModel, final PermissionListModel<VDS> permissionListModel, final HostDeviceListModel hostDeviceListModel) {
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    List<HasEntity<VDS>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(hostHardwareGeneralModel);
    list.add(getHostVmListModel());
    list.add(hostInterfaceListModel);
    list.add(hostDeviceListModel);
    list.add(getHostEventListModel());
    list.add(hostHooksListModel);
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(getGlusterStorageDeviceListModel());
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void upgradeHost(VDS host) {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(constants.upgradeHostsTitle());
    model.setHelpTag(HelpTag.upgrade_host);
    // $NON-NLS-1$
    model.setHashName("upgrade_host");
    if (host.getVmCount() > 0) {
        model.setMessage(constants.areYouSureYouWantToUpgradeTheFollowingHostWithRunningVmsMsg());
    } else {
        model.setMessage(constants.areYouSureYouWantToUpgradeTheFollowingHostMsg());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnUpgrade", this);
    tempVar.setTitle(constants.ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(constants.cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void upgradeHost(VDS host) {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(constants.upgradeHostsTitle());
    model.setHelpTag(HelpTag.upgrade_host);
    model.setHashName(HelpTag.upgrade_host.name);
    if (host.getVmCount() > 0) {
        model.setMessage(constants.areYouSureYouWantToUpgradeTheFollowingHostWithRunningVmsMsg());
    } else {
        model.setMessage(constants.areYouSureYouWantToUpgradeTheFollowingHostMsg());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnUpgrade", this);
    tempVar.setTitle(constants.ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(constants.cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void upgradeOvirtNode(final VDS host) {
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.upgrade_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getActivateHostAfterInstall().setEntity(true);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangeable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            if (host.getHostOs() == null) {
                model.setMessage(ConstantsManager.getInstance().getConstants().hostMustBeInstalledBeforeUpgrade());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#method_after
private void upgradeOvirtNode(final VDS host) {
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.upgrade_host);
    model.setHashName(HelpTag.upgrade_host.name);
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getActivateHostAfterInstall().setEntity(true);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangeable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            if (host.getHostOs() == null) {
                model.setMessage(ConstantsManager.getInstance().getConstants().hostMustBeInstalledBeforeUpgrade());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#end_block

#method_before
private void onUpgradeHost(final VDS host) {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    UpgradeHostParameters params = new UpgradeHostParameters(host.getId());
    invokeHostUpgrade(params);
}
#method_after
private void onUpgradeHost(final VDS host) {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    setConfirmWindow(null);
    UpgradeHostParameters params = new UpgradeHostParameters(host.getId());
    invokeHostUpgrade(params);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    if (getSelectedItem() != null) {
        updateAlerts();
    }
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    updateAlerts();
}
#end_block

#method_before
private void updateAlerts() {
    final VDS vds = getSelectedItem();
    if (vds.getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                @SuppressWarnings("unchecked")
                List<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (!isos.isEmpty()) {
                    // $NON-NLS-1$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    generalModel.setHasUpgradeAlert(isos, hostOsInfo);
                    setUpgradeActionStatus(vds);
                }
                generalModel.setHasAnyAlert();
            }
        }), vds.getId());
    } else if (vds.getVdsType() == VDSType.VDS) {
        setUpgradeActionStatus(vds);
        generalModel.setHasUpgradeAlert(vds.isUpdateAvailable());
    }
}
#method_after
private void updateAlerts() {
    final VDS host = getSelectedItem();
    if (host == null) {
        return;
    }
    setUpgradeActionStatus(host);
    generalModel.setHasUpgradeAlert(host.isUpdateAvailable());
    generalModel.setHasAnyAlert();
}
#end_block

#method_before
private boolean singleHostSelected(ArrayList<VDS> items) {
    return items.size() == 1 && items.get(0) instanceof VDS;
}
#method_after
private boolean singleHostSelected(List<VDS> items) {
    return items.size() == 1 && items.get(0) instanceof VDS;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("\n");
    builder.append(super.toString());
    builder.append("\n");
    if (mInfo != null) {
        XmlRpcObjectDescriptor.toStringBuilder(mInfo, builder);
    }
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("\n");
    builder.append(super.toString());
    builder.append("\n");
    XmlRpcObjectDescriptor.toStringBuilder(getInfo(), builder);
    return builder.toString();
}
#end_block

#method_before
@Override
protected StatusForXmlRpc getReturnStatus() {
    return imageInfoReturn.mStatus;
}
#method_after
@Override
protected StatusForXmlRpc getReturnStatus() {
    return imageInfoReturn.getXmlRpcStatus();
}
#end_block

#method_before
@Override
public String toString() {
    return getClass().getSimpleName() + " [mStatus=" + mStatus + "]";
}
#method_after
@Override
public String toString() {
    return getClass().getSimpleName() + " [mStatus=" + getXmlRpcStatus() + "]";
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && (getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0 || getCommandEntityDao().getCommandIdsByEntity(getParameters().getStorageDomainId()).size() > 0)) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() != StorageDomainStatus.Inactive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // For block domains, synchronize LUN details comprising the storage domain with the DB
        if (statusChanged && data.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(data.getId(), getCurrentVdsId());
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = data.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    boolean spaceThresholdMet = freeDiskInGB < Config.<Integer>getValue(ConfigValues.FreeSpaceCriticalLowInGB);
                    boolean percentThresholdMet = freePercent < Config.<Integer>getValue(ConfigValues.FreeSpaceLow);
                    if (spaceThresholdMet && percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    } else {
                        if (spaceThresholdMet || percentThresholdMet) {
                            type = AuditLogType.IRS_DISK_SPACE_LOW;
                        }
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    new AuditLogDirector().log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", data.getId());
    }
}
#method_after
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getMasterDomainVersion()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getMasterDomainVersion(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() != StorageDomainStatus.Inactive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.Inactive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // For block domains, synchronize LUN details comprising the storage domain with the DB
        if (statusChanged && data.getStatus() == StorageDomainStatus.Active && storage_domain.getStorageType().isBlockDomain()) {
            ResourceManager.getInstance().getEventListener().syncLunsInfoForBlockStorageDomain(data.getId(), getCurrentVdsId());
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.Inactive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                AuditLogType type = AuditLogType.UNASSIGNED;
                Integer freeDiskInGB = data.getStorageDynamicData().getAvailableDiskSize();
                if (freeDiskInGB != null) {
                    if (freePercent < domainFromDb.getWarningLowSpaceIndicator()) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                    if (freeDiskInGB < domainFromDb.getCriticalSpaceActionBlocker()) {
                        // Note, if both conditions are met, only IRS_DISK_SPACE_LOW_ERROR will be shown
                        type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    new AuditLogDirector().log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            new AuditLogDirector().log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.error("Unrecognized alert for domain {}(id = {}): {}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debug("The domain with id '{}' was not found in DB", data.getId());
    }
}
#end_block

#method_before
public EventQueue getEventQueue() {
    return eventQueue;
}
#method_after
protected EventQueue getEventQueue() {
    return eventQueue;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean removedStatelessSnapshot = detachUsers();
    if (!removedStatelessSnapshot) {
        // If we are dealing with a prestarted Vm or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand
        removeVmStatelessImages();
    }
    QuotaManager.getInstance().rollbackQuotaByVmId(getVmId());
    removeStatelessVmUnmanagedDevices();
    applyNextRunConfiguration();
}
#method_after
@Override
protected void executeCommand() {
    boolean removedStatelessSnapshot = detachUsers();
    if (!removedStatelessSnapshot) {
        // If we are dealing with a prestarted Vm or a regular Vm - clean stateless images
        // Otherwise this was already done in DetachUserFromVmFromPoolCommand
        removeVmStatelessImages();
    }
    QuotaManager.getInstance().rollbackQuotaByVmId(getVmId());
    removeStatelessVmUnmanagedDevices();
    boolean vmHasDirectPassthroughDevices = releaseUsedHostDevices();
    Guid hostId = cleanupVfs();
    refreshHostIfNeeded(hostId == null ? (vmHasDirectPassthroughDevices ? getVm().getDedicatedVmForVds() : null) : hostId);
    applyNextRunConfiguration();
}
#end_block

#method_before
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("VmHandler::getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("VmHandler::getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#method_after
public static List<VmDeviceUpdate> getVmDevicesFieldsToUpdateOnNextRun(Guid vmId, VMStatus vmStatus, Object objectWithEditableDeviceFields) {
    List<VmDeviceUpdate> fieldList = new ArrayList<>();
    if (objectWithEditableDeviceFields == null) {
        return fieldList;
    }
    List<Pair<EditableDeviceOnVmStatusField, Field>> pairList = BaseHandler.extractAnnotatedFields(EditableDeviceOnVmStatusField.class, objectWithEditableDeviceFields.getClass());
    for (Pair<EditableDeviceOnVmStatusField, Field> pair : pairList) {
        EditableDeviceOnVmStatusField annotation = pair.getFirst();
        Field field = pair.getSecond();
        field.setAccessible(true);
        if (VmHandler.isUpdateValidForVmDevice(field.getName(), vmStatus)) {
            // field may be updated on the current run, so not including for the next run
            continue;
        }
        try {
            Object value = field.get(objectWithEditableDeviceFields);
            if (value instanceof Boolean) {
                addDeviceUpdateOnNextRun(vmId, annotation, null, value, fieldList);
            } else if (value instanceof Map) {
                Map<?, ?> map = (Map<?, ?>) value;
                for (Map.Entry<?, ?> entry : map.entrySet()) {
                    boolean success = addDeviceUpdateOnNextRun(vmId, annotation, entry.getKey(), entry.getValue(), fieldList);
                    if (!success)
                        break;
                }
            } else {
                log.warn("getVmDevicesFieldsToUpdateOnNextRun: Unsupported field type: " + value.getClass().getName());
            }
        } catch (IllegalAccessException | ClassCastException e) {
            log.warn("getVmDevicesFieldsToUpdateOnNextRun: Reflection error");
            log.debug("Original exception was:", e);
        }
    }
    return fieldList;
}
#end_block

#method_before
private static boolean addDeviceUpdateOnNextRun(Guid vmId, EditableDeviceOnVmStatusField annotation, Object key, Object value, List<VmDeviceUpdate> updates) {
    VmDeviceGeneralType generalType = annotation.generalType();
    VmDeviceType type = annotation.type();
    if (key != null) {
        VmDeviceGeneralType keyGeneralType = VmDeviceGeneralType.UNKNOWN;
        VmDeviceType keyType = VmDeviceType.UNKNOWN;
        if (key instanceof VmDeviceGeneralType) {
            keyGeneralType = (VmDeviceGeneralType) key;
        } else if (key instanceof VmDeviceType) {
            keyType = (VmDeviceType) key;
        } else if (key instanceof GraphicsType) {
            keyType = ((GraphicsType) key).getCorrespondingDeviceType();
        } else {
            log.warn("VmHandler::addDeviceUpdateOnNextRun: Unsupported map key type: " + key.getClass().getName());
            return false;
        }
        if (keyGeneralType != VmDeviceGeneralType.UNKNOWN) {
            generalType = keyGeneralType;
        }
        if (keyType != VmDeviceType.UNKNOWN) {
            type = keyType;
        }
    }
    // if device type is set to unknown, search by general type only
    // because some devices have more than one type, like sound can be ac97/ich6
    String typeName = type != VmDeviceType.UNKNOWN ? type.getName() : null;
    if (value == null) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, false)) {
            updates.add(new VmDeviceUpdate(generalType, type, annotation.isReadOnly(), false));
        }
    } else if (value instanceof Boolean) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (Boolean) value)) {
            updates.add(new VmDeviceUpdate(annotation, (Boolean) value));
        }
    } else if (value instanceof VmDevice) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (VmDevice) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, annotation.isReadOnly(), (VmDevice) value));
        }
    } else {
        log.warn("VmHandler::addDeviceUpdateOnNextRun: Unsupported value type: " + value.getClass().getName());
        return false;
    }
    return true;
}
#method_after
private static boolean addDeviceUpdateOnNextRun(Guid vmId, EditableDeviceOnVmStatusField annotation, Object key, Object value, List<VmDeviceUpdate> updates) {
    VmDeviceGeneralType generalType = annotation.generalType();
    VmDeviceType type = annotation.type();
    if (key != null) {
        VmDeviceGeneralType keyGeneralType = VmDeviceGeneralType.UNKNOWN;
        VmDeviceType keyType = VmDeviceType.UNKNOWN;
        if (key instanceof VmDeviceGeneralType) {
            keyGeneralType = (VmDeviceGeneralType) key;
        } else if (key instanceof VmDeviceType) {
            keyType = (VmDeviceType) key;
        } else if (key instanceof GraphicsType) {
            keyType = ((GraphicsType) key).getCorrespondingDeviceType();
        } else {
            log.warn("addDeviceUpdateOnNextRun: Unsupported map key type: " + key.getClass().getName());
            return false;
        }
        if (keyGeneralType != VmDeviceGeneralType.UNKNOWN) {
            generalType = keyGeneralType;
        }
        if (keyType != VmDeviceType.UNKNOWN) {
            type = keyType;
        }
    }
    // if device type is set to unknown, search by general type only
    // because some devices have more than one type, like sound can be ac97/ich6
    String typeName = type != VmDeviceType.UNKNOWN ? type.getName() : null;
    if (value == null) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, false)) {
            updates.add(new VmDeviceUpdate(generalType, type, annotation.isReadOnly(), false));
        }
    } else if (value instanceof Boolean) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (Boolean) value)) {
            updates.add(new VmDeviceUpdate(annotation, (Boolean) value));
        }
    } else if (value instanceof VmDevice) {
        if (VmDeviceUtils.vmDeviceChanged(vmId, generalType, typeName, (VmDevice) value)) {
            updates.add(new VmDeviceUpdate(generalType, type, annotation.isReadOnly(), (VmDevice) value));
        }
    } else {
        log.warn("addDeviceUpdateOnNextRun: Unsupported value type: " + value.getClass().getName());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public VDS getValue(S object) {
    if (object instanceof VDS) {
        return (VDS) object;
    }
    if (object instanceof PairQueryable) {
        if (((PairQueryable<?, ?>) object).getSecond() instanceof VDS) {
            return (VDS) ((PairQueryable<?, ?>) object).getSecond();
        }
    }
    return null;
}
#method_after
@Override
public VDS getValue(S object) {
    if (object instanceof VDS) {
        return (VDS) object;
    }
    return null;
}
#end_block

#method_before
@Override
public void render(Context context, VDS host, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided or if no updates are available:
    if (host == null || !host.isUpdateAvailable()) {
        return;
    }
    ImageResource statusImage = resources.updateAvailableImage();
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(statusImageHtml);
    // $NON-NLS-1$ //$NON-NLS-2$
    sb.appendHtmlConstant("<div id=\"" + id + "\" style=\"text-align: center;\">");
    // $NON-NLS-1$
    sb.appendHtmlConstant("</div>");
}
#method_after
@Override
public void render(Context context, VDS host, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no host is provided or if no updates are available:
    if (host == null || !host.isUpdateAvailable()) {
        return;
    }
    ImageResource statusImage = resources.updateAvailableImage();
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(templates.hostAdditionalStatusIcon(id, statusImageHtml));
}
#end_block

#method_before
public void cancel() {
}
#method_after
protected void cancel() {
}
#end_block

#method_before
public void postAction() {
}
#method_after
protected void postAction() {
}
#end_block

#method_before
protected String getVdsSearchString(final MoveHost moveHost) {
    // $NON-NLS-1$
    StringBuilder buf = new StringBuilder("Host: ");
    int i = 0;
    for (MoveHostData hostData : moveHost.getSelectedHosts()) {
        if (i > 0) {
            // $NON-NLS-1$
            buf.append(" or ");
        }
        // $NON-NLS-1$
        buf.append("name = ");
        buf.append(hostData.getEntity().getName());
        i++;
    }
    return buf.toString();
}
#method_after
protected String getVdsSearchString(final MoveHost moveHost) {
    // $NON-NLS-1$
    StringBuilder buf = new StringBuilder("Host: ");
    for (MoveHostData hostData : moveHost.getSelectedHosts()) {
        if ((buf.length()) > 6) {
            // $NON-NLS-1$
            buf.append(" or ");
        }
        // $NON-NLS-1$
        buf.append("name = ");
        buf.append(hostData.getEntity().getName());
    }
    return buf.toString();
}
#end_block

#method_before
protected void checkVdsClusterChangeSucceeded(final GuideModel guideModel, final String searchStr, final ArrayList<VdcActionParametersBase> changeVdsParameterList, final ArrayList<VdcActionParametersBase> activateVdsParameterList) {
    final Map<Guid, Guid> hostClusterIdMap = new HashMap<>();
    for (VdcActionParametersBase param : changeVdsParameterList) {
        hostClusterIdMap.put(((ChangeVDSClusterParameters) param).getVdsId(), ((ChangeVDSClusterParameters) param).getClusterId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (!host.getVdsGroupId().equals(hostClusterIdMap.get(host.getId()))) {
                    succeeded = false;
                }
            }
            if (!succeeded) {
                guideModel.getWindow().stopProgress();
                guideModel.cancel();
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostChangeClusterTimeOut());
            } else {
                activateHostsAfterClusterChange(guideModel, searchStr, activateVdsParameterList);
            }
        }
    }));
}
#method_after
protected void checkVdsClusterChangeSucceeded(final GuideModel guideModel, final String searchStr, final List<VdcActionParametersBase> changeVdsParameterList, final List<VdcActionParametersBase> activateVdsParameterList) {
    final Map<Guid, Guid> hostClusterIdMap = new HashMap<>();
    for (VdcActionParametersBase param : changeVdsParameterList) {
        hostClusterIdMap.put(((ChangeVDSClusterParameters) param).getVdsId(), ((ChangeVDSClusterParameters) param).getClusterId());
    }
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (!host.getVdsGroupId().equals(hostClusterIdMap.get(host.getId()))) {
                    succeeded = false;
                }
            }
            if (!succeeded) {
                guideModel.getWindow().stopProgress();
                guideModel.cancel();
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostChangeClusterTimeOut());
            } else {
                activateHostsAfterClusterChange(guideModel, searchStr, activateVdsParameterList);
            }
        }
    }));
}
#end_block

#method_before
protected void activateHostsAfterClusterChange(final GuideModel guideModel, final String searchStr, final ArrayList<VdcActionParametersBase> activateVdsParameterList) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, activateVdsParameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Timer timer = new Timer() {

                public void run() {
                    checkVdsActivateSucceeded(guideModel, searchStr);
                }
            };
            // Execute the timer to expire 5 seconds in the future
            timer.schedule(5000);
        }
    }, this);
}
#method_after
protected void activateHostsAfterClusterChange(final GuideModel guideModel, final String searchStr, final List<VdcActionParametersBase> activateVdsParameterList) {
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, activateVdsParameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            Timer timer = new Timer() {

                public void run() {
                    checkVdsActivateSucceeded(guideModel, searchStr);
                }
            };
            // Execute the timer to expire 5 seconds in the future
            timer.schedule(5000);
        }
    }, this);
}
#end_block

#method_before
protected void checkVdsActivateSucceeded(final GuideModel guideModel, final String searchStr) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (host.getStatus() != VDSStatus.Up) {
                    succeeded = false;
                }
            }
            guideModel.getWindow().stopProgress();
            guideModel.cancel();
            if (succeeded) {
                guideModel.postAction();
            } else {
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostActivationTimeOut());
            }
        }
    }));
}
#method_after
protected void checkVdsActivateSucceeded(final GuideModel guideModel, final String searchStr) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(searchStr, SearchType.VDS), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<VDS> hosts = ((VdcQueryReturnValue) returnValue).getReturnValue();
            boolean succeeded = true;
            for (VDS host : hosts) {
                if (host.getStatus() != VDSStatus.Up) {
                    succeeded = false;
                }
            }
            guideModel.getWindow().stopProgress();
            guideModel.cancel();
            if (succeeded) {
                guideModel.postAction();
            } else {
                errorPopupManager.show(ConstantsManager.getInstance().getConstants().hostActivationTimeOut());
            }
        }
    }));
}
#end_block

#method_before
private void updateAddAndSelectHostAvailability(ArrayList<VDS> hosts, ArrayList<VDS> availableHosts) {
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    if (hosts.isEmpty()) {
        addHostAction.setTitle(DataCenterConfigureHostsAction);
        getCompulsoryActions().add(addHostAction);
    } else {
        addHostAction.setTitle(DataCenterAddAnotherHostAction);
        getOptionalActions().add(addHostAction);
    }
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
}
#method_after
private void updateAddAndSelectHostAvailability(ArrayList<VDS> hosts, ArrayList<VDS> availableHosts) {
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("AddHost", this);
    tempVar.setIsExecutionAllowed(clusters.size() > 0);
    UICommand addHostAction = tempVar;
    if (hosts.isEmpty()) {
        addHostAction.setTitle(DataCenterConfigureHostsAction);
        getCompulsoryActions().add(addHostAction);
    } else {
        addHostAction.setTitle(DataCenterAddAnotherHostAction);
        getOptionalActions().add(addHostAction);
    }
    // Select host action.
    // $NON-NLS-1$
    UICommand selectHostAction = new UICommand("SelectHost", this);
    // If now compatible hosts are found - disable the select host button
    selectHostAction.setIsChangeable(availableHosts.size() > 0);
    selectHostAction.setIsExecutionAllowed(availableHosts.size() > 0);
    if (clusters.size() > 0) {
        if (hosts.isEmpty()) {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getCompulsoryActions().add(selectHostAction);
        } else {
            selectHostAction.setTitle(DataCenterSelectHostsAction);
            getOptionalActions().add(selectHostAction);
        }
    }
}
#end_block

#method_before
private void addStorageInternal(String title, StorageDomainType type) {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(title);
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters, getEntity());
    model.getDataCenter().setIsChangable(false);
    List<IStorageModel> items = null;
    if (type == StorageDomainType.Data) {
        items = AsyncDataProvider.getInstance().getDataStorageModels();
    } else if (type == StorageDomainType.ISO) {
        items = AsyncDataProvider.getInstance().getIsoStorageModels();
    }
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand tempVar6 = UICommand.createDefaultOkUiCommand("OnAddStorage", this);
    model.getCommands().add(tempVar6);
    // $NON-NLS-1$
    UICommand tempVar7 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar7);
}
#method_after
private void addStorageInternal(String title, StorageDomainType type) {
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(title);
    model.setHelpTag(HelpTag.new_domain);
    // $NON-NLS-1$
    model.setHashName("new_domain");
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters, getEntity());
    model.getDataCenter().setIsChangeable(false);
    List<IStorageModel> items = null;
    if (type == StorageDomainType.Data) {
        items = AsyncDataProvider.getInstance().getDataStorageModels();
    } else if (type == StorageDomainType.ISO) {
        items = AsyncDataProvider.getInstance().getIsoStorageModels();
    }
    model.setItems(items);
    model.initialize();
    // $NON-NLS-1$
    UICommand tempVar6 = UICommand.createDefaultOkUiCommand("OnAddStorage", this);
    model.getCommands().add(tempVar6);
    // $NON-NLS-1$
    UICommand tempVar7 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar7);
}
#end_block

#method_before
public void addCluster() {
    ClusterModel model = new ClusterModel();
    model.init(false);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    model.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    model.setHashName("new_cluster");
    model.setIsNew(true);
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters, getEntity());
    model.getDataCenter().setIsChangable(false);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnAddCluster", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void addCluster() {
    ClusterModel model = new ClusterModel();
    model.init(false);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newClusterTitle());
    model.setHelpTag(HelpTag.new_cluster);
    // $NON-NLS-1$
    model.setHashName("new_cluster");
    model.setIsNew(true);
    ArrayList<StoragePool> dataCenters = new ArrayList<StoragePool>();
    dataCenters.add(getEntity());
    model.getDataCenter().setItems(dataCenters, getEntity());
    model.getDataCenter().setIsChangeable(false);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnAddCluster", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    VDSGroup cluster = (VDSGroup) model.getCluster().getSelectedItem();
    final ArrayList<VdcActionParametersBase> parameterList = new ArrayList<VdcActionParametersBase>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getVdsGroupId() != null && !host.getVdsGroupId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            ArrayList<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            final ArrayList<VdcActionParametersBase> activateVdsParameterList = new ArrayList<VdcActionParametersBase>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString(((MoveHost) dataCenterGuideModel.getWindow()));
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(dataCenterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    VDSGroup cluster = (VDSGroup) model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getVdsGroupId() != null && !host.getVdsGroupId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final DataCenterGuideModel dataCenterGuideModel = (DataCenterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) dataCenterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()), null, this);
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                dataCenterGuideModel.getWindow().stopProgress();
                dataCenterGuideModel.cancel();
                dataCenterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString(((MoveHost) dataCenterGuideModel.getWindow()));
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(dataCenterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    model.getProtocol().setEntity(true);
                } else {
                    model.getProtocol().setEntity(false);
                    model.getProtocol().setIsChangable(false);
                }
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
public void addHost() {
    final HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host_guide_me);
    // $NON-NLS-1$
    model.setHashName("new_host_guide_me");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getDataCenter().setItems(Collections.singletonList(getEntity()), getEntity());
    model.getDataCenter().setIsChangeable(false);
    model.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel<VDSGroup> clusterModel = model.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                VDSGroup cluster = clusterModel.getSelectedItem();
                Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
                if (jsonSupported) {
                    model.getProtocol().setEntity(true);
                } else {
                    model.getProtocol().setEntity(false);
                    model.getProtocol().setIsChangeable(false);
                }
            }
        }
    });
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public void postAction() {
    resetData();
    updateOptions();
}
#method_after
@Override
protected void postAction() {
    resetData();
    updateOptions();
}
#end_block

#method_before
@Override
public void cancel() {
    resetData();
    setWindow(null);
}
#method_after
@Override
protected void cancel() {
    resetData();
    setWindow(null);
}
#end_block

#method_before
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    VDSGroup cluster = (VDSGroup) model.getCluster().getSelectedItem();
    final ArrayList<VdcActionParametersBase> parameterList = new ArrayList<VdcActionParametersBase>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getVdsGroupId() != null && !host.getVdsGroupId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final ClusterGuideModel clusterGuideModel = (ClusterGuideModel) result.getState();
            ArrayList<MoveHostData> hosts = ((MoveHost) clusterGuideModel.getWindow()).getSelectedHosts();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            final ArrayList<VdcActionParametersBase> activateVdsParameterList = new ArrayList<VdcActionParametersBase>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                clusterGuideModel.getWindow().stopProgress();
                clusterGuideModel.cancel();
                clusterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString(((MoveHost) clusterGuideModel.getWindow()));
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(clusterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#method_after
public void onSelectHost() {
    MoveHost model = (MoveHost) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    model.setSelectedHosts(new ArrayList<MoveHostData>());
    for (EntityModel a : Linq.<EntityModel>cast(model.getItems())) {
        if (a.getIsSelected()) {
            model.getSelectedHosts().add((MoveHostData) a);
        }
    }
    VDSGroup cluster = (VDSGroup) model.getCluster().getSelectedItem();
    final List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (MoveHostData hostData : model.getSelectedHosts()) {
        VDS host = hostData.getEntity();
        // Try to change host's cluster as neccessary.
        if (host.getVdsGroupId() != null && !host.getVdsGroupId().equals(cluster.getId())) {
            parameterList.add(new ChangeVDSClusterParameters(cluster.getId(), host.getId()));
        }
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ChangeVDSCluster, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            final ClusterGuideModel clusterGuideModel = (ClusterGuideModel) result.getState();
            List<MoveHostData> hosts = ((MoveHost) clusterGuideModel.getWindow()).getSelectedHosts();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            final List<VdcActionParametersBase> activateVdsParameterList = new ArrayList<>();
            if (retVals != null && hosts.size() == retVals.size()) {
                int i = 0;
                for (MoveHostData selectedHostData : hosts) {
                    VDS selectedHost = selectedHostData.getEntity();
                    if (selectedHost.getStatus() == VDSStatus.PendingApproval && retVals.get(i) != null && retVals.get(i).getSucceeded()) {
                        Frontend.getInstance().runAction(VdcActionType.ApproveVds, new ApproveVdsParameters(selectedHost.getId()));
                    } else if (selectedHostData.getActivateHost()) {
                        activateVdsParameterList.add(new VdsActionParameters(selectedHostData.getEntity().getId()));
                    }
                    i++;
                }
            }
            if (activateVdsParameterList.isEmpty()) {
                clusterGuideModel.getWindow().stopProgress();
                clusterGuideModel.cancel();
                clusterGuideModel.postAction();
            } else {
                final String searchString = getVdsSearchString(((MoveHost) clusterGuideModel.getWindow()));
                Timer timer = new Timer() {

                    public void run() {
                        checkVdsClusterChangeSucceeded(clusterGuideModel, searchString, parameterList, activateVdsParameterList);
                    }
                };
                timer.schedule(2000);
            }
        }
    }, this);
}
#end_block

#method_before
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangable(false);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangable(false);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", clusterGuideModel);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clusterGuideModel);
            model.getCommands().add(tempVar2);
        }
    }));
    ListModel<VDSGroup> clusterModel = model.getCluster();
    if (clusterModel.getSelectedItem() != null) {
        VDSGroup cluster = clusterModel.getSelectedItem();
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        if (jsonSupported) {
            model.getProtocol().setEntity(true);
        } else {
            model.getProtocol().setEntity(false);
            model.getProtocol().setIsChangable(false);
        }
    }
}
#method_after
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangeable(false);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", clusterGuideModel);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clusterGuideModel);
            model.getCommands().add(tempVar2);
        }
    }));
    ListModel<VDSGroup> clusterModel = model.getCluster();
    if (clusterModel.getSelectedItem() != null) {
        VDSGroup cluster = clusterModel.getSelectedItem();
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        if (jsonSupported) {
            model.getProtocol().setEntity(true);
        } else {
            model.getProtocol().setEntity(false);
            model.getProtocol().setIsChangeable(false);
        }
    }
}
#end_block

#method_before
@Override
public void postAction() {
    resetData();
    updateOptions();
}
#method_after
@Override
protected void postAction() {
    resetData();
    updateOptions();
}
#end_block

#method_before
public void cancel() {
    resetData();
    setWindow(null);
}
#method_after
protected void cancel() {
    resetData();
    setWindow(null);
}
#end_block

#method_before
@Override
public void markAsInvalid(List<String> validationHints) {
    super.markAsInvalid(validationHints);
    getValidatedWidgetStyle().setHeight(50, Unit.PX);
}
#method_after
@Override
public void markAsInvalid(List<String> validationHints) {
    super.markAsInvalid(validationHints);
    getValidatedWidgetStyle().setDisplay(Display.INLINE_BLOCK);
}
#end_block

#method_before
public boolean validate() {
    boolean validWeekDays = true;
    boolean validMonthDays = true;
    boolean validEndDate = true;
    getSnapshotName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(128), new AsciiNameValidation() });
    if (getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.WEEKLY && (getDaysOfTheWeek().getSelectedItem() == null || getDaysOfTheWeek().getSelectedItem().isEmpty())) {
        setMessage(ConstantsManager.getInstance().getConstants().noWeekDaysSelectedMessage());
        validWeekDays = false;
        getDaysOfTheWeek().setInvalidityReasons(new ArrayList<String>());
        getDaysOfTheWeek().setIsValid(false);
    }
    if (getRecurrence().getSelectedItem() == GlusterVolumeSnapshotScheduleRecurrence.MONTHLY) {
        if (getDaysOfMonth().getSelectedItem() == null || getDaysOfMonth().getSelectedItem().equals("")) {
            // $NON-NLS-1$
            setMessage(ConstantsManager.getInstance().getConstants().noMonthDaysSelectedMessage());
            validMonthDays = false;
            getDaysOfMonth().setInvalidityReasons(new ArrayList<String>());
            getDaysOfMonth().setIsValid(false);
        } else if (getDaysOfMonth().getSelectedItem().contains(",L") || getDaysOfMonth().getSelectedItem().contains("L,")) {
            // $NON-NLS-1$//$NON-NLS-2$
            setMessage(ConstantsManager.getInstance().getConstants().lastDayMonthCanBeSelectedAlone());
            validMonthDays = false;
            getDaysOfMonth().setInvalidityReasons(new ArrayList<String>());
            getDaysOfMonth().setIsValid(false);
        }
    }
    if (getRecurrence().getSelectedItem() != GlusterVolumeSnapshotScheduleRecurrence.UNKNOWN && getEndByOptions().getSelectedItem() == EndDateOptions.HasEndDate && getEndDate().getEntity().compareTo(getStartAt().getEntity()) <= 0) {
        setMessage(ConstantsManager.getInstance().getConstants().endDateBeforeStartDate());
        validEndDate = false;
        getEndDate().setInvalidityReasons(new ArrayList<String>());
        getEndDate().setIsValid(false);
    }
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("validationResult"));
    return getSnapshotName().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && validWeekDays && validMonthDays && validEndDate;
}
#method_after
public boolean validate(boolean inplaceValidate) {
    String propName;
    validateSnapshotName();
    validateDaysOfWeek();
    validateDaysOfMonth();
    validateEndDate();
    if (!listenersRegistered) {
        initValueChangeListeners();
        listenersRegistered = true;
    }
    if (inplaceValidate) {
        // $NON-NLS-1$
        propName = "modelPropertiesChanged";
    } else {
        // $NON-NLS-1$
        propName = "validateAndSwitchAppropriateTab";
    }
    onPropertyChanged(new PropertyChangedEventArgs(propName));
    return getSnapshotName().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && getDaysOfTheWeek().getIsValid() && getDaysOfMonth().getIsValid() && getEndDate().getIsValid();
}
#end_block

#method_before
@Override
public void init(final GlusterVolumeSnapshotModel model) {
    super.init(model);
    model.getInterval().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setCriticalIntervalLabelVisibility(model, Integer.parseInt(((ListModel<String>) sender).getSelectedItem()));
        }
    });
    model.getRecurrence().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().updateVisibilities(model);
            getView().setCriticalIntervalLabelVisibility(model, Integer.parseInt(model.getInterval().getSelectedItem()));
            getView().setMessage(null);
        }
    });
    model.getEndByOptions().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setEndDateVisibility(model);
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equalsIgnoreCase("validationResult")) {
                // $NON-NLS-1$
                getView().handleValidationErrors(model);
            }
        }
    });
}
#method_after
@Override
public void init(final GlusterVolumeSnapshotModel model) {
    super.init(model);
    model.getInterval().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setCriticalIntervalLabelVisibility(model, Integer.parseInt(((ListModel<String>) sender).getSelectedItem()));
        }
    });
    model.getRecurrence().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().updateVisibilities(model);
            getView().setCriticalIntervalLabelVisibility(model, Integer.parseInt(model.getInterval().getSelectedItem()));
            getView().setMessage(null);
        }
    });
    model.getEndByOptions().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().setEndDateVisibility(model);
        }
    });
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            if (args.propertyName.equalsIgnoreCase("validateAndSwitchAppropriateTab")) {
                // $NON-NLS-1$
                getView().handleValidationErrors(model);
                getView().switchTabBasedOnEditorInvalidity();
            } else if (args.propertyName.equalsIgnoreCase("modelPropertiesChanged")) {
                // $NON-NLS-1$
                getView().handleValidationErrors(model);
            }
        }
    });
}
#end_block

#method_before
@Override
public void setMessage(String msg) {
    super.setMessage(msg);
    errorMsgLabel.setText(msg);
}
#method_after
public void setMessage(String msg, Label errorLabel) {
    errorLabel.setText(msg);
    errorLabel.setVisible(!msg.isEmpty());
}
#end_block

#method_before
@Override
public void handleValidationErrors(GlusterVolumeSnapshotModel object) {
    StringBuilder generalTabErrorBuilder = new StringBuilder();
    if (!snapshotNameEditor.isValid()) {
        appendErrors(Collections.singletonList(constants.volumeSnapshotNamePrefixLabel()), generalTabErrorBuilder);
        appendErrors(object.getSnapshotName().getInvalidityReasons(), generalTabErrorBuilder);
    }
    generalTabErrorMsgLabel.setText(generalTabErrorBuilder.toString());
    generalTabErrorMsgLabel.setVisible(generalTabErrorBuilder.toString() != null || !generalTabErrorBuilder.toString().isEmpty());
    if (!clusterNameEditor.isValid() || !volumeNameEditor.isValid() || !snapshotNameEditor.isValid() || !snapshotDescriptionEditor.isValid()) {
        tabContainer.switchTab(generalTab);
    } else if (!recurrenceEditor.isValid() || !intervalEditor.isValid() || !timeZoneEditor.isValid() || !startAtEditor.isValid() || !executionTimeEditor.isValid() || !daysOfWeekEditor.isValid() || !daysOfMonthEditor.isValid() || !endByOptionsEditor.isValid() || !endDate.isValid()) {
        tabContainer.switchTab(scheduleTab);
    }
}
#method_after
@Override
public void handleValidationErrors(GlusterVolumeSnapshotModel object) {
    String generalTabErrors = collectGeneralTabErrors(object);
    setMessage(generalTabErrors, generalTabErrorMsgLabel);
    String scheduleTabErrors = collectScheduleTabErrors(object);
    setMessage(scheduleTabErrors, scheduleTabErrorMessageLabel);
}
#end_block

#method_before
public static void main(String[] args) {
    ExtensionsToolArguments toolArguments = new ExtensionsToolArguments();
    try {
        toolArguments.parse(args);
        Class<ModuleService> service = ExtensionsToolFactory.getModule(toolArguments.getModule());
        ModuleService moduleService = ExtensionsToolLoader.load(service);
        if (moduleService != null) {
            moduleService.runModule(toolArguments);
        }
    } catch (Throwable t) {
        t.printStackTrace();
        System.exit(1);
    }
}
#method_after
public static void main(String... args) {
    int exitStatus = 1;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        setupLogger();
        ArgumentsParser parser;
        try (InputStream stream = ExtensionsToolExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "core");
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        Map<String, ModuleService> moduleServices = loadModules(ModuleService.class);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help"))) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME).replace("@MODULE_LIST@", getModules(moduleServices)));
            throw new ExitException("Help", 0);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ExitException("Version", 0);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ExitException("Parsing error", 1);
        }
        if (cmdArgs.size() < 1) {
            logger.error("Please provide module.");
            throw new ExitException("Module not provided", 1);
        }
        String module = cmdArgs.get(0);
        ModuleService moduleService = moduleServices.get(module);
        if (moduleService == null) {
            logger.error("No such '{}' module exists.", module);
            throw new ExitException(1);
        }
        moduleService.parseArguments(cmdArgs);
        loadExtensions(moduleService, argMap);
        moduleService.run();
    } catch (ExitException e) {
        logger.debug(e.getMessage(), e);
        exitStatus = e.getExitCode();
    } catch (Throwable t) {
        String message = t.getMessage() != null ? t.getMessage() : t.getClass().getName();
        logger.error(message);
        logger.debug(message, t);
    }
    logger.debug("Exiting with status '{}'", exitStatus);
    System.exit(exitStatus);
}
#end_block

#method_before
private void setDetailList(final HostInterfaceListModel hostInterfaceListModel, final HostHardwareGeneralModel hostHardwareGeneralModel, final HostHooksListModel hostHooksListModel, final PermissionListModel<VDS> permissionListModel) {
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    List<HasEntity<VDS>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(hostHardwareGeneralModel);
    list.add(getHostVmListModel());
    list.add(hostInterfaceListModel);
    list.add(getHostEventListModel());
    list.add(hostHooksListModel);
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(getGlusterStorageDeviceListModel());
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final HostInterfaceListModel hostInterfaceListModel, final HostHardwareGeneralModel hostHardwareGeneralModel, final HostHooksListModel hostHooksListModel, final PermissionListModel<VDS> permissionListModel, final HostDeviceListModel hostDeviceListModel) {
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    List<HasEntity<VDS>> list = new ArrayList<>();
    list.add(generalModel);
    list.add(hostHardwareGeneralModel);
    list.add(getHostVmListModel());
    list.add(hostInterfaceListModel);
    list.add(hostDeviceListModel);
    list.add(getHostEventListModel());
    list.add(hostHooksListModel);
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(getGlusterStorageDeviceListModel());
    list.add(permissionListModel);
    setDetailModels(list);
}
#end_block

#method_before
private void updateAlerts() {
    final VDS vds = getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (vds.getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    // $NON-NLS-1$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    generalModel.setHasUpgradeAlert(generalModel.shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        getUpgradeCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    getUpgradeCommand().setIsExecutionAllowed(executionAllowed);
                }
                generalModel.setHasAnyAlert();
            }
        }), vds.getId());
    } else if (vds.getVdsType() == VDSType.VDS) {
        generalModel.setHasUpgradeAlert(vds.isUpdateAvailable());
    }
}
#method_after
private void updateAlerts() {
    final VDS vds = getSelectedItem();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (vds.getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getInstance().getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    // $NON-NLS-1$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    generalModel.setHasUpgradeAlert(generalModel.shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        getUpgradeCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    getUpgradeCommand().setIsExecutionAllowed(executionAllowed);
                }
                generalModel.setHasAnyAlert();
            }
        }), vds.getId());
    } else if (vds.getVdsType() == VDSType.VDS) {
        generalModel.setHasUpgradeAlert(vds.isUpdateAvailable());
        generalModel.setHasAnyAlert();
    }
}
#end_block

#method_before
@Test
public void testGetClustersHavingHosts() {
    List<VDSGroup> vdsGroups = ((VdsGroupDAODbFacadeImpl) dao).getClustersHavingHosts();
    assertNotNull(vdsGroups);
    assertEquals(4, vdsGroups.size());
}
#method_after
@Test
public void testGetClustersHavingHosts() {
    List<VDSGroup> clusters = ((VdsGroupDAODbFacadeImpl) dao).getClustersHavingHosts();
    assertNotNull(clusters);
    assertThat(clusters, hasSize(4));
}
#end_block

#method_before
@Override
public List<VDSGroup> getClustersHavingHosts() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetVdsGroupsHavingHosts", VdsGroupRowMapper.instance, parameterSource);
}
#method_after
@Override
public List<VDSGroup> getClustersHavingHosts() {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource();
    return getCallsHandler().executeReadList("GetClustersHavingHosts", VdsGroupRowMapper.instance, parameterSource);
}
#end_block

#method_before
@AroundInvoke
public Object invoke(final InvocationContext context) throws Exception {
    Transaction current = TransactionSupport.current();
    if (current == null) {
        return runInTransaction(context, TransactionScopeOption.Required);
    } else {
        Transactional transactional = context.getMethod().getAnnotation(Transactional.class);
        return runInTransaction(context, transactional.propogation());
    }
}
#method_after
@AroundInvoke
public Object invoke(final InvocationContext context) throws Exception {
    Transaction current = TransactionSupport.current();
    if (current == null) {
        return runInTransaction(context, TransactionScopeOption.Required);
    } else {
        Transactional transactional = context.getMethod().getAnnotation(Transactional.class);
        if (transactional != null) {
            return runInTransaction(context, transactional.propogation());
        } else {
            return context.proceed();
        }
    }
}
#end_block

#method_before
private static List<Method> getRelevantMethods(Class<?> clz) {
    List<Method> methods = new ArrayList<>();
    if (methodCache.containsKey(clz)) {
        return methodCache.get(clz);
    }
    for (Method method : clz.getMethods()) {
        if (method.getName().startsWith("get")) {
            if (method.getReturnType().getPackage() == BaseResource.class.getPackage()) {
                methods.add(method);
            }
        }
    }
    methodCache.put(clz, methods);
    return methods;
}
#method_after
private static List<Method> getRelevantMethods(Class<?> clz) {
    List<Method> methods = methodCache.get(clz);
    if (methods == null) {
        methods = new ArrayList<Method>();
        for (Method method : clz.getMethods()) {
            if (method.getName().startsWith("get")) {
                if (method.getReturnType().getPackage() == BaseResource.class.getPackage()) {
                    methods.add(method);
                }
            }
        }
        methodCache.put(clz, methods);
    }
    return methods;
}
#end_block

#method_before
public static void main(String... args) {
    ParametersParser parser;
    try {
        try (InputStream stream = ManageDomainsExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ParametersParser(stream, "module");
        }
        Map<String, Object> argMap = parser.parse(args);
        setupLogger(argMap);
        List<String> moduleOthers = (List<String>) argMap.get(ParametersParser.PARAMETER_KEY_OTHER);
        List<Throwable> errors = (List<Throwable>) argMap.get(ParametersParser.PARAMETER_KEY_ERRORS);
        if (argMap.containsKey("help") || (moduleOthers.size() > 0 && moduleOthers.get(0).equals("help"))) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        } else if (argMap.containsKey("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        } else if (!errors.isEmpty()) {
            for (Throwable t : errors) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR);
        }
        if (moduleOthers.size() < 1) {
            logger.error("Please provide action.");
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR);
        }
        String action = moduleOthers.remove(0);
        try (InputStream stream = ManageDomainsExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ParametersParser(stream, action);
        }
        argMap = parser.parse(moduleOthers);
        if (argMap.containsKey("help")) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        }
        errors = (List<Throwable>) argMap.get(ParametersParser.PARAMETER_KEY_ERRORS);
        for (Throwable t : errors) {
            logger.error(t.getMessage());
            logger.debug(t.getMessage(), t);
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR);
        }
        ManageDomains util = new ManageDomains(action, argMap);
        // it's existence is checked during the parser validation
        util.init();
        util.createConfigurationProvider();
        util.runCommand();
    } catch (ManageDomainsResult e) {
        ManageDomains.exitOnError(e);
    } catch (Throwable t) {
        logger.error(t.getMessage());
        logger.debug(t.getMessage(), t);
        System.out.println(t.getMessage());
        System.exit(1);
    }
    System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
    System.exit(ManageDomainsResultEnum.OK.getExitCode());
}
#method_after
public static void main(String... args) {
    setupLogger();
    ArgumentsParser parser;
    List<String> cmdArgs = new ArrayList<>(Arrays.asList(args));
    try {
        try (InputStream stream = ManageDomainsExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, "module");
        }
        parser.parse(cmdArgs);
        Map<String, Object> argMap = parser.getParsedArgs();
        setupLogger(argMap);
        if ((Boolean) argMap.get("help") || (cmdArgs.size() > 0 && cmdArgs.get(0).equals("help")) || (cmdArgs.size() < 1)) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        } else if ((Boolean) argMap.get("version")) {
            System.out.format("%s-%s (%s)%n", PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DISPLAY_NAME);
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR, StringUtils.join(parser.getErrors(), ", "));
        }
        String action = cmdArgs.remove(0);
        try (InputStream stream = ManageDomainsExecutor.class.getResourceAsStream("arguments.properties")) {
            parser = new ArgumentsParser(stream, action);
        }
        parser.parse(cmdArgs);
        argMap = parser.getParsedArgs();
        ManageDomains util = new ManageDomains(action, argMap);
        if (!util.isValidAction()) {
            throw new ManageDomainsResult(ManageDomainsResultEnum.INVALID_ACTION, action);
        }
        if ((Boolean) argMap.get("help")) {
            System.out.format("usage: %s", parser.getUsage().replace("@PROGRAM_NAME@", PROGRAM_NAME));
            throw new ManageDomainsResult(ManageDomainsResultEnum.OK);
        }
        if (!parser.getErrors().isEmpty()) {
            for (Throwable t : parser.getErrors()) {
                logger.error(t.getMessage());
                logger.debug(t.getMessage(), t);
            }
            throw new ManageDomainsResult(ManageDomainsResultEnum.ARGUMENT_PARSING_ERROR, StringUtils.join(parser.getErrors(), ", "));
        }
        // it's existence is checked during the parser validation
        util.init();
        util.createConfigurationProvider();
        util.runCommand();
        System.out.println(ManageDomainsResultEnum.OK.getDetailedMessage());
        System.exit(ManageDomainsResultEnum.OK.getExitCode());
    } catch (ManageDomainsResult e) {
        ManageDomains.exitOnError(e);
    } catch (Throwable t) {
        logger.error(t.getMessage());
        logger.debug(t.getMessage(), t);
        System.exit(1);
    }
}
#end_block

#method_before
private static void setupLogger(Map<String, Object> args) {
    if (args.containsKey("log-file")) {
        JavaLoggingUtils.addFileHandler((String) args.get("log-file"));
    }
    if (args.containsKey("log-level")) {
        JavaLoggingUtils.setLogLevel((String) args.get("log-level"));
    }
}
#method_after
private static void setupLogger() {
    String logLevel = System.getenv("OVIRT_LOGGING_LEVEL");
    JavaLoggingUtils.setLogLevel(logLevel != null ? logLevel : "INFO");
}
#end_block

#method_before
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = (String) args.get(ARG_DOMAIN);
    String userName = (String) args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = LdapProviderType.valueOfIgnoreCase((String) args.get(ManageDomainsArguments.ARG_PROVIDER));
    if (ldapProviderType == null) {
        System.err.println("Provider typ was not provided. Use --providerType=<ldap_provider_type");
    } else {
        adUserNameEntry.setValueForDomain(domainName, userName);
        adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
        authModeEntry.setValueForDomain(domainName, authMode);
        ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
        if (args.containsKey(ARG_LDAP_SERVERS)) {
            setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
        }
        handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
        testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
        handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
        // Update the configuration
        setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
        printSuccessMessage(domainName, "added");
    }
}
#method_after
public void addDomain() throws ManageDomainsResult {
    String authMode = LdapAuthModeEnum.GSSAPI.name();
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    String domainName = (String) args.get(ARG_DOMAIN);
    String userName = (String) args.get(ARG_USER);
    if (domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_ALREADY_EXISTS_IN_CONFIGURATION, domainName);
    }
    List<String> ldapServers = getLdapServers(domainName);
    validateKdcServers(authMode, domainName);
    domainNameEntry.setValueForDomain(domainName, null);
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLDAPProviderTypes = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypesEntry = new DomainsConfigurationEntry(currentLDAPProviderTypes, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePasswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    LdapProviderType ldapProviderType = getProvider();
    adUserNameEntry.setValueForDomain(domainName, userName);
    adUserPasswordEntry.setValueForDomain(domainName, getPasswordInput());
    authModeEntry.setValueForDomain(domainName, authMode);
    ldapProviderTypesEntry.setValueForDomain(domainName, ldapProviderType.name());
    if (args.containsKey(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    handleChangePasswordMsg(domainName, changePasswordUrlEntry, false);
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypesEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    // Update the configuration
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypesEntry, changePasswordUrlEntry);
    printSuccessMessage(domainName, "added");
}
#end_block

#method_before
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = (String) args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = (String) args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.containsKey(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.containsKey(ARG_PROVIDER)) {
        ldapProviderType = LdapProviderType.valueOfIgnoreCase((String) args.get(ManageDomainsArguments.ARG_PROVIDER));
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    handleChangePasswordMsg(domainName, changePaswordUrlEntry, true);
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#method_after
public void editDomain() throws ManageDomainsResult {
    String authMode;
    String domainName = (String) args.get(ARG_DOMAIN);
    authMode = getDomainAuthMode(domainName);
    validateKdcServers(authMode, domainName);
    String currentDomains = configurationProvider.getConfigValue(ConfigValues.DomainName);
    String userName = (String) args.get(ARG_USER);
    DomainsConfigurationEntry domainNameEntry = new DomainsConfigurationEntry(currentDomains, DOMAIN_SEPERATOR, null);
    if (!domainNameEntry.doesDomainExist(domainName)) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.DOMAIN_DOESNT_EXIST_IN_CONFIGURATION, domainName);
    }
    domainNameEntry.setValueForDomain(domainName, null);
    // Assuming we got here, we need to change the configuration of the others as well
    String currentAdUserNameEntry = configurationProvider.getConfigValue(ConfigValues.AdUserName);
    String currentAdUserPasswordEntry = configurationProvider.getConfigValue(ConfigValues.AdUserPassword);
    String currentAuthModeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPSecurityAuthentication);
    String currentAdUserIdEntry = configurationProvider.getConfigValue(ConfigValues.AdUserId);
    String currentLdapProviderTypeEntry = configurationProvider.getConfigValue(ConfigValues.LDAPProviderTypes);
    String ldapServerPort = configurationProvider.getConfigValue(ConfigValues.LDAPServerPort);
    String currentChangePasswordUrl = configurationProvider.getConfigValue(ConfigValues.ChangePasswordMsg);
    DomainsConfigurationEntry adUserNameEntry = new DomainsConfigurationEntry(currentAdUserNameEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserPasswordEntry = new PasswordDomainsConfigurationEntry(currentAdUserPasswordEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry authModeEntry = new DomainsConfigurationEntry(currentAuthModeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry adUserIdEntry = new DomainsConfigurationEntry(currentAdUserIdEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry ldapProviderTypeEntry = new DomainsConfigurationEntry(currentLdapProviderTypeEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    DomainsConfigurationEntry changePaswordUrlEntry = new DomainsConfigurationEntry(currentChangePasswordUrl, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    if (userName != null) {
        adUserNameEntry.setValueForDomain(domainName, userName);
    }
    String password = getPasswordInput();
    if (password != null) {
        adUserPasswordEntry.setValueForDomain(domainName, password);
    }
    String currentLdapServersEntry = configurationProvider.getConfigValue(ConfigValues.LdapServers);
    DomainsConfigurationEntry ldapServersEntry = new DomainsConfigurationEntry(currentLdapServersEntry, DOMAIN_SEPERATOR, VALUE_SEPERATOR);
    List<String> ldapServers = getLdapServers(domainName);
    if (args.containsKey(ARG_LDAP_SERVERS)) {
        setLdapServersPerDomain(domainName, ldapServersEntry, StringUtils.join(ldapServers, ","));
    }
    LdapProviderType ldapProviderType = null;
    if (args.containsKey(ARG_PROVIDER)) {
        ldapProviderType = getProvider();
    }
    if (ldapProviderType != null) {
        ldapProviderTypeEntry.setValueForDomain(domainName, ldapProviderType.name());
    }
    handleChangePasswordMsg(domainName, changePaswordUrlEntry, true);
    testConfiguration(domainName, domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, adUserIdEntry, ldapProviderTypeEntry, ldapServersEntry, ldapServerPort, true, false, ldapServers);
    handleAddPermissions(domainName, userName, adUserIdEntry.getValueForDomain(domainName));
    setConfigurationEntries(domainNameEntry, adUserNameEntry, adUserPasswordEntry, authModeEntry, ldapServersEntry, adUserIdEntry, ldapProviderTypeEntry, changePaswordUrlEntry);
    printSuccessMessage(domainName, "edited");
}
#end_block

#method_before
private void setDetailList(final DiskGeneralModel diskGeneralModel, final PermissionListModel<DiskListModel> permissionListModel) {
    diskVmListModel.setIsAvailable(false);
    diskTemplateListModel.setIsAvailable(false);
    diskStorageListModel.setIsAvailable(false);
    List<EntityModel> list = new ArrayList<EntityModel>();
    list.add(diskGeneralModel);
    list.add(diskVmListModel);
    list.add(diskTemplateListModel);
    list.add(diskStorageListModel);
    list.add(permissionListModel);
    setDetailModels(list);
}
#method_after
private void setDetailList(final DiskGeneralModel diskGeneralModel, final PermissionListModel<Disk> permissionListModel) {
    diskVmListModel.setIsAvailable(false);
    diskTemplateListModel.setIsAvailable(false);
    diskStorageListModel.setIsAvailable(false);
    List<HasEntity<? extends Disk>> list = new ArrayList<>();
    list.add(diskGeneralModel);
    list.add(diskVmListModel);
    list.add(diskTemplateListModel);
    list.add(diskStorageListModel);
    list.add(permissionListModel);
    // TODO: find better type bound for list
    setDetailModels((List) list);
}
#end_block

#method_before
@Override
public void setItems(Collection value) {
    if (value == null) {
        super.setItems(null);
        return;
    }
    ArrayList<Disk> disks = Linq.<Disk>cast(value);
    super.setItems(disks);
}
#method_after
@Override
public void setItems(Collection<Disk> disks) {
    if (disks == null) {
        super.setItems(null);
        return;
    }
    super.setItems(disks);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        Disk disk = (Disk) getSelectedItem();
        diskVmListModel.setIsAvailable(disk.getVmEntityType() == null || !disk.getVmEntityType().isTemplateType());
        diskTemplateListModel.setIsAvailable(disk.getVmEntityType() != null && disk.getVmEntityType().isTemplateType());
        diskStorageListModel.setIsAvailable(disk.getDiskStorageType() == DiskStorageType.IMAGE);
    }
}
#method_after
@Override
protected void updateDetailsAvailability() {
    if (getSelectedItem() != null) {
        Disk disk = getSelectedItem();
        diskVmListModel.setIsAvailable(disk.getVmEntityType() == null || !disk.getVmEntityType().isTemplateType());
        diskTemplateListModel.setIsAvailable(disk.getVmEntityType() != null && disk.getVmEntityType().isTemplateType());
        diskStorageListModel.setIsAvailable(disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER);
    }
}
#end_block

#method_before
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disks);
    // $NON-NLS-1$
    model.setHashName("move_disks");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#method_after
private void move() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) asImages(getSelectedItems());
    if (disks == null || getWindow() != null) {
        return;
    }
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disks);
    // $NON-NLS-1$
    model.setHashName("move_disks");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#end_block

#method_before
private void scanAlignment() {
    ArrayList<VdcActionParametersBase> parameterList = new ArrayList<VdcActionParametersBase>();
    for (Disk disk : (ArrayList<Disk>) getSelectedItems()) {
        parameterList.add(new GetDiskAlignmentParameters(disk.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.GetDiskAlignment, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#method_after
private void scanAlignment() {
    ArrayList<VdcActionParametersBase> parameterList = new ArrayList<VdcActionParametersBase>();
    for (Disk disk : getSelectedItems()) {
        parameterList.add(new GetDiskAlignmentParameters(disk.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.GetDiskAlignment, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, this);
}
#end_block

#method_before
private void export() {
    @SuppressWarnings("unchecked")
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ExportRepoImageModel model = new ExportRepoImageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().exportImagesTitle());
    model.setHelpTag(HelpTag.export_disks);
    // $NON-NLS-1$
    model.setHashName("export_disks");
    model.setEntity(this);
    model.init(disks);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.setCancelCommand(cancelCommand);
    model.getCommands().add(cancelCommand);
}
#method_after
private void export() {
    @SuppressWarnings("unchecked")
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) asImages(getSelectedItems());
    if (disks == null || getWindow() != null) {
        return;
    }
    ExportRepoImageModel model = new ExportRepoImageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().exportImagesTitle());
    model.setHelpTag(HelpTag.export_disks);
    // $NON-NLS-1$
    model.setHashName("export_disks");
    model.setEntity(this);
    model.init(disks);
    // $NON-NLS-1$
    UICommand cancelCommand = UICommand.createCancelUiCommand("Cancel", this);
    model.setCancelCommand(cancelCommand);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    model.setHelpTag(HelpTag.change_quota_disks);
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("onChangeQuota", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#method_after
private void changeQuota() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) asImages(getSelectedItems());
    if (disks == null || getWindow() != null) {
        return;
    }
    ChangeQuotaModel model = new ChangeQuotaModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().assignQuotaForDisk());
    model.setHelpTag(HelpTag.change_quota_disks);
    // $NON-NLS-1$
    model.setHashName("change_quota_disks");
    model.startProgress(null);
    model.init(disks);
    // $NON-NLS-1$
    UICommand command = UICommand.createDefaultOkUiCommand("onChangeQuota", this);
    model.getCommands().add(command);
    // $NON-NLS-1$
    model.getCommands().add(UICommand.createCancelUiCommand("Cancel", this));
}
#end_block

#method_before
private void copy() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) getSelectedItems();
    if (disks == null || getWindow() != null) {
        return;
    }
    CopyDiskModel model = new CopyDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().copyDisksTitle());
    model.setHelpTag(HelpTag.copy_disks);
    // $NON-NLS-1$
    model.setHashName("copy_disks");
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#method_after
private void copy() {
    ArrayList<DiskImage> disks = (ArrayList<DiskImage>) asImages(getSelectedItems());
    if (disks == null || getWindow() != null) {
        return;
    }
    CopyDiskModel model = new CopyDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().copyDisksTitle());
    model.setHelpTag(HelpTag.copy_disks);
    // $NON-NLS-1$
    model.setHashName("copy_disks");
    model.setEntity(this);
    model.init(disks);
    model.startProgress(null);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    model.setHelpTag(HelpTag.remove_disk);
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setIsAvailable(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnRemove", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.initialize(null, getSelectedItems(), this);
    model.getLatch().setIsAvailable(false);
}
#end_block

#method_before
private void updateActionAvailability() {
    Disk disk = (Disk) getSelectedItem();
    ArrayList<Disk> disks = getSelectedItems() != null ? (ArrayList<Disk>) getSelectedItems() : null;
    boolean shouldAllowEdit = true;
    if (disk != null) {
        shouldAllowEdit = !disk.isOvfStore() && !(disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED);
    }
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && disks != null && disks.size() == 1 && shouldAllowEdit);
    getRemoveCommand().setIsExecutionAllowed(disks != null && disks.size() > 0 && isRemoveCommandAvailable());
    getScanAlignmentCommand().setIsExecutionAllowed(disks != null && disks.size() > 0 && isScanAlignmentCommandAvailable());
    getExportCommand().setIsExecutionAllowed(isExportCommandAvailable());
    updateCopyAndMoveCommandAvailability(disks);
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List<Disk>) getItems() : null, getSelectedItems() != null ? (List<Disk>) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#method_after
private void updateActionAvailability() {
    Disk disk = getSelectedItem();
    ArrayList<Disk> disks = getSelectedItems() != null ? (ArrayList) getSelectedItems() : null;
    boolean shouldAllowEdit = true;
    if (disk != null) {
        shouldAllowEdit = !disk.isOvfStore() && !isDiskLocked(disk);
    }
    getNewCommand().setIsExecutionAllowed(true);
    getEditCommand().setIsExecutionAllowed(disk != null && disks != null && disks.size() == 1 && shouldAllowEdit);
    getRemoveCommand().setIsExecutionAllowed(disks != null && disks.size() > 0 && isRemoveCommandAvailable());
    getScanAlignmentCommand().setIsExecutionAllowed(disks != null && disks.size() > 0 && isScanAlignmentCommandAvailable());
    getExportCommand().setIsExecutionAllowed(isExportCommandAvailable());
    updateCopyAndMoveCommandAvailability(disks);
    ChangeQuotaModel.updateChangeQuotaActionAvailability(getItems() != null ? (List) getItems() : null, getSelectedItems() != null ? (List) getSelectedItems() : null, getSystemTreeSelectedItem(), getChangeQuotaCommand());
}
#end_block

#method_before
private void updateCopyAndMoveCommandAvailability(List<Disk> disks) {
    boolean isMoveAllowed = true;
    boolean isCopyAllowed = true;
    if (disks == null || disks.isEmpty() || disks.get(0).getDiskStorageType() != DiskStorageType.IMAGE) {
        disableMoveAndCopyCommands();
        return;
    }
    Guid datacenterId = ((DiskImage) disks.get(0)).getStoragePoolId();
    boolean foundTemplateDisk = false;
    boolean foundVmDisk = false;
    boolean foundUnattachedDisk = false;
    for (Disk disk : disks) {
        if ((!isCopyAllowed && !isMoveAllowed) || disk.getDiskStorageType() != DiskStorageType.IMAGE) {
            disableMoveAndCopyCommands();
            return;
        }
        DiskImage diskImage = (DiskImage) disk;
        if (diskImage.getImageStatus() != ImageStatus.OK || !datacenterId.equals(diskImage.getStoragePoolId()) || diskImage.isOvfStore()) {
            disableMoveAndCopyCommands();
            return;
        }
        VmEntityType vmEntityType = disk.getVmEntityType();
        if (vmEntityType == null) {
            foundUnattachedDisk = true;
        } else if (vmEntityType.isTemplateType()) {
            foundTemplateDisk = true;
        } else if (vmEntityType.isVmType()) {
            foundVmDisk = true;
        }
        if (foundTemplateDisk && (foundUnattachedDisk || foundVmDisk)) {
            isCopyAllowed = false;
        }
        if (vmEntityType != null && vmEntityType.isTemplateType()) {
            isMoveAllowed = false;
        }
    }
    getCopyCommand().setIsExecutionAllowed(isCopyAllowed);
    getMoveCommand().setIsExecutionAllowed(isMoveAllowed);
}
#method_after
private void updateCopyAndMoveCommandAvailability(List<Disk> disks) {
    boolean isCopyAllowed = true;
    boolean isMoveAllowed = true;
    if (disks == null || disks.isEmpty() || disks.get(0).getDiskStorageType() != DiskStorageType.IMAGE) {
        disableMoveAndCopyCommands();
        return;
    }
    Guid datacenterId = ((DiskImage) disks.get(0)).getStoragePoolId();
    boolean foundTemplateDisk = false;
    boolean foundVmDisk = false;
    boolean foundUnattachedDisk = false;
    for (Disk disk : disks) {
        if ((!isCopyAllowed && !isMoveAllowed) || disk.getDiskStorageType() != DiskStorageType.IMAGE) {
            disableMoveAndCopyCommands();
            return;
        }
        DiskImage diskImage = (DiskImage) disk;
        if (diskImage.getImageStatus() != ImageStatus.OK || !datacenterId.equals(diskImage.getStoragePoolId()) || diskImage.isOvfStore()) {
            disableMoveAndCopyCommands();
            return;
        }
        VmEntityType vmEntityType = disk.getVmEntityType();
        if (vmEntityType == null) {
            foundUnattachedDisk = true;
        } else if (vmEntityType.isTemplateType()) {
            foundTemplateDisk = true;
        } else if (vmEntityType.isVmType()) {
            foundVmDisk = true;
        }
        if (foundTemplateDisk && (foundUnattachedDisk || foundVmDisk)) {
            isCopyAllowed = false;
        }
        if (vmEntityType != null && vmEntityType.isTemplateType()) {
            isMoveAllowed = false;
        }
    }
    getCopyCommand().setIsExecutionAllowed(isCopyAllowed);
    getMoveCommand().setIsExecutionAllowed(isMoveAllowed);
}
#end_block

#method_before
private boolean isRemoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        // check if the disk is template disk
        if (disk.getVmEntityType() != null && disk.getVmEntityType().isTemplateType()) {
            return false;
        }
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            ImageStatus imageStatus = ((DiskImage) disk).getImageStatus();
            if (imageStatus == ImageStatus.LOCKED) {
                return false;
            }
            if (disk.isOvfStore() && imageStatus != ImageStatus.ILLEGAL) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean isRemoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        // check if the disk is template disk
        if (disk.getVmEntityType() != null && disk.getVmEntityType().isTemplateType()) {
            return false;
        }
        if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
            ImageStatus imageStatus = ((DiskImage) disk).getImageStatus();
            if (imageStatus == ImageStatus.LOCKED) {
                return false;
            }
            if (disk.isOvfStore() && imageStatus != ImageStatus.ILLEGAL) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean isExportCommandAvailable() {
    ArrayList<Disk> disks = (ArrayList<Disk>) getSelectedItems();
    if (disks == null || disks.isEmpty()) {
        return false;
    }
    for (Disk disk : disks) {
        if (disk.getDiskStorageType() != DiskStorageType.IMAGE) {
            return false;
        }
        DiskImage diskImage = (DiskImage) disk;
        if (diskImage.getImageStatus() != ImageStatus.OK || !diskImage.getParentId().equals(Guid.Empty)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isExportCommandAvailable() {
    List<DiskImage> disks = asImages(getSelectedItems());
    if (disks == null || disks.isEmpty()) {
        return false;
    }
    for (Disk disk : disks) {
        if (disk.getDiskStorageType() != DiskStorageType.IMAGE) {
            return false;
        }
        DiskImage diskImage = (DiskImage) disk;
        if (diskImage.getImageStatus() != ImageStatus.OK || !diskImage.getParentId().equals(Guid.Empty)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getCopyCommand()) {
        copy();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (command == getExportCommand()) {
        export();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getMoveCommand()) {
        move();
    } else if (command == getCopyCommand()) {
        copy();
    } else if (command == getScanAlignmentCommand()) {
        scanAlignment();
    } else if (command == getExportCommand()) {
        export();
    } else if (// $NON-NLS-1$
    RemoveDiskModel.CANCEL_REMOVE.equals(command.getName()) || "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "CancelConfirm".equals(command.getName())) {
        cancelConfirm();
    } else if (RemoveDiskModel.ON_REMOVE.equals(command.getName())) {
        onRemove();
    } else if (command == getChangeQuotaCommand()) {
        changeQuota();
    } else if (command.getName().equals("onChangeQuota")) {
        // $NON-NLS-1$
        onChangeQuota();
    }
}
#end_block

#method_before
private void updateChangeability(DiskModel disk, boolean isDiskBasedOnTemplate, boolean noSources, boolean noTargets) {
    disk.getStorageDomain().setIsChangable(!noTargets);
    disk.getSourceStorageDomain().setIsChangable(!noSources);
    disk.getSourceStorageDomainName().setIsChangable(!noSources);
    disk.getStorageDomain().setChangeProhibitionReason(isDiskBasedOnTemplate ? constants.noActiveStorageDomainWithTemplateMsg() : getNoActiveTargetDomainMessage());
    disk.getSourceStorageDomain().setChangeProhibitionReason(getNoActiveSourceDomainMessage());
    disk.getSourceStorageDomainName().setChangeProhibitionReason(getNoActiveSourceDomainMessage());
}
#method_after
private void updateChangeability(DiskModel disk, boolean isDiskBasedOnTemplate, boolean noSources, boolean noTargets) {
    disk.getStorageDomain().setIsChangeable(!noTargets);
    disk.getSourceStorageDomain().setIsChangeable(!noSources);
    disk.getSourceStorageDomainName().setIsChangeable(!noSources);
    disk.getStorageDomain().setChangeProhibitionReason(isDiskBasedOnTemplate ? constants.noActiveStorageDomainWithTemplateMsg() : getNoActiveTargetDomainMessage());
    disk.getSourceStorageDomain().setChangeProhibitionReason(getNoActiveSourceDomainMessage());
    disk.getSourceStorageDomainName().setChangeProhibitionReason(getNoActiveSourceDomainMessage());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && isDiskUsedAsOvfStore() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkCanBeMoveInVm() && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && isDiskUsedAsOvfStore() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && validateVmSnapshotStatus() && checkCanBeMoveInVm() && checkIfNeedToBeOverride() && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving
    if (getParameters().getOperation() == ImageOperation.Move && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    return true;
}
#method_after
protected boolean validateDestStorage() {
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
        return false;
    }
    // Validate shareable disks moving/copying
    boolean moveOrCopy = getParameters().getOperation() == ImageOperation.Move || getParameters().getOperation() == ImageOperation.Copy;
    if (moveOrCopy && getImage().isShareable() && getStorageDomain().getStorageType() == StorageType.GLUSTERFS) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CANT_MOVE_SHAREABLE_DISK_TO_GLUSTERFS, String.format("$%1$s %2$s", "diskAlias", getImage().getDiskAlias()));
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), getParameters());
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (getParameters().getOperation() == ImageOperation.Copy) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    overrideParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), getParameters());
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (getParameters().getOperation() == ImageOperation.Copy && !isTemplate()) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(false);
        Guid newId = Guid.newGuid();
        Guid newGroupId = Guid.newGuid();
        DiskImage image = getImage();
        image.setId(newGroupId);
        image.setImageId(newId);
        image.setDiskAlias(getDiskAlias());
        image.setStorageIds(new ArrayList<Guid>());
        image.getStorageIds().add(getParameters().getStorageDomainId());
        image.setQuotaId(getParameters().getQuotaId());
        image.setDiskProfileId(getParameters().getDiskProfileId());
        getParameters().setDestinationImageId(newId);
        getParameters().setImageGroupID(getParameters().getImageGroupID());
        getParameters().setDestImageGroupId(newGroupId);
    } else {
        getParameters().setUseCopyCollapse(false);
        getParameters().setDestinationImageId(getImageId());
        getParameters().setImageGroupID(getImageGroupId());
        getParameters().setDestImageGroupId(getImageGroupId());
    }
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    getParameters().setDiskProfileId(getImage().getDiskProfileId());
}
#method_after
private void overrideParameters() {
    if (getParameters().getOperation() == ImageOperation.Copy) {
        getParameters().setUseCopyCollapse(true);
        getParameters().setAddImageDomainMapping(true);
        if (!isTemplate()) {
            prepareCopyNotTemplate();
        }
    } else {
        getParameters().setUseCopyCollapse(false);
    }
    if (getParameters().getOperation() == ImageOperation.Move || isTemplate()) {
        getParameters().setDestinationImageId(getImageId());
        getParameters().setImageGroupID(getImageGroupId());
        getParameters().setDestImageGroupId(getImageGroupId());
    }
    getParameters().setVolumeFormat(getDiskImage().getVolumeFormat());
    getParameters().setVolumeType(getDiskImage().getVolumeType());
    getParameters().setCopyVolumeType(CopyVolumeType.SharedVol);
    getParameters().setParentCommand(getActionType());
    getParameters().setParentParameters(getParameters());
    getParameters().setDiskProfileId(getImage().getDiskProfileId());
}
#end_block

#method_before
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmDiskImage(false);
    mockGetVmsListForDisk();
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#method_after
@Test
public void canDoActionVmIsNotDown() throws Exception {
    initializeCommand(ImageOperation.Move);
    initSnapshotValidator();
    initVmDiskImage(false);
    mockGetVmsListForDisk();
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(vmDeviceDao).when(command).getVmDeviceDAO();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN.toString()));
}
#end_block

#method_before
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initVmForSpace();
    initVmDiskImage(false);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#method_after
@Test
public void canDoActionEnoughSpace() throws Exception {
    initializeCommand(ImageOperation.Move);
    initSnapshotValidator();
    initVmForSpace();
    initVmDiskImage(false);
    initSrcStorageDomain();
    initDestStorageDomain(StorageType.NFS);
    doReturn(mockStorageDomainValidatorWithSpace()).when(command).createStorageDomainValidator();
    CanDoActionTestUtils.runAndAssertCanDoActionSuccess(command);
}
#end_block

#method_before
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    VmDevice device = new VmDevice();
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, device));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#method_after
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, vmDevice));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#end_block

#method_before
@Override
public SafeHtml getValue() {
    if (showUnderline) {
        return templates.underlinedHeader(headerText);
    }
    return headerText;
}
#method_after
@Override
public SafeHtml getValue() {
    return headerText;
}
#end_block

#method_before
protected void setValue(SafeHtml headerText) {
    this.headerText = headerText;
}
#method_after
protected void setValue(SafeHtml headerText) {
    if (showUnderline) {
        this.headerText = templates.underlinedHeader(headerText);
    } else {
        this.headerText = headerText;
    }
}
#end_block

#method_before
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#method_after
public static void filterImageDisksForVM(VM vm) {
    List<DiskImage> filteredDisks = ImagesHandler.filterImageDisks(vm.getDiskMap().values(), false, false, true);
    List<CinderDisk> filteredCinderDisks = ImagesHandler.filterDisksBasedOnCinder(vm.getDiskMap().values());
    filteredDisks.addAll(filteredCinderDisks);
    Collection<? extends Disk> vmDisksToRemove = CollectionUtils.subtract(vm.getDiskMap().values(), filteredDisks);
    vm.clearDisks();
    updateDisksForVm(vm, filteredDisks);
    for (Disk diskToRemove : vmDisksToRemove) {
        vm.getManagedVmDeviceMap().remove(diskToRemove.getId());
    }
}
#end_block

#method_before
public static ValidationResult checkVmNumaNodesIntegrity(VM paramsVm, VM actualVm) {
    List<VmNumaNode> vmNumaNodes = paramsVm.getvNumaNodeList();
    if (vmNumaNodes == null || vmNumaNodes.isEmpty()) {
        // no NUMA nodes from parameters (empty parameter)
        // try getting the actual vm NUMA nodes from database
        vmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(actualVm.getId());
    }
    if (// no NUMA nodes
    vmNumaNodes == null || vmNumaNodes.isEmpty())
        return ValidationResult.VALID;
    int cpuCount = paramsVm.getNumOfCpus();
    if (// no CPU count from parameters (empty parameter)
    cpuCount == 0)
        cpuCount = actualVm.getNumOfCpus();
    if (cpuCount < vmNumaNodes.size()) {
        return new ValidationResult(VdcBllMessages.VM_NUMA_NODE_MORE_NODES_THEN_CPUS, String.format("$numaNodes %d", vmNumaNodes.size()), String.format("$cpus %d", cpuCount));
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult checkVmNumaNodesIntegrity(VM paramsVm, VM actualVm, boolean isNumaChanged) {
    /* calculate the actual NUMA nodes */
    List<VmNumaNode> paramVmNumaNodes = paramsVm.getvNumaNodeList();
    boolean emptyParamVmNumaNodes = (paramVmNumaNodes == null) || (paramVmNumaNodes.isEmpty());
    /* origVmNumaNodes = NUMA nodes list prior to update. */
    List<VmNumaNode> origVmNumaNodes = DbFacade.getInstance().getVmNumaNodeDAO().getAllVmNumaNodeByVmId(actualVm.getId());
    boolean emptyOrigVmNumaNodes = (origVmNumaNodes == null) || (origVmNumaNodes.isEmpty());
    int NUMAnodesCount = 0;
    /* return valid if no NUMA nodes */
    if (emptyParamVmNumaNodes && emptyOrigVmNumaNodes) {
        return ValidationResult.VALID;
    }
    /* if no NUMA nodes in parameters, but there are NUMA nodes in previous vm */
    if (emptyParamVmNumaNodes && !emptyOrigVmNumaNodes) {
        /* REST-api always provide emptyParamVmNumaNodes */
        /* REST-api modifies NUMA nodes via: addVmNumaNodeCommand/updateVmNumaNodeCommand */
        /* count NUMA nodes in previous vm, by default */
        NUMAnodesCount = origVmNumaNodes.size();
        /* if GUI update to reset NUMA nodes */
        if (isNumaChanged == true)
            // no NUMA nodes.
            return ValidationResult.VALID;
    }
    if (!emptyParamVmNumaNodes) {
        // An update to NUMA nodes
        NUMAnodesCount = paramVmNumaNodes.size();
    }
    // REST-api assigns cpuCount to parameters.
    int cpuCount = paramsVm.getNumOfCpus();
    if (cpuCount < NUMAnodesCount) {
        return new ValidationResult(VdcBllMessages.VM_NUMA_NODE_MORE_NODES_THAN_CPUS, String.format("$numaNodes %d", NUMAnodesCount), String.format("$cpus %d", cpuCount));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm())))
        return false;
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVm().getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && !validate(VmHandler.checkVmNumaNodesIntegrity(getParameters().getVm(), getVm(), getParameters().isUpdateNuma()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        final boolean isDedicatedVmForVdsChanged = !(getVm().getDedicatedVmForVds() == null ? getParameters().getVmStaticData().getDedicatedVmForVds() == null : getVm().getDedicatedVmForVds().equals(getParameters().getVmStaticData().getDedicatedVmForVds()));
        final boolean isCpuPinningChanged = !(getVm().getCpuPinning() == null ? getParameters().getVmStaticData().getCpuPinning() == null : getVm().getCpuPinning().equals(getParameters().getVmStaticData().getCpuPinning()));
        if (isDedicatedVmForVdsChanged || isCpuPinningChanged) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        if (isDedicatedVmForVdsChanged() || isCpuPinningChanged()) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
public <T> void bind(Class<T> pureClsType, T instance) {
    Mockito.when(mockedInjector.instanceOf(pureClsType)).thenReturn(instance);
}
#method_after
public <T> void bind(Class<T> pureClsType, T instance) {
    when(mockedInjector.instanceOf(pureClsType)).thenReturn(instance);
}
#end_block

#method_before
@Override
public String toString() {
    return "StorageDomainStatic[" + getName() + ", " + getId() + "]";
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("name", getName()).append("id", getId()).build();
}
#end_block

#method_before
private void handleDelete(String prefix, Collection<DetailedLink> results, Method m) {
    if (m.getParameterTypes().length > 1) {
        Class<?>[] parameterTypes = m.getParameterTypes();
        Annotation[][] parameterAnnotations = m.getParameterAnnotations();
        for (int i = 0; i < parameterTypes.length; i++) {
            // ignore the id parameter (string), that's annotated with @PathParam
            if (!(parameterTypes[i].equals(String.class) && (!(parameterAnnotations[i].length == 0)))) {
                DetailedLink link = new RsdlBuilder.LinkBuilder().url(prefix + "/{" + getSingleForm(prefix) + ":id}").rel(DELETE).requestParameter(parameterTypes[i].getSimpleName()).httpMethod(HttpMethod.DELETE).build();
                addCommonActionParameters(link);
                addAsyncMatrixParameter(link);
                results.add(link);
                // we can break, because we excpect only one parameter.
                return;
            }
        }
    } else {
        DetailedLink link = new RsdlBuilder.LinkBuilder().url(prefix + "/{" + getSingleForm(prefix) + ":id}").rel(DELETE).httpMethod(HttpMethod.DELETE).build();
        addCommonActionParameters(link);
        addAsyncMatrixParameter(link);
        results.add(link);
    }
}
#method_after
private void handleDelete(String prefix, Collection<DetailedLink> results, Method m) {
    boolean collectionLevel = m.getAnnotation(Path.class) == null;
    if (m.getParameterTypes().length > 1) {
        Class<?>[] parameterTypes = m.getParameterTypes();
        Annotation[][] parameterAnnotations = m.getParameterAnnotations();
        for (int i = 0; i < parameterTypes.length; i++) {
            // ignore the id parameter (string), that's annotated with @PathParam
            if (!(parameterTypes[i].equals(String.class) && (!(parameterAnnotations[i].length == 0)))) {
                DetailedLink link = new RsdlBuilder.LinkBuilder().url(prefix + (collectionLevel ? "" : "/{" + getSingleForm(prefix) + ":id}")).rel(DELETE).requestParameter(parameterTypes[i].getSimpleName()).httpMethod(HttpMethod.DELETE).build();
                addCommonActionParameters(link);
                addAsyncMatrixParameter(link);
                results.add(link);
                // we can break, because we excpect only one parameter.
                return;
            }
        }
    } else {
        DetailedLink link = new RsdlBuilder.LinkBuilder().url(prefix + (collectionLevel ? "" : "/{" + getSingleForm(prefix) + ":id}")).rel(DELETE).httpMethod(HttpMethod.DELETE).build();
        addCommonActionParameters(link);
        addAsyncMatrixParameter(link);
        results.add(link);
    }
}
#end_block

#method_before
protected void getDowntime() {
    if (getVm() != null && getVm().getStatus() == VMStatus.Up) {
        try {
            VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
            if (retVal != null) {
                actualDowntime = (Integer) retVal.getReturnValue();
            }
        } catch (VdcBLLException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#method_after
protected void getDowntime() {
    if (FeatureSupported.migrateDowntime(getVm().getVdsGroupCompatibilityVersion())) {
        try {
            VDSReturnValue retVal = runVdsCommand(VDSCommandType.MigrateStatus, new MigrateStatusVDSCommandParameters(getDestinationVdsId(), getVmId()));
            if (retVal != null) {
                actualDowntime = (Integer) retVal.getReturnValue();
            }
        } catch (VdcBLLException e) {
            migrationErrorCode = e.getErrorCode();
        }
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion())) {
        return failCanDoAction(VdcBllMessages.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(VMStatus.NotResponding));
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetVdsGroupId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetVdsGroupId());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getDestinationVdsId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    // forceRemove not used in gluster API
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStart").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<String>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(remoteUserName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(userName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(remoteUserName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, remoteUserName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("onCreateVolume", volumeListModel);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            innerVolumeModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", volumeListModel));
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#method_after
private void newVolume() {
    if (getWindow() != null) {
        return;
    }
    VolumeModel volumeModel = new VolumeModel();
    volumeModel.setHelpTag(HelpTag.new_volume);
    // $NON-NLS-1$
    volumeModel.setHashName("new_volume");
    volumeModel.setTitle(ConstantsManager.getInstance().getConstants().newVolumeTitle());
    setWindow(volumeModel);
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VolumeListModel volumeListModel = (VolumeListModel) model;
            VolumeModel innerVolumeModel = (VolumeModel) volumeListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (volumeListModel.getSystemTreeSelectedItem() != null) {
                switch(volumeListModel.getSystemTreeSelectedItem().getType()) {
                    case Volumes:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerVolumeModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerVolumeModel.getDataCenter().setIsChangeable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerVolumeModel.getCluster().setItems(Arrays.asList(cluster));
                        innerVolumeModel.getCluster().setSelectedItem(cluster);
                        innerVolumeModel.getCluster().setIsChangeable(false);
                        innerVolumeModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case Clusters:
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) volumeListModel.getSystemTreeSelectedItem().getEntity();
                        innerVolumeModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerVolumeModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerVolumeModel.getDataCenter().setIsChangeable(false);
                        innerVolumeModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerVolumeModel.getDataCenter().setItems(dataCenters);
                        innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerVolumeModel.getDataCenter().setItems(dataCenters);
                innerVolumeModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            // $NON-NLS-1$
            UICommand command = UICommand.createDefaultOkUiCommand("onCreateVolume", volumeListModel);
            innerVolumeModel.getCommands().add(command);
            // $NON-NLS-1$
            innerVolumeModel.getCommands().add(UICommand.createCancelUiCommand("Cancel", volumeListModel));
        }
    };
    AsyncDataProvider.getInstance().getDataCenterByClusterServiceList(_asyncQuery, false, true);
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowConfigureClusterSnapshotOptions = true;
    boolean allowConfigureVolumeSnapshotOptions = false;
    boolean allowCreateSnapshot = false;
    boolean allowEditSnapshotSchedule = false;
    boolean allowCreateGeoRepSession = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
            allowConfigureVolumeSnapshotOptions = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateGeoRepSession = volumeEntity.getStatus() == GlusterStatus.UP;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
        allowCreateSnapshot = isCreateSnapshotAvailable(list);
        allowEditSnapshotSchedule = isEditSnapshotScheduleAvailable(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getConfigureClusterSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureClusterSnapshotOptions);
    getConfigureVolumeSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureVolumeSnapshotOptions);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
    getNewGeoRepSessionCommand().setIsExecutionAllowed(allowCreateGeoRepSession);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    boolean allowStartProfiling = false;
    boolean allowStopProfiling = false;
    boolean allowProfileStatisticsDetails = false;
    boolean allowConfigureClusterSnapshotOptions = true;
    boolean allowConfigureVolumeSnapshotOptions = false;
    boolean allowCreateSnapshot = false;
    boolean allowEditSnapshotSchedule = false;
    boolean allowCreateGeoRepSession = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        allowStartProfiling = isStartProfileAvailable(list);
        allowStopProfiling = isStopProfileAvailable(list);
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() == null ? asyncTask.getJobStatus() != JobExecutionStatus.STARTED : asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
            allowConfigureVolumeSnapshotOptions = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateGeoRepSession = volumeEntity.getStatus() == GlusterStatus.UP;
            allowCreateSnapshot = isCreateSnapshotAvailable(volumeEntity);
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
        allowProfileStatisticsDetails = getProfileStatisticsAvailability(list);
        allowEditSnapshotSchedule = isEditSnapshotScheduleAvailable(list);
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    getConfigureClusterSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureClusterSnapshotOptions);
    getConfigureVolumeSnapshotOptionsCommand().setIsExecutionAllowed(allowConfigureVolumeSnapshotOptions);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
    getStartVolumeProfilingCommand().setIsExecutionAllowed(allowStartProfiling);
    getStopVolumeProfilingCommand().setIsExecutionAllowed(allowStopProfiling);
    getShowVolumeProfileDetailsCommand().setIsExecutionAllowed(allowProfileStatisticsDetails);
    getNewGeoRepSessionCommand().setIsExecutionAllowed(allowCreateGeoRepSession);
}
#end_block

#method_before
private boolean isCreateSnapshotAvailable(List<GlusterVolumeEntity> list) {
    boolean bricksUpFlag = true;
    if (list.size() == 1) {
        List<GlusterBrickEntity> bricks = list.get(0).getBricks();
        for (GlusterBrickEntity brick : bricks) {
            if (brick.getStatus() != GlusterStatus.UP) {
                bricksUpFlag = false;
                break;
            }
        }
        return (list.get(0).getStatus() == GlusterStatus.UP && bricksUpFlag);
    } else {
        return false;
    }
}
#method_after
private boolean isCreateSnapshotAvailable(GlusterVolumeEntity volume) {
    if (volume.getStatus() == GlusterStatus.UP) {
        List<GlusterBrickEntity> bricks = volume.getBricks();
        for (GlusterBrickEntity brick : bricks) {
            if (brick.getStatus() != GlusterStatus.UP) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
private void startRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StartRebalanceGlusterVolume, list);
}
#method_after
private void startRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.StartRebalanceGlusterVolume, list, null, true, true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (brick.getStatus() == GlusterStatus.DOWN) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterVolumeEntity volume = getGlusterVolume();
    if (volume.getStatus() == GlusterStatus.DOWN) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_DOWN);
    }
    if (!GlusterUtil.getInstance().isVolumeThinlyProvisioned(volume)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_IS_NOT_THINLY_PROVISIONED);
    }
    if (getDbFacade().getGlusterVolumeSnapshotDao().getByName(getGlusterVolumeId(), snapshot.getSnapshotName()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_SNAPSHOT_ALREADY_EXISTS);
    }
    List<GlusterBrickEntity> bricks = volume.getBricks();
    for (GlusterBrickEntity brick : bricks) {
        if (!brick.isOnline()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ONE_OR_MORE_BRICKS_ARE_DOWN);
        }
    }
    for (GlusterGeoRepSession session : georepSessions) {
        if (session.getSlaveNodeUuid() == null || session.getSlaveVolumeId() == null) {
            // the volume
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_REMOTE_CLUSTER_NOT_MAINTAINED_BY_ENGINE);
        }
    }
    return true;
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowRestore = false;
    boolean allowDelete = true;
    boolean allowDeleteAll = true;
    boolean allowActivate = false;
    boolean allowDeactivate = false;
    boolean allowCreateSnapshot = true;
    boolean allowEditSnapshotSchedule = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowDelete = false;
    } else {
        List<GlusterVolumeSnapshotEntity> snapshots = Linq.<GlusterVolumeSnapshotEntity>cast(getSelectedItems());
        if (snapshots.size() == 1) {
            allowRestore = true;
            allowActivate = snapshots.get(0).getStatus() == GlusterSnapshotStatus.DEACTIVATED;
            allowDeactivate = snapshots.get(0).getStatus() == GlusterSnapshotStatus.ACTIVATED;
        }
    }
    if (getEntity() == null || getEntity().getStatus() != GlusterStatus.UP) {
        allowCreateSnapshot = false;
    }
    if (getEntity() != null && getEntity().getStatus() == GlusterStatus.UP && getEntity().getSnapshotScheduled()) {
        allowEditSnapshotSchedule = true;
    }
    getRestoreSnapshotCommand().setIsExecutionAllowed(allowRestore);
    getDeleteSnapshotCommand().setIsExecutionAllowed(allowDelete);
    getDeleteAllSnapshotsCommand().setIsExecutionAllowed(allowDeleteAll);
    getActivateSnapshotCommand().setIsExecutionAllowed(allowActivate);
    getDeactivateSnapshotCommand().setIsExecutionAllowed(allowDeactivate);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
}
#method_after
private void updateActionAvailability() {
    boolean allowRestore = false;
    boolean allowDelete = true;
    boolean allowDeleteAll = getItems() == null ? false : getItems().size() > 0;
    boolean allowActivate = false;
    boolean allowDeactivate = false;
    boolean allowCreateSnapshot = true;
    boolean allowEditSnapshotSchedule = false;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowDelete = false;
    } else {
        List<GlusterVolumeSnapshotEntity> snapshots = Linq.<GlusterVolumeSnapshotEntity>cast(getSelectedItems());
        if (snapshots.size() == 1) {
            allowRestore = true;
            allowActivate = snapshots.get(0).getStatus() == GlusterSnapshotStatus.DEACTIVATED;
            allowDeactivate = snapshots.get(0).getStatus() == GlusterSnapshotStatus.ACTIVATED;
        }
    }
    if (getEntity() == null || getEntity().getStatus() == GlusterStatus.DOWN) {
        allowCreateSnapshot = false;
    }
    if (getEntity() != null && getEntity().getStatus() == GlusterStatus.UP && getEntity().getSnapshotScheduled()) {
        allowEditSnapshotSchedule = true;
    }
    getRestoreSnapshotCommand().setIsExecutionAllowed(allowRestore);
    getDeleteSnapshotCommand().setIsExecutionAllowed(allowDelete);
    getDeleteAllSnapshotsCommand().setIsExecutionAllowed(allowDeleteAll);
    getActivateSnapshotCommand().setIsExecutionAllowed(allowActivate);
    getDeactivateSnapshotCommand().setIsExecutionAllowed(allowDeactivate);
    getCreateSnapshotCommand().setIsExecutionAllowed(allowCreateSnapshot);
    getEditSnapshotScheduleCommand().setIsExecutionAllowed(allowEditSnapshotSchedule);
}
#end_block

#method_before
private void createNewSnapshot(final GlusterVolumeSnapshotModel snapshotModel) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volumeEntity.getClusterId());
    snapshot.setSnapshotName(snapshotModel.getSnapshotName().getEntity());
    snapshot.setVolumeId(volumeEntity.getId());
    snapshot.setDescription(snapshotModel.getDescription().getEntity());
    CreateGlusterVolumeSnapshotParameters parameter = new CreateGlusterVolumeSnapshotParameters(snapshot, true);
    snapshotModel.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeSnapshot, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            localModel.stopProgress();
            localModel.postSnapshotAction(result.getReturnValue());
        }
    }, this);
}
#method_after
private void createNewSnapshot(final GlusterVolumeSnapshotModel snapshotModel) {
    GlusterVolumeEntity volumeEntity = getEntity();
    final GlusterVolumeSnapshotEntity snapshot = new GlusterVolumeSnapshotEntity();
    snapshot.setClusterId(volumeEntity.getClusterId());
    snapshot.setSnapshotName(snapshotModel.getSnapshotName().getEntity());
    snapshot.setVolumeId(volumeEntity.getId());
    snapshot.setDescription(snapshotModel.getDescription().getEntity());
    CreateGlusterVolumeSnapshotParameters parameter = new CreateGlusterVolumeSnapshotParameters(snapshot, false);
    snapshotModel.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.CreateGlusterVolumeSnapshot, parameter, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            GlusterVolumeSnapshotListModel localModel = (GlusterVolumeSnapshotListModel) result.getState();
            localModel.stopProgress();
            localModel.postSnapshotAction(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
protected boolean checkCanDisableVirtIoScsi() {
    VmValidator vmValidator = createVmValidator(vmFromConfiguration);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
        return false;
    } else
        return true;
}
#method_after
protected boolean checkCanDisableVirtIoScsi() {
    VmValidator vmValidator = createVmValidator(vmFromConfiguration);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(getAdjustedDiskImagesFromConfiguration()))) {
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
private Collection<CommandAssociatedEntity> buildCommandAssociatedEntities(Guid cmdId, SubjectEntity... subjectEntities) {
    if (subjectEntities.length == 0) {
        return Collections.emptyList();
    }
    Set<CommandAssociatedEntity> results = new HashSet<>(subjectEntities.length);
    for (SubjectEntity subjectEntity : subjectEntities) {
        results.add(new CommandAssociatedEntity(cmdId, subjectEntity.getEntityType(), subjectEntity.getEntityId()));
    }
    return results;
}
#method_after
private Collection<CommandAssociatedEntity> buildCommandAssociatedEntities(Guid cmdId, SubjectEntity... subjectEntities) {
    if (subjectEntities.length == 0) {
        return Collections.emptyList();
    }
    Set<SubjectEntity> entities = new HashSet<>(Arrays.asList(subjectEntities));
    List<CommandAssociatedEntity> results = new ArrayList<>(entities.size());
    for (SubjectEntity subjectEntity : entities) {
        results.add(new CommandAssociatedEntity(cmdId, subjectEntity.getEntityType(), subjectEntity.getEntityId()));
    }
    return results;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (canCreateBrick ? 0 : 1);
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((devPath == null) ? 0 : devPath.hashCode());
    result = prime * result + ((devType == null) ? 0 : devType.hashCode());
    result = prime * result + ((devUuid == null) ? 0 : devUuid.hashCode());
    result = prime * result + ((fsType == null) ? 0 : fsType.hashCode());
    result = prime * result + ((fsUuid == null) ? 0 : fsUuid.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((mountPoint == null) ? 0 : mountPoint.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (size ^ (size >>> 32));
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + (canCreateBrick ? 0 : 1);
    result = prime * result + (isGlusterBrick ? 0 : 1);
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + ((devPath == null) ? 0 : devPath.hashCode());
    result = prime * result + ((devType == null) ? 0 : devType.hashCode());
    result = prime * result + ((devUuid == null) ? 0 : devUuid.hashCode());
    result = prime * result + ((fsType == null) ? 0 : fsType.hashCode());
    result = prime * result + ((fsUuid == null) ? 0 : fsUuid.hashCode());
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((mountPoint == null) ? 0 : mountPoint.hashCode());
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + (int) (size ^ (size >>> 32));
    result = prime * result + ((vdsId == null) ? 0 : vdsId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if ((obj != null) && (obj instanceof StorageDevice)) {
        StorageDevice storageDevice = (StorageDevice) obj;
        if (ObjectUtils.objectsEqual(getId(), storageDevice.getId()) && canCreateBrick == storageDevice.canCreateBrick && (ObjectUtils.objectsEqual(getDescription(), storageDevice.getDescription())) && (ObjectUtils.objectsEqual(getDevPath(), storageDevice.getDevPath())) && (ObjectUtils.objectsEqual(getDevType(), storageDevice.getDevType())) && (ObjectUtils.objectsEqual(getDevUuid(), storageDevice.getDevUuid())) && (ObjectUtils.objectsEqual(getFsType(), storageDevice.getFsType())) && (ObjectUtils.objectsEqual(getFsUuid(), storageDevice.getFsUuid())) && (ObjectUtils.objectsEqual(getMountPoint(), storageDevice.getMountPoint())) && (ObjectUtils.objectsEqual(getName(), storageDevice.getName())) && size == storageDevice.size && (ObjectUtils.objectsEqual(getVdsId(), storageDevice.getVdsId()))) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if ((obj != null) && (obj instanceof StorageDevice)) {
        StorageDevice storageDevice = (StorageDevice) obj;
        if (ObjectUtils.objectsEqual(getId(), storageDevice.getId()) && canCreateBrick == storageDevice.canCreateBrick && isGlusterBrick == storageDevice.isGlusterBrick && (ObjectUtils.objectsEqual(getDescription(), storageDevice.getDescription())) && (ObjectUtils.objectsEqual(getDevPath(), storageDevice.getDevPath())) && (ObjectUtils.objectsEqual(getDevType(), storageDevice.getDevType())) && (ObjectUtils.objectsEqual(getDevUuid(), storageDevice.getDevUuid())) && (ObjectUtils.objectsEqual(getFsType(), storageDevice.getFsType())) && (ObjectUtils.objectsEqual(getFsUuid(), storageDevice.getFsUuid())) && (ObjectUtils.objectsEqual(getMountPoint(), storageDevice.getMountPoint())) && (ObjectUtils.objectsEqual(getName(), storageDevice.getName())) && size == storageDevice.size && (ObjectUtils.objectsEqual(getVdsId(), storageDevice.getVdsId()))) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("name", name).append("devUuid", devUuid).append("fsUuid", fsUuid).append("vdsId", vdsId).append("description", description).append("devType", devType).append("devPath", devPath).append("fsType", fsType).append("mountPoint", mountPoint).append("size", size).append("canCreateBrick", canCreateBrick).build();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("id", id).append("name", name).append("devUuid", devUuid).append("fsUuid", fsUuid).append("vdsId", vdsId).append("description", description).append("devType", devType).append("devPath", devPath).append("fsType", fsType).append("mountPoint", mountPoint).append("size", size).append("canCreateBrick", canCreateBrick).append("isGlusterBrick", isGlusterBrick).build();
}
#end_block

#method_before
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("vdsSpmId", getVdsSpmId()).append("storagePoolId", getStoragePoolId()).append("storagePoolName", getStoragePoolName()).append("masterDomainId", getMasterDomainId()).append("masterVersion", getMasterVersion()).append("domainsList", getPrintableDomainsList());
}
#method_after
@Override
protected ToStringBuilder appendAttributes(ToStringBuilder tsb) {
    return super.appendAttributes(tsb).append("vdsSpmId", getVdsSpmId()).append("storagePoolId", getStoragePoolId()).append("storagePoolName", getStoragePoolName()).append("masterDomainId", getMasterDomainId()).append("masterVersion", getMasterVersion()).append("domainsList", getDomainsList());
}
#end_block

#method_before
public boolean isStateValid() {
    return isValid;
}
#method_after
@Override
public boolean isStateValid() {
    return isValid;
}
#end_block

#method_before
@Override
protected void initWidget(Widget wrapperWidget) {
    super.initWidget(wrapperWidget);
    contentWidgetContainer.setWidget(contentWidget);
    // Adjust content widget width
    // $NON-NLS-1$
    contentWidget.asWidget().setWidth("100%");
    // Assign ID to content widget element if it's missing or empty
    Element contentWidgetElement = getContentWidgetElement();
    if (contentWidgetElement.getId() == null || contentWidgetElement.getId().isEmpty()) {
        contentWidgetElement.setId(DOM.createUniqueId());
    }
    // Connect label with content widget for better accessibility
    updateLabelElementId(getContentWidgetElement().getId());
}
#method_after
@Override
protected void initWidget(Widget wrapperWidget) {
    super.initWidget(wrapperWidget);
    contentWidgetContainer.setWidget(contentWidget);
    label.addStyleName(OvirtCss.LABEL_ENABLED);
    // Assign ID to content widget element if it's missing or empty
    Element contentWidgetElement = getContentWidgetElement();
    if (contentWidgetElement.getId() == null || contentWidgetElement.getId().isEmpty()) {
        setElementId(DOM.createUniqueId());
    }
}
#end_block

#method_before
protected void updateLabelElementId(String elementId) {
    labelElement.setHtmlFor(elementId);
}
#method_after
protected void updateLabelElementId(String elementId) {
    label.setFor(elementId);
}
#end_block

#method_before
public void setUsePatternFly(final boolean use) {
    this.usePatternFly = use;
    if (use) {
        // set the style to the bootstrap / patternfly style
        setContentWidgetStyleName(PatternflyConstants.FORM_CONTROL);
        // Set the content width back to default.
        // $NON-NLS-1$
        addLabelStyleName("label col-sm-2 col-md-2 control-label");
        // $NON-NLS-1$
        addContentWidgetContainerStyleName("col-sm-10 col-md-10");
        wrapperPanel.getElement().addClassName(PatternflyConstants.FORM_GROUP);
        wrapperPanel.getElement().removeClassName(style.wrapper());
        contentWidgetContainer.asWidget().removeStyleName(style.contentWidget());
    }
}
#method_after
public void setUsePatternFly(final boolean usePatternFly) {
    // toggle styles -- remove both PatternFly and non-PatternFly styles
    removeLabelStyleName(style.label_legacy());
    removeContentWidgetStyleName(style.contentWidget_legacy());
    removeContentWidgetStyleName(Styles.FORM_CONTROL);
    removeContentWidgetContainerStyleName(style.contentWidgetContainer_legacy());
    // $NON-NLS-1$
    removeContentWidgetContainerStyleName("avw_contentWidgetContainer_pfly_fix");
    removeWrapperStyleName(Styles.FORM_GROUP);
    removeWrapperStyleName(style.wrapper_legacy());
    // $NON-NLS-1$
    removeWrapperStyleName("avw_wrapper_pfly_fix");
    // add the proper styles
    if (usePatternFly) {
        addContentWidgetStyleName(Styles.FORM_CONTROL);
        addWrapperStyleName(Styles.FORM_GROUP);
    } else {
        addLabelStyleName(style.label_legacy());
        addContentWidgetStyleName(style.contentWidget_legacy());
        addContentWidgetContainerStyleName(style.contentWidgetContainer_legacy());
        // $NON-NLS-1$
        addContentWidgetContainerStyleName("avw_contentWidgetContainer_pfly_fix");
        addWrapperStyleName(style.wrapper_legacy());
        // $NON-NLS-1$
        addWrapperStyleName("avw_wrapper_pfly_fix");
    }
}
#end_block

#method_before
@Override
public String getLabel() {
    return labelElement.getInnerText();
}
#method_after
@Override
public String getLabel() {
    return label.getElement().getInnerText();
}
#end_block

#method_before
@Override
public void setLabel(String label) {
    labelElement.setInnerText(label);
}
#method_after
@Override
public void setLabel(String labelText) {
    label.getElement().setInnerText(labelText);
}
#end_block

#method_before
@Override
public void setEnabled(boolean enabled) {
    contentWidget.setEnabled(enabled);
    if (enabled) {
        if (usePatternFly) {
            getLabelElement().replaceClassName(style.labelDisabled(), style.labelEnabledPatternFly());
        } else {
            getLabelElement().replaceClassName(style.labelDisabled(), style.labelEnabled());
        }
    } else {
        if (usePatternFly) {
            getLabelElement().replaceClassName(style.labelEnabledPatternFly(), style.labelDisabled());
            // In case the style got added somewhere else, remove it.
            getLabelElement().removeClassName(style.labelEnabled());
        } else {
            getLabelElement().replaceClassName(style.labelEnabled(), style.labelDisabled());
        }
    }
    if (!keepTitleOnSetEnabled) {
        updateWidgetTitle(null);
    }
}
#method_after
@Override
public void setEnabled(boolean enabled) {
    contentWidget.setEnabled(enabled);
    if (enabled) {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_DISABLED, OvirtCss.LABEL_ENABLED);
    } else {
        getFormLabel().getElement().replaceClassName(OvirtCss.LABEL_ENABLED, OvirtCss.LABEL_DISABLED);
    }
}
#end_block

#method_before
@Override
public void disable(String disabilityHint) {
    setEnabled(false);
    updateWidgetTitle(disabilityHint);
}
#method_after
@Override
public void disable(String disabilityHint) {
    setEnabled(false);
    setWidgetTooltip(disabilityHint);
}
#end_block

#method_before
@Override
public void markAsValid() {
    if (editorStateValid) {
        super.markAsValid();
    }
}
#method_after
@Override
public void markAsValid() {
    if (editorStateValid) {
        super.markAsValid();
    }
    labelTooltip.setText(labelConfiguredTooltip);
    labelTooltip.reconfigure();
    contentWidgetContainerTooltip.setText(contentWidgetContainerConfiguredTooltip);
    contentWidgetContainerTooltip.reconfigure();
}
#end_block

#method_before
public void addContentWidgetStyleName(String styleName) {
    if (usePatternFly) {
        getContentWidgetElement().addClassName(styleName);
    } else {
        contentWidgetContainer.addStyleName(styleName);
    }
}
#method_after
// set styleNames on my components
public void addContentWidgetStyleName(String styleName) {
    getContentWidget().asWidget().addStyleName(styleName);
}
#end_block

#method_before
public void setContentWidgetStyleName(String styleName) {
    if (usePatternFly) {
        getContentWidgetElement().setClassName(styleName);
    } else {
        contentWidgetContainer.setStyleName(styleName);
    }
}
#method_after
public void setContentWidgetStyleName(String styleName) {
    getContentWidget().asWidget().setStyleName(styleName);
}
#end_block

#method_before
public void addLabelStyleName(String styleName) {
    getLabelElement().addClassName(styleName);
}
#method_after
public void addLabelStyleName(String styleName) {
    getFormLabel().addStyleName(styleName);
}
#end_block

#method_before
public void setLabelStyleName(String styleName) {
    getLabelElement().setClassName(styleName);
}
#method_after
public void setLabelStyleName(String styleName) {
    getFormLabel().setStyleName(styleName);
}
#end_block

#method_before
public void hideLabel() {
    getLabelElement().addClassName(style.labelHidden());
}
#method_after
// end set styleNames on my components
public void hideLabel() {
    getFormLabel().setVisible(false);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public <T> boolean visit(final EditorContext<T> ctx) {
    String absolutePath = ctx.getAbsolutePath();
    LeafValueEditor<T> currentLeafEditor = ctx.asLeafValueEditor();
    if (currentLeafEditor == null) {
        // Ignore non-leaf Editors
        return super.visit(ctx);
    }
    final LeafValueEditor<T> editor = getActualEditor(currentLeafEditor);
    // If this Editor implements HasValueChangeHandlers, register a value change listener
    if (editor instanceof HasValueChangeHandlers) {
        ((HasValueChangeHandlers<T>) editor).addValueChangeHandler(new ValueChangeHandler<T>() {

            @Override
            public void onValueChange(ValueChangeEvent<T> event) {
                // Set value in model
                if (ctx.canSetInModel()) {
                    boolean editorValid = true;
                    if (event.getSource() instanceof EntityModelTextBox) {
                        editorValid = ((EntityModelTextBox<?>) event.getSource()).isStateValid();
                    }
                    if (editorValid) {
                        ctx.setInModel(event.getValue());
                    }
                }
            }
        });
    }
    final UiCommonEditor<T> functionalEditor = getFunctionalEditor(currentLeafEditor);
    if (functionalEditor != null) {
        // Set tab index, unless it's being set manually (i.e. already been set)
        if (functionalEditor.getTabIndex() <= 0) {
            functionalEditor.setTabIndex(++tabIndexCounter);
        }
        // Add key press handler
        functionalEditor.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                    // Set value in model
                    if (ctx.canSetInModel()) {
                        boolean editorValid = true;
                        if (editor instanceof EntityModelTextBox) {
                            editorValid = ((EntityModelTextBox<?>) editor).isStateValid();
                        }
                        if (editorValid) {
                            ctx.setInModel(editor.getValue());
                        }
                    }
                }
            }
        });
    }
    // Handle owner entity models
    if (ownerModels.containsKey(absolutePath)) {
        EntityModel ownerModel = ownerModels.get(absolutePath);
        // If this editor edits a ListModel, initialize it
        if (editor instanceof TakesConstrainedValueEditor && ownerModel instanceof ListModel) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) ownerModel);
        }
        if (functionalEditor != null) {
            // Register a property change listener on the owner entity model
            ownerModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

                @Override
                public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
                    EntityModel ownerModel = (EntityModel) sender;
                    String propName = args.propertyName;
                    // IsValid
                    if ("IsValid".equals(propName)) {
                        // $NON-NLS-1$
                        onIsValidPropertyChange(functionalEditor, ownerModel);
                    } else // IsChangable
                    if ("IsChangable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsChangablePropertyChange(functionalEditor, ownerModel);
                    } else // ChangeProhibitionReason
                    if ("ChangeProhibitionReason".equals(propName)) {
                        // $NON-NLS-1$
                        onChangeProhibitionReasonChange(functionalEditor, ownerModel);
                    } else // IsAvailable
                    if ("IsAvailable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsAvailablePropertyChange(functionalEditor, ownerModel);
                    }
                }
            });
            // Update editor since we might have missed property change
            // events fired as part of the entity model constructor
            onIsValidPropertyChange(functionalEditor, ownerModel);
            onIsChangablePropertyChange(functionalEditor, ownerModel);
            onChangeProhibitionReasonChange(functionalEditor, ownerModel);
            onIsAvailablePropertyChange(functionalEditor, ownerModel);
        }
    }
    // Register listeners
    eventMap.registerListener(absolutePath, "EntityChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((EntityModel) sender).getEntity());
        }
    });
    eventMap.registerListener(absolutePath, "ItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) sender);
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((ListModel) sender).getSelectedItem());
        }
    });
    return super.visit(ctx);
}
#method_after
@SuppressWarnings("unchecked")
@Override
public <T> boolean visit(final EditorContext<T> ctx) {
    String absolutePath = ctx.getAbsolutePath();
    LeafValueEditor<T> currentLeafEditor = ctx.asLeafValueEditor();
    if (currentLeafEditor == null) {
        // Ignore non-leaf Editors
        return super.visit(ctx);
    }
    final LeafValueEditor<T> editor = getActualEditor(currentLeafEditor);
    // If this Editor implements HasValueChangeHandlers, register a value change listener
    if (editor instanceof HasValueChangeHandlers) {
        ((HasValueChangeHandlers<T>) editor).addValueChangeHandler(new ValueChangeHandler<T>() {

            @Override
            public void onValueChange(ValueChangeEvent<T> event) {
                setInModel(ctx, event.getSource(), event.getValue());
            }
        });
    }
    final UiCommonEditor<T> functionalEditor = getFunctionalEditor(currentLeafEditor);
    if (functionalEditor != null) {
        // Set tab index, unless it's being set manually (i.e. already been set)
        if (functionalEditor.getTabIndex() <= 0) {
            functionalEditor.setTabIndex(++tabIndexCounter);
        }
        // Add key press handler
        functionalEditor.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                    setInModel(ctx, editor, editor.getValue());
                }
            }
        });
    }
    // Handle owner entity models
    if (ownerModels.containsKey(absolutePath)) {
        Model ownerModel = ownerModels.get(absolutePath);
        // If this editor edits a ListModel, initialize it
        if (editor instanceof TakesConstrainedValueEditor && ownerModel instanceof ListModel) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) ownerModel);
        }
        if (functionalEditor != null) {
            // Register a property change listener on the owner entity model
            ownerModel.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

                @Override
                public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
                    Model ownerModel = (Model) sender;
                    String propName = args.propertyName;
                    // IsValid
                    if ("IsValid".equals(propName)) {
                        // $NON-NLS-1$
                        onIsValidPropertyChange(functionalEditor, ownerModel);
                    } else // IsChangable
                    if ("IsChangable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsChangablePropertyChange(functionalEditor, ownerModel);
                    } else // ChangeProhibitionReason
                    if ("ChangeProhibitionReason".equals(propName)) {
                        // $NON-NLS-1$
                        onChangeProhibitionReasonChange(functionalEditor, ownerModel);
                    } else // IsAvailable
                    if ("IsAvailable".equals(propName)) {
                        // $NON-NLS-1$
                        onIsAvailablePropertyChange(functionalEditor, ownerModel);
                    }
                }
            });
            // Update editor since we might have missed property change
            // events fired as part of the entity model constructor
            onIsValidPropertyChange(functionalEditor, ownerModel);
            onIsChangablePropertyChange(functionalEditor, ownerModel);
            onChangeProhibitionReasonChange(functionalEditor, ownerModel);
            onIsAvailablePropertyChange(functionalEditor, ownerModel);
        }
    }
    // Register listeners
    eventMap.registerListener(absolutePath, "EntityChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((EntityModel) sender).getEntity());
        }
    });
    eventMap.registerListener(absolutePath, "ItemsChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateListEditor((TakesConstrainedValueEditor<T>) editor, (ListModel) sender);
        }
    });
    eventMap.registerListener(absolutePath, "SelectedItemChanged", new // $NON-NLS-1$
    IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            editor.setValue((T) ((ListModel) sender).getSelectedItem());
        }
    });
    return super.visit(ctx);
}
#end_block

#method_before
void onIsValidPropertyChange(HasValidation editor, EntityModel model) {
    if (model.getIsValid()) {
        editor.markAsValid();
    } else {
        // updating the error message.
        if (editor.isValid()) {
            editor.markAsInvalid(model.getInvalidityReasons());
        }
    }
}
#method_after
void onIsValidPropertyChange(HasValidation editor, Model model) {
    if (model.getIsValid()) {
        editor.markAsValid();
    } else {
        // no possibility to go from one invalid reason to another without the editor message being updated.
        if (editor.isValid()) {
            editor.markAsInvalid(model.getInvalidityReasons());
        }
    }
}
#end_block

#method_before
void onIsChangablePropertyChange(HasEnabledWithHints editor, EntityModel model) {
    if (model.getIsChangable()) {
        editor.setEnabled(true);
    } else {
        editor.disable(model.getChangeProhibitionReason());
    }
}
#method_after
void onIsChangablePropertyChange(HasEnabledWithHints editor, Model model) {
    if (model.getIsChangable()) {
        editor.setEnabled(true);
    } else {
        editor.disable(model.getChangeProhibitionReason());
    }
}
#end_block

#method_before
void onChangeProhibitionReasonChange(HasEnabledWithHints editor, EntityModel model) {
    if (!editor.isEnabled()) {
        editor.disable(model.getChangeProhibitionReason());
    }
}
#method_after
void onChangeProhibitionReasonChange(HasEnabledWithHints editor, Model model) {
    if (!editor.isEnabled()) {
        editor.disable(model.getChangeProhibitionReason());
    }
}
#end_block

#method_before
void onIsAvailablePropertyChange(HasAccess editor, EntityModel model) {
    boolean isAvailable = model.getIsAvailable();
    editor.setAccessible(isAvailable);
}
#method_after
void onIsAvailablePropertyChange(HasAccess editor, Model model) {
    boolean isAvailable = model.getIsAvailable();
    editor.setAccessible(isAvailable);
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    startProgress(null);
    if (getEntity() != null && getEntity().getStoragePoolId() != null) {
        // Datacenter associated with this cluster.
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                model.dataCenter = (StoragePool) returnValue;
                if (model.dataCenter == null || !model.dataCenter.isLocal()) {
                    model.updateOptionsNonLocalFSData();
                } else {
                    model.updateOptionsLocalFSData();
                }
            }
        }), getEntity().getStoragePoolId());
    } else if (getEntity() != null && getEntity().getStoragePoolId() == null) {
        // No data-center associated with this cluster.
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                @SuppressWarnings("unchecked")
                List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                final List<StoragePool> localDataCenters = new ArrayList<StoragePool>();
                boolean enableButton = false;
                for (StoragePool dataCenter : dataCenters) {
                    // Find at least one compatible data-center, so we can show the button.
                    if (model.getEntity().getCompatibilityVersion().compareTo(dataCenter.getCompatibilityVersion()) >= 0) {
                        if (dataCenter.isLocal()) {
                            // Check if there are any clusters associated with this data-center already.
                            localDataCenters.add(dataCenter);
                        } else {
                            enableButton = true;
                            break;
                        }
                    }
                }
                if (enableButton || localDataCenters.isEmpty()) {
                    model.updateOptionsRequiredAddDataCenter(enableButton);
                } else {
                    model.updateOptionsRequiredAddDataCenter(localDataCenters);
                }
            }
        }));
    }
}
#method_after
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() == null) {
        return;
    }
    startProgress(null);
    if (getEntity().getStoragePoolId() != null) {
        // Datacenter associated with this cluster.
        AsyncDataProvider.getInstance().getDataCenterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                model.dataCenter = (StoragePool) returnValue;
                if (model.dataCenter == null || !model.dataCenter.isLocal()) {
                    model.updateOptionsNonLocalFSData();
                } else {
                    model.updateOptionsLocalFSData();
                }
            }
        }), getEntity().getStoragePoolId());
    } else {
        // No data-center associated with this cluster.
        AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                ClusterGuideModel model = (ClusterGuideModel) target;
                @SuppressWarnings("unchecked")
                List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                final List<StoragePool> localDataCenters = new ArrayList<StoragePool>();
                boolean enableButton = false;
                for (StoragePool dataCenter : dataCenters) {
                    // Find at least one compatible data-center, so we can show the button.
                    if (model.getEntity().getCompatibilityVersion().compareTo(dataCenter.getCompatibilityVersion()) >= 0) {
                        if (dataCenter.isLocal()) {
                            // Check if there are any clusters associated with this data-center already.
                            localDataCenters.add(dataCenter);
                        } else {
                            enableButton = true;
                            break;
                        }
                    }
                }
                if (enableButton || localDataCenters.isEmpty()) {
                    model.updateOptionsRequiredAddDataCenter(enableButton);
                } else {
                    model.updateOptionsRequiredAddDataCenter(localDataCenters);
                }
            }
        }));
    }
}
#end_block

#method_before
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangable(false);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangable(false);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", clusterGuideModel);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clusterGuideModel);
            model.getCommands().add(tempVar2);
        }
    }));
    ListModel<VDSGroup> clusterModel = model.getCluster();
    if (clusterModel.getSelectedItem() != null) {
        VDSGroup cluster = clusterModel.getSelectedItem();
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        if (jsonSupported) {
            model.getProtocol().setEntity(true);
        } else {
            model.getProtocol().setEntity(false);
            model.getProtocol().setIsChangable(false);
        }
    }
}
#method_after
public void addHost() {
    HostModel model = new NewHostModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    model.setHelpTag(HelpTag.new_host);
    // $NON-NLS-1$
    model.setHashName("new_host");
    model.getPort().setEntity(54321);
    model.getOverrideIpTables().setEntity(true);
    model.setSpmPriorityValue(null);
    model.getCluster().setSelectedItem(getEntity());
    model.getCluster().setIsChangeable(false);
    AsyncDataProvider.getInstance().getDataCenterList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterGuideModel clusterGuideModel = (ClusterGuideModel) target;
            HostModel model = (HostModel) clusterGuideModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
            model.getDataCenter().setItems(dataCenters);
            if (getEntity().getStoragePoolId() != null) {
                model.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(clusterGuideModel.getEntity().getStoragePoolId())));
            }
            model.getDataCenter().setIsChangeable(false);
            // $NON-NLS-1$
            UICommand tempVar = UICommand.createDefaultOkUiCommand("OnConfirmPMHost", clusterGuideModel);
            model.getCommands().add(tempVar);
            // $NON-NLS-1$
            UICommand tempVar2 = UICommand.createCancelUiCommand("Cancel", clusterGuideModel);
            model.getCommands().add(tempVar2);
        }
    }));
    ListModel<VDSGroup> clusterModel = model.getCluster();
    if (clusterModel.getSelectedItem() != null) {
        VDSGroup cluster = clusterModel.getSelectedItem();
        Boolean jsonSupported = (Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.JsonProtocolSupported, cluster.getCompatibilityVersion().toString());
        if (jsonSupported) {
            model.getProtocol().setEntity(true);
        } else {
            model.getProtocol().setEntity(false);
            model.getProtocol().setIsChangeable(false);
        }
    }
}
#end_block

#method_before
public void onAddDataCenter() {
    @SuppressWarnings("unchecked")
    ListModel<EntityModel<StoragePool>> dataCentersModel = (ListModel<EntityModel<StoragePool>>) getWindow();
    EntityModel<StoragePool> dataCenter = dataCentersModel.getSelectedItem();
    if (dataCenter != null) {
        VDSGroup cluster = getEntity();
        cluster.setStoragePoolId(dataCenter.getEntity().getId());
        dataCentersModel.startProgress(null);
        Frontend.getInstance().runAction(VdcActionType.UpdateVdsGroup, new AddClusterOperationParameters(cluster), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                if (result.getReturnValue().getSucceeded()) {
                    // Succeeded, close this window.
                    ClusterGuideModel guideModel = (ClusterGuideModel) result.getState();
                    guideModel.postAction();
                }
                // Close popup window.
                setWindow(null);
            }
        }, this);
    } else {
        setWindow(null);
    }
}
#method_after
public void onAddDataCenter() {
    @SuppressWarnings("unchecked")
    ListModel<EntityModel<StoragePool>> dataCentersModel = (ListModel<EntityModel<StoragePool>>) getWindow();
    EntityModel<StoragePool> dataCenter = dataCentersModel.getSelectedItem();
    if (dataCenter != null) {
        VDSGroup cluster = getEntity();
        cluster.setStoragePoolId(dataCenter.getEntity().getId());
        dataCentersModel.startProgress(null);
        Frontend.getInstance().runAction(VdcActionType.UpdateVdsGroup, new VdsGroupOperationParameters(cluster), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                if (result.getReturnValue().getSucceeded()) {
                    // Succeeded, close this window.
                    ClusterGuideModel guideModel = (ClusterGuideModel) result.getState();
                    guideModel.postAction();
                }
                // Close popup window.
                setWindow(null);
            }
        }, this);
    } else {
        setWindow(null);
    }
}
#end_block

#method_before
private void initTableColumns(ApplicationConstants constants) {
    dataCentersTable.addEntityModelColumn(new EntityModelTextColumn<StoragePool>() {

        @Override
        public String getText(StoragePool entity) {
            return entity.getName();
        }
    }, constants.dataCenter());
    dataCentersTable.addEntityModelColumn(new EntityModelTextColumn<StoragePool>() {

        @Override
        public String getText(StoragePool entity) {
            return entity.getCompatibilityVersion().getValue();
        }
    }, constants.comptVersDc());
}
#method_after
private void initTableColumns() {
    dataCentersTable.addColumn(new AbstractEntityModelTextColumn<StoragePool>() {

        @Override
        public String getText(StoragePool entity) {
            return entity.getName();
        }
    }, constants.dataCenter());
    dataCentersTable.addColumn(new AbstractEntityModelTextColumn<StoragePool>() {

        @Override
        public String getText(StoragePool entity) {
            return entity.getCompatibilityVersion().getValue();
        }
    }, constants.comptVersDc());
}
#end_block

#method_before
private void addCheckBoxColumn(boolean hideCheckbox, boolean showSelectAllCheckbox) {
    if (!hideCheckbox) {
        // Add selection column
        Column<EntityModel, Boolean> checkColumn = null;
        if (getSelectionModel() instanceof SingleSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new RadioboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
        } else if (getSelectionModel() instanceof MultiSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new CheckboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            if (showSelectAllCheckbox) {
                SelectAllCheckBoxHeader<EntityModel> selectAllHeader = new SelectAllCheckBoxHeader<EntityModel>() {

                    @Override
                    protected void selectionChanged(Boolean value) {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return;
                        }
                        handleSelection(value, getListModel(), getSelectionModel());
                    }

                    @Override
                    public Boolean getValue() {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return false;
                        }
                        return getCheckValue(getListModel().getItems(), getSelectionModel());
                    }
                };
                addColumn(checkColumn, selectAllHeader);
            } else {
                addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
            }
        }
        if (checkColumn != null) {
            setColumnWidth(checkColumn, CHECK_COLUMN_WIDTH, Unit.PX);
        }
        addCellPreviewHandler(new CellPreviewEvent.Handler<EntityModel>() {

            @Override
            public void onCellPreview(CellPreviewEvent<EntityModel> event) {
                int columnIndex = event.getColumn();
                Cell<?> cell = getColumn(columnIndex).getCell();
                if (cell instanceof EventHandlingCell && ((EventHandlingCell) cell).handlesEvent(event)) {
                    return;
                }
                if (BrowserEvents.CLICK.equals(event.getNativeEvent().getType()) && !(getSelectionModel() instanceof NoSelectionModel)) {
                    // Let the selection column deal with this
                    if (event.getColumn() == 0) {
                        return;
                    }
                    getSelectionModel().setSelected(event.getValue(), !getSelectionModel().isSelected(event.getValue()));
                }
            }
        });
    }
}
#method_after
private void addCheckBoxColumn(boolean hideCheckbox, boolean showSelectAllCheckbox) {
    if (!hideCheckbox) {
        // Add selection column
        Column<EntityModel, Boolean> checkColumn = null;
        if (getSelectionModel() instanceof SingleSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new RadioboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
        } else if (getSelectionModel() instanceof MultiSelectionModel) {
            checkColumn = new Column<EntityModel, Boolean>(new CheckboxCell(true, false)) {

                @Override
                public Boolean getValue(EntityModel object) {
                    return getSelectionModel().isSelected(object);
                }
            };
            if (showSelectAllCheckbox) {
                AbstractSelectAllCheckBoxHeader<EntityModel> selectAllHeader = new AbstractSelectAllCheckBoxHeader<EntityModel>() {

                    @Override
                    protected void selectionChanged(Boolean value) {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return;
                        }
                        handleSelection(value, getListModel(), getSelectionModel());
                    }

                    @Override
                    public Boolean getValue() {
                        if (getListModel() == null || getListModel().getItems() == null) {
                            return false;
                        }
                        return getCheckValue(getListModel().getItems(), getSelectionModel());
                    }
                };
                addColumn(checkColumn, selectAllHeader);
            } else {
                addColumn(checkColumn, SafeHtmlUtils.fromSafeConstant(constants.htmlNonBreakingSpace()));
            }
        }
        if (checkColumn != null) {
            setColumnWidth(checkColumn, CHECK_COLUMN_WIDTH, Unit.PX);
        }
        addCellPreviewHandler(new CellPreviewEvent.Handler<EntityModel>() {

            @Override
            public void onCellPreview(CellPreviewEvent<EntityModel> event) {
                int columnIndex = event.getColumn();
                Cell<?> cell = getColumn(columnIndex).getCell();
                if (cell instanceof EventHandlingCell && ((EventHandlingCell) cell).handlesEvent(event)) {
                    return;
                }
                if (BrowserEvents.CLICK.equals(event.getNativeEvent().getType()) && !(getSelectionModel() instanceof NoSelectionModel)) {
                    // Let the selection column deal with this
                    if (event.getColumn() == 0) {
                        return;
                    }
                    getSelectionModel().setSelected(event.getValue(), !getSelectionModel().isSelected(event.getValue()));
                }
            }
        });
    }
}
#end_block

#method_before
public void validate(List<String> errors) {
    int rowCount = getRowCount();
    // $NON-NLS-1$
    assert (errors != null && errors.size() == rowCount) : "errors must be the same size as the contents of the table!";
    for (int i = 0; i < rowCount; ++i) {
        Element element = getRowElement(i);
        // $NON-NLS-1$
        assert (element != null) : "element shouldn't be null if errors is the same size as the contents of the table!";
        String error = errors.get(i);
        boolean valid = StringUtils.isEmpty(error);
        element.setTitle(valid ? null : error);
        if (!valid) {
            element.addClassName(style.invalidRow());
        } else {
            element.removeClassName(style.invalidRow());
        }
    }
}
#method_after
public void validate(List<String> errors) {
    int rowCount = getRowCount();
    // $NON-NLS-1$
    assert (errors != null && errors.size() == rowCount) : "errors must be the same size as the contents of the table!";
    for (int i = 0; i < rowCount; ++i) {
        Element element = getRowElement(i);
        // $NON-NLS-1$
        assert (element != null) : "element shouldn't be null if errors is the same size as the contents of the table!";
        String error = errors.get(i);
        boolean valid = StringUtils.isEmpty(error);
        if (!valid) {
            TooltipMixin.addTooltipToElement(SafeHtmlUtils.fromString(error), element);
            element.addClassName(style.invalidRow());
        } else {
            element.removeClassName(style.invalidRow());
        }
    }
}
#end_block

#method_before
@Override
public void addColumn(Column column, String headerString, String width) {
    addColumnAndSetWidth(column, headerString, width);
}
#method_after
@Override
public void addColumn(Column column, String headerString, String width) {
    super.addColumnAndSetWidth(column, headerString, width);
}
#end_block

#method_before
public void addColumn(Column column, SafeHtml headerHtml, String width) {
    addColumnAndSetWidth(column, headerHtml, width);
}
#method_after
public void addColumn(Column column, SafeHtml headerHtml, String width) {
    super.addColumnWithHtmlHeader(column, headerHtml, width);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Console Public Key
    bindPresenterWidget(PublicKeyPopupPresenterWidget.class, PublicKeyPopupPresenterWidget.ViewDef.class, PublicKeyPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
public EntityModel<String> getSysPrepPassword() {
    return privateSysPrepPassword;
}
#method_after
public EntityModel<String> getSysPrepPassword() {
    return sysPrepPassword;
}
#end_block

#method_before
private void setSysPrepPassword(EntityModel<String> value) {
    privateSysPrepPassword = value;
}
#method_after
private void setSysPrepPassword(EntityModel<String> value) {
    sysPrepPassword = value;
}
#end_block

#method_before
public EntityModel<String> getSysPrepPasswordVerification() {
    return privateSysPrepPasswordVerification;
}
#method_after
public EntityModel<String> getSysPrepPasswordVerification() {
    return sysPrepPasswordVerification;
}
#end_block

#method_before
private void setSysPrepPasswordVerification(EntityModel<String> value) {
    privateSysPrepPasswordVerification = value;
}
#method_after
private void setSysPrepPasswordVerification(EntityModel<String> value) {
    sysPrepPasswordVerification = value;
}
#end_block

#method_before
public VmInitModel getVmInitModel() {
    return privateVmInitModel;
}
#method_after
public VmInitModel getVmInitModel() {
    return vmInitModel;
}
#end_block

#method_before
public void setVmInitModel(VmInitModel value) {
    privateVmInitModel = value;
}
#method_after
public void setVmInitModel(VmInitModel value) {
    vmInitModel = value;
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInitModel().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.getInstance().isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInitModel().init(vm.getStaticData());
    updateDomainList();
    updateSystemTabLists();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vga).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    boolean hasSpiceSupport = AsyncDataProvider.getInstance().hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (hasSpiceSupport) {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    } else {
        getDisplayProtocol().setItems(Arrays.asList(vncProtocol));
        getDisplayConsole_Spice_IsSelected().setIsAvailable(false);
    }
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vga ? vncProtocol : qxlProtocol);
    getSpiceFileTransferEnabled().setEntity(vm.isSpiceFileTransferEnabled());
    getSpiceCopyPasteEnabled().setEntity(vm.isSpiceCopyPasteEnabled());
    AsyncDataProvider.isFloppySupported(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Boolean isFloppySupported = (Boolean) returnValue;
            if (!isFloppySupported.booleanValue()) {
                getAttachFloppy().setIsAvailable(false);
                getFloppyImage().setIsAvailable(false);
            }
        }
    }), vm.getOs(), vm.getVdsGroupCompatibilityVersion());
}
#end_block

#method_before
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#method_after
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangeable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangeable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#end_block

#method_before
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !pluggedNics.isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#method_after
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !pluggedNics.isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangeable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
            getSpiceFileTransferEnabled().setIsChangable(false);
            getSpiceCopyPasteEnabled().setIsChangable(false);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
            getSpiceFileTransferEnabled().setIsChangable(true);
            getSpiceCopyPasteEnabled().setIsChangable(true);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(HasEntity.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangeable(true);
            getSpiceFileTransferEnabled().setIsChangeable(false);
            getSpiceCopyPasteEnabled().setIsChangeable(false);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangeable(false);
            getSpiceFileTransferEnabled().setIsChangeable(true);
            getSpiceCopyPasteEnabled().setIsChangeable(true);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable(getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable(getAttachIso().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangeable(getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangeable(getAttachIso().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable(getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangeable(getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable(getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable(getUseAlternateCredentials().getEntity());
    getSysPrepPasswordVerification().setIsChangable(getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPasswordVerification().setEntity(useAlternateCredentials ? "" : null);
}
#method_after
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangeable(getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangeable(getUseAlternateCredentials().getEntity());
    getSysPrepPasswordVerification().setIsChangeable(getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPasswordVerification().setEntity(useAlternateCredentials ? "" : null);
}
#end_block

#method_before
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if (getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#method_after
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if (getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangeable(true);
    }
}
#end_block

#method_before
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangable(false);
}
#method_after
private void initVncKeyboardLayout() {
    List<String> layouts = (List<String>) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.VncKeyboardLayoutValidValues);
    List<String> vncKeyboardLayoutItems = new ArrayList<String>();
    vncKeyboardLayoutItems.add(null);
    vncKeyboardLayoutItems.addAll(layouts);
    getVncKeyboardLayout().setItems(vncKeyboardLayoutItems);
    getVncKeyboardLayout().setIsChangeable(false);
}
#end_block

#method_before
private void doBackupCheck() {
    AuditLogableBase alert = new AuditLogableBase();
    // try to get last backup record
    EngineBackupLog lastDbBackup = engineBackupLogDao.getLastSuccessfulEngineBackup(DB_SCOPE);
    EngineBackupLog lastFilesBackup = engineBackupLogDao.getLastSuccessfulEngineBackup(FILES_SCOPE);
    if (lastDbBackup == null || lastFilesBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_FULL_BACKUP);
    } else {
        // check time elapsed from last full (db and files) backup
        Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
        Date lastDbBackupDate = lastDbBackup.getDoneAt();
        Date lastFilesBackupDate = lastFilesBackup.getDoneAt();
        Date lastFullBackupDate = lastDbBackupDate.compareTo(lastFilesBackupDate) < 0 ? lastDbBackupDate : lastFilesBackupDate;
        long diffInDays = (Calendar.getInstance().getTimeInMillis() - lastFullBackupDate.getTime()) / TimeUnit.DAYS.toMillis(1);
        if (diffInDays > backupAlertPeriodInDays) {
            alert.addCustomValue("Date", lastFullBackupDate.toString());
            auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
        }
    }
}
#method_after
private void doBackupCheck() {
    AuditLogableBase alert = new AuditLogableBase();
    // try to get last backup record
    EngineBackupLog lastDbBackup = getLastBackupByScope(BackupScope.DB);
    EngineBackupLog lastFilesBackup = getLastBackupByScope(BackupScope.FILES);
    if (lastDbBackup == null || lastFilesBackup == null) {
        auditLogDirector.log(alert, AuditLogType.ENGINE_NO_FULL_BACKUP);
    } else {
        // check time elapsed from last full (db and files) backup
        Integer backupAlertPeriodInDays = Config.<Integer>getValue(ConfigValues.BackupAlertPeriodInDays);
        Date lastDbBackupDate = lastDbBackup.getDoneAt();
        Date lastFilesBackupDate = lastFilesBackup.getDoneAt();
        Date lastFullBackupDate = lastDbBackupDate.compareTo(lastFilesBackupDate) < 0 ? lastDbBackupDate : lastFilesBackupDate;
        long diffInDays = (Calendar.getInstance().getTimeInMillis() - lastFullBackupDate.getTime()) / TimeUnit.DAYS.toMillis(1);
        if (diffInDays > backupAlertPeriodInDays) {
            alert.addCustomValue("Date", lastFullBackupDate.toString());
            auditLogDirector.log(alert, AuditLogType.ENGINE_NO_WARM_BACKUP);
        }
    }
}
#end_block

#method_before
protected void checkDestFormatCompatibility() {
    for (Object item : getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        if (vm.getDiskMap() != null) {
            for (Map.Entry<Guid, Disk> pair : vm.getDiskMap().entrySet()) {
                DiskImage disk = (DiskImage) pair.getValue();
                if (disk.getVolumeType() == VolumeType.Sparse && disk.getVolumeFormat() == VolumeFormat.RAW && getDiskImportData(disk.getId()) != null && (getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType().isBlockDomain())) {
                    ((ImportVmData) item).setWarning(ConstantsManager.getInstance().getConstants().importSparseDiskToBlockDeviceMustCollapseSnapshots());
                    ((ImportVmData) item).getCollapseSnapshots().setEntity(true);
                    ((ImportVmData) item).getCollapseSnapshots().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importSparseDiskToBlockDeviceMustCollapseSnapshots());
                    ((ImportVmData) item).getCollapseSnapshots().setIsChangable(false);
                    onPropertyChanged(new PropertyChangedEventArgs(ON_DISK_LOAD));
                }
            }
        }
    }
}
#method_after
protected void checkDestFormatCompatibility() {
    for (Object item : getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        if (vm.getDiskMap() != null) {
            for (Map.Entry<Guid, Disk> pair : vm.getDiskMap().entrySet()) {
                DiskImage disk = (DiskImage) pair.getValue();
                if (disk.getVolumeType() == VolumeType.Sparse && disk.getVolumeFormat() == VolumeFormat.RAW && getDiskImportData(disk.getId()) != null && (getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType().isBlockDomain())) {
                    ((ImportVmData) item).setWarning(ConstantsManager.getInstance().getConstants().importSparseDiskToBlockDeviceMustCollapseSnapshots());
                    ((ImportVmData) item).getCollapseSnapshots().setEntity(true);
                    ((ImportVmData) item).getCollapseSnapshots().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importSparseDiskToBlockDeviceMustCollapseSnapshots());
                    ((ImportVmData) item).getCollapseSnapshots().setIsChangeable(false);
                    onPropertyChanged(new PropertyChangedEventArgs(ON_DISK_LOAD));
                }
            }
        }
    }
}
#end_block

#method_before
public void init(final List<VM> externalVms, final Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VM> vms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                existingNames.add(vm.getName());
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangable(false);
                }
                if (!vmData.getClone().getEntity() && existingNames.contains(vm.getName())) {
                    vmData.setError(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                }
                vmDataList.add(vmData);
            }
            ImportVmFromExportDomainModel.super.setItems(vmDataList);
            doInit(storageDomainId);
        }
    }));
}
#method_after
public void init(final List<VM> externalVms, final Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VM> vms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                existingNames.add(vm.getName());
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangeable(false);
                }
                if (!vmData.getClone().getEntity() && existingNames.contains(vm.getName())) {
                    vmData.setError(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                }
                vmDataList.add(vmData);
            }
            ImportVmFromExportDomainModel.super.setItems(vmDataList);
            doInit(storageDomainId);
        }
    }));
}
#end_block

#method_before
protected ArchitectureType getArchitectureFromItem(Object item) {
    VmTemplate template = (VmTemplate) item;
    return template.getClusterArch();
}
#method_after
@Override
protected ArchitectureType getArchitectureFromItem(VmTemplate template) {
    return template.getClusterArch();
}
#end_block

#method_before
protected String getObjectName(Object object) {
    return ((ImportTemplateData) object).getTemplate().getName();
}
#method_after
protected String getObjectName(ImportTemplateData templateData) {
    return templateData.getTemplate().getName();
}
#end_block

#method_before
protected void setObjectName(Object object, String name) {
    ((ImportTemplateData) object).getTemplate().setName(name);
}
#method_after
protected void setObjectName(ImportTemplateData templateData, String name) {
    templateData.getTemplate().setName(name);
}
#end_block

#method_before
protected boolean validateName(String newVmName, EntityModel entity, IValidation[] validators) {
    EntityModel temp = new EntityModel();
    temp.setIsValid(true);
    temp.setEntity(newVmName);
    temp.validateEntity(validators);
    if (!temp.getIsValid()) {
        entity.setInvalidityReasons(temp.getInvalidityReasons());
        entity.setIsValid(false);
    }
    return temp.getIsValid();
}
#method_after
protected boolean validateName(String newVmName, EntityModel<String> entity, IValidation[] validators) {
    EntityModel<String> temp = new EntityModel<>();
    temp.setIsValid(true);
    temp.setEntity(newVmName);
    temp.validateEntity(validators);
    if (!temp.getIsValid()) {
        entity.setInvalidityReasons(temp.getInvalidityReasons());
        entity.setIsValid(false);
    }
    return temp.getIsValid();
}
#end_block

#method_before
protected void executeImport() {
    ImportTemplateModel model = (ImportTemplateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object object : importModel.getItems()) {
        ImportTemplateData importData = (ImportTemplateData) object;
        VmTemplate template = importData.getTemplate();
        ImportVmTemplateParameters importVmTemplateParameters = new ImportVmTemplateParameters(model.getStoragePool().getId(), getEntity().getId(), Guid.Empty, model.getCluster().getSelectedItem().getId(), template);
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            importVmTemplateParameters.setQuotaId(importModel.getClusterQuota().getSelectedItem().getId());
        }
        CpuProfile cpuProfile = importModel.getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            importVmTemplateParameters.setCpuProfileId(cpuProfile.getId());
        }
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (DiskImage disk : template.getDiskList()) {
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        importVmTemplateParameters.setImageToDestinationDomainMap(map);
        if (importData.isExistsInSystem() || importData.getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(template.getId())) {
                continue;
            }
            importVmTemplateParameters.setImportAsNewEntity(true);
            importVmTemplateParameters.getVmTemplate().setName(((ImportTemplateData) cloneObjectMap.get(template.getId())).getTemplate().getName());
        }
        prms.add(importVmTemplateParameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmTemplate, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            TemplateBackupModel templateBackupModel = (TemplateBackupModel) result.getState();
            templateBackupModel.getWindow().stopProgress();
            templateBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && templateBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedTemplates = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object a : templateBackupModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) a;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedTemplates.append(template.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    templateBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(constants.importTemplatesTitle());
                    confirmModel.setHelpTag(HelpTag.import_template);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_template");
                    confirmModel.setMessage(messages.importProcessHasBegunForTemplates(StringHelper.trimEnd(importedTemplates.toString().trim(), ',')));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand(CANCEL_CONFIRMATION_COMMAND, templateBackupModel).setTitle(constants.close()).setIsDefault(true).setIsCancel(true));
                }
            }
        }
    }, this);
}
#method_after
protected void executeImport() {
    ImportTemplateModel model = (ImportTemplateModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        return;
    }
    ArrayList<VdcActionParametersBase> prms = new ArrayList<VdcActionParametersBase>();
    for (Object object : importModel.getItems()) {
        ImportTemplateData importData = (ImportTemplateData) object;
        VmTemplate template = importData.getTemplate();
        ImportVmTemplateParameters importVmTemplateParameters = new ImportVmTemplateParameters(model.getStoragePool().getId(), getEntity().getId(), Guid.Empty, model.getCluster().getSelectedItem().getId(), template);
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            importVmTemplateParameters.setQuotaId(importModel.getClusterQuota().getSelectedItem().getId());
        }
        CpuProfile cpuProfile = importModel.getCpuProfiles().getSelectedItem();
        if (cpuProfile != null) {
            importVmTemplateParameters.setCpuProfileId(cpuProfile.getId());
        }
        Map<Guid, Guid> map = new HashMap<Guid, Guid>();
        for (DiskImage disk : template.getDiskList()) {
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        importVmTemplateParameters.setImageToDestinationDomainMap(map);
        if (importData.isExistsInSystem() || importData.getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(template.getId())) {
                continue;
            }
            importVmTemplateParameters.setImportAsNewEntity(true);
            importVmTemplateParameters.getVmTemplate().setName(((ImportTemplateData) cloneObjectMap.get(template.getId())).getTemplate().getName());
        }
        prms.add(importVmTemplateParameters);
    }
    model.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVmTemplate, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            TemplateBackupModel templateBackupModel = (TemplateBackupModel) result.getState();
            templateBackupModel.getWindow().stopProgress();
            templateBackupModel.cancel();
            ArrayList<VdcReturnValueBase> retVals = (ArrayList<VdcReturnValueBase>) result.getReturnValue();
            if (retVals != null && templateBackupModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedTemplates = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (VmTemplate template : templateBackupModel.getSelectedItems()) {
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedTemplates.append(template.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    templateBackupModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(constants.importTemplatesTitle());
                    confirmModel.setHelpTag(HelpTag.import_template);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_template");
                    confirmModel.setMessage(messages.importProcessHasBegunForTemplates(StringHelper.trimEnd(importedTemplates.toString().trim(), ',')));
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand(CANCEL_CONFIRMATION_COMMAND, templateBackupModel).setTitle(constants.close()).setIsDefault(true).setIsCancel(true));
                }
            }
        }
    }, this);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    switch(command.getName()) {
        case // $NON-NLS-1$
        "OnRemove":
            onRemove();
            break;
        case // $NON-NLS-1$
        "OnRestore":
            onRestore();
            break;
        case // $NON-NLS-1$
        "RemoveVmTemplates":
            removeTemplateBackup();
            break;
        default:
            super.executeCommand(command);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    switch(command.getName()) {
        case // $NON-NLS-1$
        "OnRemove":
            onRemove();
            break;
        case // $NON-NLS-1$
        "OnRestore":
            onRestore();
            break;
        case // $NON-NLS-1$
        "RemoveVmTemplates":
            removeTemplateBackup();
            break;
        case // $NON-NLS-1$
        "onClone":
            onClone();
            break;
        case // $NON-NLS-1$
        "closeClone":
            closeClone();
            break;
        case // $NON-NLS-1$
        "multipleArchsOK":
            multipleArchsOK();
            break;
        default:
            super.executeCommand(command);
    }
}
#end_block

#method_before
public void onRestore() {
    importModel = (ImportTemplateModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    cloneObjectMap = new HashMap<Guid, Object>();
    objectsToClone = new ArrayList<Object>();
    for (Object object : (ArrayList<Object>) importModel.getItems()) {
        ImportEntityData<Object> item = (ImportEntityData<Object>) object;
        if (item.getClone().getEntity()) {
            objectsToClone.add(object);
        }
    }
    executeImportClone();
}
#method_after
public void onRestore() {
    importModel = (ImportTemplateModel) getWindow();
    if (importModel.getProgress() != null) {
        return;
    }
    if (!importModel.validate()) {
        return;
    }
    cloneObjectMap = new HashMap<Guid, Object>();
    objectsToClone = new ArrayList<>();
    for (Object object : importModel.getItems()) {
        ImportTemplateData item = (ImportTemplateData) object;
        if (item.getClone().getEntity()) {
            objectsToClone.add(item);
        }
    }
    executeImportClone();
}
#end_block

#method_before
protected boolean validateSingleArchitecture() {
    // Checks if there are selected VMs of multiple architectures
    ArchitectureType firstArch = null;
    boolean multipleArchs = false;
    for (Object item : getSelectedItems()) {
        ArchitectureType arch = getArchitectureFromItem(item);
        if (firstArch == null) {
            firstArch = arch;
        } else {
            if (!firstArch.equals(arch)) {
                multipleArchs = true;
                break;
            }
        }
    }
    if (multipleArchs) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().invalidImportTitle());
        confirmModel.setHelpTag(HelpTag.multiple_archs_dialog);
        // $NON-NLS-1$
        confirmModel.setHashName("multiple_archs_dialog");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().invalidImportMsg());
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("multipleArchsOK", this);
        confirmModel.getCommands().add(command);
        setConfirmWindow(confirmModel);
        return false;
    }
    return true;
}
#method_after
protected boolean validateSingleArchitecture() {
    // Checks if there are selected VMs of multiple architectures
    ArchitectureType firstArch = null;
    boolean multipleArchs = false;
    for (T item : getSelectedItems()) {
        ArchitectureType arch = getArchitectureFromItem(item);
        if (firstArch == null) {
            firstArch = arch;
        } else {
            if (!firstArch.equals(arch)) {
                multipleArchs = true;
                break;
            }
        }
    }
    if (multipleArchs) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().invalidImportTitle());
        confirmModel.setHelpTag(HelpTag.multiple_archs_dialog);
        // $NON-NLS-1$
        confirmModel.setHashName("multiple_archs_dialog");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().invalidImportMsg());
        // $NON-NLS-1$
        UICommand command = UICommand.createDefaultOkUiCommand("multipleArchsOK", this);
        confirmModel.getCommands().add(command);
        setConfirmWindow(confirmModel);
        return false;
    }
    return true;
}
#end_block

#method_before
protected ArchitectureType getArchitectureFromItem(Object item) {
    VM vm = (VM) item;
    return vm.getClusterArch();
}
#method_after
protected ArchitectureType getArchitectureFromItem(VM vm) {
    return vm.getClusterArch();
}
#end_block

#method_before
public void init(final Collection<VmTemplate> externalTemplates, final Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalTemplates), SearchType.VmTemplate), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmTemplate> vmtList = (List<VmTemplate>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<ImportTemplateData> templateDataList = new ArrayList<ImportTemplateData>();
            for (VmTemplate template : externalTemplates) {
                ImportTemplateData templateData = new ImportTemplateData(template);
                boolean templateExistsInSystem = vmtList.contains(template);
                templateData.setExistsInSystem(templateExistsInSystem);
                if (templateExistsInSystem) {
                    templateData.getClone().setEntity(true);
                    templateData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importTemplateThatExistsInSystemMustClone());
                    templateData.getClone().setIsChangable(false);
                }
                templateDataList.add(templateData);
            }
            ImportTemplateModel.super.setSuperItems(templateDataList);
            doInit(storageDomainId);
        }
    }));
}
#method_after
public void init(final Collection<VmTemplate> externalTemplates, final Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalTemplates), SearchType.VmTemplate), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VmTemplate> vmtList = (List<VmTemplate>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<ImportTemplateData> templateDataList = new ArrayList<ImportTemplateData>();
            for (VmTemplate template : externalTemplates) {
                ImportTemplateData templateData = new ImportTemplateData(template);
                boolean templateExistsInSystem = vmtList.contains(template);
                templateData.setExistsInSystem(templateExistsInSystem);
                if (templateExistsInSystem) {
                    templateData.getClone().setEntity(true);
                    templateData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importTemplateThatExistsInSystemMustClone());
                    templateData.getClone().setIsChangeable(false);
                }
                templateDataList.add(templateData);
            }
            setItems(templateDataList);
            doInit(storageDomainId);
        }
    }));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    switch(command.getName()) {
        case // $NON-NLS-1$
        "OnRemove":
            onRemove();
            break;
        case // $NON-NLS-1$
        "OnRestore":
            onRestore();
            break;
        case // $NON-NLS-1$
        "RemoveVmTemplates":
            removeTemplateBackup();
            break;
        default:
            super.executeCommand(command);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    switch(command.getName()) {
        case // $NON-NLS-1$
        "OnRemove":
            onRemove();
            break;
        case // $NON-NLS-1$
        "OnRestore":
            onRestore();
            break;
        case // $NON-NLS-1$
        "RemoveVmTemplates":
            removeTemplateBackup();
            break;
        case // $NON-NLS-1$
        "onClone":
            onClone();
            break;
        case // $NON-NLS-1$
        "closeClone":
            closeClone();
            break;
        case // $NON-NLS-1$
        "multipleArchsOK":
            multipleArchsOK();
            break;
        default:
            super.executeCommand(command);
    }
}
#end_block

#method_before
protected void setObjectName(Object object, String name) {
    ((ImportTemplateData) object).getTemplate().setName(name);
}
#method_after
private void setObjectName(Object object, String input, boolean isSuffix) {
    String nameForTheClonedVm = isSuffix ? getObjectName(object) + input : input;
    setObjectName(object, nameForTheClonedVm);
    assignedVmNames.add(nameForTheClonedVm);
}
#end_block

#method_before
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    for (Iterator<Entry<Guid, CommandCallBack>> iterator = cmdCallBackMap.entrySet().iterator(); iterator.hasNext(); ) {
        Entry<Guid, CommandCallBack> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallBack callBack = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callBack.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callBack.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callBack.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallBackNotified(cmdId);
                iterator.remove();
            }
        }
    }
}
#method_after
@OnTimerMethodAnnotation("invokeCallbackMethods")
public void invokeCallbackMethods() {
    initCommandExecutor();
    Iterator<Entry<Guid, CommandCallback>> iterator = cmdCallbackMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Entry<Guid, CommandCallback> entry = iterator.next();
        Guid cmdId = entry.getKey();
        CommandCallback callback = entry.getValue();
        CommandStatus status = coco.getCommandStatus(cmdId);
        boolean errorInCallback = false;
        try {
            switch(status) {
                case FAILED:
                    callback.onFailed(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case SUCCEEDED:
                    callback.onSucceeded(cmdId, coco.getChildCommandIds(cmdId));
                    break;
                case ACTIVE:
                    if (coco.getCommandEntity(cmdId).isExecuted()) {
                        callback.doPolling(cmdId, coco.getChildCommandIds(cmdId));
                    }
                    break;
                default:
                    break;
            }
        } catch (Exception ex) {
            errorInCallback = true;
            handleError(ex, status, cmdId);
        } finally {
            if (CommandStatus.FAILED.equals(status) || (CommandStatus.SUCCEEDED.equals(status) && !errorInCallback)) {
                coco.updateCallbackNotified(cmdId);
                iterator.remove();
            }
        }
    }
}
#end_block

#method_before
private void handleError(Exception ex, CommandStatus status, Guid cmdId) {
    log.error("Error invoking callback method '{}' for '{}' command '{}'", getCallBackMethod(status), status, cmdId);
    log.error("Exception", ex);
    if (!CommandStatus.FAILED.equals(status)) {
        coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
    }
}
#method_after
private void handleError(Exception ex, CommandStatus status, Guid cmdId) {
    log.error("Error invoking callback method '{}' for '{}' command '{}'", getCallbackMethod(status), status, cmdId);
    log.error("Exception", ex);
    if (!CommandStatus.FAILED.equals(status)) {
        coco.updateCommandStatus(cmdId, CommandStatus.FAILED);
    }
}
#end_block

#method_before
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallBackEnabled()) {
            if (!cmdEntity.isExecuted() && cmdEntity.getCommandStatus() != CommandStatus.FAILED && cmdEntity.getCommandStatus() != CommandStatus.FAILED_RESTARTED) {
                coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
            }
            if (!cmdEntity.isCallBackNotified()) {
                addToCallBackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#method_after
private void initCommandExecutor() {
    if (!cmdExecutorInitialized) {
        for (CommandEntity cmdEntity : coco.getCommandsWithCallbackEnabled()) {
            if (!cmdEntity.isExecuted() && cmdEntity.getCommandStatus() != CommandStatus.FAILED && cmdEntity.getCommandStatus() != CommandStatus.FAILED_RESTARTED) {
                coco.retrieveCommand(cmdEntity.getId()).setCommandStatus(CommandStatus.FAILED_RESTARTED);
            }
            if (!cmdEntity.isCallbackNotified()) {
                addToCallbackMap(cmdEntity);
            }
        }
        cmdExecutorInitialized = true;
    }
}
#end_block

#method_before
private Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, final Map<Guid, VdcObjectType> entityMap) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallBack callBack = command.getCallBack();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCoCoCmdEntities(buildCoCoCmdEntities(command.getCommandId(), entityMap));
    if (callBack != null) {
        cmdCallBackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#method_after
public Future<VdcReturnValueBase> executeAsyncCommand(final VdcActionType actionType, final VdcActionParametersBase parameters, final CommandContext cmdContext, SubjectEntity... subjectEntities) {
    final CommandBase<?> command = CommandsFactory.createCommand(actionType, parameters, cmdContext);
    CommandCallback callBack = command.getCallback();
    command.persistCommand(command.getParameters().getParentCommand(), cmdContext, callBack != null);
    coco.persistCommandAssociatedEntities(buildCommandAssociatedEntities(command.getCommandId(), subjectEntities));
    if (callBack != null) {
        cmdCallbackMap.put(command.getCommandId(), callBack);
    }
    Future<VdcReturnValueBase> retVal;
    try {
        retVal = executor.submit(new Callable<VdcReturnValueBase>() {

            @Override
            public VdcReturnValueBase call() throws Exception {
                return executeCommand(command, cmdContext);
            }
        });
    } catch (RejectedExecutionException ex) {
        command.setCommandStatus(CommandStatus.FAILED);
        log.error("Failed to submit command to executor service, command '{}' status has been set to FAILED", command.getCommandId());
        retVal = new RejectedExecutionFuture();
    }
    return retVal;
}
#end_block

#method_before
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    CommandCallBack callBack = command.getCallBack();
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, null);
    updateCommand(command, result);
    if (callBack != null) {
        callBack.executed(result);
    }
    return result;
}
#method_after
private VdcReturnValueBase executeCommand(final CommandBase<?> command, final CommandContext cmdContext) {
    CommandCallback callback = command.getCallback();
    VdcReturnValueBase result = BackendUtils.getBackendCommandObjectsHandler(log).runAction(command, null);
    updateCommand(command, result);
    if (callback != null) {
        callback.executed(result);
    }
    return result;
}
#end_block

#method_before
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallBackNotified(existingCmdEntity.isCallBackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallBackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallBackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallBackNotified()) {
            cmdExecutor.addToCallBackMap(cmdEntity);
        }
    }
}
#method_after
@Override
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallbackNotified(existingCmdEntity.isCallbackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallbackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && commandsCache.get(cmdEntity.getRootCommandId()) != null && commandsCache.get(cmdEntity.getRootCommandId()).isCallbackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallbackNotified()) {
            cmdExecutor.addToCallbackMap(cmdEntity);
        }
    }
}
#end_block

#method_before
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, VdcObjectType entityType, Guid... entityIds) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, cmdContext, entityType, entityIds);
}
#method_after
@Override
public Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, SubjectEntity... subjectEntities) {
    return cmdExecutor.executeAsyncCommand(actionType, parameters, cmdContext, subjectEntities);
}
#end_block

#method_before
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    List<Guid> childIds = Collections.EMPTY_LIST;
    if (childHierarchy.containsKey(cmdId)) {
        childIds = childHierarchy.get(cmdId);
    }
    return childIds;
}
#method_after
public List<Guid> getChildCommandIds(Guid cmdId) {
    initChildHierarchy();
    if (childHierarchy.containsKey(cmdId)) {
        return childHierarchy.get(cmdId);
    }
    return Collections.emptyList();
}
#end_block

#method_before
private void initChildHierarchy() {
    if (!childHierarchyInitialized) {
        synchronized (LOCK) {
            if (!childHierarchyInitialized) {
                childHierarchy.clear();
                for (CommandEntity cmd : getCommandsWithCallBackEnabled()) {
                    buildCmdHierarchy(cmd);
                }
            }
            childHierarchyInitialized = true;
        }
    }
}
#method_after
private void initChildHierarchy() {
    if (!childHierarchyInitialized) {
        synchronized (LOCK) {
            if (!childHierarchyInitialized) {
                childHierarchy.clear();
                for (CommandEntity cmd : getCommandsWithCallbackEnabled()) {
                    buildCmdHierarchy(cmd);
                }
            }
            childHierarchyInitialized = true;
        }
    }
}
#end_block

#method_before
public AsyncTask getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public AsyncTask getAsyncTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public AsyncTask createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public AsyncTask createAsyncTask(CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coCoAsyncTaskHelper.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coCoAsyncTaskHelper.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public void cancelTasks(final CommandBase command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#method_after
public void cancelTasks(final CommandBase<?> command) {
    coCoAsyncTaskHelper.cancelTasks(command, log);
}
#end_block

#method_before
public void revertTasks(CommandBase command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#method_after
public void revertTasks(CommandBase<?> command) {
    coCoAsyncTaskHelper.revertTasks(command);
}
#end_block

#method_before
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ArrayList<AsyncTaskCreationInfo> getAllTasksInfo(Guid storagePoolID) {
    return (ArrayList<AsyncTaskCreationInfo>) runVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Map<Guid, AsyncTaskStatus> getAllTasksStatuses(Guid storagePoolID) {
    return (Map<Guid, AsyncTaskStatus>) runVdsCommand(VDSCommandType.SPMGetAllTasksStatuses, new IrsBaseVDSCommandParameters(storagePoolID)).getReturnValue();
}
#end_block

#method_before
public static Guid createTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coco.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#method_after
public static Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    return coco.createTask(taskId, command, asyncTaskCreationInfo, parentCommand, description, entitiesMap);
}
#end_block

#method_before
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static SPMAsyncTask concreteCreateTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void cancelTasks(final CommandBase command) {
    coco.cancelTasks(command);
}
#method_after
public static void cancelTasks(final CommandBase<?> command) {
    coco.cancelTasks(command);
}
#end_block

#method_before
public static void revertTasks(final CommandBase command) {
    coco.revertTasks(command);
}
#method_after
public static void revertTasks(final CommandBase<?> command) {
    coco.revertTasks(command);
}
#end_block

#method_before
public static AsyncTask getAsyncTask(Guid taskId, CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTask getAsyncTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.getAsyncTask(taskId, command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static AsyncTask createAsyncTask(CommandBase command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#method_after
public static AsyncTask createAsyncTask(CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return coco.createAsyncTask(command, asyncTaskCreationInfo, parentCommand);
}
#end_block

#method_before
public static void logAndFailTaskOfCommandWithEmptyVdsmId(AsyncTask task, String message) {
    getAsyncTaskManager().logAndFailTaskOfCommandWithEmptyVdsmId(task, message);
}
#method_after
public static void logAndFailTaskOfCommandWithEmptyVdsmId(AsyncTask task, String message) {
    getAsyncTaskManager().logAndFailPartiallySubmittedTaskOfCommand(task, message);
}
#end_block

#method_before
public static CommandBase<?> retrieveCommand(Guid commandId) {
    return coco.retrieveCommand(commandId);
}
#method_after
@SuppressWarnings("unchecked")
public static <C extends CommandBase<?>> C retrieveCommand(Guid commandId) {
    return (C) coco.retrieveCommand(commandId);
}
#end_block

#method_before
public static Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, VdcObjectType entityType, Guid... entityIds) {
    return coco.executeAsyncCommand(actionType, parameters, cmdContext, entityType, entityIds);
}
#method_after
public static Future<VdcReturnValueBase> executeAsyncCommand(VdcActionType actionType, VdcActionParametersBase parameters, CommandContext cmdContext, SubjectEntity... subjectEntities) {
    return coco.executeAsyncCommand(actionType, parameters, cmdContext, subjectEntities);
}
#end_block

#method_before
@Test
public void testGetCommandIdsByEntity() {
    Guid storageId = Guid.newGuid();
    CommandEntity cmdEntity1 = generateNewEntity();
    dao.save(cmdEntity1);
    Set<CoCoCmdEntity> cocoCmdEntities1 = new HashSet<>();
    cocoCmdEntities1.add(new CoCoCmdEntity(cmdEntity1.getId(), VdcObjectType.Storage, storageId));
    cocoCmdEntities1.add(new CoCoCmdEntity(cmdEntity1.getId(), VdcObjectType.Disk, Guid.newGuid()));
    dao.insertCoCoCmdEntities(cocoCmdEntities1);
    CommandEntity cmdEntity2 = generateNewEntity();
    dao.save(cmdEntity2);
    Set<CoCoCmdEntity> cocoCmdEntities2 = new HashSet<>();
    cocoCmdEntities2.add(new CoCoCmdEntity(cmdEntity2.getId(), VdcObjectType.Storage, storageId));
    cocoCmdEntities2.add(new CoCoCmdEntity(cmdEntity2.getId(), VdcObjectType.Disk, Guid.newGuid()));
    dao.insertCoCoCmdEntities(cocoCmdEntities2);
    List<Guid> cmIds = dao.getCommandIdsByEntity(storageId);
    assertNotNull(cmIds);
    assertEquals(2, cmIds.size());
    assertTrue(cmIds.contains(cmdEntity1.getId()));
    assertTrue(cmIds.contains(cmdEntity2.getId()));
}
#method_after
@Test
public void testGetCommandIdsByEntity() {
    Guid storageId = Guid.newGuid();
    CommandEntity cmdEntity1 = generateNewEntity();
    dao.save(cmdEntity1);
    Set<CommandAssociatedEntity> cocoCmdEntities1 = new HashSet<>();
    cocoCmdEntities1.add(new CommandAssociatedEntity(cmdEntity1.getId(), VdcObjectType.Storage, storageId));
    cocoCmdEntities1.add(new CommandAssociatedEntity(cmdEntity1.getId(), VdcObjectType.Disk, Guid.newGuid()));
    dao.insertCommandAssociatedEntities(cocoCmdEntities1);
    CommandEntity cmdEntity2 = generateNewEntity();
    dao.save(cmdEntity2);
    Set<CommandAssociatedEntity> cocoCmdEntities2 = new HashSet<>();
    cocoCmdEntities2.add(new CommandAssociatedEntity(cmdEntity2.getId(), VdcObjectType.Storage, storageId));
    cocoCmdEntities2.add(new CommandAssociatedEntity(cmdEntity2.getId(), VdcObjectType.Disk, Guid.newGuid()));
    dao.insertCommandAssociatedEntities(cocoCmdEntities2);
    List<Guid> cmIds = dao.getCommandIdsByEntity(storageId);
    assertNotNull(cmIds);
    assertThat(cmIds, hasSize(2));
    assertThat(cmIds, hasItems(cmdEntity1.getId(), cmdEntity2.getId()));
}
#end_block

#method_before
@Override
public CoCoCmdEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    CoCoCmdEntity entity = new CoCoCmdEntity();
    entity.setCommandId(getGuid(rs, "command_id"));
    entity.setEntityId(getGuid(rs, "entity_id"));
    entity.setEntityType(VdcObjectType.valueOf(rs.getString("entity_type")));
    return entity;
}
#method_after
@Override
public CommandAssociatedEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    CommandAssociatedEntity entity = new CommandAssociatedEntity(getGuid(rs, "command_id"), VdcObjectType.valueOf(rs.getString("entity_type")), getGuid(rs, "entity_id"));
    entity.setEntityType(VdcObjectType.valueOf(rs.getString("entity_type")));
    return entity;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallBackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(CommandEntity entity) {
    return getCustomMapSqlParameterSource().addValue("user_id", Guid.isNullOrEmpty(entity.getUserId()) ? Guid.Empty : entity.getUserId()).addValue("command_id", Guid.isNullOrEmpty(entity.getId()) ? Guid.Empty : entity.getId()).addValue("command_type", entity.getCommandType().getValue()).addValue("root_command_id", Guid.isNullOrEmpty(entity.getRootCommandId()) ? Guid.Empty : entity.getRootCommandId()).addValue("job_id", Guid.isNullOrEmpty(entity.getJobId()) ? Guid.Empty : entity.getJobId()).addValue("step_id", Guid.isNullOrEmpty(entity.getStepId()) ? Guid.Empty : entity.getStepId()).addValue("command_parameters", serializeParameters(entity.getCommandParameters())).addValue("command_params_class", entity.getCommandParameters() == null ? null : entity.getCommandParameters().getClass().getName()).addValue("status", entity.getCommandStatus().toString()).addValue("executed", entity.isExecuted()).addValue("callback_enabled", entity.isCallbackEnabled()).addValue("return_value", serializeReturnValue(entity.getReturnValue())).addValue("return_value_class", entity.getReturnValue() == null ? null : entity.getReturnValue().getClass().getName());
}
#end_block

#method_before
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return checkStoragePool() && checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Inactive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || checkMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast) && validate(CINDERStorageHelper.isCinderHasNoImages(getStorageDomainId()));
}
#method_after
protected boolean canDetachDomain(boolean isDestroyStoragePool, boolean isRemoveLast, boolean isInternal) {
    return checkStoragePool() && checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Inactive, StorageDomainStatus.Maintenance) && (isMaster() || isDestroyStoragePool || checkMasterDomainIsUp()) && isNotLocalData(isInternal) && isDetachAllowed(isRemoveLast) && isCinderStorageHasNoDisks();
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct) {
    return electNewMaster(duringReconstruct, false, false);
}
#method_after
protected StorageDomain electNewMaster() {
    return electNewMaster(false, false, false);
}
#end_block

#method_before
public static ValidationResult isCinderHasNoImages(Guid storageDomainId) {
    List<DiskImage> cinderDisks = getDbFacade().getDiskImageDao().getAllForStorageDomain(storageDomainId);
    if (!cinderDisks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_DETACH_EXTERNAL_VOLUME_PROVIDER_WITH_IMAGES);
    }
    return ValidationResult.VALID;
}
#method_after
public static ValidationResult isCinderHasNoImages(Guid storageDomainId) {
    List<DiskImage> cinderDisks = getDbFacade().getDiskImageDao().getAllForStorageDomain(storageDomainId);
    if (!cinderDisks.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ERROR_CANNOT_DETACH_CINDER_PROVIDER_WITH_IMAGES);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Before
public void setUp() {
    current = createMock(Current.class);
    sessionHelper = new SessionHelper();
    sessionHelper.setCurrent(current);
    sessionHelper.setSessionId(sessionId);
    resource.setSessionHelper(sessionHelper);
    backend = createMock(BackendLocal.class);
    resource.setBackend(backend);
    MessageBundle messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    resource.setMessageBundle(messageBundle);
    httpHeaders = createMock(HttpHeaders.class);
    List<Locale> locales = new ArrayList<Locale>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    List<String> filterValue = new ArrayList<String>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    resource.setHttpHeaders(httpHeaders);
}
#method_after
@Before
public void setUp() {
    currentUser = new DbUser();
    currentUser.setLoginName(USER);
    currentUser.setDomain(DOMAIN);
    current = new Current();
    current.setUser(currentUser);
    current.setSessionId(SESSION_ID);
    CurrentManager.put(current);
    backend = createMock(BackendLocal.class);
    resource.setBackend(backend);
    MessageBundle messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    resource.setMessageBundle(messageBundle);
    httpHeaders = createMock(HttpHeaders.class);
    List<Locale> locales = new ArrayList<Locale>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    List<String> filterValue = new ArrayList<String>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    resource.setHttpHeaders(httpHeaders);
}
#end_block

#method_before
@After
public void tearDown() {
    verifyAll();
}
#method_after
@After
public void tearDown() {
    verifyAll();
    CurrentManager.remove();
}
#end_block

#method_before
private void setupExpectations(ApplicationMode appMode, String[] relationships) {
    expect(current.get(ApplicationMode.class)).andReturn(appMode).anyTimes();
    resource.setUriInfo(setUpUriInfo(URI_BASE + "/", relationships));
    setUpGetSystemVersionExpectations();
    setUpGetSystemStatisticsExpectations();
}
#method_after
private void setupExpectations(ApplicationMode appMode, String[] relationships) {
    current.setApplicationMode(appMode);
    resource.setUriInfo(setUpUriInfo(URI_BASE + "/", relationships));
    setUpGetSystemVersionExpectations();
    setUpGetSystemStatisticsExpectations();
}
#end_block

#method_before
protected void setUpGetSystemVersionExpectations() {
    VdcQueryReturnValue productRpmQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productRpmQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productRpmQueryResult.getReturnValue()).andReturn(SYSTEM_VERSION).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetConfigurationValue), getProductRPMVersionParam())).andReturn(productRpmQueryResult);
    VdcQueryReturnValue productVersionQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productVersionQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productVersionQueryResult.getReturnValue()).andReturn(new Version(MAJOR, MINOR, BUILD, REVISION)).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetProductVersion), getProductVersionParams())).andReturn(productVersionQueryResult);
}
#method_after
protected void setUpGetSystemVersionExpectations() {
    VdcQueryReturnValue productRpmQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productRpmQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productRpmQueryResult.getReturnValue()).andReturn(SYSTEM_VERSION).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetConfigurationValue), getProductRPMVersionParams())).andReturn(productRpmQueryResult);
    VdcQueryReturnValue productVersionQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productVersionQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productVersionQueryResult.getReturnValue()).andReturn(new Version(MAJOR, MINOR, BUILD, REVISION)).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetProductVersion), getProductVersionParams())).andReturn(productVersionQueryResult);
}
#end_block

#method_before
protected VdcQueryParametersBase queryParams() {
    return eqQueryParams(GetSystemStatisticsQueryParameters.class, new String[] { "SessionId" }, new Object[] { getSessionId() });
}
#method_after
protected VdcQueryParametersBase queryParams() {
    return eqQueryParams(GetSystemStatisticsQueryParameters.class, new String[] { "SessionId" }, new Object[] { SESSION_ID });
}
#end_block

#method_before
@Override
public Response head() {
    appMode = getCurrent().get(ApplicationMode.class);
    API api = null;
    if (appMode == ApplicationMode.GlusterOnly) {
        api = getGlusterApi();
    } else {
        api = getApi();
    }
    return getResponseBuilder(api).build();
}
#method_after
@Override
public Response head() {
    appMode = getCurrent().getApplicationMode();
    API api = null;
    if (appMode == ApplicationMode.GlusterOnly) {
        api = getGlusterApi();
    } else {
        api = getApi();
    }
    return getResponseBuilder(api).build();
}
#end_block

#method_before
@Override
public Response get() {
    appMode = getCurrent().get(ApplicationMode.class);
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        try {
            RSDL rsdl = addSystemVersion(getRSDL());
            return Response.ok().entity(rsdl).build();
        } catch (Exception e) {
            throw new WebApplicationException(e, Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());
        }
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        BaseResource response = null;
        if (appMode == ApplicationMode.GlusterOnly) {
            response = addGlusterSummary(addSystemVersion(getGlusterApi()));
        } else {
            response = addSummary(addSystemVersion(getApi()));
        }
        return getResponseBuilder(response).entity(response).build();
    }
}
#method_after
@Override
public Response get() {
    appMode = getCurrent().getApplicationMode();
    if (QueryHelper.hasConstraint(getUriInfo(), RSDL_CONSTRAINT_PARAMETER)) {
        try {
            RSDL rsdl = addSystemVersion(getRSDL());
            return Response.ok().entity(rsdl).build();
        } catch (Exception e) {
            throw new WebApplicationException(e, Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());
        }
    } else if (QueryHelper.hasConstraint(getUriInfo(), SCHEMA_CONSTRAINT_PARAMETER)) {
        return getSchema();
    } else {
        BaseResource response = null;
        if (appMode == ApplicationMode.GlusterOnly) {
            response = addGlusterSummary(addSystemVersion(getGlusterApi()));
        } else {
            response = addSummary(addSystemVersion(getApi()));
        }
        return getResponseBuilder(response).entity(response).build();
    }
}
#end_block

#method_before
public synchronized RSDL getRSDL() throws ClassNotFoundException, IOException {
    if (rsdl == null) {
        rsdl = RsdlManager.loadRsdl(getCurrent().get(ApplicationMode.class), getUriInfo().getBaseUri().getPath());
    }
    return rsdl;
}
#method_after
public synchronized RSDL getRSDL() throws ClassNotFoundException, IOException {
    if (rsdl == null) {
        rsdl = RsdlManager.loadRsdl(getCurrent().getApplicationMode(), getUriInfo().getBaseUri().getPath());
    }
    return rsdl;
}
#end_block

#method_before
private Version parseRpmVersion(String rpmVersion) {
    Pattern pattern = Pattern.compile(RPM_REG_EX);
    Matcher matcher = pattern.matcher(rpmVersion);
    if (matcher.find()) {
        String[] parts = matcher.group(0).split("\\.", -1);
        return new Version(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Integer.parseInt(parts[2]), 0);
    } else {
        return null;
    }
}
#method_after
private Version parseRpmVersion(String rpmVersion) {
    Matcher matcher = rpmRegEx.matcher(rpmVersion);
    if (matcher.find()) {
        return new Version(Integer.parseInt(matcher.group("major")), Integer.parseInt(matcher.group("minor")), Integer.parseInt(matcher.group("build")), 0);
    } else {
        return null;
    }
}
#end_block

#method_before
private Version parseVdcVersion(String vdcVersion) {
    Pattern pattern = Pattern.compile(VDC_VERSION_REG_EX);
    Matcher matcher = pattern.matcher(vdcVersion);
    if (matcher.find()) {
        String[] parts = matcher.group(0).split("\\.", -1);
        return new Version(Integer.parseInt(parts[0]), Integer.parseInt(parts[1]), Integer.parseInt(parts[2]), Integer.parseInt(parts[3]));
    } else {
        return null;
    }
}
#method_after
private Version parseVdcVersion(String vdcVersion) {
    Matcher matcher = vdcVersionRegEx.matcher(vdcVersion);
    if (matcher.find()) {
        return new Version(Integer.parseInt(matcher.group("major")), Integer.parseInt(matcher.group("minor")), Integer.parseInt(matcher.group("build")), Integer.parseInt(matcher.group("revision")));
    } else {
        return null;
    }
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        try {
            CinderConnectionInfo connectionInfo = getCinderConnectionInfo(cinderDisk);
            CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
            if (cinderVolumeDriver == null) {
                addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
                auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_VOLUME_DRIVER_UNSUPPORTED);
            }
            cinderDisk.setCinderConnectionInfo(connectionInfo);
        } catch (OpenStackResponseException ex) {
            addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
            auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_FAILURE);
            throw ex;
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + scope.hashCode();
    result = prime * result + doneAt.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(scope, doneAt);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (!(obj instanceof EngineBackupLogId)) {
        return false;
    }
    EngineBackupLogId other = (EngineBackupLogId) obj;
    return (scope.equals(other.getScope()) && doneAt.equals(other.getDoneAt()));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof EngineBackupLogId)) {
        return false;
    }
    EngineBackupLogId other = (EngineBackupLogId) obj;
    return Objects.equals(scope, other.scope) && Objects.equals(doneAt, other.doneAt);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((scope == null) ? 0 : scope.hashCode());
    result = prime * result + ((doneAt == null) ? 0 : doneAt.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(scope, doneAt);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof EngineBackupLog)) {
        return false;
    }
    EngineBackupLog other = (EngineBackupLog) obj;
    return (Objects.equals(scope, other.scope) && Objects.equals(doneAt, other.doneAt));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof EngineBackupLog)) {
        return false;
    }
    EngineBackupLog other = (EngineBackupLog) obj;
    return Objects.equals(scope, other.scope) && Objects.equals(doneAt, other.doneAt);
}
#end_block

#method_before
public boolean validate() {
    getLvName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50), new AsciiNameValidation() });
    if (!getLvName().getIsValid()) {
        return false;
    }
    if (!validateMountPoint(getMountPoint().getEntity())) {
        return false;
    }
    IntegerValidation noOfPhysicalDiscsValidation = new IntegerValidation();
    noOfPhysicalDiscsValidation.setMinimum(1);
    getNoOfPhysicalDisksInRaidVolume().validateEntity(new IValidation[] { new NotEmptyValidation(), noOfPhysicalDiscsValidation });
    IntegerValidation stripSizeValidation = new IntegerValidation();
    stripSizeValidation.setMinimum(1);
    getStripeSize().validateEntity(new IValidation[] { new NotEmptyValidation(), stripSizeValidation });
    if (!getStripeSize().getIsValid()) {
        return false;
    }
    if (getStorageDevices().getSelectedItems() == null || getStorageDevices().getSelectedItems().isEmpty()) {
        setMessage(ConstantsManager.getInstance().getConstants().selectStorageDevice());
        return false;
    }
    return true;
}
#method_after
public boolean validate() {
    getLvName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(50), new AsciiNameValidation() });
    if (!getLvName().getIsValid()) {
        return false;
    }
    getMountPoint().validateEntity(new IValidation[] { new NotEmptyValidation(), new BrickMountPointValidation() });
    if (!getMountPoint().getIsValid()) {
        return false;
    }
    IntegerValidation noOfPhysicalDiscsValidation = new IntegerValidation();
    noOfPhysicalDiscsValidation.setMinimum(1);
    getNoOfPhysicalDisksInRaidVolume().validateEntity(new IValidation[] { new NotEmptyValidation(), noOfPhysicalDiscsValidation });
    if (!getNoOfPhysicalDisksInRaidVolume().getIsValid()) {
        return false;
    }
    IntegerValidation stripSizeValidation = new IntegerValidation();
    stripSizeValidation.setMinimum(1);
    getStripeSize().validateEntity(new IValidation[] { new NotEmptyValidation(), stripSizeValidation });
    if (!getStripeSize().getIsValid()) {
        return false;
    }
    if (getStorageDevices().getSelectedItems() == null || getStorageDevices().getSelectedItems().isEmpty()) {
        setMessage(ConstantsManager.getInstance().getConstants().selectStorageDevice());
        return false;
    }
    return true;
}
#end_block

#method_before
public static void buildCinderDisk(CinderDisk cinderDisk, Map<String, Object> struct) {
    CinderConnectionInfo connectionInfo = cinderDisk.getCinderConnectionInfo();
    CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
    if (cinderVolumeDriver == null) {
        log.error("Unsupported Cinder volume driver: '{}' (disk: '{}')", connectionInfo.getDriverVolumeType(), cinderDisk.getDiskAlias());
        return;
    }
    switch(cinderVolumeDriver) {
        case RBD:
            String path = (String) cinderDisk.getCinderConnectionInfo().getData().get("name");
            struct.put(VdsProperties.Path, path);
            struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            struct.put(VdsProperties.Protocol, cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            struct.put(VdsProperties.DiskType, VdsProperties.NETWORK);
            List<String> hostAddresses = (ArrayList<String>) cinderDisk.getCinderConnectionInfo().getData().get("hosts");
            List<String> hostPorts = (ArrayList<String>) cinderDisk.getCinderConnectionInfo().getData().get("ports");
            List<Map<String, Object>> hosts = new ArrayList<>();
            for (int i = 0; i < hostAddresses.size(); i++) {
                Map<String, Object> hostMap = new HashMap<>();
                hostMap.put(VdsProperties.NetworkDiskName, hostAddresses.get(i));
                hostMap.put(VdsProperties.NetworkDiskPort, hostPorts.get(i));
                hostMap.put(VdsProperties.NetworkDiskTransport, VdsProperties.Tcp);
                hosts.add(hostMap);
            }
            struct.put(VdsProperties.NetworkDiskHosts, hosts);
            break;
    }
}
#method_after
public static void buildCinderDisk(CinderDisk cinderDisk, Map<String, Object> struct) {
    CinderConnectionInfo connectionInfo = cinderDisk.getCinderConnectionInfo();
    CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
    if (cinderVolumeDriver == null) {
        log.error("Unsupported Cinder volume driver: '{}' (disk: '{}')", connectionInfo.getDriverVolumeType(), cinderDisk.getDiskAlias());
        return;
    }
    switch(cinderVolumeDriver) {
        case RBD:
            Map<String, Object> connectionInfoData = cinderDisk.getCinderConnectionInfo().getData();
            struct.put(VdsProperties.Path, connectionInfoData.get("name"));
            struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
            struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
            struct.put(VdsProperties.Protocol, cinderDisk.getCinderConnectionInfo().getDriverVolumeType());
            struct.put(VdsProperties.DiskType, VdsProperties.NETWORK);
            List<String> hostAddresses = (ArrayList<String>) connectionInfoData.get("hosts");
            List<String> hostPorts = (ArrayList<String>) connectionInfoData.get("ports");
            List<Map<String, Object>> hosts = new ArrayList<>();
            // (Cinder should ensure that the addresses and ports lists are synced in order).
            for (int i = 0; i < hostAddresses.size(); i++) {
                Map<String, Object> hostMap = new HashMap<>();
                hostMap.put(VdsProperties.NetworkDiskName, hostAddresses.get(i));
                hostMap.put(VdsProperties.NetworkDiskPort, hostPorts.get(i));
                hostMap.put(VdsProperties.NetworkDiskTransport, VdsProperties.Tcp);
                hosts.add(hostMap);
            }
            struct.put(VdsProperties.NetworkDiskHosts, hosts);
            break;
    }
}
#end_block

#method_before
public static void addDiskToVm(BaseDisk disk, Guid vmId) {
    DbFacade.getInstance().getBaseDiskDao().save(disk);
    VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, true, false, null);
}
#method_after
public static void addDiskToVm(BaseDisk disk, Guid vmId) {
    DbFacade.getInstance().getBaseDiskDao().save(disk);
    VmDeviceUtils.addManagedDevice(new VmDeviceId(disk.getId(), vmId), VmDeviceGeneralType.DISK, VmDeviceType.DISK, null, true, false, null, false);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId()) && updateCinderDisksConnections()) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
                markHostDevicesAsUsed();
            }
        } catch (VdcBLLException e) {
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(e.getErrorCode()) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                    reportCompleted();
                    throw e;
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    runningFailed();
                    throw e;
                default:
                    log.warn("Failed to run VM '{}': {}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.info("Trying to rerun VM '{}'", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
@Override
public void rerun() {
    setFlow(null);
    super.rerun();
}
#method_after
@Override
public void rerun() {
    setFlow(null);
    // re-acquire the host device lock (if needed) as the canDoAction already expects this
    // lock to be held (originally acquired in 'postConstruct'
    acquireHostDevicesLock();
    super.rerun();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (needsHostDevices && !hostDeviceManager.checkVmHostDeviceAvailability(getVm(), getVm().getDedicatedVmForVds())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
    }
    return true;
}
#end_block

#method_before
protected boolean updateCinderDisksConnections() {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true);
    for (CinderDisk cinderDisk : cinderDisks) {
        try {
            CinderBroker cinderBroker = new CinderBroker(cinderDisk.getStorageIds().get(0), getReturnValue().getExecuteFailedMessages());
            CinderConnectionInfo connectionInfo = cinderBroker.initializeConnectionForDisk(cinderDisk);
            CinderVolumeDriver cinderVolumeDriver = CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType());
            if (cinderVolumeDriver == null) {
                addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
                auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_VOLUME_DRIVER_UNSUPPORTED);
                return false;
            }
            cinderDisk.setCinderConnectionInfo(connectionInfo);
        } catch (OpenStackResponseException ex) {
            addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
            auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_FAILURE);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean updateCinderDisksConnections() {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true);
    for (CinderDisk cinderDisk : cinderDisks) {
        try {
            CinderBroker cinderBroker = new CinderBroker(cinderDisk.getStorageIds().get(0), getReturnValue().getExecuteFailedMessages());
            CinderConnectionInfo connectionInfo = cinderBroker.initializeConnectionForDisk(cinderDisk);
            if (CinderVolumeDriver.forValue(connectionInfo.getDriverVolumeType()) == null) {
                addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
                auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_VOLUME_DRIVER_UNSUPPORTED);
                return false;
            }
            cinderDisk.setCinderConnectionInfo(connectionInfo);
        } catch (OpenStackResponseException ex) {
            addCustomValue("DiskAlias", cinderDisk.getDiskAlias());
            auditLogDirector.log(this, AuditLogType.CINDER_DISK_CONNECTION_FAILURE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void init(List items, final Guid storageDomainId) {
    setItems(items, storageDomainId);
}
#method_after
public void init(List<?> value, final Guid storageDomainId) {
    setItems(value, storageDomainId);
}
#end_block

#method_before
private boolean validateNames() {
    boolean valid = true;
    for (ImportVmData importVmData : (Iterable<ImportVmData>) getItems()) {
        if (!validateName(importVmData)) {
            valid = false;
        } else {
            importVmData.setError(null);
        }
    }
    if (!valid) {
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("InvalidVm"));
    }
    return valid;
}
#method_after
private boolean validateNames() {
    for (ImportVmData importVmData : (Iterable<ImportVmData>) getItems()) {
        if (!importVmData.getClone().getEntity() && importVmData.getError() != null) {
            // $NON-NLS-1$
            onPropertyChanged(new PropertyChangedEventArgs("InvalidVm"));
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void setItems(final Collection value, final Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVms, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            vms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : (Iterable<VM>) value) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangable(false);
                } else {
                    vms.add(vm);
                }
                vmDataList.add(vmData);
            }
            ImportVmFromExportDomainModel.super.setItems(vmDataList);
            doInit(storageDomainId);
        }
    }));
}
#method_after
public void setItems(final Collection<?> value, final Guid storageDomainId) {
    @SuppressWarnings({ "unchecked", "rawtypes" })
    final List<VM> externalVms = (List<VM>) new ArrayList(value);
    Frontend.getInstance().runQuery(VdcQueryType.Search, new SearchParameters(createSearchPattern(externalVms), SearchType.VM), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VM> vms = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Set<String> existingNames = new HashSet<>();
            for (VM vm : vms) {
                existingNames.add(vm.getName());
            }
            List<ImportVmData> vmDataList = new ArrayList<>();
            for (VM vm : externalVms) {
                ImportVmData vmData = new ImportVmData(vm);
                if (vms.contains(vm)) {
                    vmData.setExistsInSystem(true);
                    vmData.getClone().setEntity(true);
                    vmData.getClone().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().importVMThatExistsInSystemMustClone());
                    vmData.getClone().setIsChangable(false);
                }
                if (!vmData.getClone().getEntity() && existingNames.contains(vm.getName())) {
                    vmData.setError(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                }
                vmDataList.add(vmData);
            }
            ImportVmFromExportDomainModel.super.setItems(vmDataList);
            doInit(storageDomainId);
        }
    }));
}
#end_block

#method_before
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = ((ImportVmData) object);
            if (importVmData.getError() != null) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = ((ImportVmData) object);
            String problem = importVmData.getError() != null ? importVmData.getError() : importVmData.getWarning();
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return ((ImportVmData) object).getVm().getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractImageResourceColumn<Object>() {

        @Override
        public com.google.gwt.resources.client.ImageResource getValue(Object object) {
            return new VmTypeColumn().getValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled(((Boolean) selectedObject.getCollapseSnapshots().getEntity()));
        // diskTable.edit(importVmModel.getImportDiskListModel());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#method_after
protected void initMainTable() {
    this.table = new ListModelObjectCellTable<>();
    AbstractImageResourceColumn<Object> isProblematicImportVmColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            ImportVmData importVmData = ((ImportVmData) object);
            if (!importVmData.getClone().getEntity() && importVmData.getError() != null) {
                return resources.errorImage();
            }
            if (importVmData.getWarning() != null) {
                return resources.alertImage();
            }
            return null;
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            ImportVmData importVmData = ((ImportVmData) object);
            String problem = !importVmData.getClone().getEntity() && importVmData.getError() != null ? importVmData.getError() : importVmData.getWarning();
            return problem != null ? SafeHtmlUtils.fromSafeConstant(problem) : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isProblematicImportVmColumn, constants.empty(), "20px");
    AbstractTextColumn<Object> nameColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return ((ImportVmData) object).getVm().getName();
        }
    };
    // $NON-NLS-1$
    table.addColumn(nameColumn, constants.nameVm(), "150px");
    AbstractCheckboxColumn<Object> collapseSnapshotsColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getCollapseSnapshots().setEntity(value);
            customSelectionCellFormatType.setEnabled(value);
            diskTable.asEditor().edit(importModel.getImportDiskListModel());
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getCollapseSnapshots().getChangeProhibitionReason();
        }

        @Override
        public SafeHtml getTooltip(Object object) {
            SafeHtml superTooltip = super.getTooltip(object);
            if (superTooltip == null) {
                return SafeHtmlUtils.fromSafeConstant(constants.importAllocationModifiedCollapse());
            }
            return superTooltip;
        }
    };
    // $NON-NLS-1$
    table.addColumn(collapseSnapshotsColumn, constants.collapseSnapshots(), "10px");
    AbstractCheckboxColumn<Object> cloneVMColumn = new AbstractCheckboxColumn<Object>(new FieldUpdater<Object, Boolean>() {

        @Override
        public void update(int index, Object model, Boolean value) {
            ((ImportVmData) model).getClone().setEntity(value);
            table.asEditor().edit(importModel);
        }
    }) {

        @Override
        public Boolean getValue(Object model) {
            return ((ImportVmData) model).getClone().getEntity();
        }

        @Override
        protected boolean canEdit(Object model) {
            return ((ImportVmData) model).getClone().getIsChangable();
        }

        @Override
        protected String getDisabledMessage(Object model) {
            return ((ImportVmData) model).getClone().getChangeProhibitionReason();
        }
    };
    // $NON-NLS-1$
    table.addColumn(cloneVMColumn, constants.cloneVM(), "50px");
    AbstractTextColumn<Object> originColumn = new AbstractEnumColumn<Object, OriginType>() {

        @Override
        protected OriginType getRawValue(Object object) {
            return ((ImportVmData) object).getVm().getOrigin();
        }
    };
    // $NON-NLS-1$
    table.addColumn(originColumn, constants.originVm(), "100px");
    table.addColumn(new AbstractImageResourceColumn<Object>() {

        @Override
        public com.google.gwt.resources.client.ImageResource getValue(Object object) {
            return new VmTypeColumn().getValue(((ImportVmData) object).getVm());
        }
    }, constants.empty(), // $NON-NLS-1$
    "30px");
    AbstractTextColumn<Object> memoryColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            // $NON-NLS-1$
            return String.valueOf(((ImportVmData) object).getVm().getVmMemSizeMb()) + " MB";
        }
    };
    // $NON-NLS-1$
    table.addColumn(memoryColumn, constants.memoryVm(), "100px");
    AbstractTextColumn<Object> cpuColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getNumOfCpus());
        }
    };
    // $NON-NLS-1$
    table.addColumn(cpuColumn, constants.cpusVm(), "50px");
    AbstractTextColumn<Object> archColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getClusterArch());
        }
    };
    // $NON-NLS-1$
    table.addColumn(archColumn, constants.architectureVm(), "50px");
    AbstractTextColumn<Object> diskColumn = new AbstractTextColumn<Object>() {

        @Override
        public String getValue(Object object) {
            return String.valueOf(((ImportVmData) object).getVm().getDiskMap().size());
        }
    };
    // $NON-NLS-1$
    table.addColumn(diskColumn, constants.disksVm(), "50px");
    isObjectInSystemColumn = new AbstractImageResourceColumn<Object>() {

        @Override
        public ImageResource getValue(Object object) {
            return ((ImportVmData) object).isExistsInSystem() ? resources.logNormalImage() : null;
        }
    };
    // $NON-NLS-1$
    table.addColumn(isObjectInSystemColumn, constants.vmInSetup(), "60px");
    table.getSelectionModel().addSelectionChangeHandler(new SelectionChangeEvent.Handler() {

        @Override
        public void onSelectionChange(SelectionChangeEvent event) {
            ImportVmData selectedObject = ((SingleSelectionModel<ImportVmData>) event.getSource()).getSelectedObject();
            customSelectionCellFormatType.setEnabled(((Boolean) selectedObject.getCollapseSnapshots().getEntity()));
        // diskTable.edit(importVmModel.getImportDiskListModel());
        }
    });
    ScrollPanel sp = new ScrollPanel();
    sp.add(table);
    splitLayoutPanel.add(sp);
    table.getElement().getStyle().setPosition(Position.RELATIVE);
}
#end_block

#method_before
@SafeVarargs
public static SizeUnit leastUnitInList(Pair<SizeUnit, Double>... operands) {
    SizeUnit leastUnit = SizeUnit.getMaxHandledUnit();
    for (Pair<SizeUnit, Double> operand : operands) {
        if (operand.getFirst().getUnitWeight() < leastUnit.getUnitWeight()) {
            leastUnit = operand.getFirst();
        }
    }
    return leastUnit;
}
#method_after
public static SizeUnit leastUnitInList(List<Pair<SizeUnit, Double>> operands) {
    SizeUnit leastUnit = SizeUnit.getMaxHandledUnit();
    for (Pair<SizeUnit, Double> operand : operands) {
        if (operand.getFirst().getUnitWeight() < leastUnit.getUnitWeight()) {
            leastUnit = operand.getFirst();
        }
    }
    return leastUnit;
}
#end_block

#method_before
@SafeVarargs
public static SizeUnit maxUnitInList(Pair<SizeUnit, Double>... operands) {
    SizeUnit maxUnit = SizeUnit.getMinHandledUnit();
    for (Pair<SizeUnit, Double> operand : operands) {
        if (operand.getFirst().getUnitWeight() > maxUnit.getUnitWeight()) {
            maxUnit = operand.getFirst();
        }
    }
    return maxUnit;
}
#method_after
public static SizeUnit maxUnitInList(List<Pair<SizeUnit, Double>> operands) {
    SizeUnit maxUnit = SizeUnit.getMinHandledUnit();
    for (Pair<SizeUnit, Double> operand : operands) {
        if (operand.getFirst().getUnitWeight() > maxUnit.getUnitWeight()) {
            maxUnit = operand.getFirst();
        }
    }
    return maxUnit;
}
#end_block

#method_before
@SafeVarargs
public static List<Pair<SizeUnit, Double>> getMathOperationSafeOperands(Pair<SizeUnit, Double>... operands) {
    List<Pair<SizeUnit, Double>> operatoinReadyOperands = new ArrayList<>();
    SizeUnit finalUnit = leastUnitInList(operands);
    for (Pair<SizeUnit, Double> operand : operands) {
        if (operand.getFirst() != finalUnit) {
            operand.setSecond(convert(operand.getSecond().longValue(), operand.getFirst(), finalUnit).doubleValue());
            operand.setFirst(finalUnit);
        }
    }
    return operatoinReadyOperands;
}
#method_after
@SafeVarargs
public static List<Pair<SizeUnit, Double>> getMathOperationSafeOperands(Pair<SizeUnit, Double>... operands) {
    List<Pair<SizeUnit, Double>> operationReadyOperands = new ArrayList<>();
    List<Pair<SizeUnit, Double>> convertedOperands = new ArrayList<>();
    for (Pair<SizeUnit, Double> operand : operands) {
        convertedOperands.add(autoConvert(operand.getSecond().longValue(), operand.getFirst()));
    }
    SizeUnit finalUnit = leastUnitInList(convertedOperands);
    for (Pair<SizeUnit, Double> operand : convertedOperands) {
        if (operand.getFirst() != finalUnit) {
            operationReadyOperands.add(new Pair<SizeConverter.SizeUnit, Double>(finalUnit, convert(operand.getSecond().longValue(), operand.getFirst(), finalUnit).doubleValue()));
        } else {
            operationReadyOperands.add(operand);
        }
    }
    return operationReadyOperands;
}
#end_block

#method_before
public ValidationResult validateUnregisteredEntity(IVdcQueryable entityFromConfiguration, OvfEntityData ovfEntityData, List<DiskImage> images) {
    if (ovfEntityData == null && !params.isImportAsNewEntity()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    for (DiskImage image : images) {
        StorageDomain sd = getStorageDomainDAO().getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
        if (!result.isValid()) {
            log.error("Storage Domain '{}' with id '{}', could not be found for image name '{}' with image id '{}'", sd == null ? null : sd.getStorageName(), image.getStorageIds().get(0), image.getDiskAlias(), image.getId());
            return result;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", params.getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult validateUnregisteredEntity(IVdcQueryable entityFromConfiguration, OvfEntityData ovfEntityData, List<DiskImage> images) {
    if (ovfEntityData == null && !params.isImportAsNewEntity()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_UNSUPPORTED_OVF);
    }
    if (entityFromConfiguration == null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_OVF_CONFIGURATION_NOT_SUPPORTED);
    }
    for (DiskImage image : images) {
        StorageDomain sd = getStorageDomainDAO().getForStoragePool(image.getStorageIds().get(0), getStoragePool().getId());
        ValidationResult result = new StorageDomainValidator(sd).isDomainExistAndActive();
        if (!result.isValid()) {
            log.error("Storage Domain '{}' with id '{}', could not be found for disk alias '{}' with image id '{}'", sd == null ? null : sd.getStorageName(), image.getStorageIds().get(0), image.getDiskAlias(), image.getId());
            return result;
        }
    }
    if (!getStorageDomain().getStorageDomainType().isDataDomain()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_UNSUPPORTED, String.format("$domainId %1$s", params.getStorageDomainId()), String.format("$domainType %1$s", getStorageDomain().getStorageDomainType()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#method_after
private static void initAppsList(Map<String, Object> vmStruct, VmDynamic vm) {
    if (vmStruct.containsKey(VdsProperties.app_list)) {
        Object tempAppsList = vmStruct.get(VdsProperties.app_list);
        if (tempAppsList instanceof Object[]) {
            Object[] apps = (Object[]) tempAppsList;
            StringBuilder builder = new StringBuilder();
            boolean firstTime = true;
            for (Object app : apps) {
                String appString = (String) ((app instanceof String) ? app : null);
                if (app == null) {
                    log.warn("Failed to convert app: [null] to string");
                    // Don't process this
                    continue;
                }
                if (appString == null) {
                    // Note: app cannot be null here anymore
                    log.warn("Failed to convert app: [" + app.getClass().getName() + "] is not a string");
                    // Don't process this
                    continue;
                }
                if (!firstTime) {
                    builder.append(",");
                } else {
                    firstTime = false;
                }
                builder.append(appString);
            }
            vm.setAppList(builder.toString());
        } else {
            vm.setAppList("");
        }
    }
}
#end_block

#method_before
private void validateQosOverriddenInterfaces() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        // check that the interface has a network attached to it, otherwise QoS settings should be wiped anyway
        if (networkName == null) {
            continue;
        }
        if (iface.isQosOverridden() && !iface.getQos().isEmpty()) {
            if (!hostNetworkQosSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
            }
            HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
            if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
            }
            if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
            }
        }
    }
}
#method_after
private void validateQosOverriddenInterfaces() {
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        // 2. if QoS isn't overridden - no problem
        if (networkName == null || !iface.isQosOverridden()) {
            continue;
        }
        if (!hostNetworkQosSupported) {
            addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, networkName);
        }
        // next checks are only relevant if non-empty QoS was supplied
        if (iface.getQos() != null && !iface.getQos().isEmpty()) {
            HostNetworkQosValidator qosValidator = new HostNetworkQosValidator(iface.getQos());
            if (qosValidator.requiredValuesPresent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_MISSING_VALUES, networkName);
            }
            if (qosValidator.valuesConsistent() != ValidationResult.VALID) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_SETUP_NETWORKS_INCONSISTENT_VALUES, networkName);
            }
        }
    }
}
#end_block

#method_before
private void validateGateway(VdsNetworkInterface iface) {
    if (StringUtils.isNotEmpty(iface.getGateway()) && !NetworkUtils.isManagementNetwork(iface.getNetworkName()) && !FeatureSupported.multipleGatewaysSupported(vds.getVdsGroupCompatibilityVersion())) {
        addViolation(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY, iface.getNetworkName());
    }
}
#method_after
private void validateGateway(VdsNetworkInterface iface) {
    if (StringUtils.isNotEmpty(iface.getGateway()) && !managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId()) && !FeatureSupported.multipleGatewaysSupported(vds.getVdsGroupCompatibilityVersion())) {
        addViolation(VdcBllMessages.NETWORK_ATTACH_ILLEGAL_GATEWAY, iface.getNetworkName());
    }
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("[outAverageLinkshare=").append(renderQosParameter(outAverageLinkshare)).append(", outAverageUpperlimit=").append(renderQosParameter(outAverageUpperlimit)).append(", outAverageRealtime=").append(renderQosParameter(outAverageRealtime)).append("]");
    return builder.toString();
}
#method_after
@Override
public String toString() {
    return ToStringBuilder.forInstance(this).append("outAverageLinkshare", renderQosParameter(outAverageLinkshare)).append("outAverageUpperlimit", renderQosParameter(outAverageUpperlimit)).append("outAverageRealtime", renderQosParameter(outAverageRealtime)).build();
}
#end_block

#method_before
private boolean validateVmSnapshotStatus() {
    SnapshotsValidator snapshotsValidator = getSnapshotsValidator();
    boolean returnValue = true;
    for (Pair<VM, VmDevice> pair : getVmsWithVmDeviceInfoForDiskId()) {
        VM vm = pair.getFirst();
        returnValue = returnValue && validate(snapshotsValidator.vmNotInPreview(vm.getId())) && validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId()));
    }
    return returnValue;
}
#method_after
private boolean validateVmSnapshotStatus() {
    SnapshotsValidator snapshotsValidator = getSnapshotsValidator();
    for (Pair<VM, VmDevice> pair : getVmsWithVmDeviceInfoForDiskId()) {
        VmDevice vmDevice = pair.getSecond();
        if (vmDevice.getSnapshotId() == null) {
            // Skip check for VMs with connected snapshot
            VM vm = pair.getFirst();
            if (!validate(snapshotsValidator.vmNotInPreview(vm.getId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId()))) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    VmDevice device = new VmDevice();
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, device));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#method_after
protected void initVmForSpace() {
    VM vm = new VM();
    vm.setStatus(VMStatus.Down);
    // Re-mock the vmDao to return this specific VM for it to be correlated with the vm list mocked by getVmsWithPlugInfo(..).
    doReturn(vmDao).when(command).getVmDAO();
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
    List<Pair<VM, VmDevice>> vmList = Collections.singletonList(new Pair<>(vm, vmDevice));
    when(vmDao.getVmsWithPlugInfo(any(Guid.class))).thenReturn(vmList);
}
#end_block

#method_before
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab, iconTab);
}
#method_after
protected List<Widget> adminOnlyWidgets() {
    return Arrays.<Widget>asList(// general tab
    vmIdEditor, // system tab
    detachableMemSizeEditor, totalvCPUsEditorWithInfoIcon, vcpusAdvancedParameterExpander, serialNumberPolicyEditor, // console tab
    usbSupportEditor, numOfMonitorsLabel, numOfMonitorsEditor, isSingleQxlEnabledEditor, ssoMethodLabel, ssoMethodNone, ssoMethodGuestAgent, expander, spiceProxyEnabledCheckboxWithInfoIcon, spiceProxyEditor, // rest of the tabs
    initialRunTab, hostTab, highAvailabilityTab, resourceAllocationTab, customPropertiesTab, rngDeviceTab);
}
#end_block

#method_before
private KeyPressHandler createPreventEnterKeyPressHandler() {
    return new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (!event.isAnyModifierKeyDown() && event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER && event.getUnicodeCharCode() == 0) {
                event.preventDefault();
            }
        }
    };
}
#method_after
private KeyPressHandler createPreventEnterKeyPressHandler() {
    return new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (!event.isAnyModifierKeyDown() && event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    };
}
#end_block

#method_before
@Override
public IconWithOsDefault getValue() {
    if (icon == null || defaultButton == null) {
        return null;
    }
    return new IconWithOsDefault(icon, defaultIcon, smallIconId);
}
#method_after
@Override
public IconWithOsDefault getValue() {
    if (icon == null || defaultIcon == null) {
        return null;
    }
    return new IconWithOsDefault(icon, defaultIcon, smallIconId);
}
#end_block

#method_before
private void initOsDefaultIconIds() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osIdToDefaultIconIdMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initializeLargeToSmallIconMap();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIcons, GetVmIconsParameters.getDefaultIconsParameters(), callback);
}
#method_after
private void initOsDefaultIconIds() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final Map<Integer, VmIconIdSizePair> returnMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (returnMap.get(DEFAULT_OS_ID) == null) {
                // $NON-NLS-1$
                throw new RuntimeException("Engine did not provide icon IDs of default OS.");
            }
            osIdToDefaultIconIdMap = Collections.unmodifiableMap(returnMap);
            initializeLargeToSmallIconMap();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmIcons, GetVmIconsParameters.getDefaultIconsParameters(), callback);
}
#end_block

#method_before
public Guid getDefaultIconId(boolean small) {
    final int defaultOsId = 0;
    final VmIconIdSizePair pair = osIdToDefaultIconIdMap.get(defaultOsId);
    if (pair != null) {
        return pair.get(small);
    }
    // $NON-NLS-1$
    throw new RuntimeException("Icon of default operating system not found.");
}
#method_after
public Guid getDefaultIconId(boolean small) {
    final VmIconIdSizePair pair = osIdToDefaultIconIdMap.get(DEFAULT_OS_ID);
    if (pair != null) {
        return pair.get(small);
    }
    // $NON-NLS-1$
    throw new RuntimeException("Icon of default operating system not found.");
}
#end_block

#method_before
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concat(getvms(), filteredPools);
        if (filteredPools.isEmpty()) {
            finishSearch(all);
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    finishSearch(all);
                }
            });
        }
    }
}
#method_after
@Override
public void onVmAndPoolLoad() {
    if (getvms() != null && getpools() != null) {
        // Complete search.
        // Remove pools that has provided VMs.
        ArrayList<VmPool> filteredPools = new ArrayList<VmPool>();
        for (VmPool pool : getpools()) {
            // Add pool to map.
            int attachedVmsCount = 0;
            for (VM vm : getvms()) {
                if (vm.getVmPoolId() != null && vm.getVmPoolId().equals(pool.getVmPoolId())) {
                    attachedVmsCount++;
                }
            }
            if (attachedVmsCount < pool.getMaxAssignedVmsPerUser()) {
                filteredPools.add(pool);
            }
        }
        // Merge VMs and Pools, and create item models.
        final List all = Linq.concatUnsafe(getvms(), filteredPools);
        if (filteredPools.isEmpty()) {
            finishSearch(all);
        } else {
            // if we have pools we have to update their console cache and THEN finish search
            List<VdcQueryType> poolQueryList = new ArrayList<VdcQueryType>();
            List<VdcQueryParametersBase> poolParamList = new ArrayList<VdcQueryParametersBase>();
            for (VmPool p : filteredPools) {
                poolQueryList.add(VdcQueryType.GetVmDataByPoolId);
                poolParamList.add(new IdQueryParameters(p.getVmPoolId()));
            }
            Frontend.getInstance().runMultipleQueries(poolQueryList, poolParamList, new IFrontendMultipleQueryAsyncCallback() {

                @Override
                public void executed(FrontendMultipleQueryAsyncResult result) {
                    List<VM> poolRepresentants = new LinkedList<VM>();
                    List<VdcQueryReturnValue> poolRepresentantsRetval = result.getReturnValues();
                    for (VdcQueryReturnValue poolRepresentant : poolRepresentantsRetval) {
                        // extract from return value
                        poolRepresentants.add((VM) poolRepresentant.getReturnValue());
                    }
                    consoleModelsCache.updatePoolCache(poolRepresentants);
                    finishSearch(all);
                }
            });
        }
    }
}
#end_block

#method_before
protected void executeImport(ImportVmFromExportDomainModel importModel) {
    ArrayList<VdcActionParametersBase> prms = new ArrayList<>();
    for (Object item : importModel.getItems()) {
        VM vm = ((ImportVmData) item).getVm();
        ImportVmParameters prm = new ImportVmParameters(vm, (Guid) importModel.getEntity(), Guid.Empty, importModel.getStoragePool().getId(), importModel.getCluster().getSelectedItem().getId());
        if (importModel.getClusterQuota().getSelectedItem() != null && importModel.getClusterQuota().getIsAvailable()) {
            prm.setQuotaId(importModel.getClusterQuota().getSelectedItem().getId());
        }
        prm.setForceOverride(true);
        prm.setCopyCollapse(((ImportVmData) item).getCollapseSnapshots().getEntity());
        Map<Guid, Guid> map = new HashMap<>();
        for (Map.Entry<Guid, Disk> entry : vm.getDiskMap().entrySet()) {
            DiskImage disk = (DiskImage) entry.getValue();
            map.put(disk.getId(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getId());
            disk.setvolumeFormat(AsyncDataProvider.getInstance().getDiskVolumeFormat(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType(), importModel.getDiskImportData(disk.getId()).getSelectedStorageDomain().getStorageType()));
            disk.setVolumeType(importModel.getDiskImportData(disk.getId()).getSelectedVolumeType());
            if (importModel.getDiskImportData(disk.getId()).getSelectedQuota() != null) {
                disk.setQuotaId(importModel.getDiskImportData(disk.getId()).getSelectedQuota().getId());
            }
        }
        prm.setImageToDestinationDomainMap(map);
        if (((ImportVmData) item).isExistsInSystem() || ((ImportVmData) item).getClone().getEntity()) {
            if (!cloneObjectMap.containsKey(vm.getId())) {
                continue;
            }
            prm.setImportAsNewEntity(true);
            prm.setCopyCollapse(true);
            prm.getVm().setName(((ImportVmData) cloneObjectMap.get(vm.getId())).getVm().getName());
        }
        prms.add(prm);
    }
    importModel.startProgress(null);
    Frontend.getInstance().runMultipleAction(VdcActionType.ImportVm, prms, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.stopProgress();
            vmListModel.setConfirmWindow(null);
            vmListModel.setWindow(null);
            vmListModel.clearCachedAssignedVmNames();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            if (retVals != null && vmListModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmListModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmListModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmListModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, this);
}
#method_after
protected void executeImport(ImportVmFromExportDomainModel importVmModel) {
    importVmModel.importVms(new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            VmListModel<Void> vmListModel = (VmListModel<Void>) result.getState();
            vmListModel.stopProgress();
            vmListModel.setConfirmWindow(null);
            vmListModel.setWindow(null);
            vmListModel.clearCachedAssignedVmNames();
            List<VdcReturnValueBase> retVals = result.getReturnValue();
            if (retVals != null && vmListModel.getSelectedItems().size() == retVals.size()) {
                StringBuilder importedVms = new StringBuilder();
                int counter = 0;
                boolean toShowConfirmWindow = false;
                for (Object item : vmListModel.getSelectedItems()) {
                    VM vm = (VM) item;
                    if (retVals.get(counter) != null && retVals.get(counter).getCanDoAction()) {
                        // $NON-NLS-1$
                        importedVms.append(vm.getName()).append(", ");
                        toShowConfirmWindow = true;
                    }
                    counter++;
                }
                // VM
                if (toShowConfirmWindow) {
                    ConfirmationModel confirmModel = new ConfirmationModel();
                    vmListModel.setConfirmWindow(confirmModel);
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().importVirtualMachinesTitle());
                    confirmModel.setHelpTag(HelpTag.import_virtual_machine);
                    // $NON-NLS-1$
                    confirmModel.setHashName("import_virtual_machine");
                    confirmModel.setMessage(ConstantsManager.getInstance().getMessages().importProcessHasBegunForVms(StringHelper.trimEnd(importedVms.toString().trim(), ',')));
                    UICommand tempVar2 = new // $NON-NLS-1$
                    UICommand(// $NON-NLS-1$
                    "CancelConfirm", vmListModel);
                    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().close());
                    tempVar2.setIsDefault(true);
                    tempVar2.setIsCancel(true);
                    confirmModel.getCommands().add(tempVar2);
                }
            }
        }
    }, cloneObjectMap);
    setWindow(null);
}
#end_block

#method_before
private ValidationResult validate(String icon) {
    ValidationResult typeValidation = validateType(icon);
    if (!typeValidation.getSuccess()) {
        return typeValidation;
    }
    ValidationResult dimensionsValidation = validateBrowserParsabilityAndDimensions(icon);
    ValidationResult sizeValidation = validateSize(icon);
    if (dimensionsValidation.getSuccess() && sizeValidation.getSuccess()) {
        return ValidationResult.ok();
    }
    final List<String> reasons = Linq.concatTypesafe(dimensionsValidation.getReasons(), sizeValidation.getReasons());
    return new ValidationResult(false, reasons);
}
#method_after
private ValidationResult validate(String icon) {
    ValidationResult typeValidation = validateType(icon);
    if (!typeValidation.getSuccess()) {
        return typeValidation;
    }
    ValidationResult dimensionsValidation = validateBrowserParsabilityAndDimensions(icon);
    ValidationResult sizeValidation = validateSize(icon);
    if (dimensionsValidation.getSuccess() && sizeValidation.getSuccess()) {
        return ValidationResult.ok();
    }
    final List<String> reasons = Linq.concat(dimensionsValidation.getReasons(), sizeValidation.getReasons());
    return new ValidationResult(false, reasons);
}
#end_block

#method_before
public static List concat(List... lists) {
    List result = new ArrayList<Object>();
    for (List list : lists) {
        for (Object item : list) {
            result.add(item);
        }
    }
    return result;
}
#method_after
public static <T> List<T> concat(List<T>... lists) {
    return concatUnsafe(lists);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // cause to the command to apply the compensation data and leave the domain as LOCKED.
    if (checkIsDomainLocked(getStorageDomain().getStoragePoolIsoMapData())) {
        return false;
    }
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (checkIsDomainLocked(poolDomain)) {
            return false;
        }
    }
    return initializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    // cause to the command to apply the compensation data and leave the domain as LOCKED.
    if (!validate(createStorageDomainValidator().isInProcess())) {
        return false;
    }
    if (!validate(createStoragePoolValidator().isAnyDomainInProcess())) {
        return false;
    }
    return initializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    _newMasterStorageDomainId = getNewMaster().getId();
    _isLastMaster = proceedStorageDomainTreatmentByDomainType(getNewMaster(), true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterId(), domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    isLastMaster = proceedStorageDomainTreatmentByDomainType(getNewMasterStorageDomain(), false);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterStorageDomainId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMasterStorageDomain().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterStorageDomainId(), domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#end_block

#method_before
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#method_after
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getSpmVdsId() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getSpmVdsId().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getSpmVdsId());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = runVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMaster();
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMasterStorageDomain();
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.error("Error while trying connect host {} to the needed storage server during the reinitialization" + " of Data Center '{}'", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warnFormat("skipping connect and refresh for all hosts, last master: {0}, command status: {1}", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warnFormat("");
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), getNewMasterStorageDomainId());
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? _isLastMaster ? AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER : AuditLogType.RECONSTRUCT_MASTER_DONE : AuditLogType.RECONSTRUCT_MASTER_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? isLastMaster ? AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER : AuditLogType.RECONSTRUCT_MASTER_DONE : AuditLogType.RECONSTRUCT_MASTER_FAILED;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        if (!filterDomainsByStatus(domains, StorageDomainStatus.Locked).isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getspm_vds_id() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster = electNewMaster();
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    final boolean _isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, newMasterId);
                return null;
            }
        });
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.infoFormat("Domain {0} will remain in {1} status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    final boolean isLastMaster;
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        newMaster = electNewMaster();
        isLastMaster = proceedStorageDomainTreatmentByDomainType(newMaster, true);
    } else {
        newMaster = null;
        isLastMaster = false;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    if (isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDAO().get(getStoragePool().getSpmVdsId());
    }
    if (isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), isLastMaster, newMasterId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        AuditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#method_after
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        auditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#end_block

#method_before
protected boolean proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster == null) {
        return true;
    }
    if (getStorageDomain().getStorageDomainType() != StorageDomainType.Master) {
        return false;
    }
    newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
    if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                newMaster.setStorageDomainType(StorageDomainType.Master);
                if (!lockNewMaster) {
                    newMasterMap.setStatus(StorageDomainStatus.Unknown);
                    getCompensationContext().snapshotEntityStatus(newMasterMap);
                    newMaster.setStatus(StorageDomainStatus.Locked);
                    getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                }
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
                getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    } else {
        updateStorageDomainStaticData(newMaster.getStorageStaticData());
    }
    updateStoragePoolMasterDomainVersionInDiffTransaction();
    return false;
}
#method_after
protected boolean proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster == null) {
        return true;
    }
    newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
    if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                newMaster.setStorageDomainType(StorageDomainType.Master);
                if (lockNewMaster) {
                    newMasterMap.setStatus(StorageDomainStatus.Unknown);
                    getCompensationContext().snapshotEntityStatus(newMasterMap);
                    newMaster.setStatus(StorageDomainStatus.Locked);
                    getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                }
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
                getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                getCompensationContext().stateChanged();
                return null;
            }
        });
    } else {
        updateStorageDomainStaticData(newMaster.getStorageStaticData());
    }
    updateStoragePoolMasterDomainVersionInDiffTransaction();
    return false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getStoragePool() != null) {
        try {
            // if master try to reconstruct
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                Backend.getInstance().runInternalAction(VdcActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.errorFormat("Could not force detach storage domain {0}. error: {1}", getStorageDomain().getStorageName(), ex.toString());
        }
    }
    StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    DbFacade.getInstance().getStorageDomainDao().remove(getStorageDomain().getId());
    if (getStoragePool() != null) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getStoragePool() != null) {
        try {
            // if master try to reconstruct
            if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
                ReconstructMasterParameters tempVar = new ReconstructMasterParameters(getStoragePool().getId(), getStorageDomain().getId(), false);
                tempVar.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
                runInternalAction(VdcActionType.ReconstructMasterDomain, tempVar);
            }
            // try to force detach first
            DetachStorageDomainVDSCommandParameters tempVar2 = new DetachStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), Guid.Empty, -1);
            tempVar2.setForce(true);
            runVdsCommand(VDSCommandType.DetachStorageDomain, tempVar2);
        } catch (RuntimeException ex) {
            log.error("Could not force detach storage domain '{}': {}", getStorageDomain().getStorageName(), ex.getMessage());
            log.debug("Exception", ex);
        }
    }
    StorageHelperDirector.getInstance().getItem(getStorageDomain().getStorageType()).storageDomainRemoved(getStorageDomain().getStorageStaticData());
    DbFacade.getInstance().getStorageDomainDao().remove(getStorageDomain().getId());
    if (getStoragePool() != null) {
        // if iso reset path for pool
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.ISO) {
            // todo: when iso in multiple pools will be implemented, we
            // should reset iso path for all related pools
            runVdsCommand(VDSCommandType.ResetISOPath, new IrsBaseVDSCommandParameters(getStoragePool().getId()));
        }
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
            calcStoragePoolStatusByDomainsStatus();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // FIXME: check ReconstructMasterDomain canDoAction?
    boolean returnValue = checkStoragePool();
    if (returnValue) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
            return false;
        } else if (getStorageDomain() != null && getStorageDomain().getStatus() != null && getStorageDomain().getStatus() == StorageDomainStatus.Active) {
            addStorageDomainStatusIllegalMessage();
            returnValue = false;
        } else if (electNewMaster() != null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.STORAGE_POOL_REINITIALIZE_WITH_MORE_THAN_ONE_DATA_DOMAIN.toString());
            returnValue = false;
        } else {
            StorageDomain domain = getNewMasterDomain();
            if (domain.getStorageDomainSharedStatus() != StorageDomainSharedStatus.Unattached) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                returnValue = false;
            }
        }
    }
    return returnValue && initializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean returnValue = checkStoragePool();
    if (!validate(new StorageDomainValidator(getStorageDomain()).isInProcess()) || !validate(new StoragePoolValidator(getStoragePool()).isAnyDomainInProcess())) {
        return false;
    }
    if (returnValue) {
        if (getStoragePool().getStatus() == StoragePoolStatus.Uninitialized) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_STATUS_ILLEGAL);
            return false;
        } else if (getStorageDomain() != null && getStorageDomain().getStatus() != null && getStorageDomain().getStatus() == StorageDomainStatus.Active) {
            addStorageDomainStatusIllegalMessage();
            returnValue = false;
        } else if (electNewMaster() != null) {
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.STORAGE_POOL_REINITIALIZE_WITH_MORE_THAN_ONE_DATA_DOMAIN.toString());
            returnValue = false;
        } else {
            StorageDomain domain = loadTargetedMasterDomain();
            if (domain.getStorageDomainSharedStatus() != StorageDomainSharedStatus.Unattached) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                returnValue = false;
            }
        }
    }
    return returnValue && initializeVds();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (StorageHelperDirector.getInstance().getItem(getNewMasterDomain().getStorageType()).connectStorageToDomainByVdsId(getNewMasterDomain(), getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = getBackend().runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormat(getNewMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#method_after
@Override
protected void executeCommand() {
    StorageDomain newMasterDomain = loadTargetedMasterDomain();
    if (StorageHelperDirector.getInstance().getItem(newMasterDomain.getStorageType()).connectStorageToDomainByVdsId(newMasterDomain, getVds().getId())) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getNewMasterDomainId(), null, EventType.RECOVERY, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                getParameters().setStorageDomainId(getMasterDomainIdFromDb());
                StoragePoolIsoMap domainPoolMap = new StoragePoolIsoMap(getParameters().getNewMasterDomainId(), getParameters().getStoragePoolId(), StorageDomainStatus.Active);
                DbFacade.getInstance().getStoragePoolIsoMapDao().save(domainPoolMap);
                getParameters().setVdsId(getVds().getId());
                VdcReturnValueBase returnVal = runInternalAction(VdcActionType.ReconstructMasterDomain, getParameters(), cloneContextAndDetachFromParent());
                boolean reconstructVerbExecuted = (returnVal.getActionReturnValue() != null) ? (Boolean) returnVal.getActionReturnValue() : false;
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), StoragePoolStatus.NonResponsive);
                if (!reconstructVerbExecuted) {
                    getStoragePoolIsoMapDAO().remove(domainPoolMap.getId());
                }
                if (returnVal.getSucceeded()) {
                    updateStorageDomainFormatIfNeeded(loadTargetedMasterDomain());
                }
                setSucceeded(returnVal.getSucceeded());
                return new EventResult(reconstructVerbExecuted, EventType.RECONSTRUCT);
            }
        });
    } else {
        getReturnValue().setFault(new VdcFault(new VdcBLLException(VdcBllErrors.StorageServerConnectionError, "Failed to connect storage"), VdcBllErrors.StorageServerConnectionError));
    }
}
#end_block

#method_before
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getLunDao().getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUN_id())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedBySDs) {
            formattedIds.add(getFormattedLunId(lun, lun.getStorageDomainName()));
        }
        addCanDoActionMessage(String.format("$lunIds %1$s", StringUtils.join(formattedIds, ", ")));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedByDisks) {
            formattedIds.add(getFormattedLunId(lun, lun.getDiskAlias()));
        }
        addCanDoActionMessage(String.format("$lunIds %1$s", StringUtils.join(formattedIds, ", ")));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#method_after
protected boolean isLunsAlreadyInUse(List<String> lunIds) {
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getLunDao().getAll();
    Set<LUNs> lunsUsedBySDs = new HashSet<>();
    Set<LUNs> lunsUsedByDisks = new HashSet<>();
    for (LUNs lun : lunsFromDb) {
        if (lunIds.contains(lun.getLUN_id())) {
            if (lun.getStorageDomainId() != null) {
                // LUN is already part of a storage domain
                lunsUsedBySDs.add(lun);
            }
            if (lun.getDiskId() != null) {
                // LUN is already used by a disk
                lunsUsedByDisks.add(lun);
            }
        }
    }
    if (!lunsUsedBySDs.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedBySDs) {
            formattedIds.add(getFormattedLunId(lun, lun.getStorageDomainName()));
        }
        addCanDoActionMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    if (!lunsUsedByDisks.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_USED_BY_DISKS);
        Set<String> formattedIds = new HashSet<>();
        for (LUNs lun : lunsUsedByDisks) {
            formattedIds.add(getFormattedLunId(lun, lun.getDiskAlias()));
        }
        addCanDoActionMessageVariable("lunIds", StringUtils.join(formattedIds, ", "));
    }
    return !lunsUsedBySDs.isEmpty() || !lunsUsedByDisks.isEmpty();
}
#end_block

#method_before
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        List<StorageServerConnections> connections = DbFacade.getInstance().getStorageServerConnectionDao().getAllForConnection(connection);
        if (connections.isEmpty()) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(connections.get(0).getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUN_storage_server_connection_map_id(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUN_storage_server_connection_map(lun.getLUN_id(), connection.getid()));
        }
    }
}
#method_after
public static void proceedLUNInDb(final LUNs lun, StorageType storageType, String volumeGroupId) {
    lun.setvolume_group_id(volumeGroupId);
    if (DbFacade.getInstance().getLunDao().get(lun.getLUN_id()) == null) {
        DbFacade.getInstance().getLunDao().save(lun);
    } else if (!volumeGroupId.isEmpty()) {
        DbFacade.getInstance().getLunDao().update(lun);
    }
    if (storageType == StorageType.FCP) {
        // No need to handle connections (FCP storage doesn't utilize connections).
        return;
    }
    for (StorageServerConnections connection : lun.getLunConnections()) {
        StorageServerConnections dbConnection = ISCSIStorageHelper.findConnectionWithSameDetails(connection);
        if (dbConnection == null) {
            connection.setid(Guid.newGuid().toString());
            connection.setstorage_type(storageType);
            DbFacade.getInstance().getStorageServerConnectionDao().save(connection);
        } else {
            connection.setid(dbConnection.getid());
        }
        if (DbFacade.getInstance().getStorageServerConnectionLunMapDao().get(new LUNStorageServerConnectionMapId(lun.getLUN_id(), connection.getid())) == null) {
            DbFacade.getInstance().getStorageServerConnectionLunMapDao().save(new LUNStorageServerConnectionMap(lun.getLUN_id(), connection.getid()));
        }
    }
}
#end_block

#method_before
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warnFormat("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    if (storageDomains.isEmpty()) {
        log.warnFormat("Cannot elect new master: storage domains not found");
        return null;
    }
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#method_after
protected StorageDomain electNewMaster(boolean duringReconstruct, boolean selectInactiveWhenNoActiveUnknownDomains, boolean canChooseCurrentMasterAsNewMaster) {
    if (getStoragePool() == null) {
        log.warn("Cannot elect new master: storage pool not found");
        return null;
    }
    List<StorageDomain> storageDomains = getStorageDomainDAO().getAllForStoragePool(getStoragePool().getId());
    if (storageDomains.isEmpty()) {
        log.warn("Cannot elect new master, no storage domains found for pool {}", getStoragePool().getName());
        return null;
    }
    Collections.sort(storageDomains, LastTimeUsedAsMasterComp.instance);
    StorageDomain newMaster = null;
    StorageDomain storageDomain = getStorageDomain();
    for (StorageDomain dbStorageDomain : storageDomains) {
        if ((storageDomain == null || (duringReconstruct || !dbStorageDomain.getId().equals(storageDomain.getId()))) && ((dbStorageDomain.getStorageDomainType() == StorageDomainType.Data) || (canChooseCurrentMasterAsNewMaster && dbStorageDomain.getStorageDomainType() == StorageDomainType.Master))) {
            if (dbStorageDomain.getStatus() == StorageDomainStatus.Active || dbStorageDomain.getStatus() == StorageDomainStatus.Unknown) {
                newMaster = dbStorageDomain;
                break;
            } else if (selectInactiveWhenNoActiveUnknownDomains && newMaster == null && dbStorageDomain.getStatus() == StorageDomainStatus.Inactive) {
                // if the found domain is inactive, we don't break to continue and look for
                // active/unknown domain.
                newMaster = dbStorageDomain;
            }
        }
    }
    return newMaster;
}
#end_block

#method_before
protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) {
    executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {

        @SuppressWarnings("synthetic-access")
        @Override
        public StoragePoolIsoMap runInTransaction() {
            CompensationContext context = getCompensationContext();
            context.snapshotEntityStatus(map);
            map.setStatus(status);
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) {
    changeStorageDomainStatusInTransaction(map, status, getCompensationContext());
}
#end_block

#method_before
protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status) {
    executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {

        @SuppressWarnings("synthetic-access")
        @Override
        public StoragePoolIsoMap runInTransaction() {
            CompensationContext context = getCompensationContext();
            context.snapshotEntityStatus(map);
            map.setStatus(status);
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#method_after
protected void changeStorageDomainStatusInTransaction(final StoragePoolIsoMap map, final StorageDomainStatus status, final CompensationContext context) {
    executeInNewTransaction(new TransactionMethod<StoragePoolIsoMap>() {

        @SuppressWarnings("synthetic-access")
        @Override
        public StoragePoolIsoMap runInTransaction() {
            context.snapshotEntityStatus(map);
            map.setStatus(status);
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            context.stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessage(String.format("$status %1$s", getStorageDomainStatus()));
}
#method_after
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    addCanDoActionMessageVariable("status", getStorageDomainStatus());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        if (!filterDomainsByStatus(domains, StorageDomainStatus.Locked).isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getspm_vds_id() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getParameters().isSkipChecks()) {
        return true;
    }
    if (!(checkStorageDomain())) {
        return false;
    }
    // when the execution is internal, proceed also if the domain is in unknown status.
    if (!((getParameters().getIsInternal() && checkStorageDomainStatus(StorageDomainStatus.Active, StorageDomainStatus.Unknown)) || checkStorageDomainStatus(StorageDomainStatus.Active))) {
        return false;
    }
    if (!getParameters().getIsInternal() && getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        List<StorageDomain> domains = getStorageDomainDAO().getAllForStoragePool(getStorageDomain().getStoragePoolId());
        List<StorageDomain> activeDomains = filterDomainsByStatus(domains, StorageDomainStatus.Active);
        List<StorageDomain> dataDomains = LinqUtils.filter(activeDomains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain a) {
                return a.getStorageDomainType() == StorageDomainType.Data;
            }
        });
        if (!activeDomains.isEmpty() && dataDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_NON_DATA_DOMAINS);
        }
        List<StorageDomain> busyDomains = LinqUtils.filter(domains, new Predicate<StorageDomain>() {

            @Override
            public boolean eval(StorageDomain storageDomain) {
                return storageDomain.getStatus().isStorageDomainInProcess();
            }
        });
        if (!busyDomains.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_WITH_LOCKED_DOMAINS);
        }
    }
    if (!isRunningVmsWithIsoAttached()) {
        return false;
    }
    if (!getParameters().getIsInternal() && !getVmDAO().getAllActiveForStorageDomain(getStorageDomain().getId()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_ACTIVE_VMS);
    }
    if (getStoragePool().getSpmVdsId() != null) {
        // In case there are running tasks in the pool, it is impossible to deactivate the master storage domain
        if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master && getAsyncTaskDao().getAsyncTaskIdsByStoragePoolId(getStorageDomain().getStoragePoolId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_MASTER_DOMAIN_WITH_TASKS_ON_POOL);
        } else if (getStorageDomain().getStorageDomainType() != StorageDomainType.ISO && !getParameters().getIsInternal() && getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId()).size() > 0) {
            return failCanDoAction(VdcBllMessages.ERROR_CANNOT_DEACTIVATE_DOMAIN_WITH_TASKS);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster = electNewMaster();
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    proceedStorageDomainTreatmentByDomainType(newMaster, true);
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getmaster_domain_version()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getspm_vds_id() != null) {
        spm = getVdsDAO().get(getStoragePool().getspm_vds_id());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure stopping SPM." + " Stop SPM failed due to " + stopSpmReturnValue.getExceptionString());
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, newMasterId);
                return null;
            }
        });
    }
    if (!getParameters().isInactive() && spm != null) {
        getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.infoFormat("Domain {0} will remain in {1} status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    notifyAsyncTasks();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (isCinderStorageDomain()) {
        deactivateCinderStorageDomain();
        return;
    }
    final StoragePoolIsoMap map = getStoragePoolIsoMapDAO().get(new StoragePoolIsoMapId(getParameters().getStorageDomainId(), getParameters().getStoragePoolId()));
    map.setStatus(StorageDomainStatus.Unknown);
    changeStorageDomainStatusInTransaction(map, getParameters().isInactive() ? StorageDomainStatus.Locked : StorageDomainStatus.PreparingForMaintenance);
    final StorageDomain newMaster;
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        newMaster = electNewMaster();
        proceedStorageDomainTreatmentByDomainType(newMaster, true);
    } else {
        newMaster = null;
    }
    final Guid newMasterId = newMaster != null ? newMaster.getId() : Guid.Empty;
    if (_isLastMaster) {
        executeInNewTransaction(new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                getCompensationContext().snapshotEntityStatus(getStoragePool());
                getStoragePool().setStatus(StoragePoolStatus.Maintenance);
                getStoragePoolDAO().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
                getCompensationContext().stateChanged();
                return null;
            }
        });
        StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
        getStorageDomain().getStorageDynamicData().setAvailableDiskSize(null);
        getStorageDomain().getStorageDynamicData().setUsedDiskSize(null);
    }
    if (!getParameters().isInactive()) {
        runVdsCommand(VDSCommandType.DeactivateStorageDomain, new DeactivateStorageDomainVDSCommandParameters(getStoragePool().getId(), getStorageDomain().getId(), newMasterId, getStoragePool().getMasterDomainVersion()));
    }
    freeLock();
    VDS spm = null;
    if (getStoragePool().getSpmVdsId() != null) {
        spm = getVdsDAO().get(getStoragePool().getSpmVdsId());
    }
    if (_isLastMaster) {
        if (spm != null) {
            final VDSReturnValue stopSpmReturnValue = runVdsCommand(VDSCommandType.SpmStopOnIrs, new SpmStopOnIrsVDSCommandParameters(getStoragePool().getId()));
            if (!stopSpmReturnValue.getSucceeded()) {
                // no need to continue because DisconnectStoragePool will
                // fail if host is SPM
                log.error("Aborting execution due to failure to stop SPM");
                setSucceeded(false);
                return;
            }
            runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(spm.getId(), getStoragePool().getId(), spm.getVdsSpmId()));
        }
        runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    }
    if (!getParameters().isInactive()) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), null, EventType.POOLREFRESH, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                runSynchronizeOperation(new AfterDeactivateSingleAsyncOperationFactory(), _isLastMaster, newMasterId);
                return null;
            }
        });
        if (spm != null) {
            getStorageHelper(getStorageDomain()).disconnectStorageFromDomainByVdsId(getStorageDomain(), spm.getId());
        }
    }
    executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            if (getParameters().isInactive()) {
                map.setStatus(StorageDomainStatus.Inactive);
            } else if (_isLastMaster) {
                map.setStatus(StorageDomainStatus.Maintenance);
            } else {
                log.info("Domain '{}' will remain in '{}' status until deactivated on all hosts", getStorageDomain().getId(), map.getStatus());
            }
            getStoragePoolIsoMapDAO().updateStatus(map.getId(), map.getStatus());
            if (newMaster != null) {
                StoragePoolIsoMap mapOfNewMaster = newMaster.getStoragePoolIsoMapData();
                mapOfNewMaster.setStatus(StorageDomainStatus.Active);
                getStoragePoolIsoMapDAO().updateStatus(mapOfNewMaster.getId(), mapOfNewMaster.getStatus());
            }
            return null;
        }
    });
    if (!getParameters().isSkipChecks()) {
        notifyAsyncTasks();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        AuditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#method_after
private void notifyAsyncTasks() {
    final List<Guid> asyncTasks = getDbFacade().getAsyncTaskDao().getAsyncTaskIdsByEntity(getParameters().getStorageDomainId());
    if (!asyncTasks.isEmpty()) {
        AuditLogableBase auditLogableBase = new AuditLogableBase();
        auditLogableBase.setStorageDomain(getStorageDomain());
        auditLogDirector.log(auditLogableBase, AuditLogType.STORAGE_DOMAIN_TASKS_ERROR);
    }
}
#end_block

#method_before
protected void proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (getStorageDomain().getStorageDomainType() == StorageDomainType.Master) {
        if (newMaster != null) {
            newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
            if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
                executeInNewTransaction(new TransactionMethod<Object>() {

                    @Override
                    public Object runInTransaction() {
                        StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                        getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                        newMaster.setStorageDomainType(StorageDomainType.Master);
                        if (!lockNewMaster) {
                            newMasterMap.setStatus(StorageDomainStatus.Unknown);
                            getCompensationContext().snapshotEntityStatus(newMasterMap);
                            newMaster.setStatus(StorageDomainStatus.Locked);
                            getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                        }
                        updateStorageDomainStaticData(newMaster.getStorageStaticData());
                        getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                        getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                        updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                        getCompensationContext().stateChanged();
                        return null;
                    }
                });
            } else {
                updateStorageDomainStaticData(newMaster.getStorageStaticData());
            }
            updateStoragePoolMasterDomainVersionInDiffTransaction();
        } else {
            _isLastMaster = true;
        }
    }
}
#method_after
protected void proceedStorageDomainTreatmentByDomainType(final StorageDomain newMaster, final boolean lockNewMaster) {
    if (newMaster != null) {
        newMaster.getStorageStaticData().setLastTimeUsedAsMaster(System.currentTimeMillis());
        if (newMaster.getStorageDomainType() != StorageDomainType.Master) {
            executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    StoragePoolIsoMap newMasterMap = newMaster.getStoragePoolIsoMapData();
                    getCompensationContext().snapshotEntityUpdated(newMaster.getStorageStaticData());
                    newMaster.setStorageDomainType(StorageDomainType.Master);
                    if (lockNewMaster) {
                        newMasterMap.setStatus(StorageDomainStatus.Unknown);
                        getCompensationContext().snapshotEntityStatus(newMasterMap);
                        newMaster.setStatus(StorageDomainStatus.Locked);
                        getStoragePoolIsoMapDAO().updateStatus(newMasterMap.getId(), newMasterMap.getStatus());
                    }
                    updateStorageDomainStaticData(newMaster.getStorageStaticData());
                    getCompensationContext().snapshotEntityUpdated(getStorageDomain().getStorageStaticData());
                    getStorageDomain().setStorageDomainType(StorageDomainType.Data);
                    updateStorageDomainStaticData(getStorageDomain().getStorageStaticData());
                    getCompensationContext().stateChanged();
                    return null;
                }
            });
        } else {
            updateStorageDomainStaticData(newMaster.getStorageStaticData());
        }
        updateStoragePoolMasterDomainVersionInDiffTransaction();
    } else {
        _isLastMaster = true;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // cause to the command to apply the compensation data and leave the domain as LOCKED.
    if (checkIsDomainLocked(getStorageDomain().getStoragePoolIsoMapData())) {
        return false;
    }
    List<StoragePoolIsoMap> poolDomains = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(getStoragePool().getId());
    for (StoragePoolIsoMap poolDomain : poolDomains) {
        if (checkIsDomainLocked(poolDomain)) {
            return false;
        }
    }
    return initializeVds();
}
#method_after
@Override
protected boolean canDoAction() {
    // cause to the command to apply the compensation data and leave the domain as LOCKED.
    if (!validate(createStorageDomainValidator().isInProcess())) {
        return false;
    }
    if (!validate(createStoragePoolValidator().isAnyDomainInProcess())) {
        return false;
    }
    return initializeVds();
}
#end_block

#method_before
protected boolean reconstructMaster() {
    _newMasterStorageDomainId = getNewMaster().getId();
    proceedStorageDomainTreatmentByDomainType(getNewMaster(), true);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMaster().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterId(), domains, getStoragePool().getmaster_domain_version())).getSucceeded();
}
#method_after
protected boolean reconstructMaster() {
    proceedStorageDomainTreatmentByDomainType(getNewMasterStorageDomain(), false);
    // To issue a reconstructMaster you need to set the domain inactive unless the selected domain is the current master
    if (getParameters().isInactive() && !getStorageDomain().getId().equals(getNewMasterStorageDomainId())) {
        executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                setStorageDomainStatus(StorageDomainStatus.Inactive, getCompensationContext());
                calcStoragePoolStatusByDomainsStatus();
                getCompensationContext().stateChanged();
                return null;
            }
        });
    }
    if (_isLastMaster) {
        return stopSpm();
    }
    boolean commandSucceeded = stopSpm();
    final List<String> disconnectPoolFormats = Config.<List<String>>getValue(ConfigValues.DisconnectPoolOnReconstruct);
    if (commandSucceeded && disconnectPoolFormats.contains(getNewMasterStorageDomain().getStorageFormat().getValue())) {
        commandSucceeded = runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(getVds().getId(), getStoragePool().getId(), getVds().getVdsSpmId())).getSucceeded();
    }
    if (!commandSucceeded) {
        return false;
    }
    List<StoragePoolIsoMap> domains = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
    // set to true here in case of failure in executing/getting answer from the reconstruct vds command,
    // unless we know that the command failed we assume that it succeeded (use by RecoveryStoragePool command in
    // order to avoid detaching domain that is already part of the pool in vdsm).
    setActionReturnValue(true);
    return runVdsCommand(VDSCommandType.ReconstructMaster, new ReconstructMasterVDSCommandParameters(getVds().getId(), getVds().getVdsSpmId(), getStoragePool().getId(), getStoragePool().getName(), getNewMasterStorageDomainId(), domains, getStoragePool().getMasterDomainVersion())).getSucceeded();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getcompatibility_version())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#method_after
@Override
protected void executeCommand() {
    boolean reconstructOpSucceeded = reconstructMaster();
    setActionReturnValue(reconstructOpSucceeded);
    connectAndRefreshAllUpHosts(reconstructOpSucceeded);
    if (!_isLastMaster && reconstructOpSucceeded && !FeatureSupported.ovfStoreOnAnyDomain(getStoragePool().getCompatibilityVersion())) {
        // all vms/templates metadata should be copied to the new master domain, so we need
        // to perform increment of the db version for all the vms in the storage pool.
        // currently this method is used for both templates and vms.
        getVmStaticDAO().incrementDbGenerationForAllInStoragePool(getStoragePoolId());
    }
    if (_isLastMaster) {
        getCompensationContext().resetCompensation();
    }
    setSucceeded(!_isLastMaster && reconstructOpSucceeded);
    if (getSucceeded()) {
        runVdsCommand(VDSCommandType.MarkPoolInReconstructMode, new IrsBaseVDSCommandParameters(getStoragePoolId()));
    }
}
#end_block

#method_before
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getspm_vds_id() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getspm_vds_id().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getspm_vds_id());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#method_after
protected boolean stopSpm() {
    boolean commandSucceeded = true;
    if (getStoragePool().getSpmVdsId() != null) {
        // if spm host id is different from selected host get the spm
        // in order to try and perform stop spm
        VDS spm = null;
        if (getStoragePool().getSpmVdsId().equals(getVds().getId())) {
            spm = getVds();
        } else {
            spm = DbFacade.getInstance().getVdsDao().get(getStoragePool().getSpmVdsId());
        }
        if (spm != null) {
            ResetIrsVDSCommandParameters tempVar2 = new ResetIrsVDSCommandParameters(getStoragePool().getId(), spm.getId());
            tempVar2.setIgnoreStopFailed(true);
            commandSucceeded = runVdsCommand(VDSCommandType.ResetIrs, tempVar2).getSucceeded();
            // if spm host is up switch to use it in the following logic
            if (spm.getStatus() == VDSStatus.Up) {
                setVdsId(spm.getId());
                setVds(spm);
            }
        }
    }
    return commandSucceeded;
}
#end_block

#method_before
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMaster();
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.errorFormat("Error while trying connect host {0} to the needed storage server during the reinitialization of Data Center {1}", vds.getId(), getStoragePool().getId());
    return false;
}
#method_after
private boolean connectVdsToNewMaster(VDS vds) {
    StorageDomain masterDomain = getNewMasterStorageDomain();
    if (vds.getId().equals(getVds().getId()) || StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).connectStorageToDomainByVdsId(masterDomain, vds.getId())) {
        return true;
    }
    log.error("Error while trying connect host {} to the needed storage server during the reinitialization" + " of Data Center '{}'", vds.getId(), getStoragePool().getId());
    return false;
}
#end_block

#method_before
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warnFormat("skipping connect and refresh for all hosts, last master: {0}, command status: {1}", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warnFormat("");
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.errorFormat("Post reconstruct actions (connectPool) did not complete on host {0} in the pool. error {1}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.errorFormat("Post reconstruct actions (refreshPool)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.errorFormat("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host {0} in the pool. error {1}", vds.getId(), e.getMessage());
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#method_after
private void connectAndRefreshAllUpHosts(final boolean commandSucceeded) {
    if (_isLastMaster || !commandSucceeded) {
        log.warn("skipping connect and refresh for all hosts, last master '{}', command status '{}'", _isLastMaster, commandSucceeded);
        return;
    }
    List<Callable<Void>> tasks = new ArrayList<Callable<Void>>();
    for (final VDS vds : getAllRunningVdssInPool()) {
        tasks.add(new Callable<Void>() {

            @Override
            public Void call() {
                try {
                    if (!connectVdsToNewMaster(vds)) {
                        log.warn("failed to connect vds '{}' to the new master '{}'", vds.getId(), getNewMasterStorageDomainId());
                        return null;
                    }
                    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDAO().getAllForStoragePool(getStoragePool().getId());
                    try {
                        runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap, true));
                    } catch (VdcBLLException ex) {
                        if (VdcBllErrors.StoragePoolUnknown == ex.getVdsError().getCode()) {
                            VDSReturnValue returnVal = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, getStoragePool(), getNewMasterStorageDomainId(), storagePoolIsoMap));
                            if (!returnVal.getSucceeded()) {
                                log.error("Post reconstruct actions (connectPool) did not complete on host '{}' in the pool. error {}", vds.getId(), returnVal.getVdsError().getMessage());
                            }
                        } else {
                            log.error("Post reconstruct actions (refreshPool)" + " did not complete on host '{}' in the pool. error {}", vds.getId(), ex.getMessage());
                        }
                    }
                } catch (Exception e) {
                    log.error("Post reconstruct actions (connectPool,refreshPool,disconnect storage)" + " did not complete on host '{}' in the pool: {}", vds.getId(), e.getMessage());
                    log.debug("Exception", e);
                }
                return null;
            }
        });
    }
    ThreadPoolUtil.invokeAll(tasks);
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    String sessionId = getCurrent().getSessionId();
    parameters.setSessionId(sessionId);
    return parameters;
}
#end_block

#method_before
@Override
public void initialize(ConfiguredRange constraintAnnotation) {
    if (constraintAnnotation.minConfigValue() != ConfigValues.Invalid) {
        min = Config.<Integer>getValue(constraintAnnotation.minConfigValue(), ConfigCommon.defaultConfigurationVersion);
    } else {
        min = constraintAnnotation.min();
    }
    max = Config.<Integer>getValue(constraintAnnotation.maxConfigValue(), ConfigCommon.defaultConfigurationVersion);
    rangeMessage = "$range " + min + "-" + max;
}
#method_after
@Override
public void initialize(ConfiguredRange constraintAnnotation) {
    if (constraintAnnotation.minConfigValue() != ConfigValues.Invalid) {
        min = Config.<Integer>getValue(constraintAnnotation.minConfigValue(), ConfigCommon.defaultConfigurationVersion);
    } else {
        min = constraintAnnotation.min();
    }
    max = Config.<Integer>getValue(constraintAnnotation.maxConfigValue(), ConfigCommon.defaultConfigurationVersion);
    /* this is to interpolate "${range}" in CanDoActions */
    rangeMessage = "$range " + min + "-" + max;
}
#end_block

#method_before
@Override
public boolean isValid(Integer value, ConstraintValidatorContext context) {
    boolean result = value == null ? true : value >= min && value <= max;
    if (!result) {
        context.buildConstraintViolationWithTemplate(rangeMessage);
    }
    return result;
}
#method_after
@Override
public boolean isValid(Integer value, ConstraintValidatorContext context) {
    boolean result = value == null ? true : value >= min && value <= max;
    if (!result) {
        /* this will add a constraint message with interpolated variable for can do actions */
        context.buildConstraintViolationWithTemplate(rangeMessage).addConstraintViolation();
    }
    return result;
}
#end_block

#method_before
@Override
protected void postConstruct() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameters.getVmStaticData().getVmType() == VmType.Desktop);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<Guid, DiskImage>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (parameters.isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(parameters.getVmStaticData().getVmType() == VmType.Desktop);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for canDoACtion to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getVmId() != null && getVmStaticDao().get(getVmId()) != null) {
        return failCanDoAction(VdcBllMessages.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(diskInfoDestinationMap.values(), true, false, true);
        for (DiskImage diskImage : diskImages) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
    }
}
#end_block

#method_before
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHost(getParameters().getVmStaticData().getDedicatedVmForVds());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#method_after
protected void addVmNumaNodes() {
    List<VmNumaNode> numaNodes = getParameters().getVmStaticData().getvNumaNodeList();
    VmNumaNodeOperationParameters params = new VmNumaNodeOperationParameters(getVmId(), numaNodes);
    params.setNumaTuneMode(getParameters().getVmStaticData().getNumaTuneMode());
    params.setDedicatedHost(getParameters().getVmStaticData().getDedicatedVmForVds());
    params.setMigrationSupport(getParameters().getVmStaticData().getMigrationSupport());
    if (numaNodes == null || numaNodes.isEmpty()) {
        return;
    }
    VdcReturnValueBase returnValueBase = getBackend().runInternalAction(VdcActionType.AddVmNumaNodes, params);
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_ADD_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    vmStatic.setIconId(getIconId());
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>getValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    setIconIds(vmStatic);
    // Parses the custom properties field that was filled by frontend to
    // predefined and user defined fields
    VmPropertiesUtils.getInstance().separateCustomPropertiesToUserAndPredefined(getVdsGroup().getCompatibilityVersion(), vmStatic);
    updateOriginalTemplate(vmStatic);
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage image : getImagesToCheckDestinationStorageDomains()) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (!vmDisksSource.getDiskTemplateMap().isEmpty()) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        Collection<DiskImage> templateDisks = getImagesToCheckDestinationStorageDomains();
        List<DiskImage> diskImages = ImagesHandler.filterImageDisks(templateDisks, true, false, true);
        for (DiskImage image : diskImages) {
            VdcReturnValueBase result = runInternalActionWithTasksContext(VdcActionType.CreateSnapshotFromTemplate, buildCreateSnapshotFromTemplateParameters(image));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(image.getId(), newImage.getId());
            }
        }
        // Clone volumes for Cinder disk templates
        addVmCinderDisks(ImagesHandler.filterDisksBasedOnCinder(templateDisks));
    }
    return true;
}
#end_block

#method_before
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<Permission> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permission[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permission> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getEngineSessionSeqId(), false);
    for (Permission templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getRoleId().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getRoleId().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getAdElementId(), templatePermission.getRoleId(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permissions[] permsArray = new Permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permissions(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    Permission[] permsArray = new Permission[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new Permission(getUserIdOfDiskOperator(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        handleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    final List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmTemplateId()));
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    if (!imageTemplates.isEmpty() || !cinderDisks.isEmpty()) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (!imageTemplates.isEmpty() && removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                if (!cinderDisks.isEmpty()) {
                    removeCinderDisks(cinderDisks);
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        // if for some reason template doesn't have images, remove it now and not in end action
        HandleEndAction();
    }
}
#end_block

#method_before
private void removeTemplateFromDb() {
    removeNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
    vmIconDao.removeIfUnused(getVmTemplate().getIconId());
}
#method_after
private void removeTemplateFromDb() {
    removeNetwork();
    DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplate().getId());
    vmIconDao.removeIfUnused(getVmTemplate().getSmallIconId());
    vmIconDao.removeIfUnused(getVmTemplate().getLargeIconId());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    handleEndAction();
}
#method_after
@Override
protected void endSuccessfully() {
    HandleEndAction();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    handleEndAction();
}
#method_after
@Override
protected void endWithFailure() {
    HandleEndAction();
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR).addValue(ICON_ID_COLUMN, vm.getIconId());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmStatic vm) {
    return createBaseParametersMapper(vm).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("is_initialized", vm.isInitialized()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId()).addValue("original_template_name", vm.getOriginalTemplateName()).addValue("original_template_id", vm.getOriginalTemplateGuid()).addValue("template_version_number", vm.isUseLatestVersion() ? USE_LATEST_VERSION_NUMBER_INDICATOR : DONT_USE_LATEST_VERSION_NUMBER_INDICATOR);
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setIconId(getGuid(rs, ICON_ID_COLUMN));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == USE_LATEST_VERSION_NUMBER_INDICATOR);
    return entity;
}
#end_block

#method_before
@PostConstruct
void init() {
    log.info("Initializing the DbFacade");
    dbFacadeLocator.configure(this);
    instance = this;
}
#method_after
private void init() {
    log.info("Initializing the DbFacade");
    dbFacadeLocator.configure(this);
    instance = this;
}
#end_block

#method_before
protected <T extends DAO> T getDao(Class<T> daoType) {
    T dao = DaoFactory.get(daoType);
    if (dao instanceof BaseDAODbFacade) {
        BaseDAODbFacade dbFacadeDAO = (BaseDAODbFacade) dao;
        dbFacadeDAO.setTemplate(jdbcTemplate);
        dbFacadeDAO.setDialect(dbEngineDialect);
        dbFacadeDAO.setDbFacade(this);
    }
    return dao;
}
#method_after
@SuppressWarnings("unchecked")
private <T extends DAO> T getDao(Class<T> daoType) {
    for (DAO dao : daos) {
        if (daoType.isAssignableFrom(dao.getClass())) {
            return (T) dao;
        }
    }
    log.error("Can't find dao for " + daoType);
    return null;
}
#end_block

#method_before
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<MapSqlParameterSource>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#method_after
public void populateDwhOsInfo(Map<Integer, String> osIdToName) {
    // first clear the table
    new SimpleJdbcCall(jdbcTemplate).withProcedureName("clear_osinfo").execute();
    // batch populate
    List<MapSqlParameterSource> executions = new ArrayList<>();
    for (Map.Entry<Integer, String> e : osIdToName.entrySet()) {
        executions.add(getCustomMapSqlParameterSource().addValue("os_id", e.getKey()).addValue("os_name", e.getValue()));
    }
    getCallsHandler().executeStoredProcAsBatch("insert_osinfo", executions);
}
#end_block

#method_before
@Override
public List<VM> getAllUsingQuery(String query) {
    return jdbcTemplate.query(query, VMRowMapper.instance);
}
#method_after
@Override
public List<VM> getAllUsingQuery(String query) {
    return getJdbcTemplate().query(query, VMRowMapper.instance);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    final Guid oldIconId = updateVmIcon(oldVm);
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
    }
    removeUnusedIcon(oldIconId);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    oldVm = getVm();
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getVdsGroup().getCompatibilityVersion());
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    int cpuPerSocket = newVmStatic.getCpuPerSocket();
    int numOfSockets = newVmStatic.getNumOfSockets();
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new VdcBLLException(VdcBllErrors.FAILED_UPDATE_RUNNING_VM);
        }
    }
    UpdateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(cpuPerSocket, numOfSockets);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    getVmStaticDAO().update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        VmDeviceUtils.updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevice();
        updateVmHostDevices();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        AuditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#method_after
private void auditLogHotSetCpusCandos(HotSetNumerOfCpusParameters params) {
    if (!setNumberOfCpusResult.getCanDoAction()) {
        AuditLogableBase logable = new HotSetNumberOfCpusCommand<>(params);
        List<String> canDos = getBackend().getErrorsTranslator().TranslateErrorText(setNumberOfCpusResult.getCanDoActionMessages());
        logable.addCustomValue(HotSetNumberOfCpusCommand.LOGABLE_FIELD_ERROR_MESSAGE, StringUtils.join(canDos, ","));
        auditLogDirector.log(logable, AuditLogType.FAILED_HOT_SET_NUMBER_OF_CPUS);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    if (getParameters().getVm().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getParameters().getVm().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
        }
    }
}
#method_after
protected void updateVmPayload() {
    VmDeviceDAO dao = getVmDeviceDao();
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null || getParameters().isClearPayload()) {
        List<VmDevice> disks = dao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.DISK);
        VmDevice oldPayload = null;
        for (VmDevice disk : disks) {
            if (VmPayload.isPayload(disk.getSpecParams())) {
                oldPayload = disk;
                break;
            }
        }
        if (oldPayload != null) {
            List<VmDeviceId> devs = new ArrayList<VmDeviceId>();
            devs.add(oldPayload.getId());
            dao.removeAll(devs);
        }
        if (!getParameters().isClearPayload()) {
            VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
        }
    }
}
#end_block

#method_before
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        AuditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#method_after
private void addLogMessages(VdcReturnValueBase returnValueBase) {
    if (!returnValueBase.getSucceeded()) {
        auditLogDirector.log(this, AuditLogType.NUMA_UPDATE_VM_NUMA_NODE_FAILED);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getVdsGroupId() == null) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getVdsGroup().getCompatibilityVersion(), getVdsGroup().getCpuName(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getCompatibilityVersion().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getCompatibilityVersion())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(VmDeviceUtils.getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getVdsGroup().getArchitecture(), getVdsGroup().getCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getCompatibilityVersion(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessageVariable("clusterArch", getVdsGroup().getArchitecture());
        return failCanDoAction(VdcBllMessages.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(VmHandler.checkNumaPreferredTuneMode(getParameters().getVmStaticData().getNumaTuneMode(), getParameters().getVmStaticData().getvNumaNodeList(), getVmId()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        final boolean isDedicatedVmForVdsChanged = !(getVm().getDedicatedVmForVds() == null ? getParameters().getVmStaticData().getDedicatedVmForVds() == null : getVm().getDedicatedVmForVds().equals(getParameters().getVmStaticData().getDedicatedVmForVds()));
        final boolean isCpuPinningChanged = !(getVm().getCpuPinning() == null ? getParameters().getVmStaticData().getCpuPinning() == null : getVm().getCpuPinning().equals(getParameters().getVmStaticData().getCpuPinning()));
        if (isDedicatedVmForVdsChanged || isCpuPinningChanged) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (isVmExist()) {
        // user need specific permission to change custom properties
        if (!StringUtils.equals(getVm().getPredefinedProperties(), getParameters().getVmStaticData().getPredefinedProperties()) || !StringUtils.equals(getVm().getUserDefinedProperties(), getParameters().getVmStaticData().getUserDefinedProperties())) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES));
        }
        // host-specific parameters can be changed by administration role only
        if (isDedicatedVmForVdsChanged() || isCpuPinningChanged()) {
            permissionList.add(new PermissionSubject(getParameters().getVmId(), VdcObjectType.VM, ActionGroup.EDIT_ADMIN_VM_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + (autoStartup ? 1231 : 1237);
    result = prime * result + cpuPerSocket;
    result = prime * result + ((creationDate == null) ? 0 : creationDate.hashCode());
    result = prime * result + ((defaultBootSequence == null) ? 0 : defaultBootSequence.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (failBack ? 1231 : 1237);
    result = prime * result + ((initrdUrl == null) ? 0 : initrdUrl.hashCode());
    result = prime * result + ((isoPath == null) ? 0 : isoPath.hashCode());
    result = prime * result + ((kernelParams == null) ? 0 : kernelParams.hashCode());
    result = prime * result + ((kernelUrl == null) ? 0 : kernelUrl.hashCode());
    result = prime * result + osId;
    result = prime * result + memSizeMb;
    result = prime * result + niceLevel;
    result = prime * result + cpuShares;
    result = prime * result + numOfSockets;
    result = prime * result + numOfMonitors;
    result = prime * result + ((origin == null) ? 0 : origin.hashCode());
    result = prime * result + priority;
    result = prime * result + (stateless ? 1231 : 1237);
    result = prime * result + (smartcardEnabled ? 1231 : 1237);
    result = prime * result + ((timeZone == null) ? 0 : timeZone.hashCode());
    result = prime * result + ((usbPolicy == null) ? 0 : usbPolicy.hashCode());
    result = prime * result + ((vdsGroupId == null) ? 0 : vdsGroupId.hashCode());
    result = prime * result + ((vmType == null) ? 0 : vmType.hashCode());
    result = prime * result + ((quotaId == null) ? 0 : quotaId.hashCode());
    result = prime * result + (allowConsoleReconnect ? 1231 : 1237);
    result = prime * result + ((dedicatedVmForVds == null) ? 0 : dedicatedVmForVds.hashCode());
    result = prime * result + ((migrationSupport == null) ? 0 : migrationSupport.hashCode());
    result = prime * result + ((tunnelMigration == null) ? 0 : tunnelMigration.hashCode());
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((createdByUserId == null) ? 0 : createdByUserId.hashCode());
    result = prime * result + ((defaultDisplayType == null) ? 0 : defaultDisplayType.hashCode());
    result = prime * result + ((migrationDowntime == null) ? 0 : migrationDowntime.hashCode());
    result = prime * result + ((serialNumberPolicy == null) ? 0 : serialNumberPolicy.hashCode());
    result = prime * result + ((customSerialNumber == null) ? 0 : customSerialNumber.hashCode());
    result = prime * result + (bootMenuEnabled ? 1231 : 1237);
    result = prime * result + (spiceFileTransferEnabled ? 1231 : 1237);
    result = prime * result + (spiceCopyPasteEnabled ? 1231 : 1237);
    result = prime * result + ((cpuProfileId == null) ? 0 : cpuProfileId.hashCode());
    result = prime * result + ((numaTuneMode == null) ? 0 : numaTuneMode.getValue().hashCode());
    result = prime * result + ((vNumaNodeList == null) ? 0 : vNumaNodeList.hashCode());
    result = prime * result + (autoConverge == null ? 0 : autoConverge.hashCode());
    result = prime * result + (migrateCompressed == null ? 0 : migrateCompressed.hashCode());
    result = prime * result + ((predefinedProperties == null) ? 0 : predefinedProperties.hashCode());
    result = prime * result + ((userDefinedProperties == null) ? 0 : userDefinedProperties.hashCode());
    result = prime * result + ((customEmulatedMachine == null) ? 0 : customEmulatedMachine.hashCode());
    result = prime * result + ((customCpuName == null) ? 0 : customCpuName.hashCode());
    result = prime * result + ((smallIconId == null) ? 0 : smallIconId.hashCode());
    result = prime * result + ((largeIconId == null) ? 0 : largeIconId.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof VmBase)) {
        return false;
    }
    VmBase other = (VmBase) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && autoStartup == other.autoStartup && cpuPerSocket == other.cpuPerSocket && ObjectUtils.objectsEqual(creationDate, other.creationDate) && defaultBootSequence == other.defaultBootSequence && ObjectUtils.objectsEqual(description, other.description) && failBack == other.failBack && ObjectUtils.objectsEqual(initrdUrl, other.initrdUrl) && ObjectUtils.objectsEqual(isoPath, other.isoPath) && ObjectUtils.objectsEqual(kernelParams, other.kernelParams) && ObjectUtils.objectsEqual(kernelUrl, other.kernelUrl) && osId == other.osId && memSizeMb == other.memSizeMb && niceLevel == other.niceLevel && numOfSockets == other.numOfSockets && numOfMonitors == other.numOfMonitors && singleQxlPci == other.singleQxlPci && origin == other.origin && priority == other.priority && stateless == other.stateless && smartcardEnabled == other.smartcardEnabled && deleteProtected == other.deleteProtected && ObjectUtils.objectsEqual(timeZone, other.timeZone) && usbPolicy == other.usbPolicy && ObjectUtils.objectsEqual(vdsGroupId, other.vdsGroupId) && vmType == other.vmType && ObjectUtils.objectsEqual(quotaId, other.quotaId) && allowConsoleReconnect == other.allowConsoleReconnect && ObjectUtils.objectsEqual(dedicatedVmForVds, other.dedicatedVmForVds) && migrationSupport == other.migrationSupport && ObjectUtils.objectsEqual(tunnelMigration, other.tunnelMigration) && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(createdByUserId, other.createdByUserId) && cpuShares == other.cpuShares && ObjectUtils.objectsEqual(migrationDowntime, other.migrationDowntime) && serialNumberPolicy == other.serialNumberPolicy && ObjectUtils.objectsEqual(customSerialNumber, other.customSerialNumber) && bootMenuEnabled == other.bootMenuEnabled && spiceFileTransferEnabled == other.spiceFileTransferEnabled && spiceCopyPasteEnabled == other.spiceCopyPasteEnabled && ObjectUtils.objectsEqual(cpuProfileId, other.cpuProfileId) && ObjectUtils.objectsEqual(numaTuneMode.getValue(), other.numaTuneMode.getValue()) && ObjectUtils.objectsEqual(vNumaNodeList, other.vNumaNodeList)) && ObjectUtils.objectsEqual(autoConverge, other.autoConverge) && ObjectUtils.objectsEqual(migrateCompressed, other.migrateCompressed) && ObjectUtils.objectsEqual(predefinedProperties, other.predefinedProperties) && ObjectUtils.objectsEqual(userDefinedProperties, other.userDefinedProperties) && ObjectUtils.objectsEqual(customEmulatedMachine, other.customEmulatedMachine) && ObjectUtils.objectsEqual(customCpuName, other.customCpuName) && Objects.equals(smallIconId, other.smallIconId) && Objects.equals(largeIconId, other.largeIconId);
}
#end_block

#method_before
@Override
protected void postConstruct() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#method_after
@Override
@PostConstruct
protected void postConstruct() {
    // skipped if participating in compensation flow
    if (getParameters() == null) {
        return;
    }
    Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
    // if set to use latest version, get it from db and use it as template
    if (getParameters().getVmStaticData().isUseLatestVersion()) {
        VmTemplate latest = getVmTemplateDAO().getTemplateWithLatestVersionInChain(templateIdToUse);
        if (latest != null) {
            // as it may have different set of disks
            if (!templateIdToUse.equals(latest.getId())) {
                getParameters().setDiskInfoDestinationMap(null);
            }
            setVmTemplate(latest);
            templateIdToUse = latest.getId();
            getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
        }
    }
    setVmTemplateId(templateIdToUse);
    initTemplate();
    ensureDestinationImageMap();
    nameForVmInPoolGenerator = new NameForVmInPoolGenerator(getParameters().getVmPool().getName());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVmInitPassword();
    VmHandler.warnMemorySizeLegal(getParameters().getVmStaticData(), getVdsGroup().getCompatibilityVersion());
    Guid poolId = getPoolId();
    setActionReturnValue(poolId);
    VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
    addVmsToPool(poolId);
    getReturnValue().setCanDoAction(isAddVmsSucceded());
    setSucceeded(isAddVmsSucceded());
    VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
    getCompensationContext().resetCompensation();
}
#method_after
@Override
protected void executeCommand() {
    updateVmInitPassword();
    VmHandler.warnMemorySizeLegal(getParameters().getVmStaticData(), getVdsGroup().getCompatibilityVersion());
    Guid poolId = getPoolId();
    setActionReturnValue(poolId);
    VmTemplateHandler.lockVmTemplateInTransaction(getParameters().getVmStaticData().getVmtGuid(), getCompensationContext());
    addVmsToPool(poolId);
    getReturnValue().setCanDoAction(isAddVmsSucceded());
    setSucceeded(isAddVmsSucceded());
    VmTemplateHandler.unlockVmTemplate(getParameters().getVmStaticData().getVmtGuid());
    if (!isVmsAdded())
        onNoVmsAdded(poolId);
    getCompensationContext().resetCompensation();
}
#end_block

#method_before
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVmAndAttachToPool, buildAddVmAndAttachToPoolParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getCanDoActionMessages().isEmpty()) {
            for (String msg : returnValue.getCanDoActionMessages()) {
                if (!getReturnValue().getCanDoActionMessages().contains(msg)) {
                    getReturnValue().getCanDoActionMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            AuditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#method_after
private void addVmsToPool(Guid poolId) {
    int subsequentFailedAttempts = 0;
    int vmPoolMaxSubsequentFailures = Config.<Integer>getValue(ConfigValues.VmPoolMaxSubsequentFailures);
    for (int i = 0; i < getParameters().getVmsCount(); i++) {
        String currentVmName = generateUniqueVmName();
        VdcReturnValueBase returnValue = runInternalAction(VdcActionType.AddVmAndAttachToPool, buildAddVmAndAttachToPoolParameters(poolId, currentVmName), createAddVmStepContext(currentVmName));
        if (returnValue != null && !returnValue.getSucceeded() && !returnValue.getCanDoActionMessages().isEmpty()) {
            for (String msg : returnValue.getCanDoActionMessages()) {
                if (!getReturnValue().getCanDoActionMessages().contains(msg)) {
                    getReturnValue().getCanDoActionMessages().add(msg);
                }
            }
            addVmsSucceeded = false;
            subsequentFailedAttempts++;
        } else {
            // Succeed on that , reset subsequentFailedAttempts.
            subsequentFailedAttempts = 0;
            vmsAdded = true;
        }
        // if subsequent attempts failure exceeds configuration value , abort the loop.
        if (subsequentFailedAttempts == vmPoolMaxSubsequentFailures) {
            AuditLogableBase logable = new AuditLogableBase();
            auditLogDirector.log(logable, AuditLogType.USER_VM_POOL_MAX_SUBSEQUENT_FAILURES_REACHED);
            break;
        }
    }
}
#end_block

#method_before
private AddVmAndAttachToPoolParameters buildAddVmAndAttachToPoolParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    if (getParameters().getVmIcon() != null) {
        final Guid iconId = vmIconDao.ensureIconInDatabase(getParameters().getVmIcon());
        currVm.setIconId(iconId);
    }
    AddVmAndAttachToPoolParameters parameters = new AddVmAndAttachToPoolParameters(currVm, poolId, vmName, diskInfoDestinationMap);
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setParentCommand(VdcActionType.AddVmPoolWithVms);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled() != null ? getParameters().isSoundDeviceEnabled() : VmType.Desktop == getParameters().getVmStaticData().getVmType());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#method_after
private AddVmAndAttachToPoolParameters buildAddVmAndAttachToPoolParameters(Guid poolId, String vmName) {
    VmStatic currVm = new VmStatic(getParameters().getVmStaticData());
    currVm.setName(vmName);
    if (getParameters().getVmLargeIcon() != null) {
        final VmIconIdSizePair iconIds = IconUtils.ensureIconPairInDatabase(getParameters().getVmLargeIcon());
        currVm.setSmallIconId(iconIds.getSmall());
        currVm.setLargeIconId(iconIds.getLarge());
    }
    AddVmAndAttachToPoolParameters parameters = new AddVmAndAttachToPoolParameters(currVm, poolId, vmName, diskInfoDestinationMap);
    parameters.setSessionId(getParameters().getSessionId());
    parameters.setParentCommand(VdcActionType.AddVmPoolWithVms);
    parameters.setSoundDeviceEnabled(getParameters().isSoundDeviceEnabled() != null ? getParameters().isSoundDeviceEnabled() : VmType.Desktop == getParameters().getVmStaticData().getVmType());
    parameters.setConsoleEnabled(getParameters().isConsoleEnabled());
    parameters.setVirtioScsiEnabled(getParameters().isVirtioScsiEnabled());
    parameters.setBalloonEnabled(getParameters().isBalloonEnabled());
    VmRngDevice rngDevice = getParameters().getRngDevice();
    if (rngDevice != null) {
        parameters.setUpdateRngDevice(true);
        parameters.setRngDevice(rngDevice);
    }
    parameters.getGraphicsDevices().putAll(getParameters().getGraphicsDevices());
    return parameters;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmIcon entity) {
    return createIdParameterMapper(entity.getId()).addValue(DATA_URL_COLUMN, entity.getDataUrl()).addValue(DEFAULT_FOR_OS_COLUMN, entity.getDefaultForOs());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmIcon entity) {
    return createIdParameterMapper(entity.getId()).addValue(DATA_URL_COLUMN, entity.getDataUrl());
}
#end_block

#method_before
@Override
protected RowMapper<VmIcon> createEntityRowMapper() {
    return new RowMapper<VmIcon>() {

        @Override
        public VmIcon mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmIcon icon = new VmIcon();
            icon.setId(getGuid(rs, ID_COLUMN));
            icon.setDataUrl(rs.getString(DATA_URL_COLUMN));
            icon.setDefaultForOs((Integer) rs.getObject(DEFAULT_FOR_OS_COLUMN));
            return icon;
        }
    };
}
#method_after
@Override
protected RowMapper<VmIcon> createEntityRowMapper() {
    return new RowMapper<VmIcon>() {

        @Override
        public VmIcon mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmIcon icon = new VmIcon();
            icon.setId(getGuid(rs, ID_COLUMN));
            icon.setDataUrl(rs.getString(DATA_URL_COLUMN));
            return icon;
        }
    };
}
#end_block

#method_before
@Override
public Guid ensureIconInDatabase(final String icon) {
    if (icon == null) {
        // $NON-NLS-1$
        throw new IllegalArgumentException("Argument 'icon' should not be null");
    }
    try {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                final VmIcon newIcon = new VmIcon(Guid.newGuid(), icon, null);
                save(newIcon);
                return null;
            }
        });
    } catch (RuntimeException ex) {
    // nothing, icon is already in db
    }
    final List<VmIcon> iconsOfRequiredData = getByDataUrl(icon);
    if (iconsOfRequiredData.size() != 1) {
        throw new VdcBLLException(VdcBllErrors.VM_ICON_NOT_FOUND);
    }
    return iconsOfRequiredData.get(0).getId();
}
#method_after
@Override
public Guid ensureIconInDatabase(final String icon) {
    if (icon == null) {
        throw new IllegalArgumentException("Argument 'icon' should not be null");
    }
    return TransactionSupport.executeInNewTransaction(new TransactionMethod<Guid>() {

        @Override
        public Guid runInTransaction() {
            final List<VmIcon> existingIcons = getByDataUrl(icon);
            if (!existingIcons.isEmpty()) {
                return existingIcons.get(0).getId();
            }
            final VmIcon newIcon = new VmIcon(Guid.newGuid(), icon);
            save(newIcon);
            return newIcon.getId();
        }
    });
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getVerb()) {
        case GetIcons:
            getIcons();
            break;
        case GetDefaultIconsMap:
            getDefaultIconsMap();
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    Map<Guid, String> result = new HashMap<>();
    for (Guid iconId : getParameters().getIconIds()) {
        final VmIcon vmIcon = vmIconDao.get(iconId);
        result.put(iconId, vmIcon.getDataUrl());
    }
    setReturnValue(result);
}
#end_block

#method_before
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue("icon_id", entity.getIconId());
}
#method_after
protected MapSqlParameterSource createBaseParametersMapper(T entity) {
    return createIdParameterMapper(entity.getId()).addValue("description", entity.getDescription()).addValue("free_text_comment", entity.getComment()).addValue("creation_date", entity.getCreationDate()).addValue("mem_size_mb", entity.getMemSizeMb()).addValue("vnc_keyboard_layout", entity.getVncKeyboardLayout()).addValue("tunnel_migration", entity.getTunnelMigration()).addValue("vds_group_id", entity.getVdsGroupId()).addValue("num_of_sockets", entity.getNumOfSockets()).addValue("cpu_per_socket", entity.getCpuPerSocket()).addValue("os", entity.getOsId()).addValue("num_of_monitors", entity.getNumOfMonitors()).addValue("single_qxl_pci", entity.getSingleQxlPci()).addValue("allow_console_reconnect", entity.isAllowConsoleReconnect()).addValue("vm_type", entity.getVmType()).addValue("priority", entity.getPriority()).addValue("auto_startup", entity.isAutoStartup()).addValue("is_stateless", entity.isStateless()).addValue("is_smartcard_enabled", entity.isSmartcardEnabled()).addValue("is_delete_protected", entity.isDeleteProtected()).addValue("sso_method", entity.getSsoMethod().toString()).addValue("iso_path", entity.getIsoPath()).addValue("usb_policy", entity.getUsbPolicy()).addValue("time_zone", entity.getTimeZone()).addValue("fail_back", entity.isFailBack()).addValue("nice_level", entity.getNiceLevel()).addValue("cpu_shares", entity.getCpuShares()).addValue("default_boot_sequence", entity.getDefaultBootSequence()).addValue("default_display_type", entity.getDefaultDisplayType()).addValue("origin", entity.getOrigin()).addValue("initrd_url", entity.getInitrdUrl()).addValue("kernel_url", entity.getKernelUrl()).addValue("kernel_params", entity.getKernelParams()).addValue("quota_id", entity.getQuotaId()).addValue("migration_support", entity.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", entity.getDedicatedVmForVds()).addValue("min_allocated_mem", entity.getMinAllocatedMem()).addValue("is_run_and_pause", entity.isRunAndPause()).addValue("created_by_user_id", entity.getCreatedByUserId()).addValue("migration_downtime", entity.getMigrationDowntime()).addValue("serial_number_policy", entity.getSerialNumberPolicy() == null ? null : entity.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", entity.getCustomSerialNumber()).addValue("is_boot_menu_enabled", entity.isBootMenuEnabled()).addValue("is_spice_file_transfer_enabled", entity.isSpiceFileTransferEnabled()).addValue("is_spice_copy_paste_enabled", entity.isSpiceCopyPasteEnabled()).addValue("cpu_profile_id", entity.getCpuProfileId()).addValue("numatune_mode", entity.getNumaTuneMode().getValue()).addValue("is_auto_converge", entity.getAutoConverge()).addValue("is_migrate_compressed", entity.getMigrateCompressed()).addValue("predefined_properties", entity.getPredefinedProperties()).addValue("userdefined_properties", entity.getUserDefinedProperties()).addValue("custom_emulated_machine", entity.getCustomEmulatedMachine()).addValue("custom_cpu_name", entity.getCustomCpuName()).addValue(SMALL_ICON_ID_COLUMN, entity.getSmallIconId()).addValue(LARGE_ICON_ID_COLUMN, entity.getLargeIconId());
}
#end_block

#method_before
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setIconId(getGuid(rs, "icon_id"));
}
#method_after
protected final void map(final ResultSet rs, final T entity) throws SQLException {
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setOsId(rs.getInt("os"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setDescription(rs.getString("description"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("creation_date")));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setPriority(rs.getInt("priority"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setCreatedByUserId(Guid.createGuidFromString(rs.getString("created_by_user_id")));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setBootMenuEnabled(rs.getBoolean("is_boot_menu_enabled"));
    entity.setSpiceFileTransferEnabled(rs.getBoolean("is_spice_file_transfer_enabled"));
    entity.setSpiceCopyPasteEnabled(rs.getBoolean("is_spice_copy_paste_enabled"));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuProfileId(getGuid(rs, "cpu_profile_id"));
    entity.setNumaTuneMode(NumaTuneMode.forValue(rs.getString("numatune_mode")));
    entity.setAutoConverge((Boolean) rs.getObject("is_auto_converge"));
    entity.setMigrateCompressed((Boolean) rs.getObject("is_migrate_compressed"));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setCustomEmulatedMachine(rs.getString("custom_emulated_machine"));
    entity.setCustomCpuName(rs.getString("custom_cpu_name"));
    entity.setSmallIconId(getGuid(rs, SMALL_ICON_ID_COLUMN));
    entity.setLargeIconId(getGuid(rs, LARGE_ICON_ID_COLUMN));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), getParameters().getGraphicsDevices().keySet(), false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), getParameters().getGraphicsDevices().keySet(), false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
            if (!cinderDisks.isEmpty() && !addVmTemplateCinderDisks(cinderDisks, srcDeviceIdToTargetDeviceIdMapping)) {
                setSucceeded(false);
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            map.put(diskImage, diskImage.getStorageIds().get(0));
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (diskInfoDestinationMap != null && !diskInfoDestinationMap.isEmpty()) {
        Map<DiskImage, Guid> map = new HashMap<>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            if (diskImage.getDiskStorageType() == DiskStorageType.IMAGE) {
                map.put(diskImage, diskImage.getStorageIds().get(0));
            }
        }
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getStoragePool().getCompatibilityVersion(), getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(mImages);
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false, true);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getIconId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getVdsGroupId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVds(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId()));
    DbFacade.getInstance().getVmTemplateDao().save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<DiskImage> diskImages = ImagesHandler.filterImageDisks(mImages, true, false, true);
    for (DiskImage diskImage : diskImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = Backend.getInstance().runInternalAction(VdcActionType.CreateImageTemplate, buildChildCommandParameters(diskImage, Guid.newGuid()), ExecutionHandler.createDefaultContextForTasks(getContext()));
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#end_block

#method_before
private Guid getVmIdFromImageParameters() {
    return ((CreateImageTemplateParameters) getParameters().getImagesParameters().get(0)).getVmId();
}
#method_after
private Guid getVmIdFromImageParameters() {
    return getParameters().getMasterVm().getId();
}
#end_block

#method_before
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmName", getVmName());
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVm().isTrustedService() && !getVmTemplate().isTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVm().isTrustedService() && getVmTemplate().isTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_ADD_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if (getCurrentUser() == null) {
        setCurrentUser(getParameters().getParametersCurrentUser());
    }
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<Permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permissions[permissionsList.size()]));
    }
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if (getCurrentUser() == null) {
        setCurrentUser(getParameters().getParametersCurrentUser());
    }
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<Permission> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new Permission[permissionsList.size()]));
    }
}
#end_block

#method_before
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permissions> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<Permission> vmPermissions = dao.getAllForEntity(getVmId(), getEngineSessionSeqId(), false);
    for (Permission vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getAdElementId(), vmPermission.getRoleId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean isInstanceType = getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE;
    if (getVdsGroup() == null && !isInstanceType) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(getVmTemplate().getId())) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_EDIT_BLANK_TEMPLATE);
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (!isInstanceType && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean canDoAction() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getVdsGroup() == null && !(isInstanceType || isBlankTemplate)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (mOldTemplate == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(mOldTemplate);
    }
    if (!StringUtils.equals(mOldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failCanDoAction(VdcBllMessages.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getCanDoActionMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(mOldTemplate, getVmTemplate());
        if (!returnValue) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getCompatibilityVersion());
    }
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    final Guid oldIconId = updateIcon();
    updateVmTemplate();
    deleteUnusedIcon(oldIconId);
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!isInstanceType() && !isBlankTemplate()) {
        VmHandler.warnMemorySizeLegal(getParameters().getVmTemplateData(), getVdsGroup().getCompatibilityVersion());
    }
    getVmStaticDAO().incrementDbGeneration(getVmTemplate().getId());
    updateOriginalTemplateNameOnDerivedVms();
    List<Guid> oldIconIds = Collections.emptyList();
    if (isTemplate()) {
        oldIconIds = IconUtils.updateVmIcon(mOldTemplate, getVmTemplate(), getParameters().getVmLargeIcon());
    }
    updateVmTemplate();
    IconUtils.removeUnusedIcons(oldIconIds);
    updateWatchdog(getParameters().getVmTemplateData().getId());
    updateRngDevice(getParameters().getVmTemplateData().getId());
    updateGraphicsDevice();
    checkTrustedService();
    updateVmsOfInstanceType();
    setSucceeded(true);
}
#end_block

#method_before
private void updateVmsOfInstanceType() {
    if (getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        return;
    }
    // get vms from db
    List<VM> vmsToUpdate = getVmDAO().getVmsListByInstanceType(getVmTemplateId());
    for (VM vm : vmsToUpdate) {
        VmManagementParametersBase params = new VmManagementParametersBase(vm);
        params.setApplyChangesLater(true);
        runInternalAction(VdcActionType.UpdateVm, params);
    }
}
#method_after
private void updateVmsOfInstanceType() {
    if (!isInstanceType()) {
        return;
    }
    // get vms from db
    List<VM> vmsToUpdate = getVmDAO().getVmsListByInstanceType(getVmTemplateId());
    for (VM vm : vmsToUpdate) {
        VmManagementParametersBase params = new VmManagementParametersBase(vm);
        params.setApplyChangesLater(true);
        runInternalAction(VdcActionType.UpdateVm, params);
    }
}
#end_block

#method_before
private void checkTrustedService() {
    if (getVdsGroup() == null) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        AuditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#method_after
private void checkTrustedService() {
    if (getVdsGroup() == null) {
        return;
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.addCustomValue("VmTemplateName", getVmTemplateName());
    if (getVmTemplate().isTrustedService() && !getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_TRUSTED_TO_UNTRUSTED);
    } else if (!getVmTemplate().isTrustedService() && getVdsGroup().supportsTrustedService()) {
        auditLogDirector.log(logable, AuditLogType.USER_UPDATE_VM_TEMPLATE_FROM_UNTRUSTED_TO_TRUSTED);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null && getVmTemplate().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> permissionList = super.getPermissionCheckSubjects();
    if (getVmTemplate() != null && !isInstanceType() && !isBlankTemplate()) {
        // host-specific parameters can be changed by administration role only
        if (!(getVmTemplate().getDedicatedVmForVds() == null ? getParameters().getVmTemplateData().getDedicatedVmForVds() == null : getVmTemplate().getDedicatedVmForVds().equals(getParameters().getVmTemplateData().getDedicatedVmForVds()))) {
            permissionList.add(new PermissionSubject(getParameters().getVmTemplateId(), VdcObjectType.VmTemplate, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionList;
}
#end_block

#method_before
@Override
protected boolean isQuotaDependant() {
    if (getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return false;
    }
    return super.isQuotaDependant();
}
#method_after
@Override
protected boolean isQuotaDependant() {
    if (isInstanceType() || isBlankTemplate()) {
        return false;
    }
    return super.isQuotaDependant();
}
#end_block

#method_before
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types.
    if (getVmTemplate().getTemplateType() == VmEntityType.INSTANCE_TYPE) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVdsGroup().getCompatibilityVersion()));
}
#method_after
protected boolean setAndValidateCpuProfile() {
    // cpu profile isn't supported for instance types nor for blank template.
    if (isInstanceType() || isBlankTemplate()) {
        return true;
    }
    return validate(CpuProfileHelper.setAndValidateCpuProfile(getVmTemplate(), getVdsGroup().getCompatibilityVersion()));
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    if (volume.getSnapshotScheduled()) {
        SafeHtml geoRepMasterHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(snapshotScheduledImage).getHTML());
        sb.append(applicationTemplates.statusTemplate(geoRepMasterHtml, constants.glusterVolumeSnapshotsScheduledToolTip()));
    }
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb, String id) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    if (volume.getIsGeoRepMaster()) {
        SafeHtml geoRepMasterHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(geoRepMasterImage).getHTML());
        sb.append(applicationTemplates.statusTemplate(geoRepMasterHtml, constants.geoRepMasterVolumeToolTip()));
    }
    if (volume.getIsGeoRepSlave()) {
        SafeHtml geoRepSlaveHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(geoRepSlaveImage).getHTML());
        String[] volClusterNames = formatVolClusterName(volume.getGeoRepMasterVolAndClusterName());
        String volName = volClusterNames[0];
        // $NON-NLS-1$
        String clusterName = volClusterNames.length == 2 ? volClusterNames[1] : "UNKNOWN";
        sb.append(applicationTemplates.statusTemplate(geoRepSlaveHtml, messages.geoRepSlaveVolumeToolTip(volName, clusterName)));
    }
    if (volume.getSnapshotScheduled()) {
        SafeHtml snapshotScheduledHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(snapshotScheduledImage).getHTML());
        sb.append(applicationTemplates.statusTemplate(snapshotScheduledHtml, constants.glusterVolumeSnapshotsScheduledToolTip()));
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new AbstractTextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    AbstractTextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new AbstractTextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeInfoColumn(), constants.volumeInfoVolume(), "100px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu(constants);
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    getTable().addColumn(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    }, constants.volumeCapacity(), // $NON-NLS-1$
    "60px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumnWithTooltip<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeSnapshotMainTabTitle(), getVolumeSnapshotMenu(constants), CommandLocation.ContextAndToolBar));
}
#method_after
void initTable() {
    getTable().enableColumnResizing();
    VolumeStatusColumn statusColumn = new VolumeStatusColumn();
    statusColumn.makeSortable(new Comparator<GlusterVolumeEntity>() {

        @Override
        public int compare(GlusterVolumeEntity o1, GlusterVolumeEntity o2) {
            return GlusterVolumeUtils.getVolumeStatus(o1).ordinal() - GlusterVolumeUtils.getVolumeStatus(o2).ordinal();
        }
    });
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.empty(), "30px");
    AbstractTextColumn<GlusterVolumeEntity> nameColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    nameColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> clusterColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    clusterColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    AbstractTextColumn<GlusterVolumeEntity> volumeTypeColumn = new AbstractEnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    volumeTypeColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeBrickStatusColumn(), constants.bricksStatusVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeInfoColumn(), constants.volumeInfoVolume(), "100px");
    MenuCell<GlusterTaskSupport> rebalanceMenuCell = getRebalanceActivityMenu();
    MenuCell<GlusterTaskSupport> removeBricksMenuCell = getRemoveBrickActivityMenu();
    List<HasCell<GlusterTaskSupport, ?>> list = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    list.add(new VolumeActivityStatusColumn<GlusterTaskSupport>());
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivitySeperatorCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(rebalanceMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    list.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(removeBricksMenuCell) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    List<HasCell<GlusterTaskSupport, ?>> compositeList = new ArrayList<HasCell<GlusterTaskSupport, ?>>();
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeTaskWaitingCell<GlusterTaskSupport>()) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    compositeList.add(new Column<GlusterTaskSupport, GlusterTaskSupport>(new VolumeActivityCompositeCell<GlusterTaskSupport>(list)) {

        @Override
        public GlusterTaskSupport getValue(GlusterTaskSupport object) {
            return object;
        }
    });
    Column<GlusterVolumeEntity, GlusterVolumeEntity> capacityColumn = new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeCapacityCell()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(capacityColumn, constants.volumeCapacity(), "100px");
    getTable().addColumn(new VolumeActivityColumn<GlusterVolumeEntity>(new VolumeActivityCompositeCell<GlusterTaskSupport>(compositeList) {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return !(value == null || value.getAsyncTask() == null);
        }
    }), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    AbstractTextColumn<GlusterVolumeEntity> snapshotCountColumn = new AbstractTextColumn<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getSnapshotsCount().toString();
        }
    };
    snapshotCountColumn.makeSortable();
    // $NON-NLS-1$
    getTable().addColumn(snapshotCountColumn, constants.noOfSnapshotsLabel(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> volumeProfilingActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartVolumeProfilingCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.volumeProfileDetails()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShowVolumeProfileDetailsCommand();
        }
    });
    volumeProfilingActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolumeProfiling()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopVolumeProfilingCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeProfilingAction(), volumeProfilingActions, CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.volumeSnapshotMainTabTitle(), getVolumeSnapshotMenu(), CommandLocation.ContextAndToolBar));
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.geoReplicationMainTabTitle(), getGeoRepCreateMenu(constants), CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
private List<ActionButtonDefinition<GlusterVolumeEntity>> getVolumeSnapshotMenu(ApplicationConstants constants) {
    List<ActionButtonDefinition<GlusterVolumeEntity>> snapshotMenu = new ArrayList<ActionButtonDefinition<GlusterVolumeEntity>>();
    WebAdminButtonDefinition<GlusterVolumeEntity> newSnapshotButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolumeSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    };
    snapshotMenu.add(newSnapshotButton);
    WebAdminButtonDefinition<GlusterVolumeEntity> editSnapshotScheduleButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.editVolumeSnapshotSchedule()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditSnapshotScheduleCommand();
        }
    };
    snapshotMenu.add(editSnapshotScheduleButton);
    WebAdminButtonDefinition<GlusterVolumeEntity> configureClusterSnapshotOptionsButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.configureClusterSnapshotOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureClusterSnapshotOptionsCommand();
        }
    };
    WebAdminButtonDefinition<GlusterVolumeEntity> configureVolumeSnapshotOptionsButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.configureVolumeSnapshotOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureVolumeSnapshotOptionsCommand();
        }
    };
    snapshotMenu.add(configureClusterSnapshotOptionsButton);
    snapshotMenu.add(configureVolumeSnapshotOptionsButton);
    return snapshotMenu;
}
#method_after
private List<ActionButtonDefinition<GlusterVolumeEntity>> getVolumeSnapshotMenu() {
    List<ActionButtonDefinition<GlusterVolumeEntity>> snapshotMenu = new ArrayList<ActionButtonDefinition<GlusterVolumeEntity>>();
    WebAdminButtonDefinition<GlusterVolumeEntity> newSnapshotButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolumeSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    };
    snapshotMenu.add(newSnapshotButton);
    WebAdminButtonDefinition<GlusterVolumeEntity> editSnapshotScheduleButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.editVolumeSnapshotSchedule()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditSnapshotScheduleCommand();
        }
    };
    snapshotMenu.add(editSnapshotScheduleButton);
    WebAdminButtonDefinition<GlusterVolumeEntity> configureClusterSnapshotOptionsButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.configureClusterSnapshotOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureClusterSnapshotOptionsCommand();
        }
    };
    WebAdminButtonDefinition<GlusterVolumeEntity> configureVolumeSnapshotOptionsButton = new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.configureVolumeSnapshotOptions()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConfigureVolumeSnapshotOptionsCommand();
        }
    };
    snapshotMenu.add(configureClusterSnapshotOptionsButton);
    snapshotMenu.add(configureVolumeSnapshotOptionsButton);
    return snapshotMenu;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRemoveBrickActivityMenu() {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REMOVE_BRICK;
        }
    };
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStatus()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStatusRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksStop()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getStopRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.removeBricksCommit()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getCommitRemoveBricksCommand();
        }
    });
    menuCell.addMenuItem(new WebAdminButtonDefinition<GlusterTaskSupport>(constants.retainBricks()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getBrickListModel().getRetainBricksCommand();
        }
    });
    return menuCell;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static double truncatePercentage(double value) {
    return Math.min(100, value);
}
#method_after
private static Double truncatePercentage(Double value) {
    return value == null ? null : Math.min(100, value);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            String networkName = entry.getKey();
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                VdsNetworkInterface networkIface = vdsInterfaces.get(interfaceName);
                Map<String, Object> bridge = (bridges == null) ? null : (Map<String, Object>) bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                Map<String, Object> effectiveBridge = (bridgesReported && bridgedNetwork && bridge != null) ? bridge : network;
                String addr = extractAddress(effectiveBridge);
                String subnet = extractSubnet(effectiveBridge);
                String gateway = (String) effectiveBridge.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vdsInterfaces, bridgesReported, networkIface, bridgesReported ? bridge : network);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveBridge, vds, iface);
                    }
                }
                vds.getNetworks().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> network = entry.getValue();
            String networkName = entry.getKey();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                Map<String, Object> bridgeProperties = (bridges == null) ? null : bridges.get(interfaceName);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                /**
                 * TODO: remove overly-defensive code in 4.0 - IP address, subnet, gateway and boot protocol should
                 * only be extracted for bridged networks and from bridge entries (not network entries)
                 */
                Map<String, Object> effectiveProperties = (bridgesReported && bridgedNetwork && bridgeProperties != null) ? bridgeProperties : network;
                String addr = extractAddress(effectiveProperties);
                String subnet = extractSubnet(effectiveProperties);
                String gateway = (String) effectiveProperties.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridgeProperties) : findBridgedNetworkInterfaces(network, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(effectiveProperties, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, boolean bridgesReported, VdsNetworkInterface iface, Map<String, Object> entry) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (bridgesReported) {
        if (iface == null) {
            if (entry != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
            }
        } else {
            interfaces.add(iface);
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(entry, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Object> bridgeProperties) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridgeProperties != null) {
            interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Object bondOptions = null;
                if (FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion())) {
                    bondOptions = bond.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    iface.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    bondOptions = bond.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    iface.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nic = (Map<String, Object>) entry.getValue();
            if (nic != null) {
                if (nic.get("speed") != null) {
                    Object speed = nic.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nic.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nic.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS vds, Entry<String, Object> entry) {
    iface.setName(entry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(vds.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(vds.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nic = (Map<String, Object>) entry.getValue();
    if (nic != null) {
        iface.setAddress(extractAddress(nic));
        iface.setSubnet(extractSubnet(nic));
        String mtu = (String) nic.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol(nic, vds, iface);
    }
}
#method_after
private static void updateCommonInterfaceData(VdsNetworkInterface iface, VDS host, Entry<String, Map<String, Object>> ifaceEntry) {
    iface.setName(ifaceEntry.getKey());
    iface.setId(Guid.newGuid());
    iface.setVdsId(host.getId());
    VdsNetworkStatistics iStats = new VdsNetworkStatistics();
    iStats.setId(iface.getId());
    iStats.setVdsId(host.getId());
    iface.setStatistics(iStats);
    Map<String, Object> nicProperties = ifaceEntry.getValue();
    if (nicProperties != null) {
        iface.setAddress(extractAddress(nicProperties));
        iface.setSubnet(extractSubnet(nicProperties));
        String mtu = (String) nicProperties.get(VdsProperties.MTU);
        if (StringUtils.isNotBlank(mtu)) {
            iface.setMtu(Integer.parseInt(mtu));
        }
        addBootProtocol(nicProperties, host, iface);
    }
}
#end_block

#method_before
private static String extractAddress(Map<String, Object> nic) {
    return (String) nic.get("addr");
}
#method_after
private static String extractAddress(Map<String, Object> properties) {
    return (String) properties.get("addr");
}
#end_block

#method_before
private static String extractSubnet(Map<String, Object> nic) {
    return (String) nic.get("netmask");
}
#method_after
private static String extractSubnet(Map<String, Object> properties) {
    return (String) properties.get("netmask");
}
#end_block

#method_before
public static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
public static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(remoteUserName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepKeysUpdate(userName, geoRepPubKeys);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(remoteUserName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterGeoRepMountBrokerSetup(userName, remoteGroupName, remoteVolumeName);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String remoteUserName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, remoteUserName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionCreate(volumeName, remoteHost, remoteVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeGeoRepSessionResume(volumeName, slaveHostName, slaveVolumeName, userName, force);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionPause(masterVolumeName, slaveHost, slaveVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStart(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response;
        response = vdsServer.glusterVolumeGeoRepSessionList(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        Map<String, Object> response = vdsServer.glusterVolumeGeoRepSessionStatus(volumeName, slaveHost, slaveVolumeName, userName);
        return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionDelete(volumeName, remoteHost, remoteVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepSessionStop(volumeName, remoteHost, remoteVolumeName, userName, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigSet(volumeName, slaveHost, slaveVolumeName, configKey, configValue, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeGeoRepConfigReset(volumeName, slaveHost, slaveVolumeName, configKey, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    try {
        return new GlusterVolumeGeoRepConfigListXmlRpc(vdsServer.glusterVolumeGeoRepConfigList(volumeName, slaveHost, slaveVolumeName, userName));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> getEligibilityPredicates(final GlusterVolumeEntity masterVolume) {
    Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> eligibilityPredicates = new HashMap<>();
    final List<Guid> existingSessionSlavesIds = getSessionSlaveVolumeIds();
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_BE_UP, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getStatus() == GlusterStatus.UP;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_AND_MASTER_VOLUMES_SHOULD_NOT_BE_IN_SAME_CLUSTER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !masterVolume.getClusterId().equals(slaveVolume.getClusterId());
        }
    });
    final Predicate<GlusterVolumeEntity> nonNullSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullSlaveSizePredicate);
    final Predicate<GlusterVolumeEntity> nonNullMasterSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return masterVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.MASTER_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullMasterSizePredicate);
    Predicate<GlusterVolumeEntity> masterSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            boolean eligible = nonNullSlaveSizePredicate.eval(slaveVolume) && nonNullMasterSizePredicate.eval(masterVolume);
            if (eligible) {
                eligible = slaveVolume.getAdvancedDetails().getCapacityInfo().getTotalSize() >= masterVolume.getAdvancedDetails().getCapacityInfo().getTotalSize();
            }
            return eligible;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_SHOULD_BE_GREATER_THAN_MASTER_VOLUME_SIZE, masterSlaveSizePredicate);
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_NOT_BE_SLAVE_OF_ANOTHER_GEO_REP_SESSION, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !existingSessionSlavesIds.contains(slaveVolume.getId());
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_CLUSTER_AND_MASTER_CLUSTER_COMPATIBILITY_VERSIONS_DO_NOT_MATCH, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            VdsGroupDAO vdsGroupDao = getVdsGroupDao();
            Version slaveCompatibilityVersion = vdsGroupDao.get(slaveVolume.getClusterId()).getCompatibilityVersion();
            Version masterCompatibilityVersion = vdsGroupDao.get(masterVolume.getClusterId()).getCompatibilityVersion();
            return masterCompatibilityVersion.equals(slaveCompatibilityVersion);
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_TO_BE_EMPTY, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CheckEmptyGlusterVolume, new GlusterVolumeVDSParameters(ClusterUtils.getInstance().getRandomUpServer(slaveVolume.getClusterId()).getId(), slaveVolume.getName()));
            if (!returnValue.getSucceeded()) {
                return false;
            }
            return (boolean) returnValue.getReturnValue();
        }
    });
    return eligibilityPredicates;
}
#method_after
public Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> getEligibilityPredicates(final GlusterVolumeEntity masterVolume) {
    Map<GlusterGeoRepNonEligibilityReason, Predicate<GlusterVolumeEntity>> eligibilityPredicates = new HashMap<>();
    final List<Guid> existingSessionSlavesIds = getSessionSlaveVolumeIds();
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_BE_UP, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getStatus() == GlusterStatus.UP;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_AND_MASTER_VOLUMES_SHOULD_NOT_BE_IN_SAME_CLUSTER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !masterVolume.getClusterId().equals(slaveVolume.getClusterId());
        }
    });
    final Predicate<GlusterVolumeEntity> nonNullSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return slaveVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullSlaveSizePredicate);
    final Predicate<GlusterVolumeEntity> nonNullMasterSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return masterVolume.getAdvancedDetails().getCapacityInfo() != null;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.MASTER_VOLUME_SIZE_TO_BE_AVAILABLE, nonNullMasterSizePredicate);
    Predicate<GlusterVolumeEntity> masterSlaveSizePredicate = new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            boolean eligible = nonNullSlaveSizePredicate.eval(slaveVolume) && nonNullMasterSizePredicate.eval(masterVolume);
            if (eligible) {
                eligible = slaveVolume.getAdvancedDetails().getCapacityInfo().getTotalSize() >= masterVolume.getAdvancedDetails().getCapacityInfo().getTotalSize();
            }
            return eligible;
        }
    };
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SIZE_SHOULD_BE_GREATER_THAN_MASTER_VOLUME_SIZE, masterSlaveSizePredicate);
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_SHOULD_NOT_BE_SLAVE_OF_ANOTHER_GEO_REP_SESSION, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            return !existingSessionSlavesIds.contains(slaveVolume.getId());
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_CLUSTER_AND_MASTER_CLUSTER_COMPATIBILITY_VERSIONS_DO_NOT_MATCH, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            VdsGroupDAO vdsGroupDao = getVdsGroupDao();
            Version slaveCompatibilityVersion = vdsGroupDao.get(slaveVolume.getClusterId()).getCompatibilityVersion();
            Version masterCompatibilityVersion = vdsGroupDao.get(masterVolume.getClusterId()).getCompatibilityVersion();
            return masterCompatibilityVersion.equals(slaveCompatibilityVersion);
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.NO_UP_SLAVE_SERVER, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            Guid slaveUpserverId = getUpServerId(slaveVolume.getClusterId());
            if (slaveUpserverId == null) {
                return false;
            }
            return true;
        }
    });
    eligibilityPredicates.put(GlusterGeoRepNonEligibilityReason.SLAVE_VOLUME_TO_BE_EMPTY, new Predicate<GlusterVolumeEntity>() {

        @Override
        public boolean eval(GlusterVolumeEntity slaveVolume) {
            Guid slaveUpserverId = getUpServerId(slaveVolume.getClusterId());
            if (slaveUpserverId == null) {
                return false;
            }
            return checkEmptyGlusterVolume(slaveUpserverId, slaveVolume.getName());
        }
    });
    return eligibilityPredicates;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String remoteUserName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String remoteUserName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", remoteUserName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String remoteUserName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", remoteUserName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (obj.getClass() != this.getClass()) {
        return false;
    }
    EngineBackupLog other = (EngineBackupLog) obj;
    return (Objects.equals(dbName, other.dbName) && Objects.equals(doneAt, other.doneAt) && this.passed == other.passed && Objects.equals(outputMessage, other.outputMessage));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (!(obj instanceof EngineBackupLog)) {
        return false;
    }
    EngineBackupLog other = (EngineBackupLog) obj;
    return (Objects.equals(dbName, other.dbName) && Objects.equals(doneAt, other.doneAt) && this.passed == other.passed && Objects.equals(outputMessage, other.outputMessage));
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    EngineBackupLog other = (EngineBackupLog) obj;
    return (dbName.equals(other.getDbName()) && doneAt.equals(other.getDoneAt()));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (!(obj instanceof EngineBackupLogId)) {
        return false;
    }
    EngineBackupLogId other = (EngineBackupLogId) obj;
    return (dbName.equals(other.getDbName()) && doneAt.equals(other.getDoneAt()));
}
#end_block

#method_before
@Override
public EngineBackupLog getLastSuccessfulEngineBackup(String dbName) {
    List<EngineBackupLog> logs = multipleResults(entityManager.createNamedQuery("EngineBackupLog.getLatest", EngineBackupLog.class).setParameter("dbName", dbName));
    if (logs != null && logs.size() > 0) {
        return logs.get(0);
    } else {
        return null;
    }
}
#method_after
@Override
public EngineBackupLog getLastSuccessfulEngineBackup(String dbName) {
    TypedQuery<EngineBackupLog> query = entityManager.createNamedQuery("EngineBackupLog.getLatest", EngineBackupLog.class).setParameter("dbName", dbName).setMaxResults(1);
    return singleResult(query);
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getEngineBackupLogDao();
    existingEngineBackupLog = dao.getLastSuccessfulEngineBackup(DB_NAME);
    newEntity = new EngineBackupLog();
    newEntity.setDbName("asd");
    newEntity.setOutputMessage("asd");
    newEntity.setDoneAt(new Date());
    newEntity.setPassed(true);
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getEngineBackupLogDao();
    existingEngineBackupLog = dao.getLastSuccessfulEngineBackup(DB_NAME);
    newEntity = new EngineBackupLog();
    newEntity.setDbName(RandomUtils.instance().nextString(20));
    newEntity.setOutputMessage(RandomUtils.instance().nextString(20));
    newEntity.setDoneAt(new Date());
    newEntity.setPassed(true);
}
#end_block

#method_before
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setmaster_domain_version(masterVersion);
    }
    return sPool;
}
#method_after
public static StoragePool buildStoragePool(Map<String, Object> xmlRpcStruct) {
    StoragePool sPool = new StoragePool();
    if (xmlRpcStruct.containsKey("type")) {
        sPool.setIsLocal(StorageType.valueOf(xmlRpcStruct.get("type").toString()).isLocal());
    }
    sPool.setName(AssignStringValue(xmlRpcStruct, "name"));
    Integer masterVersion = AssignIntValue(xmlRpcStruct, "master_ver");
    if (masterVersion != null) {
        sPool.setMasterDomainVersion(masterVersion);
    }
    return sPool;
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        } else {
            vm.setGuestMemoryBuffered(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        } else {
            vm.setGuestMemoryCached(null);
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        } else {
            vm.setGuestMemoryFree(null);
        }
    } else {
        vm.setGuestMemoryBuffered(null);
        vm.setGuestMemoryCached(null);
        vm.setGuestMemoryFree(null);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(AssignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
}
#end_block

#method_before
private static void updateGraphicsInfoFromConf(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    DisplayType displayType = parseDisplayType(xmlRpcStruct);
    if (displayType == null) {
        log.warn("Can't set display type from XML.");
        return;
    }
    vm.setDisplayType(displayType);
    GraphicsType vmGraphicsType = (displayType == DisplayType.qxl) ? GraphicsType.SPICE : GraphicsType.VNC;
    GraphicsInfo graphicsInfo = vm.getGraphicsInfos().get(vmGraphicsType);
    if (graphicsInfo != null) {
        if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
            try {
                graphicsInfo.setPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
            } catch (NumberFormatException e) {
                log.error("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
            }
        } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
            try {
                graphicsInfo.setPort(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
            } catch (NumberFormatException e) {
                log.error("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
            }
        }
        if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
            try {
                graphicsInfo.setTlsPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
            } catch (NumberFormatException e) {
                log.error("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
            }
        }
        if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
            graphicsInfo.setIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
        }
    }
}
#method_after
private static void updateGraphicsInfoFromConf(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    GraphicsType vmGraphicsType = parseGraphicsType(xmlRpcStruct);
    if (vmGraphicsType == null) {
        log.warn("Can't set graphics data from XML.");
        return;
    }
    GraphicsInfo graphicsInfo = new GraphicsInfo();
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            graphicsInfo.setPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            graphicsInfo.setPort(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            graphicsInfo.setTlsPort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.error("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        graphicsInfo.setIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    vm.getGraphicsInfos().put(vmGraphicsType, graphicsInfo);
}
#end_block

#method_before
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            Double rx_rate = AssignDoubleValue(nic, VdsProperties.rx_rate);
            Double rx_dropped = AssignDoubleValue(nic, VdsProperties.rx_dropped);
            Double tx_rate = AssignDoubleValue(nic, VdsProperties.tx_rate);
            Double tx_dropped = AssignDoubleValue(nic, VdsProperties.tx_dropped);
            stats.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
            stats.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
            stats.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
            stats.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
            stats.setSpeed(AssignIntValue(nic, VdsProperties.INTERFACE_SPEED));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#method_after
public static void updateVMStatisticsData(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    vm.setelapsed_time(AssignDoubleValue(xmlRpcStruct, VdsProperties.elapsed_time));
    // ------------- vm network statistics -----------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NETWORK)) {
        Map networkStruct = (Map) xmlRpcStruct.get(VdsProperties.VM_NETWORK);
        vm.setInterfaceStatistics(new ArrayList<VmNetworkInterface>());
        for (Object tempNic : networkStruct.values()) {
            Map nic = (Map) tempNic;
            VmNetworkInterface stats = new VmNetworkInterface();
            vm.getInterfaceStatistics().add(stats);
            if (nic.containsKey(VdsProperties.VM_INTERFACE_NAME)) {
                stats.setName((String) ((nic.get(VdsProperties.VM_INTERFACE_NAME) instanceof String) ? nic.get(VdsProperties.VM_INTERFACE_NAME) : null));
            }
            extractInterfaceStatistics(nic, stats);
            stats.setMacAddress((String) ((nic.get(VdsProperties.MAC_ADDR) instanceof String) ? nic.get(VdsProperties.MAC_ADDR) : null));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_DISKS_USAGE)) {
        initDisksUsage(xmlRpcStruct, vm);
    }
    // ------------- vm cpu statistics -----------------------
    vm.setcpu_sys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vm.setcpu_user(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    // ------------- vm memory statistics -----------------------
    vm.setusage_mem_percent(AssignIntValue(xmlRpcStruct, VdsProperties.vm_usage_mem_percent));
    vm.setVmBalloonInfo(getBalloonInfo(xmlRpcStruct));
    // ------------- vm migration statistics -----------------------
    Integer migrationProgress = AssignIntValue(xmlRpcStruct, VdsProperties.vm_migration_progress_percent);
    vm.setMigrationProgressPercent(migrationProgress != null ? migrationProgress : 0);
    // ------------- vm jobs -------------
    vm.setVmJobs(getVmJobs(vm.getId(), xmlRpcStruct));
    // ------------- vm numa nodes runtime info -------------------------
    if (xmlRpcStruct.containsKey(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO)) {
        updateVmNumaNodesRuntimeInfo(vm, xmlRpcStruct);
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                AuditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = AssignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface iface = nicsByName.get(entry.getKey());
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(iface) && !iface.isBondSlave()) {
                    networkUsage = (int) Math.max(networkUsage, computeInterfaceUsage(iface));
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(vds.getInterfaces());
        NetworkStatisticsBuilder statsBuilder = new NetworkStatisticsBuilder(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            if (nicsByName.containsKey(entry.getKey())) {
                VdsNetworkInterface existingIface = nicsByName.get(entry.getKey());
                existingIface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                VdsNetworkInterface reportedIface = new VdsNetworkInterface();
                extractInterfaceStatistics(dict, reportedIface);
                statsBuilder.updateExistingInterfaceStatistics(existingIface, reportedIface);
                existingIface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                if (!NetworkUtils.isVlan(existingIface) && !existingIface.isBondSlave()) {
                    Double ifaceUsage = computeInterfaceUsage(existingIface);
                    if (ifaceUsage != null) {
                        networkUsage = (int) Math.max(networkUsage, ifaceUsage);
                    }
                }
            }
        }
        vds.setUsageNetworkPercent(networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    Integer inOutMigrations;
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.INCOMING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setIncomingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setIncomingMigrations(-1);
    }
    inOutMigrations = AssignIntValue(xmlRpcStruct, VdsProperties.OUTGOING_VM_MIGRATIONS);
    if (inOutMigrations != null) {
        vds.setOutgoingMigrations(inOutMigrations);
    } else {
        // TODO remove in 4.x when all hosts will send in/out migrations separately
        vds.setOutgoingMigrations(-1);
    }
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
    updateNumaStatisticsData(vds, xmlRpcStruct);
}
#end_block

#method_before
private static double computeInterfaceUsage(VdsNetworkInterface iface) {
    return Math.max(truncatePercentage(iface.getStatistics().getReceiveRate()), truncatePercentage(iface.getStatistics().getTransmitRate()));
}
#method_after
private static Double computeInterfaceUsage(VdsNetworkInterface iface) {
    Double receiveRate = truncatePercentage(iface.getStatistics().getReceiveRate());
    Double transmitRate = truncatePercentage(iface.getStatistics().getTransmitRate());
    if (receiveRate == null) {
        return transmitRate;
    } else if (transmitRate == null) {
        return receiveRate;
    } else {
        return Math.max(receiveRate, transmitRate);
    }
}
#end_block

#method_before
private static double truncatePercentage(double value) {
    return Math.min(100, value);
}
#method_after
private static Double truncatePercentage(Double value) {
    return value == null ? null : Math.min(100, value);
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode node = buildVdsNumaNodeStatistics(percentageFormatter, item);
            vdsNumaNodes.add(node);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(AssignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(AssignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#method_after
private static void updateVDSDomainData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.domains)) {
        Map<String, Object> domains = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.domains);
        ArrayList<VDSDomainsData> domainsData = new ArrayList<VDSDomainsData>();
        for (Map.Entry<String, ?> value : domains.entrySet()) {
            try {
                VDSDomainsData data = new VDSDomainsData();
                data.setDomainId(new Guid(value.getKey().toString()));
                Map<String, Object> internalValue = (Map<String, Object>) value.getValue();
                double lastCheck = 0;
                data.setCode((Integer) (internalValue).get(VdsProperties.code));
                if (internalValue.containsKey(VdsProperties.lastCheck)) {
                    lastCheck = Double.parseDouble((String) internalValue.get(VdsProperties.lastCheck));
                }
                data.setLastCheck(lastCheck);
                double delay = 0;
                if (internalValue.containsKey(VdsProperties.delay)) {
                    delay = Double.parseDouble((String) internalValue.get(VdsProperties.delay));
                }
                data.setDelay(delay);
                Boolean actual = Boolean.TRUE;
                if (internalValue.containsKey(VdsProperties.actual)) {
                    actual = (Boolean) internalValue.get(VdsProperties.actual);
                }
                data.setActual(actual);
                domainsData.add(data);
            } catch (Exception e) {
                log.error("failed building domains: {}", e.getMessage());
                log.debug("Exception", e);
            }
        }
        vds.setDomains(domainsData);
    }
}
#end_block

#method_before
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Double returnValue = null;
    if (input.containsKey(name)) {
        String stringValue = (String) ((input.get(name) instanceof String) ? input.get(name) : null);
        returnValue = (stringValue == null) ? null : Double.parseDouble(stringValue);
    }
    return returnValue;
}
#method_after
private static Double AssignDoubleValue(Map<String, Object> input, String name) {
    Object value = input.get(name);
    if (value instanceof Double) {
        return (Double) value;
    } else if (value instanceof String) {
        return Double.parseDouble((String) value);
    }
    return null;
}
#end_block

#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Map<String, Object>> networks = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    Map<String, Map<String, Object>> bridges = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    boolean bridgesReported = FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion());
    if (networks != null) {
        vds.getNetworkNames().clear();
        for (Entry<String, Map<String, Object>> entry : networks.entrySet()) {
            Map<String, Object> network = entry.getValue();
            String networkName = entry.getKey();
            if (network != null) {
                String interfaceName = (String) network.get(VdsProperties.INTERFACE);
                boolean bridgedNetwork = isBridgedNetwork(network);
                HostNetworkQos qos = new HostNetworkQosMapper(network).deserialize();
                String addr = extractAddress(network);
                String subnet = extractSubnet(network);
                String gateway = (String) network.get(VdsProperties.GLOBAL_GATEWAY);
                List<VdsNetworkInterface> interfaces = bridgesReported ? findNetworkInterfaces(vdsInterfaces, interfaceName, bridges) : findBridgedNetworkInterfaces(network, vdsInterfaces);
                for (VdsNetworkInterface iface : interfaces) {
                    iface.setNetworkName(networkName);
                    iface.setAddress(addr);
                    iface.setSubnet(subnet);
                    iface.setBridged(bridgedNetwork);
                    iface.setQos(qos);
                    // set the management ip
                    if (getManagementNetworkUtil().isManagementNetwork(iface.getNetworkName(), vds.getVdsGroupId())) {
                        iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
                    }
                    setGatewayIfNecessary(iface, vds, gateway);
                    if (bridgedNetwork) {
                        addBootProtocol(network, vds, iface);
                    }
                }
                vds.getNetworkNames().add(networkName);
                reportInvalidInterfacesForNetwork(interfaces, networkName, vds);
            }
        }
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, String networkName, VDS vds) {
    if (interfaces.isEmpty()) {
        auditLogDirector.log(createHostNetworkAuditLog(networkName, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(networkName, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        auditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(Network network, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", network.getName());
    return logable;
}
#method_after
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static List<VdsNetworkInterface> findNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct, Map<String, Object> network) {
    Map<String, VdsNetworkInterface> vdsInterfaces = Entities.entitiesByName(vds.getInterfaces());
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    if (FeatureSupported.bridgesReportByVdsm(vds.getVdsGroupCompatibilityVersion())) {
        VdsNetworkInterface iface = null;
        String interfaceName = (String) network.get(VdsProperties.INTERFACE);
        if (interfaceName != null) {
            iface = vdsInterfaces.get(interfaceName);
            if (iface == null) {
                Map<String, Object> bridges = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BRIDGES);
                if (bridges != null && bridges.containsKey(interfaceName)) {
                    interfaces.addAll(findBridgedNetworkInterfaces((Map<String, Object>) bridges.get(interfaceName), vdsInterfaces));
                }
            } else {
                interfaces.add(iface);
            }
        }
    } else {
        interfaces.addAll(findBridgedNetworkInterfaces(network, vdsInterfaces));
    }
    return interfaces;
}
#method_after
private static List<VdsNetworkInterface> findNetworkInterfaces(Map<String, VdsNetworkInterface> vdsInterfaces, String interfaceName, Map<String, Map<String, Object>> bridges) {
    List<VdsNetworkInterface> interfaces = new ArrayList<VdsNetworkInterface>();
    VdsNetworkInterface iface = vdsInterfaces.get(interfaceName);
    if (iface == null) {
        if (bridges != null) {
            Map<String, Object> bridgeProperties = bridges.get(interfaceName);
            if (bridgeProperties != null) {
                interfaces.addAll(findBridgedNetworkInterfaces(bridgeProperties, vdsInterfaces));
            }
        }
    } else {
        interfaces.add(iface);
    }
    return interfaces;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> bonds = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Object> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iStats.setVdsId(vds.getId());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            iface.setBonded(true);
            Map<String, Object> bond = (Map<String, Object>) entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                iface.setAddress((String) bond.get("addr"));
                iface.setSubnet((String) bond.get("netmask"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                if (StringUtils.isNotBlank((String) bond.get(VdsProperties.MTU))) {
                    iface.setMtu(Integer.parseInt((String) bond.get(VdsProperties.MTU)));
                }
                Object bondOptions = null;
                if (FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion())) {
                    bondOptions = bond.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                iface.setBondOptions(bondOptions == null ? null : bondOptions.toString());
                addBootProtocol(bond, vds, iface);
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        boolean cfgEntriesDeprecated = FeatureSupported.cfgEntriesDeprecated(vds.getVdsGroupCompatibilityVersion());
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface iface = new Bond();
            updateCommonInterfaceData(iface, vds, entry);
            iface.setBonded(true);
            Map<String, Object> bond = entry.getValue();
            if (bond != null) {
                iface.setMacAddress((String) bond.get("hwaddr"));
                if (bond.get("slaves") != null) {
                    addBondDeviceToHost(vds, iface, (Object[]) bond.get("slaves"));
                }
                Object bondOptions = null;
                if (cfgEntriesDeprecated) {
                    bondOptions = bond.get("opts");
                } else {
                    Map<String, Object> config = (Map<String, Object>) bond.get("cfg");
                    bondOptions = (config == null) ? null : config.get("BONDING_OPTS");
                }
                if (bondOptions != null) {
                    iface.setBondOptions(bondOptions.toString());
                }
            }
        }
    }
}
#end_block

#method_before
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Object> vlans = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Object> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            String vlanDeviceName = entry.getKey();
            iface.setName(vlanDeviceName);
            iface.setVdsId(vds.getId());
            Map<String, Object> vlan = (Map<String, Object>) entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            iface.setAddress((String) vlan.get("addr"));
            iface.setSubnet((String) vlan.get("netmask"));
            if (StringUtils.isNotBlank((String) vlan.get(VdsProperties.MTU))) {
                iface.setMtu(Integer.parseInt((String) vlan.get(VdsProperties.MTU)));
            }
            iStats.setVdsId(vds.getId());
            addBootProtocol(vlan, vds, iface);
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostVlanDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    // vlans
    Map<String, Map<String, Object>> vlans = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_VLANS);
    if (vlans != null) {
        for (Entry<String, Map<String, Object>> entry : vlans.entrySet()) {
            VdsNetworkInterface iface = new Vlan();
            updateCommonInterfaceData(iface, vds, entry);
            String vlanDeviceName = entry.getKey();
            Map<String, Object> vlan = entry.getValue();
            if (vlan.get(VdsProperties.VLAN_ID) != null && vlan.get(VdsProperties.BASE_INTERFACE) != null) {
                iface.setVlanId((Integer) vlan.get(VdsProperties.VLAN_ID));
                iface.setBaseInterface((String) vlan.get(VdsProperties.BASE_INTERFACE));
            } else if (vlanDeviceName.contains(".")) {
                String[] names = vlanDeviceName.split("[.]", -1);
                String vlanId = names[1];
                iface.setVlanId(Integer.parseInt(vlanId));
                iface.setBaseInterface(names[0]);
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Object> nics = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Object> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new VdsNetworkInterface();
            VdsNetworkStatistics iStats = new VdsNetworkStatistics();
            iface.setStatistics(iStats);
            iStats.setId(Guid.newGuid());
            iface.setId(iStats.getId());
            iface.setName(entry.getKey());
            iface.setVdsId(vds.getId());
            updateNetworkInterfaceDataFromHost(iface, vds, (Map<String, Object>) entry.getValue());
            iStats.setVdsId(vds.getId());
            vds.getInterfaces().add(iface);
        }
    }
}
#method_after
private static void addHostNetworkInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> nics = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_NICS);
    if (nics != null) {
        for (Entry<String, Map<String, Object>> entry : nics.entrySet()) {
            VdsNetworkInterface iface = new Nic();
            updateCommonInterfaceData(iface, vds, entry);
            Map<String, Object> nicProperties = entry.getValue();
            if (nicProperties != null) {
                if (nicProperties.get("speed") != null) {
                    Object speed = nicProperties.get("speed");
                    iface.setSpeed((Integer) speed);
                }
                iface.setMacAddress((String) nicProperties.get("hwaddr"));
                // if we get "permhwaddr", we are a part of a bond and we use that as the mac address
                String mac = (String) nicProperties.get("permhwaddr");
                if (mac != null) {
                    // TODO remove when the minimal supported vdsm version is >=3.6
                    // in older VDSM version, slave's Mac is in upper case
                    iface.setMacAddress(mac.toLowerCase());
                }
            }
            vds.getInterfaces().add(iface);
        }
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> entry, VDS host, VdsNetworkInterface iface) {
    boolean cfgDeprecated = FeatureSupported.cfgEntriesDeprecated(host.getVdsGroupCompatibilityVersion());
    if (!cfgDeprecated) {
        entry = (Map<String, Object>) entry.get("cfg");
        if (entry == null) {
            return;
        }
    }
    String bootProtocolKey = cfgDeprecated ? "bootproto4" : "BOOTPROTO";
    String ipAddressKey = cfgDeprecated ? "addr" : "IPADDR";
    String gatewayKey = cfgDeprecated ? VdsProperties.GLOBAL_GATEWAY : VdsProperties.GATEWAY;
    NetworkBootProtocol bootproto = NetworkBootProtocol.NONE;
    String bootProtocol = (String) entry.get(bootProtocolKey);
    if (bootProtocol != null) {
        if (bootProtocol.toLowerCase().equals("dhcp")) {
            bootproto = NetworkBootProtocol.DHCP;
        } else if (bootProtocol.toLowerCase().equals("none") || bootProtocol.toLowerCase().equals("static")) {
            if (StringUtils.isNotEmpty((String) entry.get(ipAddressKey))) {
                bootproto = NetworkBootProtocol.STATIC_IP;
            }
        }
    } else if (StringUtils.isNotEmpty((String) entry.get(ipAddressKey))) {
        bootproto = NetworkBootProtocol.STATIC_IP;
    }
    if (bootproto == NetworkBootProtocol.STATIC_IP) {
        String gateway = (String) entry.get(gatewayKey);
        if (StringUtils.isNotEmpty(gateway)) {
            setGatewayIfNecessary(iface, host, gateway.toString());
        }
    }
    iface.setBootProtocol(bootproto);
}
#method_after
private static void addBootProtocol(Map<String, Object> entry, VDS host, VdsNetworkInterface iface) {
    BootProtocolResolver resolver = FeatureSupported.cfgEntriesDeprecated(host.getVdsGroupCompatibilityVersion()) ? new NoCfgBootProtocolResolver(entry, iface, host) : new CfgBootProtocolResolver(entry, iface, host);
    resolver.resolve();
}
#end_block

#method_before
private static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || NetworkUtils.getEngineNetwork().equals(iface.getNetworkName()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#method_after
public static void setGatewayIfNecessary(VdsNetworkInterface iface, VDS host, String gateway) {
    final ManagementNetworkUtil managementNetworkUtil = getManagementNetworkUtil();
    if (FeatureSupported.multipleGatewaysSupported(host.getVdsGroupCompatibilityVersion()) || managementNetworkUtil.isManagementNetwork(iface.getNetworkName(), host.getVdsGroupId()) || iface.getName().equals(host.getActiveNic())) {
        iface.setGateway(gateway);
    }
}
#end_block

#method_before
public ValidationResult validateCinderDisksAlreadyRegistered() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            for (CinderDisk disk : cinderDisks) {
                OpenStackVolumeProviderProxy proxy = diskProxyMap.get(disk.getId());
                Volume volume = proxy.getVolumeById(disk.getId().toString());
                if (getDiskDao().get(disk.getId()) != null) {
                    return new ValidationResult(VdcBllMessages.CINDER_DISK_ALREADY_REGISTERED, String.format("$diskAlias %s", volume.getName()));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#method_after
public ValidationResult validateCinderDisksAlreadyRegistered() {
    return validate(new Callable<ValidationResult>() {

        @Override
        public ValidationResult call() {
            for (CinderDisk disk : cinderDisks) {
                Disk diskFromDB = getDiskDao().get(disk.getId());
                if (diskFromDB != null) {
                    return new ValidationResult(VdcBllMessages.CINDER_DISK_ALREADY_REGISTERED, String.format("$diskAlias %s", diskFromDB.getDiskAlias()));
                }
            }
            return ValidationResult.VALID;
        }
    });
}
#end_block

#method_before
private void showNewDialog() {
    final AbstractDiskModel model = new NewDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // the "new" turns into "edit" - no need for attach anymore
                attachCommand.setIsAvailable(false);
                fillData();
                if (getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
                    ((DiskImage) getDisk()).setActive(true);
                }
            }
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }
    };
    VM vm = new VM();
    vm.setVdsGroupId(parentModel.getUnitVmModel().getSelectedCluster().getId());
    vm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
    vm.setVdsGroupCompatibilityVersion(parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion());
    model.setVm(vm);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().newVirtualDiskTitle(), HelpTag.new_virtual_disk, // $NON-NLS-1$
    "new_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    if (getVm() != null) {
        model.setVm(getVm());
        ((NewDiskModel) model).updateSuggestedDiskAliasFromServer();
    } else {
        String currentVmName = parentModel.getUnitVmModel().getName().getEntity();
        if (!StringUtils.isEmpty(currentVmName)) {
            // if already set the VM name on the new VM dialog, suggest the name according to the name
            model.getAlias().setEntity(suggestAliasForNewVm(currentVmName));
        }
    }
}
#method_after
private void showNewDialog() {
    final AbstractDiskModel model = new NewDiskModel() {

        @Override
        public void onSave() {
            if (validate()) {
                flush();
                getDiskModel().setEntity(this);
                parentModel.getParentListModel().setWindow(null);
                parentModel.getParentListModel().setWindow(parentModel.getUnitVmModel());
                // the "new" turns into "edit" - no need for attach anymore
                attachCommand.setIsAvailable(false);
                fillData();
                Disk disk = super.getDisk();
                if (disk.getDiskStorageType() == DiskStorageType.IMAGE || disk.getDiskStorageType() == DiskStorageType.CINDER) {
                    ((DiskImage) disk).setActive(true);
                }
            }
        }

        @Override
        protected void updateBootableDiskAvailable() {
            updateBootableFrom(parentModel.getAllCurrentDisks());
        }
    };
    VM vm = new VM();
    vm.setVdsGroupId(parentModel.getUnitVmModel().getSelectedCluster().getId());
    vm.setStoragePoolId(parentModel.getUnitVmModel().getSelectedDataCenter().getId());
    vm.setVdsGroupCompatibilityVersion(parentModel.getUnitVmModel().getSelectedCluster().getCompatibilityVersion());
    model.setVm(vm);
    setupModelAsDialog(model, ConstantsManager.getInstance().getConstants().newVirtualDiskTitle(), HelpTag.new_virtual_disk, // $NON-NLS-1$
    "new_virtual_disk");
    showDialog(model);
    model.initialize(parentModel.getAllCurrentDisks());
    if (getVm() != null) {
        model.setVm(getVm());
        ((NewDiskModel) model).updateSuggestedDiskAliasFromServer();
    } else {
        String currentVmName = parentModel.getUnitVmModel().getName().getEntity();
        if (!StringUtils.isEmpty(currentVmName)) {
            // if already set the VM name on the new VM dialog, suggest the name according to the name
            model.getAlias().setEntity(suggestAliasForNewVm(currentVmName));
        }
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getDeviceType(), payload.getSpecParams(), true, true, null, false);
    }
}
#end_block

#method_before
protected void addVmCinderDisks(List<CinderDisk> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent());
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.debug("Exception", e);
    }
}
#method_after
protected void addVmCinderDisks(List<CinderDisk> templateDisks) {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(templateDisks);
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent());
    try {
        Map<Guid, Guid> diskImageMap = future.get().getActionReturnValue();
        srcDiskIdToTargetDiskIdMapping.putAll(diskImageMap);
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks from template disks.", e);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Disk diskFromDao = getDbFacade().getDiskDao().get(getParameters().getEntityId());
    if (diskFromDao != null) {
        getQueryReturnValue().setReturnValue(null);
        return;
    }
    Volume Volume = getVolumeProviderProxy().getVolumeById(getParameters().getEntityId().toString());
    Guid storageDomainId = getParameters().getId();
    CinderDisk unregisteredDisk = CinderBroker.volumeToCinderDisk(Volume, storageDomainId);
    getQueryReturnValue().setReturnValue(unregisteredDisk);
}
#method_after
@Override
protected void executeQueryCommand() {
    Disk diskFromDao = getDbFacade().getDiskDao().get(getParameters().getEntityId());
    if (diskFromDao != null) {
        log.info("The disk already exist in the DB, hence, should not be fetched from Cinder. ID: '{}', Alias: '{}'", diskFromDao.getId(), diskFromDao.getDiskAlias());
        getQueryReturnValue().setReturnValue(null);
        return;
    }
    String volumeId = getParameters().getEntityId().toString();
    Volume volume = getVolumeProviderProxy().getVolumeById(volumeId);
    if (volume == null) {
        log.info("The volume doesn't exist in Cinder. ID: '{}'", volumeId);
        getQueryReturnValue().setReturnValue(null);
        return;
    }
    Guid storageDomainId = getParameters().getId();
    CinderDisk unregisteredDisk = CinderBroker.volumeToCinderDisk(volume, storageDomainId);
    getQueryReturnValue().setReturnValue(unregisteredDisk);
}
#end_block

#method_before
protected static ImageStatus mapCinderVolumeStatusToImageStatus(CinderVolumeStatus cinderVolumeStatus) {
    switch(cinderVolumeStatus) {
        case Available:
            return ImageStatus.OK;
        case Creating:
        case Deleting:
        case Extending:
            return ImageStatus.LOCKED;
        case Error:
        case ErrorDeleting:
            return ImageStatus.ILLEGAL;
        default:
            return null;
    }
}
#method_after
protected static ImageStatus mapCinderVolumeStatusToImageStatus(CinderVolumeStatus cinderVolumeStatus) {
    switch(cinderVolumeStatus) {
        case Available:
            return ImageStatus.OK;
        case Creating:
        case Deleting:
        case Extending:
            return ImageStatus.LOCKED;
        case Error:
        case ErrorDeleting:
        case ErrorExtending:
            return ImageStatus.ILLEGAL;
        default:
            return null;
    }
}
#end_block

#method_before
public static CinderDisk volumeToCinderDisk(Volume volume, Guid storageDomainId) {
    CinderDisk cinderDisk = new CinderDisk();
    cinderDisk.setId(Guid.createGuidFromString(volume.getId()));
    cinderDisk.setImageId(Guid.createGuidFromString(volume.getId()));
    cinderDisk.setDiskAlias(volume.getName());
    cinderDisk.setDescription(volume.getDescription());
    cinderDisk.setSizeInGigabytes(volume.getSize());
    cinderDisk.setCinderVolumeType(volume.getVolumeType());
    cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
    cinderDisk.setActive(true);
    cinderDisk.setImageStatus(ImageStatus.OK);
    cinderDisk.setvolumeFormat(VolumeFormat.RAW);
    cinderDisk.setDiskInterface(DiskInterface.VirtIO);
    try {
        cinderDisk.setCreationDate(new SimpleDateFormat(DATE_FORMAT).parse(volume.getCreatedAt()));
    } catch (ParseException e) {
        cinderDisk.setCreationDate(null);
    }
    return cinderDisk;
}
#method_after
public static CinderDisk volumeToCinderDisk(Volume volume, Guid storageDomainId) {
    CinderDisk cinderDisk = new CinderDisk();
    cinderDisk.setId(Guid.createGuidFromString(volume.getId()));
    cinderDisk.setImageId(Guid.createGuidFromString(volume.getId()));
    cinderDisk.setDiskAlias(volume.getName());
    cinderDisk.setDescription(volume.getDescription());
    cinderDisk.setSizeInGigabytes(volume.getSize());
    cinderDisk.setCinderVolumeType(volume.getVolumeType());
    cinderDisk.setStorageIds(new ArrayList<>(Arrays.asList(storageDomainId)));
    cinderDisk.setActive(true);
    cinderDisk.setImageStatus(ImageStatus.OK);
    cinderDisk.setvolumeFormat(VolumeFormat.RAW);
    cinderDisk.setDiskInterface(DiskInterface.VirtIO);
    try {
        cinderDisk.setCreationDate(new SimpleDateFormat(DATE_FORMAT).parse(volume.getCreatedAt()));
    } catch (ParseException e) {
        cinderDisk.setCreationDate(null);
        log.error("Invalid disk creation date format, id: '{}' (info: {})", volume.getId(), e.getMessage());
    }
    return cinderDisk;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    final List<Volume> allVolumes = getVolumeProviderProxy().getVolumes();
    final List<Disk> registeredDisks = getDbFacade().getDiskDao().getAllWithQuery(String.format("SELECT * FROM all_disks where disk_storage_type = '%d'", DiskStorageType.CINDER.getValue()));
    List<Volume> unregisteredVolumes = LinqUtils.filter(allVolumes, new Predicate<Volume>() {

        @Override
        public boolean eval(Volume volume) {
            for (Disk registeredDisk : registeredDisks) {
                if (volume.getId().equals(registeredDisk.getId().toString())) {
                    return false;
                }
            }
            return true;
        }
    });
    Guid storageDomainId = getParameters().getId();
    List<CinderDisk> unregisteredDisks = CinderBroker.volumesToCinderDisks(unregisteredVolumes, storageDomainId);
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    final List<Volume> allVolumes = getVolumeProviderProxy().getVolumes();
    final List<Disk> registeredDisks = getDbFacade().getDiskDao().getAllFromDisksByDiskStorageType(DiskStorageType.CINDER, getUserID(), getParameters().isFiltered());
    List<Volume> unregisteredVolumes = LinqUtils.filter(allVolumes, new Predicate<Volume>() {

        @Override
        public boolean eval(Volume volume) {
            for (Disk registeredDisk : registeredDisks) {
                if (volume.getId().equals(registeredDisk.getId().toString())) {
                    return false;
                }
            }
            return true;
        }
    });
    Guid storageDomainId = getParameters().getId();
    List<CinderDisk> unregisteredDisks = CinderBroker.volumesToCinderDisks(unregisteredVolumes, storageDomainId);
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            if (!addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
                setSucceeded(false);
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
            if (!cinderDisks.isEmpty() && !addVmTemplateCinderDisks(cinderDisks, srcDeviceIdToTargetDeviceIdMapping)) {
                setSucceeded(false);
                return null;
            }
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), graphicsToSkip, false);
            } else {
                // for instance type and new template without a VM
                VmDeviceUtils.copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getParameters().isBalloonEnabled(), graphicsToSkip, false);
            }
            updateWatchdog(getVmTemplateId());
            updateRngDevice(getVmTemplateId());
            addGraphicsDevice();
            setSucceeded(true);
            return null;
        }
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
protected boolean addVmTemplateCinderDisks(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    // Create Cinder disk templates
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values());
    if (!cinderDisks.isEmpty()) {
        Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent());
        try {
            VdcReturnValueBase vdcReturnValueBase = future.get();
            if (vdcReturnValueBase.getSucceeded()) {
                Map<Guid, Guid> diskImageMap = vdcReturnValueBase.getActionReturnValue();
                srcDeviceIdToTargetDeviceIdMapping.putAll(diskImageMap);
            } else {
                getReturnValue().setFault(vdcReturnValueBase.getFault());
                log.error("Error cloning Cinder disks for template");
                return false;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("Error cloning Cinder disks for template");
            return false;
        }
    }
    return true;
}
#method_after
protected boolean addVmTemplateCinderDisks(List<CinderDisk> cinderDisks, Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    // Create Cinder disk templates
    Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.CloneCinderDisks, buildCinderChildCommandParameters(cinderDisks, getVmSnapshotId()), cloneContextAndDetachFromParent());
    try {
        VdcReturnValueBase vdcReturnValueBase = future.get();
        if (vdcReturnValueBase.getSucceeded()) {
            Map<Guid, Guid> diskImageMap = vdcReturnValueBase.getActionReturnValue();
            srcDeviceIdToTargetDeviceIdMapping.putAll(diskImageMap);
        } else {
            getReturnValue().setFault(vdcReturnValueBase.getFault());
            log.error("Error cloning Cinder disks for template");
            return false;
        }
    } catch (InterruptedException | ExecutionException e) {
        log.error("Error cloning Cinder disks for template", e);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    boolean anyFailed = false;
    for (Guid childCmdId : childCmdIds) {
        switch(CommandCoordinatorUtil.getCommandStatus(childCmdId)) {
            case ACTIVE:
                log.info("Waiting on CloneCinderDisksCommandCallback child commands to complete");
                return;
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
                break;
            default:
                break;
        }
    }
    T command = getCommand(cmdId);
    command.getParameters().setTaskGroupSuccess(!anyFailed);
    command.setCommandStatus(anyFailed ? CommandStatus.FAILED : CommandStatus.SUCCEEDED);
    log.info("All CloneCinderDisksCommandCallback commands have completed, status '{}'", command.getCommandStatus());
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    boolean anyFailed = false;
    for (Guid childCmdId : childCmdIds) {
        CommandStatus commandStatus = CommandCoordinatorUtil.getCommandStatus(childCmdId);
        switch(commandStatus) {
            case ACTIVE:
                log.info("Waiting on CloneCinderDisksCommandCallback child commands to complete");
                return;
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
            default:
                log.error("Invalid command status: '{}", commandStatus);
                break;
        }
    }
    T command = getCommand(cmdId);
    command.getParameters().setTaskGroupSuccess(!anyFailed);
    command.setCommandStatus(anyFailed ? CommandStatus.FAILED : CommandStatus.SUCCEEDED);
    log.info("All CloneCinderDisksCommandCallback commands have completed, status '{}'", command.getCommandStatus());
}
#end_block

