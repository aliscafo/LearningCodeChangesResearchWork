115
#method_before
@Override
public void installPackage(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, VerificationParams verificationParams, String packageAbiOverride) {
    android.util.SeempLog.record(113);
    installPackageAsUser(originPath, observer, installFlags, installerPackageName, verificationParams, packageAbiOverride, UserHandle.getCallingUserId());
}
#method_after
@Override
public void installPackage(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, VerificationParams verificationParams, String packageAbiOverride) {
    android.util.SeempLog.record(90);
    installPackageAsUser(originPath, observer, installFlags, installerPackageName, verificationParams, packageAbiOverride, UserHandle.getCallingUserId());
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mDropTarget = findViewById(R.id.delete_container);
    mEditTileInstructionView = findViewById(R.id.edit_container);
    mBrightnessView = findViewById(R.id.brightness_container);
    mToastView = (TextView) findViewById(R.id.qs_toast);
    mToastView.setTranslationY(-mBrightnessView.getMeasuredHeight());
    mDropTarget.setTranslationY(-mBrightnessView.getMeasuredHeight());
    mEditTileInstructionView.setTranslationY(-mBrightnessView.getMeasuredHeight());
    animateToState();
}
#method_after
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mDropTarget = findViewById(R.id.delete_container);
    mEditTileInstructionView = findViewById(R.id.edit_container);
    mBrightnessView = findViewById(R.id.brightness_container);
    mToastView = (TextView) findViewById(R.id.qs_toast);
}
#end_block

#method_before
private boolean showBrightnessSlider() {
    boolean brightnessSliderEnabled = CMSettings.System.getIntForUser(mContext.getContentResolver(), CMSettings.System.QS_SHOW_BRIGHTNESS_SLIDER, 1, UserHandle.USER_CURRENT) == 1;
    ToggleSlider brightnessSlider = (ToggleSlider) findViewById(R.id.brightness_slider);
    if (brightnessSliderEnabled) {
        mBrightnessView.setVisibility(VISIBLE);
        brightnessSlider.setVisibility(VISIBLE);
    } else {
        mBrightnessView.setVisibility(GONE);
        brightnessSlider.setVisibility(GONE);
    }
    updateResources();
    return brightnessSliderEnabled;
}
#method_after
protected boolean showBrightnessSlider() {
    boolean brightnessSliderEnabled = CMSettings.System.getIntForUser(mContext.getContentResolver(), CMSettings.System.QS_SHOW_BRIGHTNESS_SLIDER, 1, UserHandle.USER_CURRENT) == 1;
    ToggleSlider brightnessSlider = (ToggleSlider) findViewById(R.id.brightness_slider);
    if (brightnessSliderEnabled) {
        mBrightnessView.setVisibility(VISIBLE);
        brightnessSlider.setVisibility(VISIBLE);
    } else {
        mBrightnessView.setVisibility(GONE);
        brightnessSlider.setVisibility(GONE);
    }
    updateResources();
    return brightnessSliderEnabled;
}
#end_block

#method_before
@Override
public boolean canScrollHorizontally(int direction) {
    if (direction < 0 && (!mDragPanel.isEditing() || mDragPanel.isDragging()) && mPagingEnabled && getCurrentItem() == 1) {
        // can't scroll left while not editing, OR dragging on the first page
        return false;
    }
    return super.canScrollHorizontally(direction);
}
#method_after
@Override
public boolean canScrollHorizontally(int direction) {
    if (direction < 0 && mDragPanel.isDragging() && mPagingEnabled && getCurrentItem() == 1) {
        // can't scroll left while not editing, OR dragging on the first page
        return false;
    }
    return super.canScrollHorizontally(direction);
}
#end_block

#method_before
@Override
protected void setupViews() {
    updateResources();
    mDetail = LayoutInflater.from(mContext).inflate(R.layout.qs_detail, this, false);
    mDetailContent = (ViewGroup) mDetail.findViewById(android.R.id.content);
    mDetailSettingsButton = (TextView) mDetail.findViewById(android.R.id.button2);
    mDetailDoneButton = (TextView) mDetail.findViewById(android.R.id.button1);
    updateDetailText();
    mDetail.setVisibility(GONE);
    mDetail.setClickable(true);
    mQsPanelTop = (QSPanelTopView) LayoutInflater.from(mContext).inflate(R.layout.qs_tile_top, this, false);
    // mQsPanelTop.setPaddingRelative(0, mBrightnessPaddingTop, 0, 0);
    mBrightnessView = mQsPanelTop.getBrightnessView();
    mFooter = new QSFooter(this, mContext);
    getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

        @Override
        public void onGlobalLayout() {
            getViewTreeObserver().removeOnGlobalLayoutListener(this);
            ViewPager.LayoutParams params = new ViewPager.LayoutParams();
            params.isDecor = true;
            mViewPager.addView(mQsPanelTop, params);
            // mQsPanelTop.getDropTarget().setOnDragListener(QSDragPanel.this);
            // mQsPanelTop.getBrightnessView().setOnDragListener(QSDragPanel.this);
            mQsPanelTop.setOnDragListener(QSDragPanel.this);
            mPageIndicator.setOnDragListener(QSDragPanel.this);
            mViewPager.setOnDragListener(QSDragPanel.this);
        }
    });
    // add target click listener
    mQsPanelTop.findViewById(R.id.add_target).setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            showAddDialog();
        }
    });
    mViewPager = new QSViewPager(getContext());
    mViewPager.setDragPanel(this);
    mPageIndicator = new CirclePageIndicator(getContext());
    addView(mDetail);
    addView(mViewPager);
    addView(mPageIndicator);
    addView(mFooter.getView());
    mClipper = new QSDetailClipper(mDetail);
    mBrightnessController = new BrightnessController(getContext(), (ImageView) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_icon), (ToggleSlider) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_slider));
    mDetailDoneButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            announceForAccessibility(mContext.getString(R.string.accessibility_desc_quick_settings));
            closeDetail();
        }
    });
    mPagerAdapter = new PagerAdapter() {

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            if (DEBUG_DRAG) {
                Log.d(TAG, "instantiateItem() called with " + "container = [" + container + "], position = [" + position + "]");
            }
            if (mEditing && position == 0) {
                View qss = View.inflate(container.getContext(), R.layout.qs_settings, null);
                qss.setPadding(qss.getPaddingLeft(), qss.getPaddingTop() + mBrightnessPaddingTop, qss.getPaddingRight(), qss.getPaddingBottom());
                container.addView(qss, 0);
                return qss;
            } else {
                QSPage page = new QSPage(container.getContext(), QSDragPanel.this, mEditing ? position - 1 : position);
                container.addView(page);
                int viewPos = page.getPageIndex();
                if (viewPos > mPages.size()) {
                    viewPos = mPages.size();
                }
                mPages.add(viewPos, page);
                return page;
            }
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (DEBUG_DRAG) {
                Log.d(TAG, "destroyItem() called with " + "container = [" + container + "], position = [" + position + "], object = [" + object + "]");
            }
            if (object instanceof View) {
                if (object instanceof QSPage) {
                    mPages.remove(object);
                }
                container.removeView((View) object);
            }
        }

        @Override
        public int getItemPosition(Object object) {
            if (object instanceof QSPage) {
                final int indexOf = ((QSPage) object).getPageIndex();
                Log.v(TAG, "getItemPosition() for: " + object + ", returning: " + indexOf);
                if (mEditing)
                    return indexOf + 1;
                else
                    return indexOf;
            } else if (object instanceof QSSettings) {
                if (mEditing)
                    return 0;
                else
                    return POSITION_NONE;
            }
            return super.getItemPosition(object);
        }

        @Override
        public int getCount() {
            final int qsPages = Math.max(getCurrentMaxPageCount(), 1);
            if (mEditing)
                return qsPages + 1;
            return qsPages;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }
    };
    mViewPager.setAdapter(mPagerAdapter);
    mViewPager.setOffscreenPageLimit(3);
    mPageIndicator.setViewPager(mViewPager, 0);
    mPageIndicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {

        int mPreviousPosition = mViewPager.getCurrentItem();

        int mPreviousOffsetPx = 0;

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            Log.i(TAG, "onPageScrolled() called with " + "position = [" + position + "], positionOffset = [" + positionOffset + "], positionOffsetPixels = [" + positionOffsetPixels + "]");
            if (mEditing && position < 2) {
                if (positionOffset != 0) {
                    int delta = positionOffsetPixels - mPreviousOffsetPx;
                    boolean rightShift = delta > 0;
                    boolean shouldShift = position < 1;
                    Log.d(TAG, "delta: " + delta + ", shouldShift: " + shouldShift);
                    if (shouldShift) {
                        mQsPanelTop.setTranslationX(mQsPanelTop.getTranslationX() - delta);
                        mPreviousOffsetPx = positionOffsetPixels;
                    }
                } else {
                    mPreviousOffsetPx = position * mViewPager.getMeasuredWidth();
                }
            }
            mPreviousPosition = position;
        }

        @Override
        public void onPageSelected(int position) {
            if (mDragging && position != mDraggingRecord.page && !mViewPager.isFakeDragging() && !mRestoring) {
                Log.w(TAG, "moving drag record to page: " + position);
                // remove it from the previous page and add it here
                final QSPage sourceP = getPage(mDraggingRecord.page);
                final QSPage targetP = getPage(position);
                sourceP.removeView(mDraggingRecord.tileView);
                mDraggingRecord.page = position;
                targetP.addView(mDraggingRecord.tileView);
                // set coords off screen until we're ready to place it
                mDraggingRecord.tileView.setX(-mDraggingRecord.tileView.getMeasuredWidth());
                mDraggingRecord.tileView.setY(-mDraggingRecord.tileView.getMeasuredHeight());
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {
            if (state == ViewPager.SCROLL_STATE_SETTLING && mPreviousPosition == 1 && mEditing && mQsPanelTop.getTranslationX() != 0) {
                mQsPanelTop.setTranslationX(0);
                if (DEBUG_DRAG) {
                    Log.w(TAG, "reset panel top translation x to 0");
                }
            }
        }
    });
    mViewPager.setOverScrollMode(OVER_SCROLL_NEVER);
}
#method_after
@Override
protected void setupViews() {
    updateResources();
    mDetail = LayoutInflater.from(mContext).inflate(R.layout.qs_detail, this, false);
    mDetailContent = (ViewGroup) mDetail.findViewById(android.R.id.content);
    mDetailSettingsButton = (TextView) mDetail.findViewById(android.R.id.button2);
    mDetailDoneButton = (TextView) mDetail.findViewById(android.R.id.button1);
    updateDetailText();
    mDetail.setVisibility(GONE);
    mDetail.setClickable(true);
    mQsPanelTop = (QSPanelTopView) LayoutInflater.from(mContext).inflate(R.layout.qs_tile_top, this, false);
    mBrightnessView = mQsPanelTop.getBrightnessView();
    mFooter = new QSFooter(this, mContext);
    getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

        @Override
        public void onGlobalLayout() {
            getViewTreeObserver().removeOnGlobalLayoutListener(this);
            ViewPager.LayoutParams params = new ViewPager.LayoutParams();
            params.isDecor = true;
            mViewPager.addView(mQsPanelTop, params);
            mQsPanelTop.setOnDragListener(QSDragPanel.this);
            mPageIndicator.setOnDragListener(QSDragPanel.this);
            mViewPager.setOnDragListener(QSDragPanel.this);
        }
    });
    // add target click listener
    mQsPanelTop.findViewById(R.id.add_target).setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            showAddDialog();
        }
    });
    mViewPager = new QSViewPager(getContext());
    mViewPager.setDragPanel(this);
    mPageIndicator = new CirclePageIndicator(getContext());
    addView(mDetail);
    addView(mViewPager);
    addView(mPageIndicator);
    addView(mFooter.getView());
    mClipper = new QSDetailClipper(mDetail);
    mBrightnessController = new BrightnessController(getContext(), (ImageView) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_icon), (ToggleSlider) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_slider));
    mDetailDoneButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            announceForAccessibility(mContext.getString(R.string.accessibility_desc_quick_settings));
            closeDetail();
        }
    });
    mPagerAdapter = new PagerAdapter() {

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            if (DEBUG_DRAG) {
                Log.d(TAG, "instantiateItem() called with " + "container = [" + container + "], position = [" + position + "]");
            }
            if (mEditing && position == 0) {
                QSSettings qss = (QSSettings) View.inflate(container.getContext(), R.layout.qs_settings, null);
                qss.setHost(mHost);
                container.addView(qss, 0);
                return qss;
            } else {
                QSPage page = new QSPage(container.getContext(), QSDragPanel.this, mEditing ? position - 1 : position);
                container.addView(page);
                int viewPos = page.getPageIndex();
                if (viewPos > mPages.size()) {
                    mPages.add(page);
                } else {
                    mPages.add(viewPos, page);
                }
                return page;
            }
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (DEBUG_DRAG) {
                Log.d(TAG, "destroyItem() called with " + "container = [" + container + "], position = [" + position + "], object = [" + object + "]");
            }
            if (object instanceof View) {
                if (object instanceof QSPage) {
                    mPages.remove(object);
                }
                container.removeView((View) object);
            }
        }

        @Override
        public int getItemPosition(Object object) {
            if (object instanceof QSPage) {
                final int indexOf = ((QSPage) object).getPageIndex();
                Log.v(TAG, "getItemPosition() for: " + object + ", returning: " + indexOf);
                if (mEditing)
                    return indexOf + 1;
                else
                    return indexOf;
            } else if (object instanceof QSSettings) {
                if (mEditing)
                    return 0;
                else
                    return POSITION_NONE;
            }
            return super.getItemPosition(object);
        }

        @Override
        public int getCount() {
            final int qsPages = Math.max(getCurrentMaxPageCount(), 1);
            if (mEditing)
                return qsPages + 1;
            return qsPages;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }
    };
    mViewPager.setAdapter(mPagerAdapter);
    mViewPager.setOffscreenPageLimit(INITIAL_OFFSCREEN_PAGE_LIMIT);
    mPageIndicator.setViewPager(mViewPager);
    mPageIndicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            Log.i(TAG, "onPageScrolled() called with " + "position = [" + position + "], positionOffset = [" + positionOffset + "], positionOffsetPixels = [" + positionOffsetPixels + "]");
            if (mEditing) {
                float targetTranslationX = 0;
                // targetTranslationX = where it's supposed to be - diff
                int homeLocation = mViewPager.getMeasuredWidth();
                // how far away from homeLocation is the scroll?
                if (positionOffsetPixels < homeLocation && position == 0) {
                    targetTranslationX = homeLocation - positionOffsetPixels;
                }
                mQsPanelTop.setTranslationX(targetTranslationX);
            }
        }

        @Override
        public void onPageSelected(int position) {
            if (mDragging && position != mDraggingRecord.page && !mViewPager.isFakeDragging() && !mRestoring) {
                Log.w(TAG, "moving drag record to page: " + position);
                // remove it from the previous page and add it here
                final QSPage sourceP = getPage(mDraggingRecord.page);
                final QSPage targetP = getPage(position);
                sourceP.removeView(mDraggingRecord.tileView);
                mDraggingRecord.page = position;
                targetP.addView(mDraggingRecord.tileView);
                // set coords off screen until we're ready to place it
                mDraggingRecord.tileView.setX(-mDraggingRecord.tileView.getMeasuredWidth());
                mDraggingRecord.tileView.setY(-mDraggingRecord.tileView.getMeasuredHeight());
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    });
    mViewPager.setOverScrollMode(OVER_SCROLL_NEVER);
    setClipChildren(false);
}
#end_block

#method_before
@Override
public void setBrightnessMirror(BrightnessMirrorController c) {
    ToggleSlider brightnessSlider = (ToggleSlider) mQsPanelTop.findViewById(R.id.brightness_slider);
    ToggleSlider mirror = (ToggleSlider) c.getMirror().findViewById(R.id.brightness_slider);
    brightnessSlider.setMirror(mirror);
    brightnessSlider.setMirrorController(c);
}
#method_after
@Override
public void setBrightnessMirror(BrightnessMirrorController c) {
    super.onFinishInflate();
    ToggleSlider brightnessSlider = (ToggleSlider) mQsPanelTop.findViewById(R.id.brightness_slider);
    ToggleSlider mirror = (ToggleSlider) c.getMirror().findViewById(R.id.brightness_slider);
    brightnessSlider.setMirror(mirror);
    brightnessSlider.setMirrorController(c);
}
#end_block

#method_before
public void setEditing(boolean editing) {
    if (mEditing == editing)
        return;
    mEditing = editing;
    if (!editing) {
        // persist the new config.
        List<String> newTiles = new ArrayList<>();
        for (TileRecord record : mRecords) {
            newTiles.add(mHost.getSpec(record.tile));
        }
        mHost.setTiles(newTiles);
        refreshAllTiles();
        mQsPanelTop.animate().translationX(0).start();
    }
    // clear the record state
    for (TileRecord record : mRecords) {
        setupRecord(record);
        drawTile(record, record.tile.getState());
    }
    mQsPanelTop.setEditing(editing);
    mPagerAdapter.notifyDataSetChanged();
    ensurePagerState();
    requestLayout();
}
#method_after
public void setEditing(boolean editing) {
    if (mEditing == editing)
        return;
    mEditing = editing;
    if (!editing) {
        // persist the new config.
        List<String> newTiles = new ArrayList<>();
        for (TileRecord record : mRecords) {
            newTiles.add(mHost.getSpec(record.tile));
        }
        mHost.setTiles(newTiles);
        refreshAllTiles();
        mQsPanelTop.animate().translationX(0).start();
    }
    // clear the record state
    for (TileRecord record : mRecords) {
        setupRecord(record);
        drawTile(record, record.tile.getState());
    }
    mQsPanelTop.setEditing(editing);
    mPageIndicator.setEditing(editing);
    mPagerAdapter.notifyDataSetChanged();
    ensurePagerState();
    requestLayout();
}
#end_block

#method_before
public void ensurePagerState() {
    final boolean pagingEnabled = getVisibleTilePageCount() > 1 || mDragging || mEditing;
    mViewPager.setPagingEnabled(pagingEnabled);
}
#method_after
public void ensurePagerState() {
    if (!isShowingDetail()) {
        final boolean pagingEnabled = getVisibleTilePageCount() > 1 || mDragging || mEditing;
        mViewPager.setPagingEnabled(pagingEnabled);
    }
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (DEBUG_DRAG)
        Log.d(TAG, "onMeasure()");
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    if (isLaidOut()) {
        mQsPanelTop.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    }
    mViewPager.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    mPageIndicator.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    mFooter.getView().measure(exactly(width), MeasureSpec.UNSPECIFIED);
    int h = mBrightnessPaddingTop + mViewPager.getMeasuredHeight() + mPageIndicator.getMeasuredHeight();
    if (mFooter.hasFooter()) {
        h += mFooter.getView().getMeasuredHeight();
    }
    mDetail.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    if (mDetail.getMeasuredHeight() < h) {
        mDetail.measure(exactly(width), exactly(h));
    }
    mGridHeight = h;
    setMeasuredDimension(width, Math.max(h, mDetail.getMeasuredHeight()));
    for (TileRecord record : mRecords) {
        setupRecord(record);
    }
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    final int width = MeasureSpec.getSize(widthMeasureSpec);
    if (isLaidOut()) {
        mQsPanelTop.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    }
    mViewPager.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    mPageIndicator.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    mFooter.getView().measure(exactly(width), MeasureSpec.UNSPECIFIED);
    int h = mBrightnessPaddingTop + mViewPager.getMeasuredHeight() + mPageIndicator.getMeasuredHeight();
    if (mFooter.hasFooter()) {
        h += mFooter.getView().getMeasuredHeight();
    }
    mDetail.measure(exactly(width), MeasureSpec.UNSPECIFIED);
    if (mDetail.getMeasuredHeight() < h) {
        mDetail.measure(exactly(width), exactly(h));
    }
    mGridHeight = h;
    setMeasuredDimension(width, Math.max(h, mDetail.getMeasuredHeight()));
    for (TileRecord record : mRecords) {
        setupRecord(record);
    }
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    if (DEBUG_DRAG)
        Log.d(TAG, "onLayout()");
    final int w = getWidth();
    int top = mBrightnessPaddingTop;
    mViewPager.layout(0, top, w, top + mViewPager.getMeasuredHeight());
    top += mViewPager.getMeasuredHeight();
    // layout page indicator below view pager
    mPageIndicator.layout(0, top, w, top + mPageIndicator.getMeasuredHeight());
    // detail takes up whole height
    mDetail.layout(0, 0, mDetail.getMeasuredWidth(), getMeasuredHeight());
    if (mFooter.hasFooter()) {
        View footer = mFooter.getView();
        footer.layout(0, getMeasuredHeight() - footer.getMeasuredHeight(), footer.getMeasuredWidth(), getMeasuredHeight());
    }
    if (mTempTiles != null) {
        final Iterator<QSTile<?>> iterator = mTempTiles.iterator();
        while (iterator.hasNext()) {
            addTile(iterator.next());
            iterator.remove();
        }
        mTempTiles = null;
        mPagerAdapter.notifyDataSetChanged();
    }
    ensurePagerState();
}
#method_after
@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    final int w = getWidth();
    int top = mBrightnessPaddingTop;
    mViewPager.layout(0, top, w, top + mViewPager.getMeasuredHeight());
    top += mViewPager.getMeasuredHeight();
    // layout page indicator below view pager
    mPageIndicator.layout(0, top, w, top + mPageIndicator.getMeasuredHeight());
    // detail takes up whole height
    mDetail.layout(0, 0, mDetail.getMeasuredWidth(), getMeasuredHeight());
    if (mFooter.hasFooter()) {
        View footer = mFooter.getView();
        footer.layout(0, getMeasuredHeight() - footer.getMeasuredHeight(), footer.getMeasuredWidth(), getMeasuredHeight());
    }
    if (mTempTiles != null) {
        final Iterator<QSTile<?>> iterator = mTempTiles.iterator();
        while (iterator.hasNext()) {
            addTile(iterator.next());
            iterator.remove();
        }
        mTempTiles = null;
        mPagerAdapter.notifyDataSetChanged();
    }
    ensurePagerState();
}
#end_block

#method_before
private boolean isDropTargetEvent(DragEvent event, View v) {
    if (DEBUG_DRAG) {
        Log.d(TAG, "isDropTargetEvent() called with " + "event = [" + event + "], v = [" + v + "]");
    }
    if (v == getDropTarget() || v == mQsPanelTop) {
        if (DEBUG_DRAG) {
            Log.d(TAG, "isDropTargetEvent() returns true by view");
        }
        return true;
    }
    if (v.getX() <= getRowTop(0)) {
        if (DEBUG_DRAG) {
            Log.d(TAG, "isDropTargetEvent() returns true by loc");
        }
        return true;
    }
    return false;
}
#method_after
private boolean isDropTargetEvent(DragEvent event, View v) {
    if (DEBUG_DRAG) {
        Log.d(TAG, "isDropTargetEvent() called with " + "event = [" + event + "], v = [" + v + "]");
    }
    if (v == getDropTarget() || v == mQsPanelTop) {
        if (DEBUG_DRAG) {
            Log.d(TAG, "isDropTargetEvent() returns true by view");
        }
        return true;
    }
    if (v == mViewPager && mLastTouchLocationY <= getRowTop(0)) {
        if (DEBUG_DRAG) {
            Log.d(TAG, "isDropTargetEvent() returns true by loc");
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private final void updateVolumeZen() {
    AudioManager audioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
    boolean zenVisible = false;
    int zenIconId = 0;
    String zenDescription = null;
    boolean volumeVisible = false;
    int volumeIconId = 0;
    String volumeDescription = null;
    if (DndTile.isVisible(mContext) || DndTile.isCombinedIcon(mContext)) {
        zenVisible = mZen != Global.ZEN_MODE_OFF;
        if (mZen == Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS) {
            zenIconId = R.drawable.stat_sys_dnd_priority;
        } else if (mZen == Global.ZEN_MODE_NO_INTERRUPTIONS) {
            zenIconId = R.drawable.stat_sys_dnd_total_silence;
        } else {
            zenIconId = R.drawable.stat_sys_dnd;
        }
        zenDescription = mContext.getString(R.string.quick_settings_dnd_label);
    } else if (mZen == Global.ZEN_MODE_NO_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_none;
        zenDescription = mContext.getString(R.string.interruption_level_none);
    } else if (mZen == Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_important;
        zenDescription = mContext.getString(R.string.interruption_level_priority);
    }
    if (DndTile.isVisible(mContext) && !DndTile.isCombinedIcon(mContext) && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_silent;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_silent);
    } else if (mZen != Global.ZEN_MODE_NO_INTERRUPTIONS && mZen != Global.ZEN_MODE_ALARMS && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_vibrate;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_vibrate);
    }
    if (zenVisible) {
        mService.setIcon(SLOT_ZEN, zenIconId, 0, zenDescription);
    }
    if (zenVisible != mZenVisible) {
        mService.setIconVisibility(SLOT_ZEN, zenVisible);
        mZenVisible = zenVisible;
    }
    if (volumeVisible) {
        mService.setIcon(SLOT_VOLUME, volumeIconId, 0, volumeDescription);
    }
    if (volumeVisible != mVolumeVisible) {
        mService.setIconVisibility(SLOT_VOLUME, volumeVisible);
        mVolumeVisible = volumeVisible;
    }
    updateAlarm();
}
#method_after
private final void updateVolumeZen() {
    AudioManager audioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
    boolean zenVisible = false;
    int zenIconId = 0;
    String zenDescription = null;
    boolean volumeVisible = false;
    int volumeIconId = 0;
    String volumeDescription = null;
    if (DndTile.isVisible(mContext) || DndTile.isCombinedIcon(mContext)) {
        zenVisible = mZen != Global.ZEN_MODE_OFF;
        switch(mZen) {
            case Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS:
                zenIconId = R.drawable.stat_sys_dnd_priority;
                break;
            case Global.ZEN_MODE_NO_INTERRUPTIONS:
                zenIconId = R.drawable.stat_sys_dnd_total_silence;
                break;
            default:
                zenIconId = R.drawable.stat_sys_dnd;
                break;
        }
        zenDescription = mContext.getString(R.string.quick_settings_dnd_label);
    } else if (mZen == Global.ZEN_MODE_NO_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_none;
        zenDescription = mContext.getString(R.string.interruption_level_none);
    } else if (mZen == Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_important;
        zenDescription = mContext.getString(R.string.interruption_level_priority);
    }
    if (DndTile.isVisible(mContext) && !DndTile.isCombinedIcon(mContext) && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_silent;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_silent);
    } else if (mZen != Global.ZEN_MODE_NO_INTERRUPTIONS && mZen != Global.ZEN_MODE_ALARMS && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_vibrate;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_vibrate);
    }
    if (zenVisible) {
        mService.setIcon(SLOT_ZEN, zenIconId, 0, zenDescription);
    }
    if (zenVisible != mZenVisible) {
        mService.setIconVisibility(SLOT_ZEN, zenVisible);
        mZenVisible = zenVisible;
    }
    if (volumeVisible) {
        mService.setIcon(SLOT_VOLUME, volumeIconId, 0, volumeDescription);
    }
    if (volumeVisible != mVolumeVisible) {
        mService.setIconVisibility(SLOT_VOLUME, volumeVisible);
        mVolumeVisible = volumeVisible;
    }
    updateAlarm();
}
#end_block

#method_before
private void updateCast() {
    boolean isCasting = false;
    for (CastDevice device : mCast.getCastDevices()) {
        if (device.state == CastDevice.STATE_CONNECTING || device.state == CastDevice.STATE_CONNECTED) {
            isCasting = true;
            break;
        }
    }
    if (DEBUG)
        Log.v(TAG, "updateCast: isCasting: " + isCasting);
    if (isCasting) {
        mService.setIcon(SLOT_CAST, R.drawable.stat_sys_cast, 0, mContext.getString(R.string.accessibility_casting));
    }
    mService.setIconVisibility(SLOT_CAST, isCasting);
}
#method_after
private void updateCast() {
    boolean isCasting = false;
    for (CastDevice device : mCast.getCastDevices()) {
        if (device.state == CastDevice.STATE_CONNECTING || device.state == CastDevice.STATE_CONNECTED) {
            isCasting = true;
            break;
        }
    }
    if (DEBUG)
        Log.v(TAG, "updateCast: isCasting: " + isCasting);
    mHandler.removeCallbacks(mRemoveCastIconRunnable);
    if (isCasting) {
        mService.setIcon(SLOT_CAST, R.drawable.stat_sys_cast, 0, mContext.getString(R.string.accessibility_casting));
        mService.setIconVisibility(SLOT_CAST, true);
    } else {
        // has seen it
        if (DEBUG)
            Log.v(TAG, "updateCast: hiding icon in 3 sec...");
        mHandler.postDelayed(mRemoveCastIconRunnable, 3000);
    }
}
#end_block

#method_before
protected void showAddDialog() {
    List<String> tiles = mHost.getTileSpecs();
    int numBroadcast = 0;
    for (int i = 0; i < tiles.size(); i++) {
        if (tiles.get(i).startsWith(IntentTile.PREFIX)) {
            numBroadcast++;
        }
    }
    String[] defaults = getContext().getString(R.string.quick_settings_tiles_default).split(",");
    int availableSize = defaults.length + 1 - (tiles.size() - numBroadcast);
    if (availableSize < 1) {
        availableSize = 1;
    }
    final String[] available = new String[availableSize];
    final String[] availableTiles = new String[availableSize];
    int index = 0;
    for (int i = 0; i < defaults.length; i++) {
        if (tiles.contains(defaults[i])) {
            continue;
        }
        int resource = mHost.getLabelResource(defaults[i]);
        if (resource != 0) {
            availableTiles[index] = defaults[i];
            available[index++] = getContext().getString(resource);
        } else {
            availableTiles[index] = defaults[i];
            available[index++] = defaults[i];
        }
    }
    available[index++] = getContext().getString(R.string.broadcast_tile);
    final AlertDialog d = new AlertDialog.Builder(getContext(), R.style.Theme_SystemUI_Dialog).setTitle(R.string.add_tile).setItems(available, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            if (which < available.length - 1) {
                add(availableTiles[which]);
            } else {
                showBroadcastTileDialog();
            }
        }
    }).create();
    SystemUIDialog.makeSystemUIDialog(d);
    d.show();
}
#method_after
protected void showAddDialog() {
    List<String> currentTileSpec = mHost.getTileSpecs();
    final List<String> availableTilesSpec = QSUtils.getAvailableTiles(getContext());
    // Remove tiles already used
    availableTilesSpec.removeAll(currentTileSpec);
    // Populate labels
    List<String> availableTilesLabel = new ArrayList<String>();
    for (String tileSpec : availableTilesSpec) {
        int resource = QSTileHost.getLabelResource(tileSpec);
        if (resource != 0) {
            availableTilesLabel.add(getContext().getString(resource));
        } else {
            availableTilesLabel.add(tileSpec);
        }
    }
    // Add broadcast tile
    availableTilesLabel.add(getContext().getString(R.string.broadcast_tile));
    availableTilesSpec.add(BROADCAST_TILE_SPEC_PLACEHOLDER);
    String[] items = new String[availableTilesLabel.size()];
    availableTilesLabel.toArray(items);
    final AlertDialog d = new AlertDialog.Builder(getContext(), R.style.Theme_SystemUI_Dialog).setTitle(R.string.add_tile).setItems(items, new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            String tileSpec = availableTilesSpec.get(which);
            if (tileSpec.equals(BROADCAST_TILE_SPEC_PLACEHOLDER)) {
                showBroadcastTileDialog();
            } else {
                add(tileSpec);
            }
        }
    }).create();
    SystemUIDialog.makeSystemUIDialog(d);
    d.show();
}
#end_block

#method_before
public QSTile<?> createTile(String tileSpec) {
    if (tileSpec.equals("wifi"))
        return new WifiTile(this);
    else if (tileSpec.equals("bt"))
        return new BluetoothTile(this);
    else if (tileSpec.equals("inversion"))
        return new ColorInversionTile(this);
    else if (tileSpec.equals("cell"))
        return new CellularTile(this);
    else if (tileSpec.equals("airplane"))
        return new AirplaneModeTile(this);
    else if (tileSpec.equals("dnd"))
        return new DndTile(this);
    else if (tileSpec.equals("rotation"))
        return new RotationLockTile(this);
    else if (tileSpec.equals("flashlight"))
        return new FlashlightTile(this);
    else if (tileSpec.equals("location"))
        return new LocationTile(this);
    else if (tileSpec.equals("cast"))
        return new CastTile(this);
    else if (tileSpec.equals("hotspot"))
        return new HotspotTile(this);
    else if (tileSpec.equals("edit"))
        return new EditTile(this);
    else if (tileSpec.startsWith(IntentTile.PREFIX))
        return IntentTile.create(this, tileSpec);
    else
        throw new IllegalArgumentException("Bad tile spec: " + tileSpec);
}
#method_after
public QSTile<?> createTile(String tileSpec) {
    if (tileSpec.equals("wifi"))
        return new WifiTile(this);
    else if (tileSpec.equals("bt"))
        return new BluetoothTile(this);
    else if (tileSpec.equals("inversion"))
        return new ColorInversionTile(this);
    else if (tileSpec.equals("cell"))
        return new CellularTile(this);
    else if (tileSpec.equals("airplane"))
        return new AirplaneModeTile(this);
    else if (tileSpec.equals("dnd"))
        return new DndTile(this);
    else if (tileSpec.equals("rotation"))
        return new RotationLockTile(this);
    else if (tileSpec.equals("flashlight"))
        return new FlashlightTile(this);
    else if (tileSpec.equals("location"))
        return new LocationTile(this);
    else if (tileSpec.equals("cast"))
        return new CastTile(this);
    else if (tileSpec.equals("hotspot"))
        return new HotspotTile(this);
    else if (tileSpec.equals("edit"))
        return new EditTile(this);
    else if (tileSpec.equals("compass"))
        return new CompassTile(this);
    else if (tileSpec.equals("nfc"))
        return new NfcTile(this);
    else if (tileSpec.equals("profiles"))
        return new ProfilesTile(this);
    else if (tileSpec.equals("sync"))
        return new SyncTile(this);
    else if (tileSpec.equals("volume_panel"))
        return new VolumeTile(this);
    else if (tileSpec.equals("usb_tether"))
        return new UsbTetherTile(this);
    else if (tileSpec.equals("screen_timeout"))
        return new ScreenTimeoutTile(this);
    else if (tileSpec.equals("performance"))
        return new PerfProfileTile(this);
    else if (tileSpec.startsWith(IntentTile.PREFIX))
        return IntentTile.create(this, tileSpec);
    else
        throw new IllegalArgumentException("Bad tile spec: " + tileSpec);
}
#end_block

#method_before
protected List<String> loadTileSpecs(String tileList) {
    final Resources res = mContext.getResources();
    final String defaultTileList = res.getString(R.string.quick_settings_tiles_default);
    if (tileList == null) {
        tileList = res.getString(R.string.quick_settings_tiles);
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from config: " + tileList);
    } else {
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from setting: " + tileList);
    }
    final ArrayList<String> tiles = new ArrayList<String>();
    boolean addedDefault = false;
    for (String tile : tileList.split(",")) {
        tile = tile.trim();
        if (tile.isEmpty())
            continue;
        if (tile.equals("default")) {
            if (!addedDefault) {
                tiles.addAll(Arrays.asList(defaultTileList.split(",")));
                addedDefault = true;
            }
        } else {
            tiles.add(tile);
        }
    }
    // ensure edit tile is present
    if (tiles.size() < TILES_PER_PAGE && !tiles.contains("edit")) {
        tiles.add("edit");
    } else if (tiles.size() > TILES_PER_PAGE && !tiles.contains("edit")) {
        tiles.add((TILES_PER_PAGE - 1), "edit");
    }
    return tiles;
}
#method_after
protected List<String> loadTileSpecs(String tileList) {
    final Resources res = mContext.getResources();
    final String defaultTileList = res.getString(org.cyanogenmod.platform.internal.R.string.config_defaultQuickSettingsTiles);
    if (tileList == null) {
        tileList = res.getString(R.string.quick_settings_tiles);
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from config: " + tileList);
    } else {
        if (DEBUG)
            Log.d(TAG, "Loaded tile specs from setting: " + tileList);
    }
    final ArrayList<String> tiles = new ArrayList<String>();
    boolean addedDefault = false;
    for (String tile : tileList.split(",")) {
        tile = tile.trim();
        if (tile.isEmpty())
            continue;
        if (tile.equals("default")) {
            if (!addedDefault) {
                tiles.addAll(Arrays.asList(defaultTileList.split(",")));
                addedDefault = true;
            }
        } else {
            tiles.add(tile);
        }
    }
    // ensure edit tile is present
    if (tiles.size() < TILES_PER_PAGE && !tiles.contains("edit")) {
        tiles.add("edit");
    } else if (tiles.size() > TILES_PER_PAGE && !tiles.contains("edit")) {
        tiles.add((TILES_PER_PAGE - 1), "edit");
    }
    return tiles;
}
#end_block

#method_before
public static int getLabelResource(String spec) {
    if (spec.equals("wifi"))
        return R.string.quick_settings_wifi_label;
    else if (spec.equals("bt"))
        return R.string.quick_settings_bluetooth_label;
    else if (spec.equals("inversion"))
        return R.string.quick_settings_inversion_label;
    else if (spec.equals("cell"))
        return R.string.quick_settings_cellular_detail_title;
    else if (spec.equals("airplane"))
        return R.string.airplane_mode;
    else if (spec.equals("dnd"))
        return R.string.quick_settings_dnd_label;
    else if (spec.equals("rotation"))
        return R.string.quick_settings_rotation_locked_label;
    else if (spec.equals("flashlight"))
        return R.string.quick_settings_flashlight_label;
    else if (spec.equals("location"))
        return R.string.quick_settings_location_label;
    else if (spec.equals("cast"))
        return R.string.quick_settings_cast_title;
    else if (spec.equals("hotspot"))
        return R.string.quick_settings_hotspot_label;
    else if (spec.equals("edit"))
        return R.string.quick_settings_edit_label;
    return 0;
}
#method_after
public static int getLabelResource(String spec) {
    if (spec.equals("wifi"))
        return R.string.quick_settings_wifi_label;
    else if (spec.equals("bt"))
        return R.string.quick_settings_bluetooth_label;
    else if (spec.equals("inversion"))
        return R.string.quick_settings_inversion_label;
    else if (spec.equals("cell"))
        return R.string.quick_settings_cellular_detail_title;
    else if (spec.equals("airplane"))
        return R.string.airplane_mode;
    else if (spec.equals("dnd"))
        return R.string.quick_settings_dnd_label;
    else if (spec.equals("rotation"))
        return R.string.quick_settings_rotation_locked_label;
    else if (spec.equals("flashlight"))
        return R.string.quick_settings_flashlight_label;
    else if (spec.equals("location"))
        return R.string.quick_settings_location_label;
    else if (spec.equals("cast"))
        return R.string.quick_settings_cast_title;
    else if (spec.equals("hotspot"))
        return R.string.quick_settings_hotspot_label;
    else if (spec.equals("edit"))
        return R.string.quick_settings_edit_label;
    else if (spec.equals("adb_network"))
        return R.string.qs_tile_adb_over_network;
    else if (spec.equals("compass"))
        return R.string.qs_tile_compass;
    else if (spec.equals("nfc"))
        return R.string.quick_settings_nfc;
    else if (spec.equals("profiles"))
        return R.string.quick_settings_profiles;
    else if (spec.equals("sync"))
        return R.string.quick_settings_sync_label;
    else if (spec.equals("volume_panel"))
        return R.string.quick_settings_volume_panel_label;
    else if (spec.equals("usb_tether"))
        return R.string.quick_settings_usb_tether_label;
    else if (spec.equals("screen_timeout"))
        return R.string.quick_settings_screen_timeout_detail_title;
    else if (spec.equals("performance"))
        return R.string.qs_tile_performance;
    return 0;
}
#end_block

#method_before
private final void updateVolumeZen() {
    AudioManager audioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
    boolean zenVisible = false;
    int zenIconId = 0;
    String zenDescription = null;
    boolean volumeVisible = false;
    int volumeIconId = 0;
    String volumeDescription = null;
    if (DndTile.isVisible(mContext) || DndTile.isCombinedIcon(mContext)) {
        zenVisible = mZen != Global.ZEN_MODE_OFF;
        zenIconId = mZen == Global.ZEN_MODE_NO_INTERRUPTIONS ? R.drawable.stat_sys_dnd_total_silence : R.drawable.stat_sys_dnd;
        zenDescription = mContext.getString(R.string.quick_settings_dnd_label);
    } else if (mZen == Global.ZEN_MODE_NO_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_none;
        zenDescription = mContext.getString(R.string.interruption_level_none);
    } else if (mZen == Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_important;
        zenDescription = mContext.getString(R.string.interruption_level_priority);
    }
    if (DndTile.isVisible(mContext) && !DndTile.isCombinedIcon(mContext) && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_silent;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_silent);
    } else if (mZen != Global.ZEN_MODE_NO_INTERRUPTIONS && mZen != Global.ZEN_MODE_ALARMS && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_vibrate;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_vibrate);
    }
    if (zenVisible) {
        mService.setIcon(SLOT_ZEN, zenIconId, 0, zenDescription);
    }
    if (zenVisible != mZenVisible) {
        mService.setIconVisibility(SLOT_ZEN, zenVisible);
        mZenVisible = zenVisible;
    }
    if (volumeVisible) {
        mService.setIcon(SLOT_VOLUME, volumeIconId, 0, volumeDescription);
    }
    if (volumeVisible != mVolumeVisible) {
        mService.setIconVisibility(SLOT_VOLUME, volumeVisible);
        mVolumeVisible = volumeVisible;
    }
    updateAlarm();
}
#method_after
private final void updateVolumeZen() {
    AudioManager audioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
    boolean zenVisible = false;
    int zenIconId = 0;
    String zenDescription = null;
    boolean volumeVisible = false;
    int volumeIconId = 0;
    String volumeDescription = null;
    if (DndTile.isVisible(mContext) || DndTile.isCombinedIcon(mContext)) {
        zenVisible = mZen != Global.ZEN_MODE_OFF;
        switch(mZen) {
            case Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS:
                zenIconId = R.drawable.stat_sys_dnd_priority;
                break;
            case Global.ZEN_MODE_NO_INTERRUPTIONS:
                zenIconId = R.drawable.stat_sys_dnd_total_silence;
                break;
            default:
                zenIconId = R.drawable.stat_sys_dnd;
                break;
        }
        zenDescription = mContext.getString(R.string.quick_settings_dnd_label);
    } else if (mZen == Global.ZEN_MODE_NO_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_none;
        zenDescription = mContext.getString(R.string.interruption_level_none);
    } else if (mZen == Global.ZEN_MODE_IMPORTANT_INTERRUPTIONS) {
        zenVisible = true;
        zenIconId = R.drawable.stat_sys_zen_important;
        zenDescription = mContext.getString(R.string.interruption_level_priority);
    }
    if (DndTile.isVisible(mContext) && !DndTile.isCombinedIcon(mContext) && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_silent;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_silent);
    } else if (mZen != Global.ZEN_MODE_NO_INTERRUPTIONS && mZen != Global.ZEN_MODE_ALARMS && audioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE) {
        volumeVisible = true;
        volumeIconId = R.drawable.stat_sys_ringer_vibrate;
        volumeDescription = mContext.getString(R.string.accessibility_ringer_vibrate);
    }
    if (zenVisible) {
        mService.setIcon(SLOT_ZEN, zenIconId, 0, zenDescription);
    }
    if (zenVisible != mZenVisible) {
        mService.setIconVisibility(SLOT_ZEN, zenVisible);
        mZenVisible = zenVisible;
    }
    if (volumeVisible) {
        mService.setIcon(SLOT_VOLUME, volumeIconId, 0, volumeDescription);
    }
    if (volumeVisible != mVolumeVisible) {
        mService.setIconVisibility(SLOT_VOLUME, volumeVisible);
        mVolumeVisible = volumeVisible;
    }
    updateAlarm();
}
#end_block

#method_before
private void updateSu() {
    mService.setIconVisibility(SLOT_SU, mSuController.hasActiveSessions());
    if (mSuController.hasActiveSessions()) {
        publishSuCustomTile();
    } else {
        unpublishSuCustomTile();
    }
}
#method_after
private void updateSu() {
    mService.setIconVisibility(SLOT_SU, mSuController.hasActiveSessions());
    final int userId = UserHandle.myUserId();
    if (isSuEnabledForUser(userId)) {
        publishSuCustomTile();
    } else {
        unpublishSuCustomTile();
    }
}
#end_block

#method_before
private void publishSuCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        if (!QSUtils.isQSTileEnabledForUser(mContext, QSConstants.DYNAMIC_TILE_SU, userId)) {
            return;
        }
        final UserHandle user = new UserHandle(userId);
        final int icon = QSUtils.getDynamicQSTileResIconId(mContext, userId, QSConstants.DYNAMIC_TILE_SU);
        final String contentDesc = QSUtils.getDynamicQSTileLabel(mContext, userId, QSConstants.DYNAMIC_TILE_SU);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CustomTile.ListExpandedStyle style = new CustomTile.ListExpandedStyle();
        ArrayList<CustomTile.ExpandedListItem> items = new ArrayList<>();
        for (String pkg : mSuController.getPackageNamesWithActiveSuSessions()) {
            CustomTile.ExpandedListItem item = new CustomTile.ExpandedListItem();
            item.setExpandedListItemDrawable(icon);
            item.setExpandedListItemTitle(getActiveSuApkLabel(pkg));
            item.setExpandedListItemSummary(pkg);
            item.setExpandedListItemOnClickIntent(getCustomTilePendingIntent(pkg));
            items.add(item);
        }
        style.setListItems(items);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(contentDesc).setContentDescription(contentDesc).setIcon(icon).setOnSettingsClickIntent(getCustomTileSettingsIntent()).setExpandedStyle(style).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_SU, PhoneStatusBarPolicy.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void publishSuCustomTile() {
    // This action should be performed as system
    final int userId = UserHandle.myUserId();
    long token = Binder.clearCallingIdentity();
    try {
        if (!QSUtils.isQSTileEnabledForUser(mContext, QSConstants.DYNAMIC_TILE_SU, userId)) {
            return;
        }
        final UserHandle user = new UserHandle(userId);
        final int icon = QSUtils.getDynamicQSTileResIconId(mContext, userId, QSConstants.DYNAMIC_TILE_SU);
        final String contentDesc = QSUtils.getDynamicQSTileLabel(mContext, userId, QSConstants.DYNAMIC_TILE_SU);
        final Context resourceContext = QSUtils.getQSTileContext(mContext, userId);
        CustomTile.ListExpandedStyle style = new CustomTile.ListExpandedStyle();
        ArrayList<CustomTile.ExpandedListItem> items = new ArrayList<>();
        for (String pkg : mSuController.getPackageNamesWithActiveSuSessions()) {
            CustomTile.ExpandedListItem item = new CustomTile.ExpandedListItem();
            int appIconIdentifier = getActiveSuApkDrawableId(pkg);
            if (appIconIdentifier != -1) {
                item.setExpandedListItemDrawable(appIconIdentifier);
            } else {
                item.setExpandedListItemDrawable(icon);
            }
            item.setExpandedListItemTitle(getActiveSuApkLabel(pkg));
            item.setExpandedListItemSummary(pkg);
            item.setExpandedListItemOnClickIntent(getCustomTilePendingIntent(pkg));
            items.add(item);
        }
        style.setListItems(items);
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(mContext);
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(contentDesc).setContentDescription(contentDesc).setIcon(icon).setOnSettingsClickIntent(getCustomTileSettingsIntent()).setExpandedStyle(style).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_SU, PhoneStatusBarPolicy.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private PendingIntent getCustomTilePendingIntent(String pkg) {
    Intent i = new Intent(Intent.ACTION_MAIN);
    i.setPackage(pkg);
    i.addCategory(Intent.CATEGORY_LAUNCHER);
    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    return PendingIntent.getActivity(mContext, 0, i, PendingIntent.FLAG_UPDATE_CURRENT, null);
}
#method_after
private PendingIntent getCustomTilePendingIntent(String pkg) {
    Intent i = new Intent(Intent.ACTION_MAIN);
    i.setPackage(pkg);
    i.addCategory(Intent.CATEGORY_LAUNCHER);
    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    return PendingIntent.getActivity(mContext, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
}
#end_block

#method_before
private void processQSChangedLocked() {
    final int userId = UserHandle.myUserId();
    final boolean hasSuAccess = mSuController.hasActiveSessions();
    final boolean isEnabledForUser = QSUtils.isQSTileEnabledForUser(mContext, QSConstants.DYNAMIC_TILE_SU, userId);
    boolean enabled = (userId == UserHandle.USER_OWNER) && isEnabledForUser && hasSuAccess;
    if (enabled) {
        publishSuCustomTile();
    } else {
        unpublishSuCustomTile();
    }
}
#method_after
private void processQSChangedLocked() {
    final int userId = UserHandle.myUserId();
    if (isSuEnabledForUser(userId)) {
        publishSuCustomTile();
    } else {
        unpublishSuCustomTile();
    }
}
#end_block

#method_before
private void setImplLocked(Alarm a, boolean rebatching, boolean doValidate) {
    if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
        // bring us out of idle at an earlier time.
        if (mNextWakeFromIdle != null && a.whenElapsed > mNextWakeFromIdle.whenElapsed) {
            a.when = a.whenElapsed = a.maxWhenElapsed = mNextWakeFromIdle.whenElapsed;
        }
        // Add fuzz to make the alarm go off some time before the actual desired time.
        final long nowElapsed = SystemClock.elapsedRealtime();
        final int fuzz = fuzzForDuration(a.whenElapsed - nowElapsed);
        if (fuzz > 0) {
            if (mRandom == null) {
                mRandom = new Random();
            }
            final int delta = mRandom.nextInt(fuzz);
            a.whenElapsed -= delta;
            if (false) {
                Slog.d(TAG, "Alarm when: " + a.whenElapsed);
                Slog.d(TAG, "Delta until alarm: " + (a.whenElapsed - nowElapsed));
                Slog.d(TAG, "Applied fuzz: " + fuzz);
                Slog.d(TAG, "Final delta: " + delta);
                Slog.d(TAG, "Final when: " + a.whenElapsed);
            }
            a.when = a.maxWhenElapsed = a.whenElapsed;
        }
    } else if (mPendingIdleUntil != null) {
        // not explicitly stated it wants to run while idle, then put it on hold.
        if ((a.flags & (AlarmManager.FLAG_ALLOW_WHILE_IDLE | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED | AlarmManager.FLAG_WAKE_FROM_IDLE)) == 0) {
            mPendingWhileIdleAlarms.add(a);
            return;
        }
    }
    int whichBatch = ((a.flags & AlarmManager.FLAG_STANDALONE) != 0) ? -1 : attemptCoalesceLocked(a.whenElapsed, a.maxWhenElapsed);
    if (whichBatch < 0) {
        Batch batch = new Batch(a);
        addBatchLocked(mAlarmBatches, batch);
    } else {
        Batch batch = mAlarmBatches.get(whichBatch);
        if (batch.add(a)) {
            // The start time of this batch advanced, so batch ordering may
            // have just been broken.  Move it to where it now belongs.
            mAlarmBatches.remove(whichBatch);
            addBatchLocked(mAlarmBatches, batch);
        }
    }
    if (a.alarmClock != null) {
        mNextAlarmClockMayChange = true;
        publishNextAlarmCustomTile(Process.myUid());
    }
    boolean needRebatch = false;
    if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
        mPendingIdleUntil = a;
        mConstants.updateAllowWhileIdleMinTimeLocked();
        needRebatch = true;
    } else if ((a.flags & AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) {
        if (mNextWakeFromIdle == null || mNextWakeFromIdle.whenElapsed > a.whenElapsed) {
            mNextWakeFromIdle = a;
            // until time needs to be updated.
            if (mPendingIdleUntil != null) {
                needRebatch = true;
            }
        }
    }
    if (!rebatching) {
        if (DEBUG_VALIDATE) {
            if (doValidate && !validateConsistencyLocked()) {
                Slog.v(TAG, "Tipping-point operation: type=" + a.type + " when=" + a.when + " when(hex)=" + Long.toHexString(a.when) + " whenElapsed=" + a.whenElapsed + " maxWhenElapsed=" + a.maxWhenElapsed + " interval=" + a.repeatInterval + " op=" + a.operation + " flags=0x" + Integer.toHexString(a.flags));
                rebatchAllAlarmsLocked(false);
                needRebatch = false;
            }
        }
        if (needRebatch) {
            rebatchAllAlarmsLocked(false);
        }
        rescheduleKernelAlarmsLocked();
        updateNextAlarmClockLocked();
    }
}
#method_after
private void setImplLocked(Alarm a, boolean rebatching, boolean doValidate) {
    if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
        // bring us out of idle at an earlier time.
        if (mNextWakeFromIdle != null && a.whenElapsed > mNextWakeFromIdle.whenElapsed) {
            a.when = a.whenElapsed = a.maxWhenElapsed = mNextWakeFromIdle.whenElapsed;
        }
        // Add fuzz to make the alarm go off some time before the actual desired time.
        final long nowElapsed = SystemClock.elapsedRealtime();
        final int fuzz = fuzzForDuration(a.whenElapsed - nowElapsed);
        if (fuzz > 0) {
            if (mRandom == null) {
                mRandom = new Random();
            }
            final int delta = mRandom.nextInt(fuzz);
            a.whenElapsed -= delta;
            if (false) {
                Slog.d(TAG, "Alarm when: " + a.whenElapsed);
                Slog.d(TAG, "Delta until alarm: " + (a.whenElapsed - nowElapsed));
                Slog.d(TAG, "Applied fuzz: " + fuzz);
                Slog.d(TAG, "Final delta: " + delta);
                Slog.d(TAG, "Final when: " + a.whenElapsed);
            }
            a.when = a.maxWhenElapsed = a.whenElapsed;
        }
    } else if (mPendingIdleUntil != null) {
        // not explicitly stated it wants to run while idle, then put it on hold.
        if ((a.flags & (AlarmManager.FLAG_ALLOW_WHILE_IDLE | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED | AlarmManager.FLAG_WAKE_FROM_IDLE)) == 0) {
            mPendingWhileIdleAlarms.add(a);
            return;
        }
    }
    int whichBatch = ((a.flags & AlarmManager.FLAG_STANDALONE) != 0) ? -1 : attemptCoalesceLocked(a.whenElapsed, a.maxWhenElapsed);
    if (whichBatch < 0) {
        Batch batch = new Batch(a);
        addBatchLocked(mAlarmBatches, batch);
    } else {
        Batch batch = mAlarmBatches.get(whichBatch);
        if (batch.add(a)) {
            // The start time of this batch advanced, so batch ordering may
            // have just been broken.  Move it to where it now belongs.
            mAlarmBatches.remove(whichBatch);
            addBatchLocked(mAlarmBatches, batch);
        }
    }
    if (a.alarmClock != null) {
        mNextAlarmClockMayChange = true;
        // Publish as system user
        publishNextAlarmCustomTile(Process.SYSTEM_UID);
    }
    boolean needRebatch = false;
    if ((a.flags & AlarmManager.FLAG_IDLE_UNTIL) != 0) {
        mPendingIdleUntil = a;
        mConstants.updateAllowWhileIdleMinTimeLocked();
        needRebatch = true;
    } else if ((a.flags & AlarmManager.FLAG_WAKE_FROM_IDLE) != 0) {
        if (mNextWakeFromIdle == null || mNextWakeFromIdle.whenElapsed > a.whenElapsed) {
            mNextWakeFromIdle = a;
            // until time needs to be updated.
            if (mPendingIdleUntil != null) {
                needRebatch = true;
            }
        }
    }
    if (!rebatching) {
        if (DEBUG_VALIDATE) {
            if (doValidate && !validateConsistencyLocked()) {
                Slog.v(TAG, "Tipping-point operation: type=" + a.type + " when=" + a.when + " when(hex)=" + Long.toHexString(a.when) + " whenElapsed=" + a.whenElapsed + " maxWhenElapsed=" + a.maxWhenElapsed + " interval=" + a.repeatInterval + " op=" + a.operation + " flags=0x" + Integer.toHexString(a.flags));
                rebatchAllAlarmsLocked(false);
                needRebatch = false;
            }
        }
        if (needRebatch) {
            rebatchAllAlarmsLocked(false);
        }
        rescheduleKernelAlarmsLocked();
        updateNextAlarmClockLocked();
    }
}
#end_block

#method_before
private void publishNextAlarmCustomTile(int userId) {
    // This action should be performed as system
    long token = Binder.clearCallingIdentity();
    try {
        if (!QSUtils.isQSTileEnabledForUser(getContext(), QSConstants.DYNAMIC_TILE_NEXT_ALARM, userId)) {
            return;
        }
        final UserHandle user = new UserHandle(userId);
        final int icon = QSUtils.getDynamicQSTileResIconId(getContext(), userId, QSConstants.DYNAMIC_TILE_NEXT_ALARM);
        final String contentDesc = QSUtils.getDynamicQSTileLabel(getContext(), userId, QSConstants.DYNAMIC_TILE_NEXT_ALARM);
        final Context resourceContext = QSUtils.getQSTileContext(getContext(), userId);
        // Create the expanded view with all the user alarms
        AlarmManager.AlarmClockInfo nextAlarm = null;
        CustomTile.ListExpandedStyle style = new CustomTile.ListExpandedStyle();
        ArrayList<CustomTile.ExpandedListItem> items = new ArrayList<>();
        for (Alarm alarm : getAllUserAlarmsLocked(userId)) {
            if (nextAlarm == null) {
                nextAlarm = alarm.alarmClock;
            }
            final String pkg = alarm.operation.getCreatorPackage();
            CustomTile.ExpandedListItem item = new CustomTile.ExpandedListItem();
            item.setExpandedListItemDrawable(icon);
            item.setExpandedListItemTitle(formatNextAlarm(getContext(), alarm.alarmClock, userId));
            item.setExpandedListItemSummary(getAlarmApkLabel(pkg));
            item.setExpandedListItemOnClickIntent(getCustomTilePendingIntent(user, pkg));
            items.add(item);
        }
        style.setListItems(items);
        // Build the custom tile
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(getContext());
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(formatNextAlarm(getContext(), nextAlarm, userId)).setContentDescription(contentDesc).setIcon(icon).setExpandedStyle(style).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_NEXT_ALARM, AlarmManagerService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
private void publishNextAlarmCustomTile(int userId) {
    // This action should be performed as system
    long token = Binder.clearCallingIdentity();
    try {
        final UserHandle user = new UserHandle(userId);
        if (!QSUtils.isQSTileEnabledForUser(getContext(), QSConstants.DYNAMIC_TILE_NEXT_ALARM, user.getUserId(userId))) {
            return;
        }
        final int icon = QSUtils.getDynamicQSTileResIconId(getContext(), userId, QSConstants.DYNAMIC_TILE_NEXT_ALARM);
        final String contentDesc = QSUtils.getDynamicQSTileLabel(getContext(), userId, QSConstants.DYNAMIC_TILE_NEXT_ALARM);
        final Context resourceContext = QSUtils.getQSTileContext(getContext(), userId);
        // Create the expanded view with all the user alarms
        AlarmManager.AlarmClockInfo nextAlarm = null;
        CustomTile.ListExpandedStyle style = new CustomTile.ListExpandedStyle();
        ArrayList<CustomTile.ExpandedListItem> items = new ArrayList<>();
        for (Alarm alarm : getAllUserAlarmsLocked(userId)) {
            if (nextAlarm == null) {
                nextAlarm = alarm.alarmClock;
            }
            final String pkg = alarm.operation.getCreatorPackage();
            CustomTile.ExpandedListItem item = new CustomTile.ExpandedListItem();
            item.setExpandedListItemDrawable(icon);
            item.setExpandedListItemTitle(formatNextAlarm(getContext(), alarm.alarmClock, userId));
            item.setExpandedListItemSummary(getAlarmApkLabel(pkg));
            item.setExpandedListItemOnClickIntent(getCustomTilePendingIntent(user, pkg));
            items.add(item);
        }
        style.setListItems(items);
        // Build the custom tile
        CMStatusBarManager statusBarManager = CMStatusBarManager.getInstance(getContext());
        CustomTile tile = new CustomTile.Builder(resourceContext).setLabel(formatNextAlarm(getContext(), nextAlarm, userId)).setContentDescription(contentDesc).setIcon(icon).setExpandedStyle(style).build();
        statusBarManager.publishTileAsUser(QSConstants.DYNAMIC_TILE_NEXT_ALARM, AlarmManagerService.class.hashCode(), tile, user);
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
private final void updatePrivacyGuardNotificationLocked(ActivityRecord next) {
    String privacyGuardPackageName = mStackSupervisor.mPrivacyGuardPackageName;
    if (privacyGuardPackageName != null && privacyGuardPackageName.equals(next.packageName)) {
        return;
    }
    boolean privacy = mService.mAppOpsService.getPrivacyGuardSettingForPackage(next.app.uid, next.packageName);
    boolean privacyNotification = (Settings.Secure.getInt(mService.mContext.getContentResolver(), Settings.Secure.PRIVACY_GUARD_NOTIFICATION, 1) == 1);
    if (privacyGuardPackageName != null && !privacy) {
        Message msg = mService.mHandler.obtainMessage(ActivityManagerService.CANCEL_PRIVACY_NOTIFICATION_MSG, next.userId);
        msg.sendToTarget();
        mStackSupervisor.mPrivacyGuardPackageName = null;
    } else if (privacy && privacyNotification) {
        Message msg = mService.mHandler.obtainMessage(ActivityManagerService.POST_PRIVACY_NOTIFICATION_MSG, next);
        msg.sendToTarget();
        mStackSupervisor.mPrivacyGuardPackageName = next.packageName;
    }
}
#method_after
private final void updatePrivacyGuardNotificationLocked(ActivityRecord next) {
    String privacyGuardPackageName = mStackSupervisor.mPrivacyGuardPackageName;
    if (privacyGuardPackageName != null && privacyGuardPackageName.equals(next.packageName)) {
        return;
    }
    boolean privacy = mService.mAppOpsService.getPrivacyGuardSettingForPackage(next.app.uid, next.packageName);
    boolean privacyNotification = (CMSettings.Secure.getInt(mService.mContext.getContentResolver(), CMSettings.Secure.PRIVACY_GUARD_NOTIFICATION, 1) == 1);
    if (privacyGuardPackageName != null && !privacy) {
        Message msg = mService.mHandler.obtainMessage(ActivityManagerService.CANCEL_PRIVACY_NOTIFICATION_MSG, next.userId);
        msg.sendToTarget();
        mStackSupervisor.mPrivacyGuardPackageName = null;
    } else if (privacy && privacyNotification) {
        Message msg = mService.mHandler.obtainMessage(ActivityManagerService.POST_PRIVACY_NOTIFICATION_MSG, next);
        msg.sendToTarget();
        mStackSupervisor.mPrivacyGuardPackageName = next.packageName;
    }
}
#end_block

#method_before
private int getActiveStreamType(int suggestedStreamType) {
    switch(mPlatformType) {
        case AudioSystem.PLATFORM_VOICE:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(StreamOverride.sDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlRingStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
                        return AudioSystem.STREAM_RING;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default");
                        return AudioSystem.STREAM_MUSIC;
                    }
                }
            } else if (isAfMusicActiveRecently(0)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        case AudioSystem.PLATFORM_TELEVISION:
            if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                // TV always defaults to STREAM_MUSIC
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        default:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION, StreamOverride.sDelayMs) || AudioSystem.isStreamActive(AudioSystem.STREAM_RING, StreamOverride.sDelayMs)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
                return AudioSystem.STREAM_NOTIFICATION;
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(StreamOverride.sDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: forcing STREAM_MUSIC");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlRingStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION b/c default");
                        return AudioSystem.STREAM_NOTIFICATION;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default");
                        return AudioSystem.STREAM_MUSIC;
                    }
                }
            }
            break;
    }
    if (DEBUG_VOL)
        Log.v(TAG, "getActiveStreamType: Returning suggested type " + suggestedStreamType);
    return suggestedStreamType;
}
#method_after
private int getActiveStreamType(int suggestedStreamType) {
    switch(mPlatformType) {
        case AudioSystem.PLATFORM_VOICE:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO...");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    // Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL...");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(StreamOverride.sDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlRingStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_RING b/c default");
                        return AudioSystem.STREAM_RING;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default");
                        return AudioSystem.STREAM_MUSIC;
                    }
                }
            } else if (isAfMusicActiveRecently(0)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC stream active");
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        case AudioSystem.PLATFORM_TELEVISION:
            if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                // TV always defaults to STREAM_MUSIC
                return AudioSystem.STREAM_MUSIC;
            }
            break;
        default:
            if (isInCommunication()) {
                if (AudioSystem.getForceUse(AudioSystem.FOR_COMMUNICATION) == AudioSystem.FORCE_BT_SCO) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_BLUETOOTH_SCO");
                    return AudioSystem.STREAM_BLUETOOTH_SCO;
                } else {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: Forcing STREAM_VOICE_CALL");
                    return AudioSystem.STREAM_VOICE_CALL;
                }
            } else if (AudioSystem.isStreamActive(AudioSystem.STREAM_NOTIFICATION, StreamOverride.sDelayMs) || AudioSystem.isStreamActive(AudioSystem.STREAM_RING, StreamOverride.sDelayMs)) {
                if (DEBUG_VOL)
                    Log.v(TAG, "getActiveStreamType: Forcing STREAM_NOTIFICATION");
                return AudioSystem.STREAM_NOTIFICATION;
            } else if (suggestedStreamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
                if (isAfMusicActiveRecently(StreamOverride.sDelayMs)) {
                    if (DEBUG_VOL)
                        Log.v(TAG, "getActiveStreamType: forcing STREAM_MUSIC");
                    return AudioSystem.STREAM_MUSIC;
                } else {
                    if (mVolumeKeysControlRingStream) {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: using STREAM_NOTIFICATION as default");
                        return AudioSystem.STREAM_NOTIFICATION;
                    } else {
                        if (DEBUG_VOL)
                            Log.v(TAG, "getActiveStreamType: Forcing STREAM_MUSIC b/c default");
                        return AudioSystem.STREAM_MUSIC;
                    }
                }
            }
            break;
    }
    if (DEBUG_VOL)
        Log.v(TAG, "getActiveStreamType: Returning suggested type " + suggestedStreamType);
    return suggestedStreamType;
}
#end_block

#method_before
private List<UEventInfo> makeObservedUEventList() {
    List<UEventInfo> retVal = new ArrayList<UEventInfo>();
    UEventInfo uei;
    // Monitor h2w
    if (!mUseDevInputEventForAudioJack) {
        uei = new UEventInfo(NAME_H2W, BIT_HEADSET, BIT_HEADSET_NO_MIC, BIT_LINEOUT);
        if (uei.checkSwitchExists()) {
            retVal.add(uei);
        } else {
            Slog.w(TAG, "This kernel does not have wired headset support");
        }
    }
    // Monitor USB
    uei = new UEventInfo(NAME_USB_AUDIO, BIT_USB_HEADSET_ANLG, BIT_USB_HEADSET_DGTL, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        Slog.w(TAG, "This kernel does not have usb audio support");
    }
    // Monitor Motorola EMU audio jack
    uei = new UEventInfo(NAME_EMU_AUDIO, BIT_USB_HEADSET_ANLG, 0, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        Slog.w(TAG, "This kernel does not have Motorola EMU audio support");
    }
    // Monitor Samsung USB audio
    uei = new UEventInfo(NAME_SAMSUNG_USB_AUDIO, BIT_USB_HEADSET_DGTL, BIT_USB_HEADSET_ANLG, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        Slog.w(TAG, "This kernel does not have samsung usb dock audio support");
    }
    // Monitor HDMI
    // 
    // If the kernel has support for the "hdmi_audio" switch, use that.  It will be
    // signalled only when the HDMI driver has a video mode configured, and the downstream
    // sink indicates support for audio in its EDID.
    // 
    // If the kernel does not have an "hdmi_audio" switch, just fall back on the older
    // "hdmi" switch instead.
    uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        uei = new UEventInfo(NAME_HDMI, BIT_HDMI_AUDIO, 0, 0);
        if (uei.checkSwitchExists()) {
            retVal.add(uei);
        } else {
            Slog.w(TAG, "This kernel does not have HDMI audio support");
        }
    }
    return retVal;
}
#method_after
private List<UEventInfo> makeObservedUEventList() {
    List<UEventInfo> retVal = new ArrayList<UEventInfo>();
    UEventInfo uei;
    // Monitor h2w
    if (!mUseDevInputEventForAudioJack) {
        uei = new UEventInfo(NAME_H2W, BIT_HEADSET, BIT_HEADSET_NO_MIC, BIT_LINEOUT);
        if (uei.checkSwitchExists()) {
            retVal.add(uei);
        } else {
            Slog.w(TAG, "This kernel does not have wired headset support");
        }
    }
    // Monitor USB
    uei = new UEventInfo(NAME_USB_AUDIO, BIT_USB_HEADSET_ANLG, BIT_USB_HEADSET_DGTL, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        Slog.w(TAG, "This kernel does not have usb audio support");
    }
    // Monitor Motorola EMU audio jack
    uei = new UEventInfo(NAME_EMU_AUDIO, BIT_USB_HEADSET_ANLG, 0, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    }
    // Monitor Samsung USB audio
    uei = new UEventInfo(NAME_SAMSUNG_USB_AUDIO, BIT_USB_HEADSET_DGTL, BIT_USB_HEADSET_ANLG, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        Slog.w(TAG, "This kernel does not have samsung usb dock audio support");
    }
    // Monitor HDMI
    // 
    // If the kernel has support for the "hdmi_audio" switch, use that.  It will be
    // signalled only when the HDMI driver has a video mode configured, and the downstream
    // sink indicates support for audio in its EDID.
    // 
    // If the kernel does not have an "hdmi_audio" switch, just fall back on the older
    // "hdmi" switch instead.
    uei = new UEventInfo(NAME_HDMI_AUDIO, BIT_HDMI_AUDIO, 0, 0);
    if (uei.checkSwitchExists()) {
        retVal.add(uei);
    } else {
        uei = new UEventInfo(NAME_HDMI, BIT_HDMI_AUDIO, 0, 0);
        if (uei.checkSwitchExists()) {
            retVal.add(uei);
        } else {
            Slog.w(TAG, "This kernel does not have HDMI audio support");
        }
    }
    return retVal;
}
#end_block

#method_before
private void initiateTileReset() {
    final AlertDialog d = new AlertDialog.Builder(mContext).setMessage(R.string.qs_tiles_reset_confirmation).setNegativeButton(R.string.cancel, null).setPositiveButton(com.android.internal.R.string.reset, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            mHost.resetTiles();
        }
    }).create();
    SystemUIDialog.makeSystemUIDialog(d);
    d.show();
}
#method_after
private void initiateTileReset() {
    final AlertDialog d = new AlertDialog.Builder(mContext).setMessage(R.string.qs_tiles_reset_confirmation).setNegativeButton(R.string.cancel, null).setPositiveButton(com.android.internal.R.string.reset, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            mHost.initiateReset();
        }
    }).create();
    SystemUIDialog.makeSystemUIDialog(d);
    d.show();
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources(null);
    mStatusBarWindowContent = (FrameLayout) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindowContent.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindowContent.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindowContent.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindowContent.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindowContent.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    if (mHeadsUpManager == null) {
        mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    }
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav && !mRecreating) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.updateResources(getNavbarThemedResources());
            mNavigationBarView.setDisabledFlags(mDisabled1);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mAssistManager == null) {
        mAssistManager = new AssistManager(this, context);
    }
    if (mNavigationBarView == null) {
        mAssistManager.onConfigurationChanged();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindowContent.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindowContent.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    FrameLayout scrimView = (FrameLayout) mStatusBarWindowContent.findViewById(R.id.scrimview);
    ScrimView scrimBehind = (ScrimView) scrimView.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindowContent.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindowContent.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mVisualizerView = (VisualizerView) scrimView.findViewById(R.id.visualizerview);
    mHeader = (StatusBarHeaderView) mStatusBarWindowContent.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindowContent.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindowContent.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindowContent.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindowContent.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    if (mLocationController == null) {
        mLocationController = new LocationControllerImpl(mContext, // will post a notification
        mHandlerThread.getLooper());
    }
    if (mBatteryController == null) {
        mBatteryController = new BatteryController(mContext, mHandler);
        mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

            @Override
            public void onPowerSaveChanged() {
                mHandler.post(mCheckBarModes);
                if (mDozeServiceHost != null) {
                    mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
                }
            }

            @Override
            public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
            // noop
            }

            @Override
            public void onBatteryStyleChanged(int style, int percentMode) {
            // noop
            }
        });
    }
    if (mNetworkController == null) {
        mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mHotspotController == null) {
        mHotspotController = new HotspotControllerImpl(mContext);
    }
    if (mBluetoothController == null) {
        mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mSecurityController == null) {
        mSecurityController = new SecurityControllerImpl(mContext);
    }
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        if (mRotationLockController == null) {
            mRotationLockController = new RotationLockControllerImpl(mContext);
        }
    }
    if (mUserInfoController == null) {
        mUserInfoController = new UserInfoController(mContext);
    }
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        if (mZenModeController == null) {
            mZenModeController = mVolumeComponent.getZenController();
        }
    }
    if (mCastController == null) {
        mCastController = new CastControllerImpl(mContext);
    }
    if (mSuController == null) {
        mSuController = new SuControllerImpl(mContext);
    }
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    if (mFlashlightController == null) {
        mFlashlightController = new FlashlightController(mContext);
    }
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    if (mAccessibilityController == null) {
        mAccessibilityController = new AccessibilityController(mContext);
    }
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    if (mNextAlarmController == null) {
        mNextAlarmController = new NextAlarmController(mContext);
    }
    if (mKeyguardMonitor == null) {
        mKeyguardMonitor = new KeyguardMonitor(mContext);
    }
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        if (mUserSwitcherController == null) {
            mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
        }
    }
    if (mWeatherController == null) {
        mWeatherController = new WeatherControllerImpl(mContext);
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindowContent.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSDragPanel) mStatusBarWindowContent.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        if (mQSTileHost == null) {
            mQSTileHost = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        }
        mQSPanel.setHost(mQSTileHost);
        if (mBrightnessMirrorController == null) {
            mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindowContent);
        }
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        mQSTileHost.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.setTiles(mQSTileHost.getTiles());
                    }
                });
            }

            @Override
            public void setEditing(final boolean editing) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.setEditing(editing);
                        mHeader.setEditing(editing);
                    }
                });
            }

            @Override
            public boolean isEditing() {
                return mQSPanel.isEditing();
            }

            @Override
            public void goToSettingsPage() {
                setEditing(true);
                mHandler.postDelayed(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.goToSettingsPage();
                    }
                }, 500);
            }
        });
    }
    // Set up the initial custom tile listener state.
    try {
        mCustomTileListenerService.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register custom tile listener", e);
    }
    mQSPanel.getHost().setCustomTileListenerService(mCustomTileListenerService);
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    BatteryMeterView batteryMeterView = ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery));
    batteryMeterView.setBatteryController(mBatteryController);
    batteryMeterView.setAnimationsEnabled(false);
    ((BatteryLevelTextView) mStatusBarView.findViewById(R.id.battery_level_text)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mVisualizerView.setKeyguardMonitor(mKeyguardMonitor);
    mHeader.setNextAlarmController(mNextAlarmController);
    mHeader.setWeatherController(mWeatherController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_KEYGUARD_WALLPAPER_CHANGED);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // receive broadcasts for packages
    IntentFilter packageFilter = new IntentFilter();
    packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_FULLY_REMOVED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    packageFilter.addDataScheme("package");
    context.registerReceiver(mPackageBroadcastReceiver, packageFilter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources(null);
    mStatusBarWindowContent = (FrameLayout) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindowContent.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindowContent.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindowContent.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindowContent.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindowContent.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    if (mHeadsUpManager == null) {
        mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    }
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav && !mRecreating) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.updateResources(getNavbarThemedResources());
            mNavigationBarView.setDisabledFlags(mDisabled1);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

                @Override
                public void onVerticalChanged(boolean isVertical) {
                    if (mAssistManager != null) {
                        mAssistManager.onConfigurationChanged();
                    }
                    mNotificationPanel.setQsScrimEnabled(!isVertical);
                }
            });
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mAssistManager == null) {
        mAssistManager = new AssistManager(this, context);
    }
    if (mNavigationBarView == null) {
        mAssistManager.onConfigurationChanged();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindowContent.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindowContent.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    FrameLayout scrimView = (FrameLayout) mStatusBarWindowContent.findViewById(R.id.scrimview);
    ScrimView scrimBehind = (ScrimView) scrimView.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindowContent.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindowContent.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mVisualizerView = (VisualizerView) scrimView.findViewById(R.id.visualizerview);
    mHeader = (StatusBarHeaderView) mStatusBarWindowContent.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindowContent.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindowContent.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindowContent.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindowContent.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    // Other icons
    if (mLocationController == null) {
        mLocationController = new LocationControllerImpl(mContext, // will post a notification
        mHandlerThread.getLooper());
    }
    if (mBatteryController == null) {
        mBatteryController = new BatteryController(mContext, mHandler);
        mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

            @Override
            public void onPowerSaveChanged() {
                mHandler.post(mCheckBarModes);
                if (mDozeServiceHost != null) {
                    mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
                }
            }

            @Override
            public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
            // noop
            }

            @Override
            public void onBatteryStyleChanged(int style, int percentMode) {
            // noop
            }
        });
    }
    if (mNetworkController == null) {
        mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mHotspotController == null) {
        mHotspotController = new HotspotControllerImpl(mContext);
    }
    if (mBluetoothController == null) {
        mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mSecurityController == null) {
        mSecurityController = new SecurityControllerImpl(mContext);
    }
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        if (mRotationLockController == null) {
            mRotationLockController = new RotationLockControllerImpl(mContext);
        }
    }
    if (mUserInfoController == null) {
        mUserInfoController = new UserInfoController(mContext);
    }
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        if (mZenModeController == null) {
            mZenModeController = mVolumeComponent.getZenController();
        }
    }
    if (mCastController == null) {
        mCastController = new CastControllerImpl(mContext);
    }
    if (mSuController == null) {
        mSuController = new SuControllerImpl(mContext);
    }
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    if (mFlashlightController == null) {
        mFlashlightController = new FlashlightController(mContext);
    }
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    if (mAccessibilityController == null) {
        mAccessibilityController = new AccessibilityController(mContext);
    }
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    if (mNextAlarmController == null) {
        mNextAlarmController = new NextAlarmController(mContext);
    }
    if (mKeyguardMonitor == null) {
        mKeyguardMonitor = new KeyguardMonitor(mContext);
    }
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        if (mUserSwitcherController == null) {
            mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
        }
    }
    if (mWeatherController == null) {
        mWeatherController = new WeatherControllerImpl(mContext);
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindowContent.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSDragPanel) mStatusBarWindowContent.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        if (mQSTileHost == null) {
            mQSTileHost = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        }
        mQSPanel.setHost(mQSTileHost);
        if (mBrightnessMirrorController == null) {
            mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindowContent);
        }
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        mQSTileHost.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.setTiles(mQSTileHost.getTiles());
                    }
                });
            }

            @Override
            public void setEditing(final boolean editing) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.setEditing(editing);
                        mHeader.setEditing(editing);
                    }
                });
            }

            @Override
            public boolean isEditing() {
                return mQSPanel.isEditing();
            }

            @Override
            public void goToSettingsPage() {
                setEditing(true);
                mHandler.postDelayed(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.goToSettingsPage();
                    }
                }, 500);
            }

            @Override
            public void resetTiles() {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mQSPanel.setEditing(false);
                        mHeader.setEditing(false);
                        // callbacks from custom tiles
                        try {
                            mCustomTileListenerService.unregisterAsSystemService();
                        } catch (RemoteException e) {
                            Log.e(TAG, "Unable to unregister custom tile listener", e);
                        }
                        // clear out old tile states and views
                        mQSPanel.setTiles(new ArrayList<QSTile<?>>());
                        mQSTileHost.resetTiles();
                        // reregister service
                        try {
                            mCustomTileListenerService.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), PhoneStatusBar.this.getClass().getCanonicalName()), UserHandle.USER_ALL);
                        } catch (RemoteException e) {
                            Log.e(TAG, "Unable to register custom tile listener", e);
                        }
                    }
                });
            }
        });
    }
    // Set up the initial custom tile listener state.
    try {
        mCustomTileListenerService.registerAsSystemService(mContext, new ComponentName(mContext.getPackageName(), getClass().getCanonicalName()), UserHandle.USER_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "Unable to register custom tile listener", e);
    }
    mQSPanel.getHost().setCustomTileListenerService(mCustomTileListenerService);
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    BatteryMeterView batteryMeterView = ((BatteryMeterView) mStatusBarView.findViewById(R.id.battery));
    batteryMeterView.setBatteryController(mBatteryController);
    batteryMeterView.setAnimationsEnabled(false);
    ((BatteryLevelTextView) mStatusBarView.findViewById(R.id.battery_level_text)).setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mVisualizerView.setKeyguardMonitor(mKeyguardMonitor);
    mHeader.setNextAlarmController(mNextAlarmController);
    mHeader.setWeatherController(mWeatherController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_KEYGUARD_WALLPAPER_CHANGED);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // receive broadcasts for packages
    IntentFilter packageFilter = new IntentFilter();
    packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_FULLY_REMOVED);
    packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    packageFilter.addDataScheme("package");
    context.registerReceiver(mPackageBroadcastReceiver, packageFilter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
        case MSG_UPDATE_NOTIFICATIONS:
            handleUpdateNotifications();
            break;
    }
}
#end_block

#method_before
@Override
protected void setupViews() {
    updateResources();
    mDetail = LayoutInflater.from(mContext).inflate(R.layout.qs_detail, this, false);
    mDetailContent = (ViewGroup) mDetail.findViewById(android.R.id.content);
    mDetailRemoveButton = (TextView) mDetail.findViewById(android.R.id.button3);
    mDetailSettingsButton = (TextView) mDetail.findViewById(android.R.id.button2);
    mDetailDoneButton = (TextView) mDetail.findViewById(android.R.id.button1);
    updateDetailText();
    mDetail.setVisibility(GONE);
    mDetail.setClickable(true);
    mQsPanelTop = (QSPanelTopView) LayoutInflater.from(mContext).inflate(R.layout.qs_tile_top, this, false);
    // tint trash can to default color
    final int color = mContext.getColor(R.color.qs_tile_trash);
    DrawableCompat.setTint(mQsPanelTop.getDropTargetIcon().getDrawable(), color);
    mBrightnessView = mQsPanelTop.getBrightnessView();
    mFooter = new QSFooter(this, mContext);
    // add target click listener
    mQsPanelTop.getAddTarget().setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            TilesListAdapter adapter = new TilesListAdapter(mContext, QSDragPanel.this);
            showDetailAdapter(true, adapter, v.getLocationOnScreen());
            mDetail.bringToFront();
        }
    });
    mViewPager = new QSViewPager(getContext());
    mViewPager.setDragPanel(this);
    mPageIndicator = new CirclePageIndicator(getContext());
    addView(mDetail);
    addView(mQsPanelTop);
    addView(mViewPager);
    addView(mPageIndicator);
    addView(mFooter.getView());
    mClipper = new QSDetailClipper(mDetail);
    mBrightnessController = new BrightnessController(getContext(), (ImageView) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_icon), (ToggleSlider) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_slider));
    mDetailDoneButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            announceForAccessibility(mContext.getString(R.string.accessibility_desc_quick_settings));
            closeDetail();
        }
    });
    mPagerAdapter = new PagerAdapter() {

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            if (DEBUG_TILES) {
                Log.d(TAG, "instantiateItem() called with " + "container = [" + container + "], position = [" + position + "]");
            }
            if (mEditing && position == 0) {
                QSSettings qss = (QSSettings) View.inflate(container.getContext(), R.layout.qs_settings, null);
                qss.setHost(mHost);
                container.addView(qss, 0);
                return qss;
            } else {
                final int adjustedPosition = mEditing ? position - 1 : position;
                QSPage page = mPages.get(adjustedPosition);
                container.addView(page, position);
                return page;
            }
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (DEBUG_TILES) {
                Log.d(TAG, "destroyItem() called with " + "container = [" + container + "], position = [" + position + "], object = [" + object + "]");
            }
            if (object instanceof View) {
                container.removeView((View) object);
            }
        }

        @Override
        public int getItemPosition(Object object) {
            if (object instanceof QSPage) {
                if (mEditing != ((QSPage) object).mAdapterEditingState) {
                    // position of item changes when we set change the editing mode,
                    // sync it and send the new position
                    ((QSPage) object).mAdapterEditingState = mEditing;
                    // calculate new position
                    int indexOf = ((QSPage) object).getPageIndex();
                    if (mEditing)
                        return indexOf + 1;
                    else
                        return indexOf;
                } else if (!mPages.contains(object) && !mDragging) {
                    // we don't want to prematurely remove this page
                    return POSITION_NONE;
                } else {
                    return POSITION_UNCHANGED;
                }
            } else if (object instanceof QSSettings) {
                if (((QSSettings) object).mAdapterEditingState != mEditing) {
                    ((QSSettings) object).mAdapterEditingState = mEditing;
                    if (mEditing)
                        return 0;
                    else
                        return POSITION_NONE;
                } else {
                    return POSITION_UNCHANGED;
                }
            }
            return super.getItemPosition(object);
        }

        @Override
        public int getCount() {
            final int qsPages = Math.max(getCurrentMaxPageCount(), 1);
            if (mPages != null && qsPages > mPages.size()) {
                for (int i = mPages.size(); i < qsPages; i++) {
                    mPages.add(i, new QSPage(mViewPager.getContext(), QSDragPanel.this, i));
                }
            }
            if (mEditing)
                return qsPages + 1;
            return qsPages;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }
    };
    mViewPager.setAdapter(mPagerAdapter);
    mPageIndicator.setViewPager(mViewPager);
    mPageIndicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            if (DEBUG_DRAG) {
                Log.i(TAG, "onPageScrolled() called with " + "position = [" + position + "], positionOffset = [" + positionOffset + "], positionOffsetPixels = [" + positionOffsetPixels + "]");
            }
            if (mEditing) {
                float targetTranslationX = 0;
                // targetTranslationX = where it's supposed to be - diff
                int homeLocation = mViewPager.getMeasuredWidth();
                // how far away from homeLocation is the scroll?
                if (positionOffsetPixels < homeLocation && position == 0) {
                    targetTranslationX = homeLocation - positionOffsetPixels;
                }
                mQsPanelTop.setTranslationX(targetTranslationX);
            }
        }

        @Override
        public void onPageSelected(int position) {
            if (mDragging && position != mDraggingRecord.page && !mViewPager.isFakeDragging() && !mRestoring) {
                if (DEBUG_DRAG) {
                    Log.w(TAG, "moving drag record to page: " + position);
                }
                // remove it from the previous page and add it here
                final QSPage sourceP = getPage(mDraggingRecord.page);
                final QSPage targetP = getPage(position);
                sourceP.removeView(mDraggingRecord.tileView);
                mDraggingRecord.page = position;
                targetP.addView(mDraggingRecord.tileView);
                // set coords off screen until we're ready to place it
                mDraggingRecord.tileView.setX(-mDraggingRecord.tileView.getMeasuredWidth());
                mDraggingRecord.tileView.setY(-mDraggingRecord.tileView.getMeasuredHeight());
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    });
    mViewPager.setOverScrollMode(OVER_SCROLL_NEVER);
    setClipChildren(false);
    mSettingsObserver = new SettingsObserver(new Handler());
    mViewPager.setOnDragListener(QSDragPanel.this);
    mQsPanelTop.setOnDragListener(QSDragPanel.this);
    mPageIndicator.setOnDragListener(QSDragPanel.this);
    setOnDragListener(QSDragPanel.this);
    mViewPager.setOverScrollMode(View.OVER_SCROLL_NEVER);
}
#method_after
@Override
protected void setupViews() {
    updateResources();
    mDetail = LayoutInflater.from(mContext).inflate(R.layout.qs_detail, this, false);
    mDetailContent = (ViewGroup) mDetail.findViewById(android.R.id.content);
    mDetailRemoveButton = (TextView) mDetail.findViewById(android.R.id.button3);
    mDetailSettingsButton = (TextView) mDetail.findViewById(android.R.id.button2);
    mDetailDoneButton = (TextView) mDetail.findViewById(android.R.id.button1);
    updateDetailText();
    mDetail.setVisibility(GONE);
    mDetail.setClickable(true);
    mQsPanelTop = (QSPanelTopView) LayoutInflater.from(mContext).inflate(R.layout.qs_tile_top, this, false);
    // tint trash can to default color
    final int color = mContext.getColor(R.color.qs_tile_trash);
    DrawableCompat.setTint(mQsPanelTop.getDropTargetIcon().getDrawable(), color);
    mBrightnessView = mQsPanelTop.getBrightnessView();
    mFooter = new QSFooter(this, mContext);
    // add target click listener
    mQsPanelTop.getAddTarget().setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            TilesListAdapter adapter = new TilesListAdapter(mContext, QSDragPanel.this);
            showDetailAdapter(true, adapter, v.getLocationOnScreen());
            mDetail.bringToFront();
        }
    });
    mViewPager = new QSViewPager(getContext());
    mViewPager.setDragPanel(this);
    mPageIndicator = new CirclePageIndicator(getContext());
    addView(mDetail);
    addView(mQsPanelTop);
    addView(mViewPager);
    addView(mPageIndicator);
    addView(mFooter.getView());
    mClipper = new QSDetailClipper(mDetail);
    mBrightnessController = new BrightnessController(getContext(), (ImageView) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_icon), (ToggleSlider) mQsPanelTop.getBrightnessView().findViewById(R.id.brightness_slider));
    mDetailDoneButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            announceForAccessibility(mContext.getString(R.string.accessibility_desc_quick_settings));
            closeDetail();
        }
    });
    mPagerAdapter = new PagerAdapter() {

        @Override
        public Object instantiateItem(ViewGroup container, int position) {
            if (DEBUG_TILES) {
                Log.d(TAG, "instantiateItem() called with " + "container = [" + container + "], position = [" + position + "]");
            }
            if (mEditing && position == 0) {
                QSSettings qss = (QSSettings) View.inflate(container.getContext(), R.layout.qs_settings, null);
                qss.setHost(mHost);
                container.addView(qss, 0);
                return qss;
            } else {
                final int adjustedPosition = mEditing ? position - 1 : position;
                QSPage page = mPages.get(adjustedPosition);
                container.addView(page, position);
                return page;
            }
        }

        @Override
        public void destroyItem(ViewGroup container, int position, Object object) {
            if (DEBUG_TILES) {
                Log.d(TAG, "destroyItem() called with " + "container = [" + container + "], position = [" + position + "], object = [" + object + "]");
            }
            if (object instanceof View) {
                container.removeView((View) object);
            }
        }

        @Override
        public int getItemPosition(Object object) {
            if (object instanceof QSPage) {
                if (mEditing != ((QSPage) object).getAdapterEditingState()) {
                    // position of item changes when we set change the editing mode,
                    // sync it and send the new position
                    ((QSPage) object).setAdapterEditingState(mEditing);
                    // calculate new position
                    int indexOf = ((QSPage) object).getPageIndex();
                    if (mEditing)
                        return indexOf + 1;
                    else
                        return indexOf;
                } else if (!mPages.contains(object) && !mDragging) {
                    // we don't want to prematurely remove this page
                    return POSITION_NONE;
                } else {
                    return POSITION_UNCHANGED;
                }
            } else if (object instanceof QSSettings) {
                if (((QSSettings) object).getAdapterEditingState() != mEditing) {
                    ((QSSettings) object).setAdapterEditingState(mEditing);
                    if (mEditing)
                        return 0;
                    else
                        return POSITION_NONE;
                } else {
                    return POSITION_UNCHANGED;
                }
            }
            return super.getItemPosition(object);
        }

        @Override
        public int getCount() {
            final int qsPages = Math.max(getCurrentMaxPageCount(), 1);
            if (mPages != null && qsPages > mPages.size()) {
                for (int i = mPages.size(); i < qsPages; i++) {
                    mPages.add(i, new QSPage(mViewPager.getContext(), QSDragPanel.this, i));
                }
            }
            if (mEditing)
                return qsPages + 1;
            return qsPages;
        }

        @Override
        public boolean isViewFromObject(View view, Object object) {
            return view == object;
        }
    };
    mViewPager.setAdapter(mPagerAdapter);
    mPageIndicator.setViewPager(mViewPager);
    mPageIndicator.setOnPageChangeListener(new ViewPager.OnPageChangeListener() {

        @Override
        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
            if (DEBUG_DRAG) {
                Log.i(TAG, "onPageScrolled() called with " + "position = [" + position + "], positionOffset = [" + positionOffset + "], positionOffsetPixels = [" + positionOffsetPixels + "]");
            }
            if (mEditing) {
                float targetTranslationX = 0;
                // targetTranslationX = where it's supposed to be - diff
                int homeLocation = mViewPager.getMeasuredWidth();
                // how far away from homeLocation is the scroll?
                if (positionOffsetPixels < homeLocation && position == 0) {
                    targetTranslationX = homeLocation - positionOffsetPixels;
                }
                mQsPanelTop.setTranslationX(targetTranslationX);
            }
        }

        @Override
        public void onPageSelected(int position) {
            if (mDragging && position != mDraggingRecord.page && !mViewPager.isFakeDragging() && !mRestoring) {
                if (DEBUG_DRAG) {
                    Log.w(TAG, "moving drag record to page: " + position);
                }
                // remove it from the previous page and add it here
                final QSPage sourceP = getPage(mDraggingRecord.page);
                final QSPage targetP = getPage(position);
                sourceP.removeView(mDraggingRecord.tileView);
                mDraggingRecord.page = position;
                targetP.addView(mDraggingRecord.tileView);
                // set coords off screen until we're ready to place it
                mDraggingRecord.tileView.setX(-mDraggingRecord.tileView.getMeasuredWidth());
                mDraggingRecord.tileView.setY(-mDraggingRecord.tileView.getMeasuredHeight());
            }
        }

        @Override
        public void onPageScrollStateChanged(int state) {
        }
    });
    mViewPager.setOverScrollMode(OVER_SCROLL_NEVER);
    setClipChildren(false);
    mSettingsObserver = new SettingsObserver(new Handler());
    mViewPager.setOnDragListener(QSDragPanel.this);
    mQsPanelTop.setOnDragListener(QSDragPanel.this);
    mPageIndicator.setOnDragListener(QSDragPanel.this);
    setOnDragListener(QSDragPanel.this);
    mViewPager.setOverScrollMode(View.OVER_SCROLL_NEVER);
}
#end_block

#method_before
public void ensurePagerState() {
    Log.i(TAG, "+++   ensurePagerState()");
    if (!isShowingDetail()) {
        final boolean pagingEnabled = getVisibleTilePageCount() > 1 || mDragging || mEditing;
        mViewPager.setPagingEnabled(pagingEnabled);
        int currentPage = mViewPager.getCurrentItem();
        Log.d(TAG, "currentPage: " + currentPage);
        Log.d(TAG, "currentMaxPageCount: " + getCurrentMaxPageCount());
        Log.d(TAG, "mEditing: " + mEditing);
    }
    Log.i(TAG, "---   ensurePagerState()");
}
#method_after
public void ensurePagerState() {
    if (!isShowingDetail()) {
        final boolean pagingEnabled = getVisibleTilePageCount() > 1 || mDragging || mEditing;
        mViewPager.setPagingEnabled(pagingEnabled);
    }
}
#end_block

#method_before
private void compileResourcesWithAapt(String target, PackageParser.Package pkg) throws IOException, AaptException {
    String internalPath = APK_PATH_TO_OVERLAY + target + File.separator;
    String resPath = ThemeUtils.getTargetCacheDir(target, pkg);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    int pkgId;
    if ("android".equals(target)) {
        pkgId = Resources.THEME_FRAMEWORK_PKG_ID;
    } else if (COMMON_OVERLAY.equals(target)) {
        pkgId = Resources.THEME_COMMON_PKG_ID;
    } else {
        pkgId = Resources.THEME_APP_PKG_ID;
    }
    boolean hasCommonResources = (hasCommonResources(pkg) && !COMMON_OVERLAY.equals(target));
    if (mInstaller.aapt(pkg.baseCodePath, internalPath, resPath, sharedGid, pkgId, pkg.applicationInfo.targetSdkVersion, hasCommonResources ? ThemeUtils.getTargetCacheDir(COMMON_OVERLAY, pkg) + File.separator + "resources.apk" : "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#method_after
private void compileResourcesWithAapt(String target, PackageParser.Package pkg) throws IOException, AaptException {
    String internalPath = APK_PATH_TO_OVERLAY + target + File.separator;
    String resPath = ThemeUtils.getTargetCacheDir(target, pkg);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    int pkgId;
    if ("android".equals(target)) {
        pkgId = Resources.THEME_FRAMEWORK_PKG_ID;
    } else if (COMMON_OVERLAY.equals(target)) {
        pkgId = Resources.THEME_COMMON_PKG_ID;
    } else {
        pkgId = Resources.THEME_APP_PKG_ID;
    }
    boolean hasCommonResources = (hasCommonResources(pkg) && !COMMON_OVERLAY.equals(target));
    PackageParser.Package targetPkg = mPackages.get(target);
    String appPath = targetPkg != null ? targetPkg.baseCodePath : "";
    if (mInstaller.aapt(pkg.baseCodePath, internalPath, resPath, sharedGid, pkgId, pkg.applicationInfo.targetSdkVersion, appPath, hasCommonResources ? ThemeUtils.getTargetCacheDir(COMMON_OVERLAY, pkg) + File.separator + "resources.apk" : "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#end_block

#method_before
private void compileIconsWithAapt(Package pkg) throws Exception {
    String resPath = ThemeUtils.getIconPackDir(pkg.packageName);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    if (mInstaller.aapt(pkg.baseCodePath, APK_PATH_TO_ICONS, resPath, sharedGid, Resources.THEME_ICON_PKG_ID, pkg.applicationInfo.targetSdkVersion, "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#method_after
private void compileIconsWithAapt(Package pkg) throws Exception {
    String resPath = ThemeUtils.getIconPackDir(pkg.packageName);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    if (mInstaller.aapt(pkg.baseCodePath, APK_PATH_TO_ICONS, resPath, sharedGid, Resources.THEME_ICON_PKG_ID, pkg.applicationInfo.targetSdkVersion, "", "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#end_block

#method_before
@Override
public boolean isComponentProtected(String callingPackage, ComponentName componentName, int userId) {
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
    // Allow managers full access
    List<String> protectedComponentManagers = CMSettings.Secure.getDelimitedStringAsList(mContext.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENT_MANAGERS, "|");
    if (protectedComponentManagers.contains(callingPackage)) {
        return false;
    }
    String packageName = componentName.getPackageName();
    String className = componentName.getClassName();
    PackageSetting pkgSetting;
    ArraySet<String> components;
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (className == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
        }
        components = pkgSetting.getProtectedComponents(userId);
        return components.contains(className);
    }
}
#method_after
@Override
public boolean isComponentProtected(String callingPackage, ComponentName componentName, int userId) {
    if (DEBUG_PROTECTED)
        Log.d(TAG, "Checking if component is protected " + componentName.flattenToShortString() + " from calling package " + callingPackage);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
    // Allow managers full access
    List<String> protectedComponentManagers = CMSettings.Secure.getDelimitedStringAsList(mContext.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENT_MANAGERS, "|");
    if (protectedComponentManagers.contains(callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is a protected manager, allow");
        return false;
    }
    String packageName = componentName.getPackageName();
    String className = componentName.getClassName();
    // If this component is launched from the same package, allow it.
    if (TextUtils.equals(packageName, callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is same as target, allow");
        return false;
    }
    PackageSetting pkgSetting;
    ArraySet<String> components;
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (className == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
        }
        // Get all the protected components
        components = pkgSetting.getProtectedComponents(userId);
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Got " + components.size() + " protected components");
        return components.size() > 0;
    }
}
#end_block

#method_before
final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    boolean componentSpecified = intent.getComponent() != null;
    // Don't modify the client's object!
    intent = new Intent(intent);
    // Collect information about the target of the Intent.
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);
    ActivityContainer container = (ActivityContainer) iContainer;
    synchronized (mService) {
        if (container != null && container.mParentActivity != null && container.mParentActivity.state != RESUMED) {
            // Cannot start a child activity if the parent is not resumed.
            return ActivityManager.START_CANCELED;
        }
        try {
            // TODO: This needs to be a flushed out API in the future.
            if (AppGlobals.getPackageManager().isComponentProtected(callingPackage, intent.getComponent(), userId)) {
                Message msg = mService.mHandler.obtainMessage(ActivityManagerService.POST_COMPONENT_PROTECTED_MSG);
                msg.obj = aInfo;
                mService.mHandler.sendMessage(msg);
                return ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;
            }
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        final int realCallingPid = Binder.getCallingPid();
        final int realCallingUid = Binder.getCallingUid();
        int callingPid;
        if (callingUid >= 0) {
            callingPid = -1;
        } else if (caller == null) {
            callingPid = realCallingPid;
            callingUid = realCallingUid;
        } else {
            callingPid = callingUid = -1;
        }
        final ActivityStack stack;
        if (container == null || container.mStack.isOnHomeDisplay()) {
            stack = mFocusedStack;
        } else {
            stack = container.mStack;
        }
        stack.mConfigWillChange = config != null && mService.mConfiguration.diff(config) != 0;
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Starting activity when config will change = " + stack.mConfigWillChange);
        final long origId = Binder.clearCallingIdentity();
        if (aInfo != null && (aInfo.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
            // have another, different heavy-weight process running.
            if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
                if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
                    int appCallingUid = callingUid;
                    if (caller != null) {
                        ProcessRecord callerApp = mService.getRecordForAppLocked(caller);
                        if (callerApp != null) {
                            appCallingUid = callerApp.info.uid;
                        } else {
                            Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString());
                            ActivityOptions.abort(options);
                            return ActivityManager.START_PERMISSION_DENIED;
                        }
                    }
                    IIntentSender target = mService.getIntentSenderLocked(ActivityManager.INTENT_SENDER_ACTIVITY, "android", appCallingUid, userId, null, null, 0, new Intent[] { intent }, new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null);
                    Intent newIntent = new Intent();
                    if (requestCode >= 0) {
                        // Caller is requesting a result.
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT, new IntentSender(target));
                    if (mService.mHeavyWeightProcess.activities.size() > 0) {
                        ActivityRecord hist = mService.mHeavyWeightProcess.activities.get(0);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP, hist.packageName);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK, hist.task.taskId);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP, aInfo.packageName);
                    newIntent.setFlags(intent.getFlags());
                    newIntent.setClassName("android", HeavyWeightSwitcherActivity.class.getName());
                    intent = newIntent;
                    resolvedType = null;
                    caller = null;
                    callingUid = Binder.getCallingUid();
                    callingPid = Binder.getCallingPid();
                    componentSpecified = true;
                    try {
                        ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent(intent, null, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId);
                        aInfo = rInfo != null ? rInfo.activityInfo : null;
                        aInfo = mService.getActivityInfoForUser(aInfo, userId);
                    } catch (RemoteException e) {
                        aInfo = null;
                    }
                }
            }
        }
        int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask);
        Binder.restoreCallingIdentity(origId);
        if (stack.mConfigWillChange) {
            // If the caller also wants to switch to a new configuration,
            // do so now.  This allows a clean switch, as we are waiting
            // for the current activity to pause (so we will not destroy
            // it), and have not yet started the next activity.
            mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
            stack.mConfigWillChange = false;
            if (DEBUG_CONFIGURATION)
                Slog.v(TAG_CONFIGURATION, "Updating to new configuration after starting activity.");
            mService.updateConfigurationLocked(config, null, false, false);
        }
        if (outResult != null) {
            outResult.result = res;
            if (res == ActivityManager.START_SUCCESS) {
                mWaitingActivityLaunched.add(outResult);
                do {
                    try {
                        mService.wait();
                    } catch (InterruptedException e) {
                    }
                } while (!outResult.timeout && outResult.who == null);
            } else if (res == ActivityManager.START_TASK_TO_FRONT) {
                ActivityRecord r = stack.topRunningActivityLocked(null);
                if (r.nowVisible && r.state == RESUMED) {
                    outResult.timeout = false;
                    outResult.who = new ComponentName(r.info.packageName, r.info.name);
                    outResult.totalTime = 0;
                    outResult.thisTime = 0;
                } else {
                    outResult.thisTime = SystemClock.uptimeMillis();
                    mWaitingActivityVisible.add(outResult);
                    do {
                        try {
                            mService.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (!outResult.timeout && outResult.who == null);
                }
            }
        }
        return res;
    }
}
#method_after
final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    boolean componentSpecified = intent.getComponent() != null;
    // Don't modify the client's object!
    intent = new Intent(intent);
    // Collect information about the target of the Intent.
    ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId);
    ActivityContainer container = (ActivityContainer) iContainer;
    synchronized (mService) {
        if (container != null && container.mParentActivity != null && container.mParentActivity.state != RESUMED) {
            // Cannot start a child activity if the parent is not resumed.
            return ActivityManager.START_CANCELED;
        }
        try {
            // TODO: This needs to be a flushed out API in the future.
            if (AppGlobals.getPackageManager().isComponentProtected(callingPackage, intent.getComponent(), userId)) {
                Message msg = mService.mHandler.obtainMessage(ActivityManagerService.POST_COMPONENT_PROTECTED_MSG);
                // Store start flags, userid
                intent.setFlags(startFlags);
                intent.putExtra("com.android.settings.PROTECTED_APPS_USER_ID", userId);
                msg.obj = intent;
                mService.mHandler.sendMessage(msg);
                return ActivityManager.START_NOT_CURRENT_USER_ACTIVITY;
            }
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        final int realCallingPid = Binder.getCallingPid();
        final int realCallingUid = Binder.getCallingUid();
        int callingPid;
        if (callingUid >= 0) {
            callingPid = -1;
        } else if (caller == null) {
            callingPid = realCallingPid;
            callingUid = realCallingUid;
        } else {
            callingPid = callingUid = -1;
        }
        final ActivityStack stack;
        if (container == null || container.mStack.isOnHomeDisplay()) {
            stack = mFocusedStack;
        } else {
            stack = container.mStack;
        }
        stack.mConfigWillChange = config != null && mService.mConfiguration.diff(config) != 0;
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Starting activity when config will change = " + stack.mConfigWillChange);
        final long origId = Binder.clearCallingIdentity();
        if (aInfo != null && (aInfo.applicationInfo.privateFlags & ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
            // have another, different heavy-weight process running.
            if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) {
                if (mService.mHeavyWeightProcess != null && (mService.mHeavyWeightProcess.info.uid != aInfo.applicationInfo.uid || !mService.mHeavyWeightProcess.processName.equals(aInfo.processName))) {
                    int appCallingUid = callingUid;
                    if (caller != null) {
                        ProcessRecord callerApp = mService.getRecordForAppLocked(caller);
                        if (callerApp != null) {
                            appCallingUid = callerApp.info.uid;
                        } else {
                            Slog.w(TAG, "Unable to find app for caller " + caller + " (pid=" + callingPid + ") when starting: " + intent.toString());
                            ActivityOptions.abort(options);
                            return ActivityManager.START_PERMISSION_DENIED;
                        }
                    }
                    IIntentSender target = mService.getIntentSenderLocked(ActivityManager.INTENT_SENDER_ACTIVITY, "android", appCallingUid, userId, null, null, 0, new Intent[] { intent }, new String[] { resolvedType }, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_ONE_SHOT, null);
                    Intent newIntent = new Intent();
                    if (requestCode >= 0) {
                        // Caller is requesting a result.
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, true);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT, new IntentSender(target));
                    if (mService.mHeavyWeightProcess.activities.size() > 0) {
                        ActivityRecord hist = mService.mHeavyWeightProcess.activities.get(0);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP, hist.packageName);
                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK, hist.task.taskId);
                    }
                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP, aInfo.packageName);
                    newIntent.setFlags(intent.getFlags());
                    newIntent.setClassName("android", HeavyWeightSwitcherActivity.class.getName());
                    intent = newIntent;
                    resolvedType = null;
                    caller = null;
                    callingUid = Binder.getCallingUid();
                    callingPid = Binder.getCallingPid();
                    componentSpecified = true;
                    try {
                        ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent(intent, null, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId);
                        aInfo = rInfo != null ? rInfo.activityInfo : null;
                        aInfo = mService.getActivityInfoForUser(aInfo, userId);
                    } catch (RemoteException e) {
                        aInfo = null;
                    }
                }
            }
        }
        int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask);
        Binder.restoreCallingIdentity(origId);
        if (stack.mConfigWillChange) {
            // If the caller also wants to switch to a new configuration,
            // do so now.  This allows a clean switch, as we are waiting
            // for the current activity to pause (so we will not destroy
            // it), and have not yet started the next activity.
            mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
            stack.mConfigWillChange = false;
            if (DEBUG_CONFIGURATION)
                Slog.v(TAG_CONFIGURATION, "Updating to new configuration after starting activity.");
            mService.updateConfigurationLocked(config, null, false, false);
        }
        if (outResult != null) {
            outResult.result = res;
            if (res == ActivityManager.START_SUCCESS) {
                mWaitingActivityLaunched.add(outResult);
                do {
                    try {
                        mService.wait();
                    } catch (InterruptedException e) {
                    }
                } while (!outResult.timeout && outResult.who == null);
            } else if (res == ActivityManager.START_TASK_TO_FRONT) {
                ActivityRecord r = stack.topRunningActivityLocked(null);
                if (r.nowVisible && r.state == RESUMED) {
                    outResult.timeout = false;
                    outResult.who = new ComponentName(r.info.packageName, r.info.name);
                    outResult.totalTime = 0;
                    outResult.thisTime = 0;
                } else {
                    outResult.thisTime = SystemClock.uptimeMillis();
                    mWaitingActivityVisible.add(outResult);
                    do {
                        try {
                            mService.wait();
                        } catch (InterruptedException e) {
                        }
                    } while (!outResult.timeout && outResult.who == null);
                }
            }
        }
        return res;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfiguration(resolver, (Configuration) msg.obj);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);
                    return;
                }
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, PROC_START_TIMEOUT);
                    return;
                }
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mStackSupervisor.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int appid = msg.arg1;
                    boolean restart = (msg.arg2 == 1);
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appid, restart, false, true, false, false, UserHandle.USER_ALL, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.heavy_weight_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.heavy_weight_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked(true);
                    removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    finishBooting();
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IMountService mountService = IMountService.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    mountService.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int i = mTaskStackListeners.beginBroadcast();
                    while (i > 0) {
                        i--;
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onTaskStackChanged();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.OWNER)).build();
                try {
                    int[] outId = new int[1];
                    inm.enqueueNotificationWithTag("android", "android", null, R.string.dump_heap_notification, notification, outId, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case APP_BOOST_DEACTIVATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    if (mIsBoosted) {
                        if (mBoostStartTime < (SystemClock.uptimeMillis() - APP_BOOST_TIMEOUT)) {
                            nativeMigrateFromBoost();
                            mIsBoosted = false;
                            mBoostStartTime = 0;
                        } else {
                            Message newmsg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
                            mHandler.sendMessageDelayed(newmsg, APP_BOOST_TIMEOUT);
                        }
                    }
                }
            }
            break;
        case POST_PRIVACY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.privacy_guard_notification_detail, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    String title = mContext.getString(R.string.privacy_guard_notification);
                    Intent infoIntent = new Intent(Settings.ACTION_APP_OPS_DETAILS_SETTINGS, Uri.fromParts("package", root.packageName, null));
                    Notification notification = new Notification();
                    notification.icon = com.android.internal.R.drawable.stat_notify_privacy_guard;
                    notification.when = 0;
                    notification.flags = Notification.FLAG_ONGOING_EVENT;
                    notification.priority = Notification.PRIORITY_LOW;
                    notification.defaults = 0;
                    notification.sound = null;
                    notification.vibrate = null;
                    notification.setLatestEventInfo(mContext, title, text, PendingIntent.getActivityAsUser(mContext, 0, infoIntent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId)));
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.privacy_guard_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for privacy guard", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for privacy guard notification", e);
                }
            }
            break;
        case CANCEL_PRIVACY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.privacy_guard_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case POST_COMPONENT_PROTECTED_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityInfo root = (ActivityInfo) msg.obj;
                if (root == null) {
                    return;
                }
                try {
                    Intent protectedAppIntent = new Intent();
                    protectedAppIntent.setComponent(new ComponentName("com.android.settings", "com.android.settings.applications.ProtectedAppsActivity"));
                    Context context = mContext.createPackageContext("com.android.settings", 0);
                    String title = mContext.getString(com.android.internal.R.string.notify_package_component_protected_title);
                    String text = mContext.getString(com.android.internal.R.string.notify_package_component_protected_text, root.packageName);
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_notify_protected).setWhen(0).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(text).setStyle(new Notification.BigTextStyle().bigText(text)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, protectedAppIntent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(mCurrentUserId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.notify_package_component_protected_title, notification, outId, mCurrentUserId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for protected app component", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for protected app notification", e);
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfiguration(resolver, (Configuration) msg.obj);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);
                    return;
                }
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, PROC_START_TIMEOUT);
                    return;
                }
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mStackSupervisor.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int appid = msg.arg1;
                    boolean restart = (msg.arg2 == 1);
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appid, restart, false, true, false, false, UserHandle.USER_ALL, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.heavy_weight_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.heavy_weight_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked(true);
                    removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    finishBooting();
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IMountService mountService = IMountService.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    mountService.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int i = mTaskStackListeners.beginBroadcast();
                    while (i > 0) {
                        i--;
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onTaskStackChanged();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.OWNER)).build();
                try {
                    int[] outId = new int[1];
                    inm.enqueueNotificationWithTag("android", "android", null, R.string.dump_heap_notification, notification, outId, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case APP_BOOST_DEACTIVATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    if (mIsBoosted) {
                        if (mBoostStartTime < (SystemClock.uptimeMillis() - APP_BOOST_TIMEOUT)) {
                            nativeMigrateFromBoost();
                            mIsBoosted = false;
                            mBoostStartTime = 0;
                        } else {
                            Message newmsg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
                            mHandler.sendMessageDelayed(newmsg, APP_BOOST_TIMEOUT);
                        }
                    }
                }
            }
            break;
        case POST_PRIVACY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.privacy_guard_notification_detail, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    String title = mContext.getString(R.string.privacy_guard_notification);
                    Intent infoIntent = new Intent(Settings.ACTION_APP_OPS_DETAILS_SETTINGS, Uri.fromParts("package", root.packageName, null));
                    Notification notification = new Notification();
                    notification.icon = com.android.internal.R.drawable.stat_notify_privacy_guard;
                    notification.when = 0;
                    notification.flags = Notification.FLAG_ONGOING_EVENT;
                    notification.priority = Notification.PRIORITY_LOW;
                    notification.defaults = 0;
                    notification.sound = null;
                    notification.vibrate = null;
                    notification.setLatestEventInfo(mContext, title, text, PendingIntent.getActivityAsUser(mContext, 0, infoIntent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId)));
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.privacy_guard_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for privacy guard", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for privacy guard notification", e);
                }
            }
            break;
        case CANCEL_PRIVACY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.privacy_guard_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case POST_COMPONENT_PROTECTED_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                Intent targetIntent = (Intent) msg.obj;
                if (targetIntent == null) {
                    return;
                }
                int targetUserId = targetIntent.getIntExtra("com.android.settings.PROTECTED_APPS_USER_ID", mCurrentUserId);
                // Resolve for labels and whatnot
                ActivityInfo root = resolveActivityInfo(targetIntent, targetIntent.getFlags(), targetUserId);
                try {
                    Intent protectedAppIntent = new Intent();
                    protectedAppIntent.setComponent(new ComponentName("com.android.settings", "com.android.settings.applications.ProtectedAppsActivity"));
                    protectedAppIntent.putExtra("com.android.settings.PROTECTED_APP_TARGET_INTENT", targetIntent);
                    Context context = mContext.createPackageContext("com.android.settings", 0);
                    String title = mContext.getString(com.android.internal.R.string.notify_package_component_protected_title);
                    String text = mContext.getString(com.android.internal.R.string.notify_package_component_protected_text, root.applicationInfo.loadLabel(mContext.getPackageManager()));
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_notify_protected).setWhen(0).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(text).setDefaults(Notification.DEFAULT_VIBRATE).setPriority(Notification.PRIORITY_MAX).setStyle(new Notification.BigTextStyle().bigText(text)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, protectedAppIntent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(mCurrentUserId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.notify_package_component_protected_title, notification, outId, mCurrentUserId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for protected app component", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for protected app notification", e);
                }
            }
            break;
    }
}
#end_block

#method_before
private void showTetheredNotification(int icon) {
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mLastNotificationId != 0) {
        if (mLastNotificationId == icon) {
            if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) && icon == com.android.internal.R.drawable.stat_sys_tether_wifi) {
            // if softap extension feature is on, allow to update icon.
            } else {
                return;
            }
        }
        notificationManager.cancelAsUser(null, mLastNotificationId, UserHandle.ALL);
        mLastNotificationId = 0;
    }
    Intent intent = new Intent();
    intent.setClassName("com.android.settings", "com.android.settings.TetherSettings");
    intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    Resources r = Resources.getSystem();
    CharSequence title = r.getText(com.android.internal.R.string.tethered_notification_title);
    CharSequence message;
    int size = mConnectedDeviceMap.size();
    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) && icon == com.android.internal.R.drawable.stat_sys_tether_wifi) {
        if (size == 0) {
            message = r.getText(com.android.internal.R.string.tethered_notification_no_device_message);
        } else if (size == 1) {
            message = String.format((r.getText(com.android.internal.R.string.tethered_notification_one_device_message)).toString(), size);
        } else {
            message = String.format((r.getText(com.android.internal.R.string.tethered_notification_multi_device_message)).toString(), size);
        }
    } else {
        message = r.getText(com.android.internal.R.string.tethered_notification_message);
    }
    if (mTetheredNotificationBuilder == null) {
        mTetheredNotificationBuilder = new Notification.Builder(mContext);
        mTetheredNotificationBuilder.setWhen(0).setOngoing(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS);
    }
    mTetheredNotificationBuilder.setSmallIcon(icon).setContentTitle(title).setContentText(message).setContentIntent(pi);
    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) && icon == com.android.internal.R.drawable.stat_sys_tether_wifi && size > 0) {
        mTetheredNotificationBuilder.setContentText(message);
    } else {
        mTetheredNotificationBuilder.setContentTitle(title);
    }
    mLastNotificationId = icon;
    notificationManager.notifyAsUser(null, mLastNotificationId, mTetheredNotificationBuilder.build(), UserHandle.ALL);
}
#method_after
private void showTetheredNotification(int icon) {
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mLastNotificationId != 0) {
        if (mLastNotificationId == icon) {
            if (!mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) || icon != com.android.internal.R.drawable.stat_sys_tether_wifi) {
                // if softap extension feature is on, allow to update icon else return.
                return;
            }
        }
        notificationManager.cancelAsUser(null, mLastNotificationId, UserHandle.ALL);
        mLastNotificationId = 0;
    }
    Intent intent = new Intent();
    intent.setClassName("com.android.settings", "com.android.settings.TetherSettings");
    intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    Resources r = Resources.getSystem();
    CharSequence title = r.getText(com.android.internal.R.string.tethered_notification_title);
    CharSequence message;
    int size = mConnectedDeviceMap.size();
    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) && icon == com.android.internal.R.drawable.stat_sys_tether_wifi) {
        if (size == 0) {
            message = r.getText(com.android.internal.R.string.tethered_notification_no_device_message);
        } else if (size == 1) {
            message = String.format((r.getText(com.android.internal.R.string.tethered_notification_one_device_message)).toString(), size);
        } else {
            message = String.format((r.getText(com.android.internal.R.string.tethered_notification_multi_device_message)).toString(), size);
        }
    } else {
        message = r.getText(com.android.internal.R.string.tethered_notification_message);
    }
    if (mTetheredNotificationBuilder == null) {
        mTetheredNotificationBuilder = new Notification.Builder(mContext);
        mTetheredNotificationBuilder.setWhen(0).setOngoing(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS);
    }
    mTetheredNotificationBuilder.setSmallIcon(icon).setContentTitle(title).setContentText(message).setContentIntent(pi);
    if (mContext.getResources().getBoolean(com.android.internal.R.bool.config_softap_extention) && icon == com.android.internal.R.drawable.stat_sys_tether_wifi && size > 0) {
        mTetheredNotificationBuilder.setContentText(message);
    } else {
        mTetheredNotificationBuilder.setContentTitle(title);
    }
    mLastNotificationId = icon;
    notificationManager.notifyAsUser(null, mLastNotificationId, mTetheredNotificationBuilder.build(), UserHandle.ALL);
}
#end_block

#method_before
@Override
public void enter() {
}
#method_after
@Override
public void enter() {
    setAvailable(true);
    setTethered(false);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        Log.d(TAG, "MasterInitialState.processMessage what=" + message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_MODE_REQUESTED:
            TetherInterfaceSM who = (TetherInterfaceSM) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            mNotifyList.add(who);
            transitionTo(mTetherModeAliveState);
            break;
        case CMD_TETHER_MODE_UNREQUESTED:
            who = (TetherInterfaceSM) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            int index = mNotifyList.indexOf(who);
            if (index != -1) {
                mNotifyList.remove(who);
            }
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        Log.d(TAG, "InitialState.processMessage what=" + message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            setLastError(ConnectivityManager.TETHER_ERROR_NO_ERROR);
            mTetherMasterSM.sendMessage(TetherMasterSM.CMD_TETHER_MODE_REQUESTED, TetherInterfaceSM.this);
            transitionTo(mStartingState);
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
private void showBatteryFullyChargedNotificationLocked() {
    NotificationManager nm = mContext.getSystemService(NotificationManager.class);
    Intent intent = new Intent(Intent.ACTION_POWER_USAGE_SUMMARY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    CharSequence title = mContext.getText(com.android.internal.R.string.notify_battery_fully_charged_title);
    CharSequence message = mContext.getText(com.android.internal.R.string.notify_battery_fully_charged_text);
    ;
    Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_battery_charge).setWhen(0).setOngoing(false).setAutoCancel(true).setTicker(title).setDefaults(// please be quiet
    0).setPriority(Notification.PRIORITY_DEFAULT).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(message).setStyle(new Notification.BigTextStyle().bigText(message)).setContentIntent(pi).setVisibility(Notification.VISIBILITY_PUBLIC).build();
    nm.notifyAsUser(null, BATTERY_FULL_NOTIFICATION_ID, notification, UserHandle.ALL);
    mIsShowingBatteryFullyChargedNotification = true;
}
#method_after
private void showBatteryFullyChargedNotificationLocked() {
    NotificationManager nm = mContext.getSystemService(NotificationManager.class);
    Intent intent = new Intent(Intent.ACTION_POWER_USAGE_SUMMARY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    CharSequence title = mContext.getText(com.android.internal.R.string.notify_battery_fully_charged_title);
    CharSequence message = mContext.getText(com.android.internal.R.string.notify_battery_fully_charged_text);
    Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_battery_charge).setWhen(0).setOngoing(false).setAutoCancel(true).setTicker(title).setDefaults(// please be quiet
    0).setPriority(Notification.PRIORITY_DEFAULT).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(message).setStyle(new Notification.BigTextStyle().bigText(message)).setContentIntent(pi).setVisibility(Notification.VISIBILITY_PUBLIC).build();
    nm.notifyAsUser(null, com.android.internal.R.string.notify_battery_fully_charged_title, notification, UserHandle.ALL);
    mIsShowingBatteryFullyChargedNotification = true;
}
#end_block

#method_before
private boolean shouldClearBatteryFullyChargedNotificationLocked() {
    return mIsShowingBatteryFullyChargedNotification && mPlugType == 0;
}
#method_after
private boolean shouldClearBatteryFullyChargedNotificationLocked() {
    return mIsShowingBatteryFullyChargedNotification && (mPlugType == 0 || mBatteryProps.batteryLevel < BATTERY_SCALE);
}
#end_block

#method_before
private void clearBatteryFullyChargedNotificationLocked() {
    NotificationManager nm = mContext.getSystemService(NotificationManager.class);
    nm.cancel(BATTERY_FULL_NOTIFICATION_ID);
    mIsShowingBatteryFullyChargedNotification = false;
}
#method_after
private void clearBatteryFullyChargedNotificationLocked() {
    NotificationManager nm = mContext.getSystemService(NotificationManager.class);
    nm.cancel(com.android.internal.R.string.notify_battery_fully_charged_title);
    mIsShowingBatteryFullyChargedNotification = false;
}
#end_block

#method_before
@Override
public boolean requireSecureKeyguard(int userHandle) {
    if (!mHasFeature) {
        return false;
    }
    int passwordQuality = getPasswordQuality(null, userHandle);
    if (passwordQuality > DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) {
        return true;
    }
    int encryptionStatus = getStorageEncryptionStatus(userHandle);
    if (encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE || encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVATING) {
        return true;
    }
    final int keyguardDisabledFeatures = getKeyguardDisabledFeatures(null, userHandle);
    final boolean disableTrustAgents = (keyguardDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS) != 0;
    if (disableTrustAgents) {
        return true;
    }
    return false;
}
#method_after
@Override
public boolean requireSecureKeyguard(int userHandle) {
    if (!mHasFeature) {
        return false;
    }
    int passwordQuality = getPasswordQuality(null, userHandle);
    if (passwordQuality > DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED) {
        return true;
    }
    int encryptionStatus = getStorageEncryptionStatus(userHandle);
    if (encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE || encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_ACTIVATING) {
        return true;
    }
    final int keyguardDisabledFeatures = getKeyguardDisabledFeatures(null, userHandle);
    return (keyguardDisabledFeatures & DevicePolicyManager.KEYGUARD_DISABLE_TRUST_AGENTS) != 0;
}
#end_block

#method_before
private boolean evaluateZenMode(String reason, boolean setRingerMode) {
    if (DEBUG)
        Log.d(TAG, "evaluateZenMode");
    final ArraySet<ZenRule> automaticRules = new ArraySet<ZenRule>();
    final int zen = computeZenMode(automaticRules);
    if (zen == mZenMode)
        return false;
    ZenLog.traceSetZenMode(zen, reason);
    mZenMode = zen;
    updateRingerModeAffectedStreams();
    setZenModeSetting(mZenMode);
    if (setRingerMode) {
        applyZenToRingerMode();
    }
    applyRestrictions();
    mHandler.postDispatchOnZenModeChanged();
    return true;
}
#method_after
private boolean evaluateZenMode(String reason, boolean setRingerMode) {
    if (DEBUG)
        Log.d(TAG, "evaluateZenMode");
    final ArraySet<ZenRule> automaticRules = new ArraySet<ZenRule>();
    final int zen = computeZenMode(automaticRules);
    if (zen == mZenMode)
        return false;
    ZenLog.traceSetZenMode(zen, reason);
    mZenMode = zen;
    updateRingerModeAffectedStreams();
    readAllowLightsFromSettings();
    setZenModeSetting(mZenMode);
    if (setRingerMode) {
        applyZenToRingerMode();
    }
    applyRestrictions();
    mHandler.postDispatchOnZenModeChanged();
    return true;
}
#end_block

#method_before
private void applyRestrictions() {
    final boolean zen = mZenMode != Global.ZEN_MODE_OFF;
    // notification restrictions
    final boolean muteNotifications = mEffectsSuppressed;
    applyRestrictions(muteNotifications, USAGE_NOTIFICATION);
    // call restrictions
    final boolean muteCalls = zen && !mConfig.allowCalls && !mConfig.allowRepeatCallers || mEffectsSuppressed;
    applyRestrictions(muteCalls, USAGE_NOTIFICATION_RINGTONE);
    // alarm restrictions
    final boolean muteAlarms = mZenMode == Global.ZEN_MODE_NO_INTERRUPTIONS;
    applyRestrictions(muteAlarms, USAGE_ALARM);
}
#method_after
private void applyRestrictions() {
    final boolean zen = mZenMode != Global.ZEN_MODE_OFF;
    // notification restrictions
    final boolean muteNotifications = mEffectsSuppressed;
    applyRestrictions(muteNotifications, USAGE_NOTIFICATION);
    // call restrictions
    final boolean muteCalls = zen && !mConfig.allowCalls && !mConfig.allowRepeatCallers || mEffectsSuppressed;
    applyRestrictions(muteCalls, USAGE_NOTIFICATION_RINGTONE);
    // alarm restrictions
    final boolean muteAlarms = mZenMode == Global.ZEN_MODE_NO_INTERRUPTIONS;
    applyRestrictions(muteAlarms, USAGE_ALARM);
    readAllowLightsFromSettings();
}
#end_block

#method_before
public void observe() {
    final ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(ZEN_MODE, false, /*notifyForDescendents*/
    this);
    resolver.registerContentObserver(ALLOW_LIGHTS, false, /*notifyForDescendents*/
    this);
    update(null);
}
#method_after
public void observe() {
    final ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(ZEN_MODE, false, /*notifyForDescendents*/
    this);
    resolver.registerContentObserver(ZEN_ALLOW_LIGHTS, false, /*notifyForDescendents*/
    this);
    resolver.registerContentObserver(ZEN_PRIORITY_ALLOW_LIGHTS, false, /*notifyForDescendents*/
    this);
    update(null);
}
#end_block

#method_before
public void update(Uri uri) {
    if (ZEN_MODE.equals(uri)) {
        if (mZenMode != getZenModeSetting()) {
            if (DEBUG)
                Log.d(TAG, "Fixing zen mode setting");
            setZenModeSetting(mZenMode);
        }
    } else if (ALLOW_LIGHTS.equals(uri)) {
        readLightsAllowedModeFromSetting();
    }
}
#method_after
public void update(Uri uri) {
    if (ZEN_MODE.equals(uri)) {
        if (mZenMode != getZenModeSetting()) {
            if (DEBUG)
                Log.d(TAG, "Fixing zen mode setting");
            setZenModeSetting(mZenMode);
        }
    } else if (ZEN_ALLOW_LIGHTS.equals(uri) || ZEN_PRIORITY_ALLOW_LIGHTS.equals(uri)) {
        readAllowLightsFromSettings();
    }
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = getContext().getContentResolver();
    resolver.registerContentObserver(NOTIFICATION_LIGHT_PULSE_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(ENABLED_NOTIFICATION_LISTENERS_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_SCREEN_ON), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.Global.getUriFor(CMSettings.Global.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK), false, this, UserHandle.USER_ALL);
    if (mAdjustableNotificationLedBrightness) {
        resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL), false, this, UserHandle.USER_ALL);
    }
    if (mMultipleNotificationLeds) {
        resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE), false, this, UserHandle.USER_ALL);
    }
    update(null);
}
#method_after
void observe() {
    ContentResolver resolver = getContext().getContentResolver();
    resolver.registerContentObserver(NOTIFICATION_LIGHT_PULSE_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(ENABLED_NOTIFICATION_LISTENERS_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_SCREEN_ON), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.Global.getUriFor(CMSettings.Global.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_COLOR_AUTO), false, this, UserHandle.USER_ALL);
    if (mAdjustableNotificationLedBrightness) {
        resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL), false, this, UserHandle.USER_ALL);
    }
    if (mMultipleNotificationLeds) {
        resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE), false, this, UserHandle.USER_ALL);
    }
    update(null);
}
#end_block

#method_before
public void update(Uri uri) {
    ContentResolver resolver = getContext().getContentResolver();
    // LED enabled
    mNotificationPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE, 0, UserHandle.USER_CURRENT) != 0;
    // LED default color
    mDefaultNotificationColor = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR, mDefaultNotificationColor, UserHandle.USER_CURRENT);
    // LED default on MS
    mDefaultNotificationLedOn = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON, mDefaultNotificationLedOn, UserHandle.USER_CURRENT);
    // LED default off MS
    mDefaultNotificationLedOff = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF, mDefaultNotificationLedOff, UserHandle.USER_CURRENT);
    // LED custom notification colors
    mNotificationPulseCustomLedValues.clear();
    if (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE, 0, UserHandle.USER_CURRENT) != 0) {
        parseNotificationPulseCustomValuesString(CMSettings.System.getStringForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES, UserHandle.USER_CURRENT));
    }
    // Notification LED brightness
    if (mAdjustableNotificationLedBrightness) {
        mNotificationLedBrightnessLevel = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL, LIGHT_BRIGHTNESS_MAXIMUM, UserHandle.USER_CURRENT);
    }
    // Multiple LEDs enabled
    if (mMultipleNotificationLeds) {
        mMultipleLedsEnabledSetting = (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE, mMultipleNotificationLeds ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    }
    // Notification lights with screen on
    mScreenOnEnabled = (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_SCREEN_ON, mScreenOnDefault ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    updateNotificationPulse();
    mDisableDuckingWhileMedia = CMSettings.Global.getInt(resolver, CMSettings.Global.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK, 0) == 1;
    updateDisableDucking();
}
#method_after
public void update(Uri uri) {
    ContentResolver resolver = getContext().getContentResolver();
    // LED enabled
    mNotificationPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE, 0, UserHandle.USER_CURRENT) != 0;
    // Automatically pick a color for LED if not set
    mAutoGenerateNotificationColor = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_COLOR_AUTO, 1, UserHandle.USER_CURRENT) != 0;
    // LED default color
    mDefaultNotificationColor = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR, mDefaultNotificationColor, UserHandle.USER_CURRENT);
    // LED default on MS
    mDefaultNotificationLedOn = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON, mDefaultNotificationLedOn, UserHandle.USER_CURRENT);
    // LED default off MS
    mDefaultNotificationLedOff = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF, mDefaultNotificationLedOff, UserHandle.USER_CURRENT);
    // LED generated notification colors
    mGeneratedPackageLedColors.clear();
    // LED custom notification colors
    mNotificationPulseCustomLedValues.clear();
    if (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE, 0, UserHandle.USER_CURRENT) != 0) {
        parseNotificationPulseCustomValuesString(CMSettings.System.getStringForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES, UserHandle.USER_CURRENT));
    }
    // Notification LED brightness
    if (mAdjustableNotificationLedBrightness) {
        mNotificationLedBrightnessLevel = CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_BRIGHTNESS_LEVEL, LIGHT_BRIGHTNESS_MAXIMUM, UserHandle.USER_CURRENT);
    }
    // Multiple LEDs enabled
    if (mMultipleNotificationLeds) {
        mMultipleLedsEnabledSetting = (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_MULTIPLE_LEDS_ENABLE, mMultipleNotificationLeds ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    }
    // Notification lights with screen on
    mScreenOnEnabled = (CMSettings.System.getIntForUser(resolver, CMSettings.System.NOTIFICATION_LIGHT_SCREEN_ON, mScreenOnDefault ? 1 : 0, UserHandle.USER_CURRENT) != 0);
    updateNotificationPulse();
    mDisableDuckingWhileMedia = CMSettings.Global.getInt(resolver, CMSettings.Global.ZEN_DISABLE_DUCKING_DURING_MEDIA_PLAYBACK, 0) == 1;
    updateDisableDucking();
}
#end_block

#method_before
@Override
public void onStart() {
    Resources resources = getContext().getResources();
    mAm = ActivityManagerNative.getDefault();
    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);
    mZenModeHelper.readLightsAllowedModeFromSetting();
    mVibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
    mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);
    mKeyguardManager = (KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE);
    mHandler = new WorkerHandler();
    mRankingThread.start();
    String[] extractorNames;
    try {
        extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);
    } catch (Resources.NotFoundException e) {
        extractorNames = new String[0];
    }
    mUsageStats = new NotificationUsageStats(getContext());
    mRankingHelper = new RankingHelper(getContext(), new RankingWorkerHandler(mRankingThread.getLooper()), mUsageStats, extractorNames);
    mConditionProviders = new ConditionProviders(getContext(), mHandler, mUserProfiles);
    mZenModeHelper = new ZenModeHelper(getContext(), mHandler.getLooper(), mConditionProviders);
    mZenModeHelper.addCallback(new ZenModeHelper.Callback() {

        @Override
        public void onConfigChanged() {
            savePolicyFile();
        }

        @Override
        void onZenModeChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
            synchronized (mNotificationList) {
                updateInterruptionFilterLocked();
            }
        }

        @Override
        void onPolicyChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED);
        }
    });
    final File systemDir = new File(Environment.getDataDirectory(), "system");
    mPolicyFile = new AtomicFile(new File(systemDir, "notification_policy.xml"));
    importOldBlockDb();
    mListeners = new NotificationListeners();
    mStatusBar = getLocalService(StatusBarManagerInternal.class);
    mStatusBar.setNotificationDelegate(mNotificationDelegate);
    final LightsManager lights = getLocalService(LightsManager.class);
    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
    mAttentionLight = lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDefaultNotificationColor = resources.getColor(R.color.config_defaultNotificationColor);
    mDefaultNotificationLedOn = resources.getInteger(R.integer.config_defaultNotificationLedOn);
    mDefaultNotificationLedOff = resources.getInteger(R.integer.config_defaultNotificationLedOff);
    mNotificationPulseCustomLedValues = new HashMap<String, NotificationLedValues>();
    mPackageNameMappings = new HashMap<String, String>();
    final String[] defaultMapping = resources.getStringArray(com.android.internal.R.array.notification_light_package_mapping);
    for (String mapping : defaultMapping) {
        String[] map = mapping.split("\\|");
        mPackageNameMappings.put(map[0], map[1]);
    }
    mDefaultVibrationPattern = getLongArray(resources, R.array.config_defaultNotificationVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mFallbackVibrationPattern = getLongArray(resources, R.array.config_notificationFallbackVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mAdjustableNotificationLedBrightness = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_adjustableNotificationLedBrightness);
    mMultipleNotificationLeds = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_multipleNotificationLeds);
    mUseAttentionLight = resources.getBoolean(R.bool.config_useAttentionLight);
    // flag at least once and we'll go back to 0 after that.
    if (0 == Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0)) {
        mDisableNotificationEffects = true;
    }
    mZenModeHelper.initZenMode();
    mInterruptionFilter = mZenModeHelper.getZenModeListenerInterruptionFilter();
    mUserProfiles.updateCache(getContext());
    listenForCallState();
    // register for various Intents
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    filter.addAction(Intent.ACTION_USER_STOPPED);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_REMOVED);
    getContext().registerReceiver(mIntentReceiver, filter);
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, pkgFilter, null, null);
    IntentFilter sdFilter = new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, sdFilter, null, null);
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mSpamFilterObserver = new SpamFilterObserver(mHandler);
    mSpamFilterObserver.observe();
    mArchive = new Archive(resources.getInteger(R.integer.config_notificationServiceArchiveSize));
    publishBinderService(Context.NOTIFICATION_SERVICE, mService);
    publishLocalService(NotificationManagerInternal.class, mInternalService);
}
#method_after
@Override
public void onStart() {
    Resources resources = getContext().getResources();
    mAm = ActivityManagerNative.getDefault();
    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);
    mVibrator = (Vibrator) getContext().getSystemService(Context.VIBRATOR_SERVICE);
    mAppUsageStats = LocalServices.getService(UsageStatsManagerInternal.class);
    mKeyguardManager = (KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE);
    mHandler = new WorkerHandler();
    mRankingThread.start();
    String[] extractorNames;
    try {
        extractorNames = resources.getStringArray(R.array.config_notificationSignalExtractors);
    } catch (Resources.NotFoundException e) {
        extractorNames = new String[0];
    }
    mUsageStats = new NotificationUsageStats(getContext());
    mRankingHelper = new RankingHelper(getContext(), new RankingWorkerHandler(mRankingThread.getLooper()), mUsageStats, extractorNames);
    mConditionProviders = new ConditionProviders(getContext(), mHandler, mUserProfiles);
    mZenModeHelper = new ZenModeHelper(getContext(), mHandler.getLooper(), mConditionProviders);
    mZenModeHelper.addCallback(new ZenModeHelper.Callback() {

        @Override
        public void onConfigChanged() {
            savePolicyFile();
        }

        @Override
        void onZenModeChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_INTERRUPTION_FILTER_CHANGED);
            synchronized (mNotificationList) {
                updateInterruptionFilterLocked();
            }
        }

        @Override
        void onPolicyChanged() {
            sendRegisteredOnlyBroadcast(NotificationManager.ACTION_NOTIFICATION_POLICY_CHANGED);
        }
    });
    final File systemDir = new File(Environment.getDataDirectory(), "system");
    mPolicyFile = new AtomicFile(new File(systemDir, "notification_policy.xml"));
    importOldBlockDb();
    mListeners = new NotificationListeners();
    mStatusBar = getLocalService(StatusBarManagerInternal.class);
    mStatusBar.setNotificationDelegate(mNotificationDelegate);
    final LightsManager lights = getLocalService(LightsManager.class);
    mNotificationLight = lights.getLight(LightsManager.LIGHT_ID_NOTIFICATIONS);
    mAttentionLight = lights.getLight(LightsManager.LIGHT_ID_ATTENTION);
    mDefaultNotificationColor = resources.getColor(R.color.config_defaultNotificationColor);
    mDefaultNotificationLedOn = resources.getInteger(R.integer.config_defaultNotificationLedOn);
    mDefaultNotificationLedOff = resources.getInteger(R.integer.config_defaultNotificationLedOff);
    mNotificationPulseCustomLedValues = new HashMap<String, NotificationLedValues>();
    mPackageNameMappings = new HashMap<String, String>();
    final String[] defaultMapping = resources.getStringArray(com.android.internal.R.array.notification_light_package_mapping);
    for (String mapping : defaultMapping) {
        String[] map = mapping.split("\\|");
        mPackageNameMappings.put(map[0], map[1]);
    }
    mDefaultVibrationPattern = getLongArray(resources, R.array.config_defaultNotificationVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mFallbackVibrationPattern = getLongArray(resources, R.array.config_notificationFallbackVibePattern, VIBRATE_PATTERN_MAXLEN, DEFAULT_VIBRATE_PATTERN);
    mAdjustableNotificationLedBrightness = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_adjustableNotificationLedBrightness);
    mMultipleNotificationLeds = resources.getBoolean(org.cyanogenmod.platform.internal.R.bool.config_multipleNotificationLeds);
    mUseAttentionLight = resources.getBoolean(R.bool.config_useAttentionLight);
    // flag at least once and we'll go back to 0 after that.
    if (0 == Settings.Global.getInt(getContext().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0)) {
        mDisableNotificationEffects = true;
    }
    mZenModeHelper.initZenMode();
    mZenModeHelper.readAllowLightsFromSettings();
    mInterruptionFilter = mZenModeHelper.getZenModeListenerInterruptionFilter();
    mUserProfiles.updateCache(getContext());
    listenForCallState();
    // register for various Intents
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(TelephonyManager.ACTION_PHONE_STATE_CHANGED);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    filter.addAction(Intent.ACTION_USER_STOPPED);
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(Intent.ACTION_USER_ADDED);
    filter.addAction(Intent.ACTION_USER_REMOVED);
    getContext().registerReceiver(mIntentReceiver, filter);
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);
    pkgFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, pkgFilter, null, null);
    IntentFilter sdFilter = new IntentFilter(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE);
    getContext().registerReceiverAsUser(mPackageIntentReceiver, UserHandle.ALL, sdFilter, null, null);
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mSpamFilterObserver = new SpamFilterObserver(mHandler);
    mSpamFilterObserver.observe();
    mArchive = new Archive(resources.getInteger(R.integer.config_notificationServiceArchiveSize));
    publishBinderService(Context.NOTIFICATION_SERVICE, mService);
    publishLocalService(NotificationManagerInternal.class, mInternalService);
}
#end_block

#method_before
private String disableNotificationEffects(NotificationRecord record) {
    if (mDisableNotificationEffects) {
        return "booleanState";
    }
    if ((mListenerHints & HINT_HOST_DISABLE_EFFECTS) != 0) {
        return "listenerHints";
    }
    if (mCallState != TelephonyManager.CALL_STATE_IDLE && !mZenModeHelper.isCall(record)) {
        return "callState";
    }
    return null;
}
#method_after
private String disableNotificationEffects(NotificationRecord record) {
    boolean smsRingtone = getContext().getResources().getBoolean(com.android.internal.R.bool.config_sms_ringtone_incall);
    if (mDisableNotificationEffects) {
        return "booleanState";
    }
    if ((mListenerHints & HINT_HOST_DISABLE_EFFECTS) != 0) {
        return "listenerHints";
    }
    if (mCallState != TelephonyManager.CALL_STATE_IDLE && !mZenModeHelper.isCall(record) && !smsRingtone) {
        return "callState";
    }
    return null;
}
#end_block

#method_before
private void buzzBeepBlinkLocked(NotificationRecord record) {
    boolean buzz = false;
    boolean beep = false;
    boolean blink = false;
    final Notification notification = record.sbn.getNotification();
    // Should this notification make noise, vibe, or use the LED?
    final boolean aboveThreshold = record.score >= SCORE_INTERRUPTION_THRESHOLD;
    final boolean canInterrupt = aboveThreshold && !record.isIntercepted();
    if (DBG || record.isIntercepted())
        Slog.v(TAG, "pkg=" + record.sbn.getPackageName() + " canInterrupt=" + canInterrupt + " intercept=" + record.isIntercepted());
    final int currentUser;
    final long token = Binder.clearCallingIdentity();
    try {
        currentUser = ActivityManager.getCurrentUser();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // If we're not supposed to beep, vibrate, etc. then don't.
    final String disableEffects = disableNotificationEffects(record);
    if (disableEffects != null) {
        ZenLog.traceDisableEffects(record, disableEffects);
    }
    boolean smsRingtone = getContext().getResources().getBoolean(com.android.internal.R.bool.config_sms_ringtone_incall);
    if ((disableEffects == null || (smsRingtone && mInCall)) && (!(record.isUpdate && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (record.getUserId() == UserHandle.USER_ALL || record.getUserId() == currentUser || mUserProfiles.isCurrentProfile(record.getUserId())) && canInterrupt && mSystemReady && mAudioManager != null) {
        if (DBG)
            Slog.v(TAG, "Interrupting!");
        sendAccessibilityEvent(notification, record.sbn.getPackageName());
        // sound
        // should we use the default notification sound? (indicated either by
        // DEFAULT_SOUND or because notification.sound is pointing at
        // Settings.System.NOTIFICATION_SOUND)
        final boolean useDefaultSound = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
        Uri soundUri = null;
        boolean hasValidSound = false;
        if (useDefaultSound) {
            soundUri = Settings.System.DEFAULT_NOTIFICATION_URI;
            // check to see if the default notification sound is silent
            ContentResolver resolver = getContext().getContentResolver();
            hasValidSound = Settings.System.getString(resolver, Settings.System.NOTIFICATION_SOUND) != null;
        } else if (notification.sound != null) {
            soundUri = notification.sound;
            hasValidSound = (soundUri != null);
        }
        if (hasValidSound && (!mDisableDuckingWhileMedia || !mActiveMedia)) {
            boolean looping = (notification.flags & Notification.FLAG_INSISTENT) != 0;
            AudioAttributes audioAttributes = audioAttributesForNotification(notification);
            mSoundNotificationKey = record.getKey();
            // ringer mode is silent) or if there is a user of exclusive audio focus
            if ((mAudioManager.getStreamVolume(AudioAttributes.toLegacyStreamType(audioAttributes)) != 0) && !mAudioManager.isAudioFocusExclusive()) {
                final long identity = Binder.clearCallingIdentity();
                try {
                    final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
                    if (player != null) {
                        if (DBG)
                            Slog.v(TAG, "Playing sound " + soundUri + " with attributes " + audioAttributes);
                        player.playAsync(soundUri, record.sbn.getUser(), looping, audioAttributes);
                        beep = true;
                    }
                } catch (RemoteException e) {
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            }
        }
        // vibrate
        // Does the notification want to specify its own vibration?
        final boolean hasCustomVibrate = notification.vibrate != null;
        // new in 4.2: if there was supposed to be a sound and we're in vibrate
        // mode, and no other vibration is specified, we fall back to vibration
        final boolean convertSoundToVibration = !hasCustomVibrate && hasValidSound && (mAudioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE);
        // The DEFAULT_VIBRATE flag trumps any custom vibration AND the fallback.
        final boolean useDefaultVibrate = (notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
        if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotificationKey = record.getKey();
            if (useDefaultVibrate || convertSoundToVibration) {
                // Escalate privileges so we can use the vibrator even if the
                // notifying app does not have the VIBRATE permission.
                long identity = Binder.clearCallingIdentity();
                try {
                    mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern, ((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1, audioAttributesForNotification(notification));
                    buzz = true;
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            } else if (notification.vibrate.length > 1) {
                // If you want your own vibration pattern, you need the VIBRATE
                // permission
                mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), notification.vibrate, ((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1, audioAttributesForNotification(notification));
                buzz = true;
            }
        }
    }
    // light
    // release the light
    boolean wasShowLights = mLights.remove(record.getKey());
    final boolean canInterruptWithLight = canInterrupt || isLedNotificationForcedOn(record) || (!canInterrupt && mZenModeHelper.getAreLightsAllowed());
    if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterruptWithLight) {
        mLights.add(record.getKey());
        updateLightsLocked();
        if (mUseAttentionLight) {
            mAttentionLight.pulse();
        }
        blink = true;
    } else if (wasShowLights) {
        updateLightsLocked();
    }
    if (buzz || beep || blink) {
        EventLogTags.writeNotificationAlert(record.getKey(), buzz ? 1 : 0, beep ? 1 : 0, blink ? 1 : 0);
        mHandler.post(mBuzzBeepBlinked);
    }
}
#method_after
private void buzzBeepBlinkLocked(NotificationRecord record) {
    boolean buzz = false;
    boolean beep = false;
    boolean blink = false;
    final Notification notification = record.sbn.getNotification();
    // Should this notification make noise, vibe, or use the LED?
    final boolean aboveThreshold = record.score >= SCORE_INTERRUPTION_THRESHOLD;
    final boolean canInterrupt = aboveThreshold && !record.isIntercepted();
    if (DBG || record.isIntercepted())
        Slog.v(TAG, "pkg=" + record.sbn.getPackageName() + " canInterrupt=" + canInterrupt + " intercept=" + record.isIntercepted());
    final int currentUser;
    final long token = Binder.clearCallingIdentity();
    try {
        currentUser = ActivityManager.getCurrentUser();
    } finally {
        Binder.restoreCallingIdentity(token);
    }
    // If we're not supposed to beep, vibrate, etc. then don't.
    final String disableEffects = disableNotificationEffects(record);
    if (disableEffects != null) {
        ZenLog.traceDisableEffects(record, disableEffects);
    }
    if ((disableEffects == null) && (!(record.isUpdate && (notification.flags & Notification.FLAG_ONLY_ALERT_ONCE) != 0)) && (record.getUserId() == UserHandle.USER_ALL || record.getUserId() == currentUser || mUserProfiles.isCurrentProfile(record.getUserId())) && canInterrupt && mSystemReady && mAudioManager != null) {
        if (DBG)
            Slog.v(TAG, "Interrupting!");
        sendAccessibilityEvent(notification, record.sbn.getPackageName());
        // sound
        // should we use the default notification sound? (indicated either by
        // DEFAULT_SOUND or because notification.sound is pointing at
        // Settings.System.NOTIFICATION_SOUND)
        final boolean useDefaultSound = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || Settings.System.DEFAULT_NOTIFICATION_URI.equals(notification.sound);
        Uri soundUri = null;
        boolean hasValidSound = false;
        if (useDefaultSound) {
            soundUri = Settings.System.DEFAULT_NOTIFICATION_URI;
            // check to see if the default notification sound is silent
            ContentResolver resolver = getContext().getContentResolver();
            hasValidSound = Settings.System.getString(resolver, Settings.System.NOTIFICATION_SOUND) != null;
        } else if (notification.sound != null) {
            soundUri = notification.sound;
            hasValidSound = (soundUri != null);
        }
        if (hasValidSound && (!mDisableDuckingWhileMedia || !mActiveMedia)) {
            boolean looping = (notification.flags & Notification.FLAG_INSISTENT) != 0;
            AudioAttributes audioAttributes = audioAttributesForNotification(notification);
            mSoundNotificationKey = record.getKey();
            // ringer mode is silent) or if there is a user of exclusive audio focus
            if ((mAudioManager.getStreamVolume(AudioAttributes.toLegacyStreamType(audioAttributes)) != 0) && !mAudioManager.isAudioFocusExclusive()) {
                final long identity = Binder.clearCallingIdentity();
                try {
                    final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
                    if (player != null) {
                        if (DBG)
                            Slog.v(TAG, "Playing sound " + soundUri + " with attributes " + audioAttributes);
                        player.playAsync(soundUri, record.sbn.getUser(), looping, audioAttributes);
                        beep = true;
                    }
                } catch (RemoteException e) {
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            }
        }
        // vibrate
        // Does the notification want to specify its own vibration?
        final boolean hasCustomVibrate = notification.vibrate != null;
        // new in 4.2: if there was supposed to be a sound and we're in vibrate
        // mode, and no other vibration is specified, we fall back to vibration
        final boolean convertSoundToVibration = !hasCustomVibrate && hasValidSound && (mAudioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_VIBRATE);
        // The DEFAULT_VIBRATE flag trumps any custom vibration AND the fallback.
        final boolean useDefaultVibrate = (notification.defaults & Notification.DEFAULT_VIBRATE) != 0;
        if ((useDefaultVibrate || convertSoundToVibration || hasCustomVibrate) && !(mAudioManager.getRingerModeInternal() == AudioManager.RINGER_MODE_SILENT)) {
            mVibrateNotificationKey = record.getKey();
            if (useDefaultVibrate || convertSoundToVibration) {
                // Escalate privileges so we can use the vibrator even if the
                // notifying app does not have the VIBRATE permission.
                long identity = Binder.clearCallingIdentity();
                try {
                    mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), useDefaultVibrate ? mDefaultVibrationPattern : mFallbackVibrationPattern, ((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1, audioAttributesForNotification(notification));
                    buzz = true;
                } finally {
                    Binder.restoreCallingIdentity(identity);
                }
            } else if (notification.vibrate.length > 1) {
                // If you want your own vibration pattern, you need the VIBRATE
                // permission
                mVibrator.vibrate(record.sbn.getUid(), record.sbn.getOpPkg(), notification.vibrate, ((notification.flags & Notification.FLAG_INSISTENT) != 0) ? 0 : -1, audioAttributesForNotification(notification));
                buzz = true;
            }
        }
    }
    // light
    // release the light
    boolean wasShowLights = mLights.remove(record.getKey());
    final boolean canInterruptWithLight = canInterrupt || isLedNotificationForcedOn(record) || (!canInterrupt && mZenModeHelper.getAllowLights());
    if ((notification.flags & Notification.FLAG_SHOW_LIGHTS) != 0 && canInterruptWithLight) {
        mLights.add(record.getKey());
        updateLightsLocked();
        if (mUseAttentionLight) {
            mAttentionLight.pulse();
        }
        blink = true;
    } else if (wasShowLights) {
        updateLightsLocked();
    }
    if (buzz || beep || blink) {
        EventLogTags.writeNotificationAlert(record.getKey(), buzz ? 1 : 0, beep ? 1 : 0, blink ? 1 : 0);
        mHandler.post(mBuzzBeepBlinked);
    }
}
#end_block

#method_before
void updateLightsLocked() {
    // handle notification lights
    NotificationRecord ledNotification = null;
    while (ledNotification == null && !mLights.isEmpty()) {
        final String owner = mLights.get(mLights.size() - 1);
        ledNotification = mNotificationsByKey.get(owner);
        if (ledNotification == null) {
            Slog.wtfStack(TAG, "LED Notification does not exist: " + owner);
            mLights.remove(owner);
        }
    }
    // Don't flash while we are in a call or screen is on
    // (unless Notification has EXTRA_FORCE_SHOW_LGHTS)
    final boolean enableLed;
    if (ledNotification == null) {
        enableLed = false;
    } else if (isLedNotificationForcedOn(ledNotification)) {
        enableLed = true;
    } else if (!mScreenOnEnabled && (mInCall || mScreenOn)) {
        enableLed = false;
    } else {
        enableLed = true;
    }
    if (!enableLed) {
        mNotificationLight.turnOff();
        mStatusBar.notificationLightOff();
    } else {
        final Notification ledno = ledNotification.sbn.getNotification();
        final NotificationLedValues ledValues = getLedValuesForNotification(ledNotification);
        int ledARGB;
        int ledOnMS;
        int ledOffMS;
        if (ledValues != null) {
            ledARGB = ledValues.color != 0 ? ledValues.color : mDefaultNotificationColor;
            ledOnMS = ledValues.onMS >= 0 ? ledValues.onMS : mDefaultNotificationLedOn;
            ledOffMS = ledValues.offMS >= 0 ? ledValues.offMS : mDefaultNotificationLedOff;
        } else if ((ledno.defaults & Notification.DEFAULT_LIGHTS) != 0) {
            ledARGB = mDefaultNotificationColor;
            ledOnMS = mDefaultNotificationLedOn;
            ledOffMS = mDefaultNotificationLedOff;
        } else {
            ledARGB = ledno.ledARGB;
            ledOnMS = ledno.ledOnMS;
            ledOffMS = ledno.ledOffMS;
        }
        // update the LEDs modes variables
        mNotificationLight.setModes(mNotificationLedBrightnessLevel, mMultipleLedsEnabledSetting);
        if (mNotificationPulseEnabled) {
            // pulse repeatedly
            mNotificationLight.setFlashing(ledARGB, Light.LIGHT_FLASH_TIMED, ledOnMS, ledOffMS);
        }
        // let SystemUI make an independent decision
        mStatusBar.notificationLightPulse(ledARGB, ledOnMS, ledOffMS);
    }
}
#method_after
void updateLightsLocked() {
    // handle notification lights
    NotificationRecord ledNotification = null;
    while (ledNotification == null && !mLights.isEmpty()) {
        final String owner = mLights.get(mLights.size() - 1);
        ledNotification = mNotificationsByKey.get(owner);
        if (ledNotification == null) {
            Slog.wtfStack(TAG, "LED Notification does not exist: " + owner);
            mLights.remove(owner);
        }
    }
    // Don't flash while we are in a call or screen is on
    // (unless Notification has EXTRA_FORCE_SHOW_LGHTS)
    final boolean enableLed;
    if (ledNotification == null) {
        enableLed = false;
    } else if (isLedNotificationForcedOn(ledNotification)) {
        enableLed = true;
    } else if (!mScreenOnEnabled && (mInCall || mScreenOn)) {
        enableLed = false;
    } else {
        enableLed = true;
    }
    if (!enableLed) {
        mNotificationLight.turnOff();
        mStatusBar.notificationLightOff();
    } else {
        final Notification ledno = ledNotification.sbn.getNotification();
        final NotificationLedValues ledValues = getLedValuesForNotification(ledNotification);
        int ledARGB;
        int ledOnMS;
        int ledOffMS;
        if (ledValues != null) {
            ledARGB = ledValues.color != 0 ? ledValues.color : mDefaultNotificationColor;
            ledOnMS = ledValues.onMS >= 0 ? ledValues.onMS : mDefaultNotificationLedOn;
            ledOffMS = ledValues.offMS >= 0 ? ledValues.offMS : mDefaultNotificationLedOff;
        } else if ((ledno.defaults & Notification.DEFAULT_LIGHTS) != 0) {
            ledARGB = generateLedColorForNotification(ledNotification);
            ledOnMS = mDefaultNotificationLedOn;
            ledOffMS = mDefaultNotificationLedOff;
        } else {
            ledARGB = ledno.ledARGB;
            ledOnMS = ledno.ledOnMS;
            ledOffMS = ledno.ledOffMS;
        }
        // update the LEDs modes variables
        mNotificationLight.setModes(mNotificationLedBrightnessLevel, mMultipleLedsEnabledSetting);
        if (mNotificationPulseEnabled) {
            // pulse repeatedly
            mNotificationLight.setFlashing(ledARGB, Light.LIGHT_FLASH_TIMED, ledOnMS, ledOffMS);
        }
        // let SystemUI make an independent decision
        mStatusBar.notificationLightPulse(ledARGB, ledOnMS, ledOffMS);
    }
}
#end_block

#method_before
@Override
public View createDetailView(Context context, View convertView, ViewGroup parent) {
    mItems = QSDetailItemsList.convertOrInflate(context, convertView, parent);
    ListView listView = mItems.getListView();
    listView.setOnItemClickListener(this);
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    listView.setDivider(null);
    RadioAdapter adapter = new RadioAdapter(context, android.R.layout.simple_list_item_single_choice, mEntries);
    int indexOfSelection = Arrays.asList(mValues).indexOf(String.valueOf(getScreenTimeout()));
    mItems.setAdapter(adapter);
    listView.setItemChecked(indexOfSelection, true);
    mItems.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() {

        @Override
        public void onViewAttachedToWindow(View v) {
        }

        @Override
        public void onViewDetachedFromWindow(View v) {
            mUiHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    mShowingDetail = false;
                    refreshState(true);
                }
            }, 100);
        }
    });
    return mItems;
}
#method_after
@Override
public View createDetailView(Context context, View convertView, ViewGroup parent) {
    mItems = QSDetailItemsList.convertOrInflate(context, convertView, parent);
    ListView listView = mItems.getListView();
    listView.setOnItemClickListener(this);
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    listView.setDivider(null);
    RadioAdapter adapter = new RadioAdapter(context, android.R.layout.simple_list_item_single_choice, mEntries);
    int indexOfSelection = Arrays.asList(mValues).indexOf(String.valueOf(getScreenTimeout()));
    mItems.setAdapter(adapter);
    listView.setItemChecked(indexOfSelection, true);
    mItems.addOnAttachStateChangeListener(new View.OnAttachStateChangeListener() {

        @Override
        public void onViewAttachedToWindow(View v) {
        }

        @Override
        public void onViewDetachedFromWindow(View v) {
            mUiHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    refreshState(true);
                }
            }, 100);
        }
    });
    return mItems;
}
#end_block

#method_before
String tokenToDirectoryPath(String domainToken) {
    try {
        if (domainToken.equals(FullBackup.DATA_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        } else if (domainToken.startsWith(FullBackup.SHARED_STORAGE_TOKEN)) {
            File dir = new File(domainToken);
            return dir.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        }
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, "Error reading directory for domain: " + domainToken);
        return null;
    }
}
#method_after
String tokenToDirectoryPath(String domainToken) {
    try {
        if (domainToken.equals(FullBackup.DATA_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        } else if (domainToken.startsWith(FullBackup.SHARED_PREFIX)) {
            int slash = domainToken.indexOf('/');
            int i = Integer.parseInt(domainToken.substring(slash + 1));
            if (i < mVolumes.length) {
                return mVolumes[i].getPath();
            } else {
                Log.e(TAG, "Could not find volume for " + domainToken);
            }
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        }
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, "Error reading directory for domain: " + domainToken);
        return null;
    }
}
#end_block

#method_before
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                mPendingInstalls.remove(0);
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                mRunningInstalls.delete(msg.arg1);
                boolean deleteOld = false;
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo res = data.res;
                    if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                        final String packageName = res.pkg.applicationInfo.packageName;
                        res.removedInfo.sendBroadcast(false, true, false);
                        Bundle extras = new Bundle(1);
                        extras.putInt(Intent.EXTRA_UID, res.uid);
                        // permissions if requested before broadcasting the install.
                        if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
                            grantRequestedRuntimePermissions(res.pkg, args.user.getIdentifier(), args.installGrantPermissions);
                        }
                        // Determine the set of users who are adding this
                        // package for the first time vs. those who are seeing
                        // an update.
                        int[] firstUsers;
                        int[] updateUsers = new int[0];
                        if (res.origUsers == null || res.origUsers.length == 0) {
                            firstUsers = res.newUsers;
                        } else {
                            firstUsers = new int[0];
                            for (int i = 0; i < res.newUsers.length; i++) {
                                int user = res.newUsers[i];
                                boolean isNew = true;
                                for (int j = 0; j < res.origUsers.length; j++) {
                                    if (res.origUsers[j] == user) {
                                        isNew = false;
                                        break;
                                    }
                                }
                                if (isNew) {
                                    int[] newFirst = new int[firstUsers.length + 1];
                                    System.arraycopy(firstUsers, 0, newFirst, 0, firstUsers.length);
                                    newFirst[firstUsers.length] = user;
                                    firstUsers = newFirst;
                                } else {
                                    int[] newUpdate = new int[updateUsers.length + 1];
                                    System.arraycopy(updateUsers, 0, newUpdate, 0, updateUsers.length);
                                    newUpdate[updateUsers.length] = user;
                                    updateUsers = newUpdate;
                                }
                            }
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, firstUsers);
                        final boolean update = res.removedInfo.removedPackage != null;
                        if (update) {
                            extras.putBoolean(Intent.EXTRA_REPLACING, true);
                        }
                        String category = null;
                        if (res.pkg.mIsThemeApk) {
                            category = Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, updateUsers);
                        if (update) {
                            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, null, extras, null, null, updateUsers);
                            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, updateUsers);
                            // treat asec-hosted packages like removable media on upgrade
                            if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                                if (DEBUG_INSTALL) {
                                    Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                                }
                                int[] uidArray = new int[] { res.pkg.applicationInfo.uid };
                                ArrayList<String> pkgList = new ArrayList<String>(1);
                                pkgList.add(packageName);
                                sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null);
                            }
                        }
                        // if this was a theme, send it off to the theme service for processing
                        if (res.pkg.mIsThemeApk || res.pkg.mIsLegacyIconPackApk) {
                            processThemeResourcesInThemeService(res.pkg.packageName);
                        }
                        if (res.removedInfo.args != null) {
                            // Remove the replaced package's older resources safely now
                            deleteOld = true;
                        }
                        // users, clear any default-browser state in those users
                        if (firstUsers.length > 0) {
                            // check its browser nature in any user and generalize.
                            if (packageIsBrowser(packageName, firstUsers[0])) {
                                synchronized (mPackages) {
                                    for (int userId : firstUsers) {
                                        mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                                    }
                                }
                            }
                        }
                        if (!update && !isSystemApp(res.pkg)) {
                            boolean privacyGuard = CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.PRIVACY_GUARD_DEFAULT, 0, UserHandle.USER_CURRENT) == 1;
                            if (privacyGuard) {
                                mAppOps.setPrivacyGuardSettingForPackage(res.pkg.applicationInfo.uid, res.pkg.applicationInfo.packageName, true);
                            }
                        }
                        // Log current value of "unknown sources" setting
                        EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
                    }
                    // Force a gc to clear up things
                    Runtime.getRuntime().gc();
                    // We delete after a gc for applications  on sdcard.
                    if (deleteOld) {
                        synchronized (mInstallLock) {
                            res.removedInfo.args.doPostDeleteLI(true);
                        }
                    }
                    if (args.observer != null) {
                        try {
                            Bundle extras = extrasForInstallResult(res);
                            args.observer.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras);
                        } catch (RemoteException e) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#method_after
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                mPendingInstalls.remove(0);
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                mRunningInstalls.delete(msg.arg1);
                boolean deleteOld = false;
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo res = data.res;
                    if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                        final String packageName = res.pkg.applicationInfo.packageName;
                        res.removedInfo.sendBroadcast(false, true, false);
                        Bundle extras = new Bundle(1);
                        extras.putInt(Intent.EXTRA_UID, res.uid);
                        // permissions if requested before broadcasting the install.
                        if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
                            grantRequestedRuntimePermissions(res.pkg, args.user.getIdentifier(), args.installGrantPermissions);
                        }
                        // Determine the set of users who are adding this
                        // package for the first time vs. those who are seeing
                        // an update.
                        int[] firstUsers;
                        int[] updateUsers = new int[0];
                        if (res.origUsers == null || res.origUsers.length == 0) {
                            firstUsers = res.newUsers;
                        } else {
                            firstUsers = new int[0];
                            for (int i = 0; i < res.newUsers.length; i++) {
                                int user = res.newUsers[i];
                                boolean isNew = true;
                                for (int j = 0; j < res.origUsers.length; j++) {
                                    if (res.origUsers[j] == user) {
                                        isNew = false;
                                        break;
                                    }
                                }
                                if (isNew) {
                                    int[] newFirst = new int[firstUsers.length + 1];
                                    System.arraycopy(firstUsers, 0, newFirst, 0, firstUsers.length);
                                    newFirst[firstUsers.length] = user;
                                    firstUsers = newFirst;
                                } else {
                                    int[] newUpdate = new int[updateUsers.length + 1];
                                    System.arraycopy(updateUsers, 0, newUpdate, 0, updateUsers.length);
                                    newUpdate[updateUsers.length] = user;
                                    updateUsers = newUpdate;
                                }
                            }
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, firstUsers);
                        final boolean update = res.removedInfo.removedPackage != null;
                        if (update) {
                            extras.putBoolean(Intent.EXTRA_REPLACING, true);
                        }
                        String category = null;
                        if (res.pkg.mIsThemeApk) {
                            category = cyanogenmod.content.Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, updateUsers);
                        if (update) {
                            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, null, extras, null, null, updateUsers);
                            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, updateUsers);
                            // treat asec-hosted packages like removable media on upgrade
                            if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                                if (DEBUG_INSTALL) {
                                    Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                                }
                                int[] uidArray = new int[] { res.pkg.applicationInfo.uid };
                                ArrayList<String> pkgList = new ArrayList<String>(1);
                                pkgList.add(packageName);
                                sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null);
                            }
                        }
                        // if this was a theme, send it off to the theme service for processing
                        if (res.pkg.mIsThemeApk || res.pkg.mIsLegacyIconPackApk) {
                            processThemeResourcesInThemeService(res.pkg.packageName);
                        }
                        if (res.removedInfo.args != null) {
                            // Remove the replaced package's older resources safely now
                            deleteOld = true;
                        }
                        // users, clear any default-browser state in those users
                        if (firstUsers.length > 0) {
                            // check its browser nature in any user and generalize.
                            if (packageIsBrowser(packageName, firstUsers[0])) {
                                synchronized (mPackages) {
                                    for (int userId : firstUsers) {
                                        mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                                    }
                                }
                            }
                        }
                        if (!update && !isSystemApp(res.pkg)) {
                            boolean privacyGuard = CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.PRIVACY_GUARD_DEFAULT, 0, UserHandle.USER_CURRENT) == 1;
                            if (privacyGuard) {
                                mAppOps.setPrivacyGuardSettingForPackage(res.pkg.applicationInfo.uid, res.pkg.applicationInfo.packageName, true);
                            }
                        }
                        // Log current value of "unknown sources" setting
                        EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
                    }
                    // Force a gc to clear up things
                    Runtime.getRuntime().gc();
                    // We delete after a gc for applications  on sdcard.
                    if (deleteOld) {
                        synchronized (mInstallLock) {
                            res.removedInfo.args.doPostDeleteLI(true);
                        }
                    }
                    if (args.observer != null) {
                        try {
                            Bundle extras = extrasForInstallResult(res);
                            args.observer.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras);
                        } catch (RemoteException e) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#end_block

#method_before
private void compileResourcesWithAapt(String target, PackageParser.Package pkg) throws IOException, AaptException {
    String internalPath = APK_PATH_TO_OVERLAY + target + File.separator;
    String resPath = ThemeUtils.getTargetCacheDir(target, pkg);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    int pkgId;
    if ("android".equals(target)) {
        pkgId = Resources.THEME_FRAMEWORK_PKG_ID;
    } else if (COMMON_OVERLAY.equals(target)) {
        pkgId = Resources.THEME_COMMON_PKG_ID;
    } else {
        pkgId = Resources.THEME_APP_PKG_ID;
    }
    boolean hasCommonResources = (hasCommonResources(pkg) && !COMMON_OVERLAY.equals(target));
    PackageParser.Package targetPkg = mPackages.get(target);
    String appPath = targetPkg != null ? targetPkg.baseCodePath : "";
    if (mInstaller.aapt(pkg.baseCodePath, internalPath, resPath, sharedGid, pkgId, pkg.applicationInfo.targetSdkVersion, appPath, hasCommonResources ? ThemeUtils.getTargetCacheDir(COMMON_OVERLAY, pkg) + File.separator + "resources.apk" : "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#method_after
private void compileResourcesWithAapt(String target, PackageParser.Package pkg) throws IOException, AaptException {
    String internalPath = APK_PATH_TO_OVERLAY + target + File.separator;
    String resPath = ThemeUtils.getTargetCacheDir(target, pkg);
    final int sharedGid = UserHandle.getSharedAppGid(pkg.applicationInfo.uid);
    int pkgId;
    if ("android".equals(target)) {
        pkgId = Resources.THEME_FRAMEWORK_PKG_ID;
    } else if (COMMON_OVERLAY.equals(target)) {
        pkgId = Resources.THEME_COMMON_PKG_ID;
    } else {
        pkgId = Resources.THEME_APP_PKG_ID;
    }
    boolean hasCommonResources = (hasCommonResources(pkg) && !COMMON_OVERLAY.equals(target));
    PackageParser.Package targetPkg = mPackages.get(target);
    String appPath = targetPkg != null ? targetPkg.baseCodePath : Environment.getRootDirectory() + "/framework/framework-res.apk";
    if (mInstaller.aapt(pkg.baseCodePath, internalPath, resPath, sharedGid, pkgId, pkg.applicationInfo.targetSdkVersion, appPath, hasCommonResources ? ThemeUtils.getTargetCacheDir(COMMON_OVERLAY, pkg) + File.separator + "resources.apk" : "") != 0) {
        throw new AaptException("Failed to run aapt");
    }
}
#end_block

#method_before
private int deletePackageX(String packageName, int userId, int flags) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    final boolean res;
    final UserHandle removeForUser = (flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId);
    if (isPackageDeviceAdmin(packageName, removeForUser.getIdentifier())) {
        Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
        return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
    boolean removedForAllUsers = false;
    boolean systemUpdate = false;
    // for the uninstall-updates case and restricted profiles, remember the per-
    // userhandle installed state
    int[] allUsers;
    boolean[] perUserInstalled;
    synchronized (mPackages) {
        PackageSetting ps = mSettings.mPackages.get(packageName);
        allUsers = sUserManager.getUserIds();
        perUserInstalled = new boolean[allUsers.length];
        for (int i = 0; i < allUsers.length; i++) {
            perUserInstalled[i] = ps != null ? ps.getInstalled(allUsers[i]) : false;
        }
    }
    synchronized (mInstallLock) {
        if (DEBUG_REMOVE)
            Slog.d(TAG, "deletePackageX: pkg=" + packageName + " user=" + userId);
        res = deletePackageLI(packageName, removeForUser, true, allUsers, perUserInstalled, flags | REMOVE_CHATTY, info, true);
        systemUpdate = info.isRemovedPackageSystemUpdate;
        if (res && !systemUpdate && mPackages.get(packageName) == null) {
            removedForAllUsers = true;
        }
        if (DEBUG_REMOVE)
            Slog.d(TAG, "delete res: systemUpdate=" + systemUpdate + " removedForAllUsers=" + removedForAllUsers);
    }
    if (res) {
        info.sendBroadcast(true, systemUpdate, removedForAllUsers);
        // was re-enabled; we need to broadcast this information
        if (systemUpdate) {
            Bundle extras = new Bundle(1);
            extras.putInt(Intent.EXTRA_UID, info.removedAppId >= 0 ? info.removedAppId : info.uid);
            extras.putBoolean(Intent.EXTRA_REPLACING, true);
            String category = null;
            if (info.isThemeApk) {
                category = Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
            }
            sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, category, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, category, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, null);
        }
    }
    // Force a gc here.
    Runtime.getRuntime().gc();
    // other processes clean up before deleting resources.
    if (info.args != null) {
        synchronized (mInstallLock) {
            info.args.doPostDeleteLI(true);
        }
    }
    return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}
#method_after
private int deletePackageX(String packageName, int userId, int flags) {
    final PackageRemovedInfo info = new PackageRemovedInfo();
    final boolean res;
    final UserHandle removeForUser = (flags & PackageManager.DELETE_ALL_USERS) != 0 ? UserHandle.ALL : new UserHandle(userId);
    if (isPackageDeviceAdmin(packageName, removeForUser.getIdentifier())) {
        Slog.w(TAG, "Not removing package " + packageName + ": has active device admin");
        return PackageManager.DELETE_FAILED_DEVICE_POLICY_MANAGER;
    }
    boolean removedForAllUsers = false;
    boolean systemUpdate = false;
    // for the uninstall-updates case and restricted profiles, remember the per-
    // userhandle installed state
    int[] allUsers;
    boolean[] perUserInstalled;
    synchronized (mPackages) {
        PackageSetting ps = mSettings.mPackages.get(packageName);
        allUsers = sUserManager.getUserIds();
        perUserInstalled = new boolean[allUsers.length];
        for (int i = 0; i < allUsers.length; i++) {
            perUserInstalled[i] = ps != null ? ps.getInstalled(allUsers[i]) : false;
        }
    }
    synchronized (mInstallLock) {
        if (DEBUG_REMOVE)
            Slog.d(TAG, "deletePackageX: pkg=" + packageName + " user=" + userId);
        res = deletePackageLI(packageName, removeForUser, true, allUsers, perUserInstalled, flags | REMOVE_CHATTY, info, true);
        systemUpdate = info.isRemovedPackageSystemUpdate;
        if (res && !systemUpdate && mPackages.get(packageName) == null) {
            removedForAllUsers = true;
        }
        if (DEBUG_REMOVE)
            Slog.d(TAG, "delete res: systemUpdate=" + systemUpdate + " removedForAllUsers=" + removedForAllUsers);
    }
    if (res) {
        info.sendBroadcast(true, systemUpdate, removedForAllUsers);
        // was re-enabled; we need to broadcast this information
        if (systemUpdate) {
            Bundle extras = new Bundle(1);
            extras.putInt(Intent.EXTRA_UID, info.removedAppId >= 0 ? info.removedAppId : info.uid);
            extras.putBoolean(Intent.EXTRA_REPLACING, true);
            String category = null;
            if (info.isThemeApk) {
                category = cyanogenmod.content.Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
            }
            sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, category, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, category, extras, null, null, null);
            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, null);
        }
    }
    // Force a gc here.
    Runtime.getRuntime().gc();
    // other processes clean up before deleting resources.
    if (info.args != null) {
        synchronized (mInstallLock) {
            info.args.doPostDeleteLI(true);
        }
    }
    return res ? PackageManager.DELETE_SUCCEEDED : PackageManager.DELETE_FAILED_INTERNAL_ERROR;
}
#end_block

#method_before
void sendBroadcast(boolean fullRemove, boolean replacing, boolean removedForAllUsers) {
    Bundle extras = new Bundle(1);
    extras.putInt(Intent.EXTRA_UID, removedAppId >= 0 ? removedAppId : uid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED, fullRemove);
    if (replacing) {
        extras.putBoolean(Intent.EXTRA_REPLACING, true);
    }
    extras.putBoolean(Intent.EXTRA_REMOVED_FOR_ALL_USERS, removedForAllUsers);
    if (removedPackage != null) {
        String category = null;
        if (isThemeApk) {
            category = Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
        }
        sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED, removedPackage, category, extras, null, null, removedUsers);
        if (fullRemove && !replacing) {
            sendPackageBroadcast(Intent.ACTION_PACKAGE_FULLY_REMOVED, removedPackage, category, extras, null, null, removedUsers);
        }
    }
    if (removedAppId >= 0) {
        sendPackageBroadcast(Intent.ACTION_UID_REMOVED, null, null, extras, null, null, removedUsers);
    }
}
#method_after
void sendBroadcast(boolean fullRemove, boolean replacing, boolean removedForAllUsers) {
    Bundle extras = new Bundle(1);
    extras.putInt(Intent.EXTRA_UID, removedAppId >= 0 ? removedAppId : uid);
    extras.putBoolean(Intent.EXTRA_DATA_REMOVED, fullRemove);
    if (replacing) {
        extras.putBoolean(Intent.EXTRA_REPLACING, true);
    }
    extras.putBoolean(Intent.EXTRA_REMOVED_FOR_ALL_USERS, removedForAllUsers);
    if (removedPackage != null) {
        String category = null;
        if (isThemeApk) {
            category = cyanogenmod.content.Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
        }
        sendPackageBroadcast(Intent.ACTION_PACKAGE_REMOVED, removedPackage, category, extras, null, null, removedUsers);
        if (fullRemove && !replacing) {
            sendPackageBroadcast(Intent.ACTION_PACKAGE_FULLY_REMOVED, removedPackage, category, extras, null, null, removedUsers);
        }
    }
    if (removedAppId >= 0) {
        sendPackageBroadcast(Intent.ACTION_UID_REMOVED, null, null, extras, null, null, removedUsers);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String[] externalServices = context.getResources().getStringArray(com.android.internal.R.array.config_externalCMServices);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    EdgeGestureService edgeGestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
        try {
            Slog.i(TAG, "EdgeGesture service");
            edgeGestureService = new EdgeGestureService(context, inputManager);
            ServiceManager.addService("edgegestureservice", edgeGestureService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting EdgeGesture service", e);
        }
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    for (String service : externalServices) {
        try {
            Slog.i(TAG, service);
            mSystemServiceManager.startService(service);
        } catch (Throwable e) {
            reportWtf("starting " + service, e);
        }
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (edgeGestureService != null) {
        try {
            edgeGestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making EdgeGesture service ready", e);
        }
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_APP_FAILURE);
    filter.addAction(Intent.ACTION_APP_FAILURE_RESET);
    filter.addAction(Intent.ACTION_PACKAGE_ADDED);
    filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
    filter.addAction(ThemeUtils.ACTION_THEME_CHANGED);
    filter.addCategory(Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE);
    filter.addDataScheme("package");
    context.registerReceiver(new AppsFailureReceiver(), filter);
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            // valid NfcAdapter from NfcManager
            try {
                startNfcService(context);
            } catch (Throwable e) {
                // Don't crash. Nfc is an optional service. Just annotate that isn't ready
                Slog.e(TAG, "Nfc service didn't start. Nfc will not be available.", e);
            }
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#method_after
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String[] externalServices = context.getResources().getStringArray(com.android.internal.R.array.config_externalCMServices);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    EdgeGestureService edgeGestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
        try {
            Slog.i(TAG, "EdgeGesture service");
            edgeGestureService = new EdgeGestureService(context, inputManager);
            ServiceManager.addService("edgegestureservice", edgeGestureService);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting EdgeGesture service", e);
        }
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    for (String service : externalServices) {
        try {
            Slog.i(TAG, service);
            mSystemServiceManager.startService(service);
        } catch (Throwable e) {
            reportWtf("starting " + service, e);
        }
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (edgeGestureService != null) {
        try {
            edgeGestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making EdgeGesture service ready", e);
        }
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            // valid NfcAdapter from NfcManager
            try {
                startNfcService(context);
            } catch (Throwable e) {
                // Don't crash. Nfc is an optional service. Just annotate that isn't ready
                Slog.e(TAG, "Nfc service didn't start. Nfc will not be available.", e);
            }
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#end_block

#method_before
private void sendAppFailureBroadcast(String pkgName) {
    Intent intent = new Intent(Intent.ACTION_APP_FAILURE, (pkgName != null) ? Uri.fromParts("package", pkgName, null) : null);
    mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
}
#method_after
private void sendAppFailureBroadcast(String pkgName) {
    Intent intent = new Intent(cyanogenmod.content.Intent.ACTION_APP_FAILURE, (pkgName != null) ? Uri.fromParts("package", pkgName, null) : null);
    mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
}
#end_block

#method_before
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    ThemeConfig currentTheme = mContext.getResources().getConfiguration().themeConfig;
    if (currentTheme != null) {
        mCurrentTheme = (ThemeConfig) currentTheme.clone();
    } else {
        mCurrentTheme = ThemeConfig.getBootTheme(mContext.getContentResolver());
    }
    mStatusBarWindow = new StatusBarWindowView(mContext, null);
    mStatusBarWindow.setService(this);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    // Developer options - Force Navigation bar
    try {
        boolean needsNav = mWindowManagerService.needsNavigationBar();
        if (!needsNav) {
            mDevForceNavbarObserver = new DevForceNavbarObserver(mHandler);
            mDevForceNavbarObserver.observe();
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController, mSuController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    WallpaperManager wallpaperManager = (WallpaperManager) mContext.getSystemService(Context.WALLPAPER_SERVICE);
    mKeyguardWallpaper = wallpaperManager.getKeyguardBitmap();
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    updateCustomRecentsLongPressHandler(true);
}
#method_after
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    ThemeConfig currentTheme = mContext.getResources().getConfiguration().themeConfig;
    if (currentTheme != null) {
        mCurrentTheme = (ThemeConfig) currentTheme.clone();
    } else {
        mCurrentTheme = ThemeConfig.getBootTheme(mContext.getContentResolver());
    }
    mStatusBarWindow = new StatusBarWindowView(mContext, null);
    mStatusBarWindow.setService(this);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    // Developer options - Force Navigation bar
    try {
        boolean needsNav = mWindowManagerService.needsNavigationBar();
        if (!needsNav) {
            mDevForceNavbarObserver = new DevForceNavbarObserver(mHandler);
            mDevForceNavbarObserver.observe();
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController, mSuController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    WallpaperManager wallpaperManager = (WallpaperManager) mContext.getSystemService(Context.WALLPAPER_SERVICE);
    mKeyguardWallpaper = wallpaperManager.getKeyguardBitmap();
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    updateCustomRecentsLongPressHandler(true);
    mThemeService = IThemeService.Stub.asInterface(ServiceManager.getService(CMContextConstants.CM_THEME_SERVICE));
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void recreateStatusBar() {
    mRecreating = true;
    if (mNetworkController != null) {
        removeSignalCallbacks(mNetworkController);
        if (mNetworkController.hasVoiceCallingFeature()) {
            mNetworkController.removeEmergencyListener(mHeader);
        }
    }
    if (mHeadsUpManager != null) {
        mHeadsUpManager.removeListener(mNotificationPanel);
        mHeadsUpManager.removeListener(mScrimController);
    }
    if (mIconController != null) {
        mIconController.cleanup();
    }
    if (mKeyguardIndicationController != null) {
        mKeyguardIndicationController.cleanup();
    }
    mStatusBarWindow.removeContent(mStatusBarWindowContent);
    mStatusBarWindow.clearDisappearingChildren();
    // extract icons from the soon-to-be recreated viewgroup.
    ViewGroup statusIcons = mIconController.getStatusIcons();
    int nIcons = statusIcons != null ? statusIcons.getChildCount() : 0;
    ArrayList<StatusBarIcon> icons = new ArrayList<StatusBarIcon>(nIcons);
    ArrayList<String> iconSlots = new ArrayList<String>(nIcons);
    for (int i = 0; i < nIcons; i++) {
        StatusBarIconView iconView = (StatusBarIconView) statusIcons.getChildAt(i);
        icons.add(iconView.getStatusBarIcon());
        iconSlots.add(iconView.getStatusBarSlot());
    }
    removeAllViews(mStatusBarWindowContent);
    // extract notifications.
    RankingMap rankingMap = mNotificationData.getRankingMap();
    int nNotifs = mNotificationData.size();
    ArrayList<Pair<String, StatusBarNotification>> notifications = new ArrayList<>(nNotifs);
    copyNotifications(notifications, mNotificationData);
    // data
    for (int i = 0; i < nNotifs; i++) {
        final NotificationData.Entry entry = mNotificationData.get(i);
        if (entry != null) {
            removeNotificationViews(entry.key, rankingMap);
        }
    }
    if (mCustomTileListenerService != null) {
        try {
            mCustomTileListenerService.unregisterAsSystemService();
        } catch (RemoteException e) {
            Log.e(TAG, "Unable to unregister custom tile listener", e);
        }
    }
    mQSPanel.getHost().setCustomTileListenerService(null);
    mQSPanel.setListening(false);
    makeStatusBarView();
    repositionNavigationBar();
    // re-add status icons
    for (int i = 0; i < nIcons; i++) {
        StatusBarIcon icon = icons.get(i);
        String slot = iconSlots.get(i);
        addIcon(slot, i, i, icon);
    }
    // recreate notifications.
    for (int i = 0; i < nNotifs; i++) {
        Pair<String, StatusBarNotification> notifData = notifications.get(i);
        addNotificationViews(createNotificationViews(notifData.second), rankingMap);
    }
    mNotificationData.filterAndSort();
    setAreThereNotifications();
    mStatusBarWindow.addContent(mStatusBarWindowContent);
    checkBarModes();
    // Stop the command queue until the new status bar container settles and has a layout pass
    mCommandQueue.pause();
    // fix notification panel being shifted to the left by calling
    // instantCollapseNotificationPanel()
    instantCollapseNotificationPanel();
    mStatusBarWindow.requestLayout();
    mStatusBarWindow.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

        @Override
        public void onGlobalLayout() {
            mStatusBarWindow.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            mCommandQueue.resume();
            mRecreating = false;
        }
    });
    // restart the keyguard so it picks up the newly created ScrimController
    startKeyguard();
    // if the keyguard was showing while this change occurred we'll need to do some extra work
    if (mState == StatusBarState.KEYGUARD) {
        // this will make sure the keyguard is showing
        showKeyguard();
    }
}
#method_after
private void recreateStatusBar() {
    mRecreating = true;
    if (mNetworkController != null) {
        removeSignalCallbacks(mNetworkController);
        if (mNetworkController.hasVoiceCallingFeature()) {
            mNetworkController.removeEmergencyListener(mHeader);
        }
    }
    if (mHeadsUpManager != null) {
        mHeadsUpManager.removeListener(mNotificationPanel);
        mHeadsUpManager.removeListener(mScrimController);
    }
    if (mIconController != null) {
        mIconController.cleanup();
    }
    if (mKeyguardIndicationController != null) {
        mKeyguardIndicationController.cleanup();
    }
    mStatusBarWindow.removeContent(mStatusBarWindowContent);
    mStatusBarWindow.clearDisappearingChildren();
    // extract icons from the soon-to-be recreated viewgroup.
    ViewGroup statusIcons = mIconController.getStatusIcons();
    int nIcons = statusIcons != null ? statusIcons.getChildCount() : 0;
    ArrayList<StatusBarIcon> icons = new ArrayList<StatusBarIcon>(nIcons);
    ArrayList<String> iconSlots = new ArrayList<String>(nIcons);
    for (int i = 0; i < nIcons; i++) {
        StatusBarIconView iconView = (StatusBarIconView) statusIcons.getChildAt(i);
        icons.add(iconView.getStatusBarIcon());
        iconSlots.add(iconView.getStatusBarSlot());
    }
    removeAllViews(mStatusBarWindowContent);
    // extract notifications.
    RankingMap rankingMap = mNotificationData.getRankingMap();
    int nNotifs = mNotificationData.size();
    ArrayList<Pair<String, StatusBarNotification>> notifications = new ArrayList<>(nNotifs);
    copyNotifications(notifications, mNotificationData);
    // now remove all the notifications since we'll be re-creating these with the copied data
    mNotificationData.clear();
    if (mCustomTileListenerService != null) {
        try {
            mCustomTileListenerService.unregisterAsSystemService();
        } catch (RemoteException e) {
            Log.e(TAG, "Unable to unregister custom tile listener", e);
        }
    }
    mQSPanel.getHost().setCustomTileListenerService(null);
    mQSPanel.setListening(false);
    makeStatusBarView();
    repositionNavigationBar();
    // re-add status icons
    for (int i = 0; i < nIcons; i++) {
        StatusBarIcon icon = icons.get(i);
        String slot = iconSlots.get(i);
        addIcon(slot, i, i, icon);
    }
    // recreate notifications.
    for (int i = 0; i < nNotifs; i++) {
        Pair<String, StatusBarNotification> notifData = notifications.get(i);
        addNotificationViews(createNotificationViews(notifData.second), rankingMap);
    }
    mNotificationData.filterAndSort();
    setAreThereNotifications();
    mStatusBarWindow.addContent(mStatusBarWindowContent);
    checkBarModes();
    // Stop the command queue until the new status bar container settles and has a layout pass
    mCommandQueue.pause();
    // fix notification panel being shifted to the left by calling
    // instantCollapseNotificationPanel()
    instantCollapseNotificationPanel();
    mStatusBarWindow.requestLayout();
    mStatusBarWindow.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {

        @Override
        public void onGlobalLayout() {
            mStatusBarWindow.getViewTreeObserver().removeOnGlobalLayoutListener(this);
            mCommandQueue.resume();
            mRecreating = false;
        }
    });
    // restart the keyguard so it picks up the newly created ScrimController
    startKeyguard();
    // if the keyguard was showing while this change occurred we'll need to do some extra work
    if (mState == StatusBarState.KEYGUARD) {
        // this will make sure the keyguard is showing
        showKeyguard();
    }
    // update mLastThemeChangeTime
    try {
        mLastThemeChangeTime = mThemeService.getLastThemeChangeTime();
    } catch (RemoteException e) {
    /* ignore */
    }
}
#end_block

#method_before
private boolean shouldUpdateStatusbar(ThemeConfig oldTheme, ThemeConfig newTheme) {
    // no newTheme, so no need to update status bar
    if (newTheme == null)
        return false;
    final String overlay = newTheme.getOverlayForStatusBar();
    final String icons = newTheme.getIconPackPkgName();
    final String fonts = newTheme.getFontPkgName();
    return oldTheme == null || (overlay != null && !overlay.equals(oldTheme.getOverlayForStatusBar()) || (fonts != null && !fonts.equals(oldTheme.getFontPkgName())) || (icons != null && !icons.equals(oldTheme.getIconPackPkgName())) || newTheme.getLastThemeChangeRequestType() == RequestType.THEME_UPDATED);
}
#method_after
private boolean shouldUpdateStatusbar(ThemeConfig oldTheme, ThemeConfig newTheme) {
    // no newTheme, so no need to update status bar
    if (newTheme == null)
        return false;
    final String overlay = newTheme.getOverlayForStatusBar();
    final String icons = newTheme.getIconPackPkgName();
    final String fonts = newTheme.getFontPkgName();
    boolean isNewThemeChange = false;
    try {
        isNewThemeChange = mLastThemeChangeTime < mThemeService.getLastThemeChangeTime();
    } catch (RemoteException e) {
    /* ignore */
    }
    return oldTheme == null || (overlay != null && !overlay.equals(oldTheme.getOverlayForStatusBar()) || (fonts != null && !fonts.equals(oldTheme.getFontPkgName())) || (icons != null && !icons.equals(oldTheme.getIconPackPkgName())) || isNewThemeChange);
}
#end_block

#method_before
private boolean shouldUpdateNavbar(ThemeConfig oldTheme, ThemeConfig newTheme) {
    // no newTheme, so no need to update navbar
    if (newTheme == null)
        return false;
    final String overlay = newTheme.getOverlayForNavBar();
    return oldTheme == null || (overlay != null && !overlay.equals(oldTheme.getOverlayForNavBar()) || newTheme.getLastThemeChangeRequestType() == RequestType.THEME_UPDATED);
}
#method_after
private boolean shouldUpdateNavbar(ThemeConfig oldTheme, ThemeConfig newTheme) {
    // no newTheme, so no need to update navbar
    if (newTheme == null)
        return false;
    final String overlay = newTheme.getOverlayForNavBar();
    boolean isNewThemeChange = false;
    try {
        isNewThemeChange = mLastThemeChangeTime < mThemeService.getLastThemeChangeTime();
    } catch (RemoteException e) {
    /* ignore */
    }
    return oldTheme == null || (overlay != null && !overlay.equals(oldTheme.getOverlayForNavBar()) || isNewThemeChange);
}
#end_block

#method_before
public void updateStackScrollerState(boolean goingToFullShade) {
    if (mStackScroller == null)
        return;
    boolean onKeyguard = mState == StatusBarState.KEYGUARD;
    mStackScroller.setHideSensitive(onKeyguard && !userAllowsPrivateNotificationsInPublic(mCurrentUserId), goingToFullShade);
    mStackScroller.setDimmed(onKeyguard, false);
    mStackScroller.setExpandingEnabled(!onKeyguard);
    ActivatableNotificationView activatedChild = mStackScroller.getActivatedChild();
    mStackScroller.setActivatedChild(null);
    if (activatedChild != null) {
        activatedChild.makeInactive(false);
    }
}
#method_after
public void updateStackScrollerState(boolean goingToFullShade) {
    if (mStackScroller == null)
        return;
    boolean onKeyguard = mState == StatusBarState.KEYGUARD;
    mStackScroller.setHideSensitive(isLockscreenPublicMode() || (!userAllowsPrivateNotificationsInPublic(mCurrentUserId) && onKeyguard), goingToFullShade);
    mStackScroller.setDimmed(onKeyguard, false);
    mStackScroller.setExpandingEnabled(!onKeyguard);
    ActivatableNotificationView activatedChild = mStackScroller.getActivatedChild();
    mStackScroller.setActivatedChild(null);
    if (activatedChild != null) {
        activatedChild.makeInactive(false);
    }
}
#end_block

#method_before
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    vibrateForCameraGesture();
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#method_after
@Override
public void onCameraLaunchGestureDetected(int source) {
    mLastCameraLaunchSource = source;
    if (mStartedGoingToSleep) {
        mLaunchCameraOnFinishedGoingToSleep = true;
        return;
    }
    if (!mNotificationPanel.canCameraGestureBeLaunched(mStatusBarKeyguardViewManager.isShowing() && mExpandedVisible)) {
        return;
    }
    if (!mDeviceInteractive) {
        PowerManager pm = mContext.getSystemService(PowerManager.class);
        pm.wakeUp(SystemClock.uptimeMillis(), "com.android.systemui:CAMERA_GESTURE");
        mStatusBarKeyguardViewManager.notifyDeviceWakeUpRequested();
    }
    if (source != StatusBarManager.CAMERA_LAUNCH_SOURCE_SCREEN_GESTURE) {
        vibrateForCameraGesture();
    }
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        startActivity(KeyguardBottomAreaView.INSECURE_CAMERA_INTENT, true);
    } else {
        if (!mDeviceInteractive) {
            // Avoid flickering of the scrim when we instant launch the camera and the bouncer
            // comes on.
            mScrimController.dontAnimateBouncerChangesUntilNextFrame();
            mGestureWakeLock.acquire(LAUNCH_TRANSITION_TIMEOUT_MS + 1000L);
        }
        if (mScreenTurningOn || mStatusBarKeyguardViewManager.isScreenTurnedOn()) {
            mNotificationPanel.launchCamera(mDeviceInteractive, /* animate */
            source);
        } else {
            // We need to defer the camera launch until the screen comes on, since otherwise
            // we will dismiss us too early since we are waiting on an activity to be drawn and
            // incorrectly get notified because of the screen on event (which resumes and pauses
            // some activities)
            mLaunchCameraOnScreenTurningOn = true;
        }
    }
}
#end_block

#method_before
public void registerContentObserverLocked(int userId) {
    if (mRegistered && mUserId == userId) {
        return;
    }
    ContentResolver resolver = mContext.getContentResolver();
    if (mRegistered) {
        mContext.getContentResolver().unregisterContentObserver(this);
        mRegistered = false;
    }
    if (mUserId != userId) {
        mLastEnabled = "";
        mUserId = userId;
    }
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ENABLED_INPUT_METHODS), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_IME_WITH_HARD_KEYBOARD), false, this, userId);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.STATUS_BAR_IME_SWITCHER), false, new ContentObserver(mHandler) {

        public void onChange(boolean selfChange) {
            updateFromSettingsLocked(true);
        }
    }, userId);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.HIGH_TOUCH_SENSITIVITY_ENABLE), false, this, userId);
    resolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.FEATURE_TOUCH_HOVERING), false, this, userId);
    mRegistered = true;
}
#method_after
public void registerContentObserverLocked(int userId) {
    if (mRegistered && mUserId == userId) {
        return;
    }
    ContentResolver resolver = mContext.getContentResolver();
    if (mRegistered) {
        mContext.getContentResolver().unregisterContentObserver(this);
        mRegistered = false;
    }
    if (mUserId != userId) {
        mLastEnabled = "";
        mUserId = userId;
    }
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ENABLED_INPUT_METHODS), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE), false, this, userId);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.SHOW_IME_WITH_HARD_KEYBOARD), false, this, userId);
    resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.STATUS_BAR_IME_SWITCHER), false, new ContentObserver(mHandler) {

        public void onChange(boolean selfChange) {
            updateFromSettingsLocked(true);
        }
    }, userId);
    if (mCMHardware.isSupported(CMHardwareManager.FEATURE_HIGH_TOUCH_SENSITIVITY)) {
        resolver.registerContentObserver(CMSettings.System.getUriFor(CMSettings.System.HIGH_TOUCH_SENSITIVITY_ENABLE), false, this, userId);
    }
    if (mCMHardware.isSupported(CMHardwareManager.FEATURE_TOUCH_HOVERING)) {
        resolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.FEATURE_TOUCH_HOVERING), false, this, userId);
    }
    mRegistered = true;
}
#end_block

#method_before
private void switchUserLocked(int newUserId) {
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 1/3. newUserId=" + newUserId + " currentUserId=" + mSettings.getCurrentUserId());
    // ContentObserver should be registered again when the user is changed
    mSettingsObserver.registerContentObserverLocked(newUserId);
    mSettings.setCurrentUserId(newUserId);
    updateCurrentProfileIds();
    // InputMethodFileManager should be reset when the user is changed
    mFileManager = new InputMethodFileManager(mMethodMap, newUserId);
    final String defaultImiId = mSettings.getSelectedInputMethod();
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 2/3. newUserId=" + newUserId + " defaultImiId=" + defaultImiId);
    // For secondary users, the list of enabled IMEs may not have been updated since the
    // callbacks to PackageMonitor are ignored for the secondary user. Here, defaultImiId may
    // not be empty even if the IME has been uninstalled by the primary user.
    // Even in such cases, IMMS works fine because it will find the most applicable
    // IME for that user.
    final boolean initialUserSwitch = TextUtils.isEmpty(defaultImiId);
    resetAllInternalStateLocked(false, /* updateOnlyWhenLocaleChanged */
    initialUserSwitch);
    if (initialUserSwitch) {
        InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), newUserId, mContext.getBasePackageName());
    }
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 3/3. newUserId=" + newUserId + " selectedIme=" + mSettings.getSelectedInputMethod());
}
#method_after
private void switchUserLocked(int newUserId) {
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 1/3. newUserId=" + newUserId + " currentUserId=" + mSettings.getCurrentUserId());
    // ContentObserver should be registered again when the user is changed
    mSettingsObserver.registerContentObserverLocked(newUserId);
    mSettings.setCurrentUserId(newUserId);
    updateCurrentProfileIds();
    // InputMethodFileManager should be reset when the user is changed
    mFileManager = new InputMethodFileManager(mMethodMap, newUserId);
    final String defaultImiId = mSettings.getSelectedInputMethod();
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 2/3. newUserId=" + newUserId + " defaultImiId=" + defaultImiId);
    // For secondary users, the list of enabled IMEs may not have been updated since the
    // callbacks to PackageMonitor are ignored for the secondary user. Here, defaultImiId may
    // not be empty even if the IME has been uninstalled by the primary user.
    // Even in such cases, IMMS works fine because it will find the most applicable
    // IME for that user.
    final boolean initialUserSwitch = TextUtils.isEmpty(defaultImiId);
    resetAllInternalStateLocked(false, /* updateOnlyWhenLocaleChanged */
    initialUserSwitch);
    if (initialUserSwitch) {
        InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), newUserId, mContext.getBasePackageName());
    }
    updateTouchHovering();
    updateTouchSensitivity();
    if (DEBUG)
        Slog.d(TAG, "Switching user stage 3/3. newUserId=" + newUserId + " selectedIme=" + mSettings.getSelectedInputMethod());
}
#end_block

#method_before
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateSystemUiLocked(mCurToken, mImeWindowVis, mBackDisposition);
            if (mShowOngoingImeSwitcherForPhones) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), mSettings.getCurrentUserId(), mContext.getBasePackageName());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
            mCMHardware = CMHardwareManager.getInstance(mContext);
        }
    }
}
#method_after
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateSystemUiLocked(mCurToken, mImeWindowVis, mBackDisposition);
            if (mShowOngoingImeSwitcherForPhones) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), mSettings.getCurrentUserId(), mContext.getBasePackageName());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
        }
    }
}
#end_block

#method_before
private void updateTouchSensitivity() {
    boolean touchSensitivityEnable = CMSettings.System.getInt(mContext.getContentResolver(), CMSettings.System.HIGH_TOUCH_SENSITIVITY_ENABLE, 0) == 1;
    mCMHardware.set(CMHardwareManager.FEATURE_HIGH_TOUCH_SENSITIVITY, touchSensitivityEnable);
}
#method_after
private void updateTouchSensitivity() {
    if (!mCMHardware.isSupported(CMHardwareManager.FEATURE_HIGH_TOUCH_SENSITIVITY)) {
        return;
    }
    boolean touchSensitivityEnable = CMSettings.System.getInt(mContext.getContentResolver(), CMSettings.System.HIGH_TOUCH_SENSITIVITY_ENABLE, 0) == 1;
    mCMHardware.set(CMHardwareManager.FEATURE_HIGH_TOUCH_SENSITIVITY, touchSensitivityEnable);
}
#end_block

#method_before
private void updateTouchHovering() {
    boolean touchHovering = CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.FEATURE_TOUCH_HOVERING, 0) == 1;
    mCMHardware.set(CMHardwareManager.FEATURE_TOUCH_HOVERING, touchHovering);
}
#method_after
private void updateTouchHovering() {
    if (!mCMHardware.isSupported(CMHardwareManager.FEATURE_TOUCH_HOVERING)) {
        return;
    }
    boolean touchHovering = CMSettings.Secure.getInt(mContext.getContentResolver(), CMSettings.Secure.FEATURE_TOUCH_HOVERING, 0) == 1;
    mCMHardware.set(CMHardwareManager.FEATURE_TOUCH_HOVERING, touchHovering);
}
#end_block

#method_before
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            // Must happen before registerContentObserverLocked
            mCMHardware = CMHardwareManager.getInstance(mContext);
            mSettingsObserver.registerContentObserverLocked(userId);
            updateFromSettingsLocked(true);
            updateTouchHovering();
            updateTouchSensitivity();
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateSystemUiLocked(mCurToken, mImeWindowVis, mBackDisposition);
            if (mShowOngoingImeSwitcherForPhones) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), mSettings.getCurrentUserId(), mContext.getBasePackageName());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
        }
    }
}
#method_after
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            // Must happen before registerContentObserverLocked
            mCMHardware = CMHardwareManager.getInstance(mContext);
            mSettingsObserver.registerContentObserverLocked(mSettings.getCurrentUserId());
            updateFromSettingsLocked(true);
            updateTouchHovering();
            updateTouchSensitivity();
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateSystemUiLocked(mCurToken, mImeWindowVis, mBackDisposition);
            if (mShowOngoingImeSwitcherForPhones) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mIPackageManager, mSettings.getEnabledInputMethodListLocked(), mSettings.getCurrentUserId(), mContext.getBasePackageName());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
        }
    }
}
#end_block

#method_before
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                mPendingInstalls.remove(0);
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                mRunningInstalls.delete(msg.arg1);
                boolean deleteOld = false;
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo res = data.res;
                    if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                        final String packageName = res.pkg.applicationInfo.packageName;
                        res.removedInfo.sendBroadcast(false, true, false);
                        Bundle extras = new Bundle(1);
                        extras.putInt(Intent.EXTRA_UID, res.uid);
                        // permissions if requested before broadcasting the install.
                        if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
                            grantRequestedRuntimePermissions(res.pkg, args.user.getIdentifier(), args.installGrantPermissions);
                        }
                        // Determine the set of users who are adding this
                        // package for the first time vs. those who are seeing
                        // an update.
                        int[] firstUsers;
                        int[] updateUsers = new int[0];
                        if (res.origUsers == null || res.origUsers.length == 0) {
                            firstUsers = res.newUsers;
                        } else {
                            firstUsers = new int[0];
                            for (int i = 0; i < res.newUsers.length; i++) {
                                int user = res.newUsers[i];
                                boolean isNew = true;
                                for (int j = 0; j < res.origUsers.length; j++) {
                                    if (res.origUsers[j] == user) {
                                        isNew = false;
                                        break;
                                    }
                                }
                                if (isNew) {
                                    int[] newFirst = new int[firstUsers.length + 1];
                                    System.arraycopy(firstUsers, 0, newFirst, 0, firstUsers.length);
                                    newFirst[firstUsers.length] = user;
                                    firstUsers = newFirst;
                                } else {
                                    int[] newUpdate = new int[updateUsers.length + 1];
                                    System.arraycopy(updateUsers, 0, newUpdate, 0, updateUsers.length);
                                    newUpdate[updateUsers.length] = user;
                                    updateUsers = newUpdate;
                                }
                            }
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, firstUsers);
                        final boolean update = res.removedInfo.removedPackage != null;
                        if (update) {
                            extras.putBoolean(Intent.EXTRA_REPLACING, true);
                        }
                        String category = null;
                        if (res.pkg.mIsThemeApk) {
                            category = cyanogenmod.content.Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, updateUsers);
                        if (update) {
                            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, null, extras, null, null, updateUsers);
                            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, updateUsers);
                            // treat asec-hosted packages like removable media on upgrade
                            if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                                if (DEBUG_INSTALL) {
                                    Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                                }
                                int[] uidArray = new int[] { res.pkg.applicationInfo.uid };
                                ArrayList<String> pkgList = new ArrayList<String>(1);
                                pkgList.add(packageName);
                                sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null);
                            }
                        }
                        // if this was a theme, send it off to the theme service for processing
                        if (res.pkg.mIsThemeApk || res.pkg.mIsLegacyIconPackApk) {
                            processThemeResourcesInThemeService(res.pkg.packageName);
                        } else if (mOverlays.containsKey(res.pkg.packageName)) {
                            Log.d(TAG, "Compiling themes in background for " + res.pkg.packageName);
                            // if this was an app and is themed send themes that theme it for processing
                            ArrayMap<String, PackageParser.Package> themes = mOverlays.get(res.pkg.packageName);
                            for (PackageParser.Package themePkg : themes.values()) {
                                processThemeResourcesInThemeService(themePkg.packageName);
                            }
                        }
                        if (res.removedInfo.args != null) {
                            // Remove the replaced package's older resources safely now
                            deleteOld = true;
                        }
                        // users, clear any default-browser state in those users
                        if (firstUsers.length > 0) {
                            // check its browser nature in any user and generalize.
                            if (packageIsBrowser(packageName, firstUsers[0])) {
                                synchronized (mPackages) {
                                    for (int userId : firstUsers) {
                                        mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                                    }
                                }
                            }
                        }
                        if (!update && !isSystemApp(res.pkg)) {
                            boolean privacyGuard = CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.PRIVACY_GUARD_DEFAULT, 0, UserHandle.USER_CURRENT) == 1;
                            if (privacyGuard) {
                                mAppOps.setPrivacyGuardSettingForPackage(res.pkg.applicationInfo.uid, res.pkg.applicationInfo.packageName, true);
                            }
                        }
                        // Log current value of "unknown sources" setting
                        EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
                    }
                    // Force a gc to clear up things
                    Runtime.getRuntime().gc();
                    // We delete after a gc for applications  on sdcard.
                    if (deleteOld) {
                        synchronized (mInstallLock) {
                            res.removedInfo.args.doPostDeleteLI(true);
                        }
                    }
                    if (args.observer != null) {
                        try {
                            Bundle extras = extrasForInstallResult(res);
                            args.observer.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras);
                        } catch (RemoteException e) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#method_after
void doHandleMessage(Message msg) {
    switch(msg.what) {
        case INIT_COPY:
            {
                HandlerParams params = (HandlerParams) msg.obj;
                int idx = mPendingInstalls.size();
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "init_copy idx=" + idx + ": " + params);
                // will be processed later on.
                if (!mBound) {
                    // have to bind to the service again.
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        params.serviceError();
                        return;
                    } else {
                        // Once we bind to the service, the first
                        // pending request will be processed.
                        mPendingInstalls.add(idx, params);
                    }
                } else {
                    mPendingInstalls.add(idx, params);
                    // sure we trigger off processing the first request.
                    if (idx == 0) {
                        mHandler.sendEmptyMessage(MCS_BOUND);
                    }
                }
                break;
            }
        case MCS_BOUND:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_bound");
                if (msg.obj != null) {
                    mContainerService = (IMediaContainerService) msg.obj;
                }
                if (mContainerService == null) {
                    if (!mBound) {
                        // Something seriously wrong since we are not bound and we are not
                        // waiting for connection. Bail out.
                        Slog.e(TAG, "Cannot bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    } else {
                        Slog.w(TAG, "Waiting to connect to media container service");
                    }
                } else if (mPendingInstalls.size() > 0) {
                    HandlerParams params = mPendingInstalls.get(0);
                    if (params != null) {
                        if (params.startCopy()) {
                            // go idle.
                            if (DEBUG_SD_INSTALL)
                                Log.i(TAG, "Checking for more work or unbind...");
                            // Delete pending install
                            if (mPendingInstalls.size() > 0) {
                                mPendingInstalls.remove(0);
                            }
                            if (mPendingInstalls.size() == 0) {
                                if (mBound) {
                                    if (DEBUG_SD_INSTALL)
                                        Log.i(TAG, "Posting delayed MCS_UNBIND");
                                    removeMessages(MCS_UNBIND);
                                    Message ubmsg = obtainMessage(MCS_UNBIND);
                                    // Unbind after a little delay, to avoid
                                    // continual thrashing.
                                    sendMessageDelayed(ubmsg, 10000);
                                }
                            } else {
                                // of next pending install.
                                if (DEBUG_SD_INSTALL)
                                    Log.i(TAG, "Posting MCS_BOUND for next work");
                                mHandler.sendEmptyMessage(MCS_BOUND);
                            }
                        }
                    }
                } else {
                    // Should never happen ideally.
                    Slog.w(TAG, "Empty queue");
                }
                break;
            }
        case MCS_RECONNECT:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_reconnect");
                if (mPendingInstalls.size() > 0) {
                    if (mBound) {
                        disconnectService();
                    }
                    if (!connectToService()) {
                        Slog.e(TAG, "Failed to bind to media container service");
                        for (HandlerParams params : mPendingInstalls) {
                            // Indicate service bind error
                            params.serviceError();
                        }
                        mPendingInstalls.clear();
                    }
                }
                break;
            }
        case MCS_UNBIND:
            {
                // If there is no actual work left, then time to unbind.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_unbind");
                if (mPendingInstalls.size() == 0 && mPendingVerification.size() == 0) {
                    if (mBound) {
                        if (DEBUG_INSTALL)
                            Slog.i(TAG, "calling disconnectService()");
                        disconnectService();
                    }
                } else if (mPendingInstalls.size() > 0) {
                    // There are more pending requests in queue.
                    // Just post MCS_BOUND message to trigger processing
                    // of next pending install.
                    mHandler.sendEmptyMessage(MCS_BOUND);
                }
                break;
            }
        case MCS_GIVE_UP:
            {
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "mcs_giveup too many retries");
                mPendingInstalls.remove(0);
                break;
            }
        case SEND_PENDING_BROADCAST:
            {
                String[] packages;
                ArrayList<String>[] components;
                int size = 0;
                int[] uids;
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    if (mPendingBroadcasts == null) {
                        return;
                    }
                    size = mPendingBroadcasts.size();
                    if (size <= 0) {
                        // Nothing to be done. Just return
                        return;
                    }
                    packages = new String[size];
                    components = new ArrayList[size];
                    uids = new int[size];
                    // filling out the above arrays
                    int i = 0;
                    for (int n = 0; n < mPendingBroadcasts.userIdCount(); n++) {
                        int packageUserId = mPendingBroadcasts.userIdAt(n);
                        Iterator<Map.Entry<String, ArrayList<String>>> it = mPendingBroadcasts.packagesForUserId(packageUserId).entrySet().iterator();
                        while (it.hasNext() && i < size) {
                            Map.Entry<String, ArrayList<String>> ent = it.next();
                            packages[i] = ent.getKey();
                            components[i] = ent.getValue();
                            PackageSetting ps = mSettings.mPackages.get(ent.getKey());
                            uids[i] = (ps != null) ? UserHandle.getUid(packageUserId, ps.appId) : -1;
                            i++;
                        }
                    }
                    size = i;
                    mPendingBroadcasts.clear();
                }
                // Send broadcasts
                for (int i = 0; i < size; i++) {
                    sendPackageChangedBroadcast(packages[i], true, components[i], uids[i]);
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                break;
            }
        case START_CLEANING_PACKAGE:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                final String packageName = (String) msg.obj;
                final int userId = msg.arg1;
                final boolean andCode = msg.arg2 != 0;
                synchronized (mPackages) {
                    if (userId == UserHandle.USER_ALL) {
                        int[] users = sUserManager.getUserIds();
                        for (int user : users) {
                            mSettings.addPackageToCleanLPw(new PackageCleanItem(user, packageName, andCode));
                        }
                    } else {
                        mSettings.addPackageToCleanLPw(new PackageCleanItem(userId, packageName, andCode));
                    }
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                startCleaningPackages();
            }
            break;
        case POST_INSTALL:
            {
                if (DEBUG_INSTALL)
                    Log.v(TAG, "Handling post-install for " + msg.arg1);
                PostInstallData data = mRunningInstalls.get(msg.arg1);
                mRunningInstalls.delete(msg.arg1);
                boolean deleteOld = false;
                if (data != null) {
                    InstallArgs args = data.args;
                    PackageInstalledInfo res = data.res;
                    if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) {
                        final String packageName = res.pkg.applicationInfo.packageName;
                        res.removedInfo.sendBroadcast(false, true, false);
                        Bundle extras = new Bundle(1);
                        extras.putInt(Intent.EXTRA_UID, res.uid);
                        // permissions if requested before broadcasting the install.
                        if ((args.installFlags & PackageManager.INSTALL_GRANT_RUNTIME_PERMISSIONS) != 0) {
                            grantRequestedRuntimePermissions(res.pkg, args.user.getIdentifier(), args.installGrantPermissions);
                        }
                        // Determine the set of users who are adding this
                        // package for the first time vs. those who are seeing
                        // an update.
                        int[] firstUsers;
                        int[] updateUsers = new int[0];
                        if (res.origUsers == null || res.origUsers.length == 0) {
                            firstUsers = res.newUsers;
                        } else {
                            firstUsers = new int[0];
                            for (int i = 0; i < res.newUsers.length; i++) {
                                int user = res.newUsers[i];
                                boolean isNew = true;
                                for (int j = 0; j < res.origUsers.length; j++) {
                                    if (res.origUsers[j] == user) {
                                        isNew = false;
                                        break;
                                    }
                                }
                                if (isNew) {
                                    int[] newFirst = new int[firstUsers.length + 1];
                                    System.arraycopy(firstUsers, 0, newFirst, 0, firstUsers.length);
                                    newFirst[firstUsers.length] = user;
                                    firstUsers = newFirst;
                                } else {
                                    int[] newUpdate = new int[updateUsers.length + 1];
                                    System.arraycopy(updateUsers, 0, newUpdate, 0, updateUsers.length);
                                    newUpdate[updateUsers.length] = user;
                                    updateUsers = newUpdate;
                                }
                            }
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, firstUsers);
                        final boolean update = res.removedInfo.removedPackage != null;
                        if (update) {
                            extras.putBoolean(Intent.EXTRA_REPLACING, true);
                        }
                        String category = null;
                        if (res.pkg.mIsThemeApk) {
                            category = cyanogenmod.content.Intent.CATEGORY_THEME_PACKAGE_INSTALLED_STATE_CHANGE;
                        }
                        sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED, packageName, null, extras, null, null, updateUsers);
                        if (update) {
                            sendPackageBroadcast(Intent.ACTION_PACKAGE_REPLACED, packageName, null, extras, null, null, updateUsers);
                            sendPackageBroadcast(Intent.ACTION_MY_PACKAGE_REPLACED, null, null, null, packageName, null, updateUsers);
                            // treat asec-hosted packages like removable media on upgrade
                            if (res.pkg.isForwardLocked() || isExternal(res.pkg)) {
                                if (DEBUG_INSTALL) {
                                    Slog.i(TAG, "upgrading pkg " + res.pkg + " is ASEC-hosted -> AVAILABLE");
                                }
                                int[] uidArray = new int[] { res.pkg.applicationInfo.uid };
                                ArrayList<String> pkgList = new ArrayList<String>(1);
                                pkgList.add(packageName);
                                sendResourcesChangedBroadcast(true, true, pkgList, uidArray, null);
                            }
                        }
                        // if this was a theme, send it off to the theme service for processing
                        if (res.pkg.mIsThemeApk || res.pkg.mIsLegacyIconPackApk) {
                            processThemeResourcesInThemeService(res.pkg.packageName);
                        } else if (mOverlays.containsKey(res.pkg.packageName)) {
                            // if this was an app and is themed send themes that theme it
                            // for processing
                            ArrayMap<String, PackageParser.Package> themes = mOverlays.get(res.pkg.packageName);
                            for (PackageParser.Package themePkg : themes.values()) {
                                processThemeResourcesInThemeService(themePkg.packageName);
                            }
                        }
                        if (res.removedInfo.args != null) {
                            // Remove the replaced package's older resources safely now
                            deleteOld = true;
                        }
                        // users, clear any default-browser state in those users
                        if (firstUsers.length > 0) {
                            // check its browser nature in any user and generalize.
                            if (packageIsBrowser(packageName, firstUsers[0])) {
                                synchronized (mPackages) {
                                    for (int userId : firstUsers) {
                                        mSettings.setDefaultBrowserPackageNameLPw(null, userId);
                                    }
                                }
                            }
                        }
                        if (!update && !isSystemApp(res.pkg)) {
                            boolean privacyGuard = CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.PRIVACY_GUARD_DEFAULT, 0, UserHandle.USER_CURRENT) == 1;
                            if (privacyGuard) {
                                mAppOps.setPrivacyGuardSettingForPackage(res.pkg.applicationInfo.uid, res.pkg.applicationInfo.packageName, true);
                            }
                        }
                        // Log current value of "unknown sources" setting
                        EventLog.writeEvent(EventLogTags.UNKNOWN_SOURCES_ENABLED, getUnknownSourcesSettings());
                    }
                    // Force a gc to clear up things
                    Runtime.getRuntime().gc();
                    // We delete after a gc for applications  on sdcard.
                    if (deleteOld) {
                        synchronized (mInstallLock) {
                            res.removedInfo.args.doPostDeleteLI(true);
                        }
                    }
                    if (args.observer != null) {
                        try {
                            Bundle extras = extrasForInstallResult(res);
                            args.observer.onPackageInstalled(res.name, res.returnCode, res.returnMsg, extras);
                        } catch (RemoteException e) {
                            Slog.i(TAG, "Observer no longer exists.");
                        }
                    }
                } else {
                    Slog.e(TAG, "Bogus post-install token " + msg.arg1);
                }
            }
            break;
        case UPDATED_MEDIA_STATUS:
            {
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "Got message UPDATED_MEDIA_STATUS");
                boolean reportStatus = msg.arg1 == 1;
                boolean doGc = msg.arg2 == 1;
                if (DEBUG_SD_INSTALL)
                    Log.i(TAG, "reportStatus=" + reportStatus + ", doGc = " + doGc);
                if (doGc) {
                    // Force a gc to clear up stale containers.
                    Runtime.getRuntime().gc();
                }
                if (msg.obj != null) {
                    @SuppressWarnings("unchecked")
                    Set<AsecInstallArgs> args = (Set<AsecInstallArgs>) msg.obj;
                    if (DEBUG_SD_INSTALL)
                        Log.i(TAG, "Unloading all containers");
                    // Unload containers
                    unloadAllContainers(args);
                }
                if (reportStatus) {
                    try {
                        if (DEBUG_SD_INSTALL)
                            Log.i(TAG, "Invoking MountService call back");
                        PackageHelper.getMountService().finishMediaUpdate();
                    } catch (RemoteException e) {
                        Log.e(TAG, "MountService not running?");
                    }
                }
            }
            break;
        case WRITE_SETTINGS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_SETTINGS);
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    mSettings.writeLPr();
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case WRITE_PACKAGE_RESTRICTIONS:
            {
                Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
                synchronized (mPackages) {
                    removeMessages(WRITE_PACKAGE_RESTRICTIONS);
                    for (int userId : mDirtyUsers) {
                        mSettings.writePackageRestrictionsLPr(userId);
                    }
                    mDirtyUsers.clear();
                }
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            }
            break;
        case CHECK_PENDING_VERIFICATION:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if ((state != null) && !state.timeoutExtended()) {
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    Slog.i(TAG, "Verification timed out for " + originUri);
                    mPendingVerification.remove(verificationId);
                    int ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    if (getDefaultVerificationResponse() == PackageManager.VERIFICATION_ALLOW) {
                        Slog.i(TAG, "Continuing with installation of " + originUri);
                        state.setVerifierResponse(Binder.getCallingUid(), PackageManager.VERIFICATION_ALLOW_WITHOUT_SUFFICIENT);
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_ALLOW, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        broadcastPackageVerified(verificationId, originUri, PackageManager.VERIFICATION_REJECT, state.getInstallArgs().getUser());
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case PACKAGE_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final PackageVerificationState state = mPendingVerification.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid verification token " + verificationId + " received");
                    break;
                }
                final PackageVerificationResponse response = (PackageVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (state.isVerificationComplete()) {
                    mPendingVerification.remove(verificationId);
                    final InstallArgs args = state.getInstallArgs();
                    final Uri originUri = Uri.fromFile(args.origin.resolvedFile);
                    int ret;
                    if (state.isInstallAllowed()) {
                        ret = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
                        broadcastPackageVerified(verificationId, originUri, response.code, state.getInstallArgs().getUser());
                        try {
                            ret = args.copyApk(mContainerService, true);
                        } catch (RemoteException e) {
                            Slog.e(TAG, "Could not contact the ContainerService");
                        }
                    } else {
                        ret = PackageManager.INSTALL_FAILED_VERIFICATION_FAILURE;
                    }
                    processPendingInstall(args, ret);
                    mHandler.sendEmptyMessage(MCS_UNBIND);
                }
                break;
            }
        case START_INTENT_FILTER_VERIFICATIONS:
            {
                IFVerificationParams params = (IFVerificationParams) msg.obj;
                verifyIntentFiltersIfNeeded(params.userId, params.verifierUid, params.replacing, params.pkg);
                break;
            }
        case INTENT_FILTER_VERIFIED:
            {
                final int verificationId = msg.arg1;
                final IntentFilterVerificationState state = mIntentFilterVerificationStates.get(verificationId);
                if (state == null) {
                    Slog.w(TAG, "Invalid IntentFilter verification token " + verificationId + " received");
                    break;
                }
                final int userId = state.getUserId();
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "Processing IntentFilter verification with token:" + verificationId + " and userId:" + userId);
                final IntentFilterVerificationResponse response = (IntentFilterVerificationResponse) msg.obj;
                state.setVerifierResponse(response.callerUid, response.code);
                if (DEBUG_DOMAIN_VERIFICATION)
                    Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " and userId:" + userId + " is settings verifier response with response code:" + response.code);
                if (response.code == PackageManager.INTENT_FILTER_VERIFICATION_FAILURE) {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "Domains failing verification: " + response.getFailedDomainsString());
                }
                if (state.isVerificationComplete()) {
                    mIntentFilterVerifier.receiveVerificationResponse(verificationId);
                } else {
                    if (DEBUG_DOMAIN_VERIFICATION)
                        Slog.d(TAG, "IntentFilter verification with token:" + verificationId + " was not said to be complete");
                }
                break;
            }
    }
}
#end_block

#method_before
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    final File scanFile = new File(pkg.codePath);
    if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
        // Bail out. The resource and code paths haven't been set.
        throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, "Code and resource paths haven't been set correctly");
    }
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
    } else {
        // Only allow system apps to be flagged as core apps.
        pkg.coreApp = false;
    }
    if ((parseFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
    if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
        setUpCustomResolverActivity(pkg);
    }
    if (pkg.packageName.equals("android")) {
        synchronized (mPackages) {
            if (mAndroidApplication != null) {
                Slog.w(TAG, "*************************************************");
                Slog.w(TAG, "Core android package being redefined.  Skipping.");
                Slog.w(TAG, " file=" + scanFile);
                Slog.w(TAG, "*************************************************");
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Core android package being redefined.  Skipping.");
            }
            // Set up information for our fall-back user intent resolution activity.
            mPlatformPackage = pkg;
            pkg.mVersionCode = mSdkVersion;
            mAndroidApplication = pkg.applicationInfo;
            if (!mResolverReplaced) {
                mResolveActivity.applicationInfo = mAndroidApplication;
                mResolveActivity.name = ResolverActivity.class.getName();
                mResolveActivity.packageName = mAndroidApplication.packageName;
                mResolveActivity.processName = "system:ui";
                mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
                mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;
                mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
                mResolveActivity.theme = R.style.Theme_Holo_Dialog_Alert;
                mResolveActivity.exported = true;
                mResolveActivity.enabled = true;
                mResolveInfo.activityInfo = mResolveActivity;
                mResolveInfo.priority = 0;
                mResolveInfo.preferredOrder = 0;
                mResolveInfo.match = 0;
                mResolveComponentName = new ComponentName(mAndroidApplication.packageName, mResolveActivity.name);
            }
        }
    }
    if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
    }
    // user-installed version of the application will be ignored.
    if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {
        if (mExpectingBetter.containsKey(pkg.packageName)) {
            logCriticalInfo(Log.WARN, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
        } else {
            PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);
            if (known != null) {
                if (DEBUG_PACKAGE_SCANNING) {
                    Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                }
                if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                    throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                }
            }
        }
    }
    if (Build.TAGS.equals("test-keys") && !pkg.applicationInfo.sourceDir.startsWith(Environment.getRootDirectory().getPath()) && !pkg.applicationInfo.sourceDir.startsWith("/vendor")) {
        Object obj = mSettings.getUserIdLPr(1000);
        Signature[] s1 = null;
        if (obj instanceof SharedUserSetting) {
            s1 = ((SharedUserSetting) obj).signatures.mSignatures;
        }
        if ((compareSignatures(pkg.mSignatures, s1) == PackageManager.SIGNATURE_MATCH)) {
            throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install platform packages to user storage!");
        }
    }
    // Initialize package source and resource directories
    File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    if (!isSystemApp(pkg)) {
        // Only system apps can use these features.
        pkg.mOriginalPackages = null;
        pkg.mRealPackage = null;
        pkg.mAdoptPermissions = null;
    }
    // collect manifest digest which includes getting manifest hash code for themes
    if (pkg.manifestDigest == null || pkg.manifestHashCode == 0) {
        PackageParser pp = new PackageParser();
        try {
            pp.collectManifestDigest(pkg);
        } catch (PackageParserException e) {
            Slog.w(TAG, "Unable to collect manifest digest", e);
        }
    }
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
            if (suid == null) {
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " for shared user failed");
            }
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // Just create the setting, don't add it yet. For already existing packages
        // the PkgSetting exists already and doesn't have to be created.
        pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false);
        if (pkgSetting == null) {
            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " failed");
        }
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            mTransferedPackages.add(origPackage.name);
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        if (realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done.
            updateSharedLibrariesLPw(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeinfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) {
            if (checkUpgradeKeySetLP(pkgSetting, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                verifySignaturesLP(pkgSetting, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (pkgSetting.sharedUser != null) {
                    if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user : " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        // things that are installed.
        if ((scanFlags & SCAN_NEW_INSTALL) != 0) {
            final int N = pkg.providers.size();
            int i;
            for (i = 0; i < N; i++) {
                PackageParser.Provider p = pkg.providers.get(i);
                if (p.info.authority != null) {
                    String[] names = p.info.authority.split(";");
                    for (int j = 0; j < names.length; j++) {
                        if (mProvidersByAuthority.containsKey(names[j])) {
                            PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                            final String otherPackageName = ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?");
                            throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER, "Can't install because provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + ") is already used by " + otherPackageName);
                        }
                    }
                }
            }
        }
        if (pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.peekPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    final String pkgName = pkg.packageName;
    final long scanFileTime = scanFile.lastModified();
    final boolean forceDex = (scanFlags & SCAN_FORCE_DEX) != 0;
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid);
    File dataPath;
    if (mPlatformPackage == pkg) {
        // The system package is special.
        dataPath = new File(Environment.getDataDirectory(), "system");
        pkg.applicationInfo.dataDir = dataPath.getPath();
    } else {
        // This is a normal package, need to make its data directory.
        dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid, UserHandle.USER_OWNER, pkg.packageName);
        boolean uidError = false;
        if (dataPath.exists()) {
            int currentUid = 0;
            try {
                StructStat stat = Os.stat(dataPath.getPath());
                currentUid = stat.st_uid;
            } catch (ErrnoException e) {
                Slog.e(TAG, "Couldn't stat path " + dataPath.getPath(), e);
            }
            // If we have mismatched owners for the data path, we have a problem.
            if (currentUid != pkg.applicationInfo.uid) {
                boolean recovered = false;
                if (currentUid == 0) {
                    // The directory somehow became owned by root.  Wow.
                    // This is probably because the system was stopped while
                    // installd was in the middle of messing with its libs
                    // directory.  Ask installd to fix that.
                    int ret = mInstaller.fixUid(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.uid);
                    if (ret >= 0) {
                        recovered = true;
                        String msg = "Package " + pkg.packageName + " unexpectedly changed to uid 0; recovered to " + +pkg.applicationInfo.uid;
                        reportSettingsProblem(Log.WARN, msg);
                    }
                }
                if (!recovered && ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 || (scanFlags & SCAN_BOOTING) != 0)) {
                    // If this is a system app, we can at least delete its
                    // current data so the application will still work.
                    int ret = removeDataDirsLI(pkg.volumeUuid, pkgName);
                    if (ret >= 0) {
                        // TODO: Kill the processes first
                        // Old data gone!
                        String prefix = (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 ? "System package " : "Third party package ";
                        String msg = prefix + pkg.packageName + " has changed from uid: " + currentUid + " to " + pkg.applicationInfo.uid + "; old data erased";
                        reportSettingsProblem(Log.WARN, msg);
                        recovered = true;
                        // And now re-install the app.
                        ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
                        if (ret == -1) {
                            // Ack should not happen!
                            msg = prefix + pkg.packageName + " could not have data directory re-created after delete.";
                            reportSettingsProblem(Log.WARN, msg);
                            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, msg);
                        }
                    }
                    if (!recovered) {
                        mHasSystemUidErrors = true;
                    }
                } else if (!recovered) {
                    // Abort, abort!
                    throw new PackageManagerException(INSTALL_FAILED_UID_CHANGED, "scanPackageLI");
                }
                if (!recovered) {
                    pkg.applicationInfo.dataDir = "/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_" + currentUid;
                    pkg.applicationInfo.nativeLibraryDir = pkg.applicationInfo.dataDir;
                    pkg.applicationInfo.nativeLibraryRootDir = pkg.applicationInfo.dataDir;
                    String msg = "Package " + pkg.packageName + " has mismatched uid: " + currentUid + " on disk, " + pkg.applicationInfo.uid + " in settings";
                    // writer
                    synchronized (mPackages) {
                        mSettings.mReadMessages.append(msg);
                        mSettings.mReadMessages.append('\n');
                        uidError = true;
                        if (!pkgSetting.uidError) {
                            reportSettingsProblem(Log.ERROR, msg);
                        }
                    }
                }
            }
            pkg.applicationInfo.dataDir = dataPath.getPath();
            if (mShouldRestoreconData) {
                Slog.i(TAG, "SELinux relabeling of " + pkg.packageName + " issued.");
                mInstaller.restoreconData(pkg.volumeUuid, pkg.packageName, pkg.applicationInfo.seinfo, pkg.applicationInfo.uid);
            }
        } else {
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.v(TAG, "Want this data dir: " + dataPath);
            }
            // invoke installer to do the actual installation
            int ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
            if (ret < 0) {
                // Error from installer
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Unable to create data dirs [errorCode=" + ret + "]");
            }
            if (dataPath.exists()) {
                pkg.applicationInfo.dataDir = dataPath.getPath();
            } else {
                Slog.w(TAG, "Unable to create data directory: " + dataPath);
                pkg.applicationInfo.dataDir = null;
            }
        }
        pkgSetting.uidError = uidError;
    }
    final String path = scanFile.getPath();
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        derivePackageAbi(pkg, scanFile, cpuAbiOverride, true, /* extract libs */
        parseFlags);
        // structure. Try to detect abi based on directory structure.
        if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
            setBundledAppAbisAndRoots(pkg, pkgSetting);
            setNativeLibraryPaths(pkg, parseFlags);
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg, parseFlags);
    }
    if (DEBUG_INSTALL)
        Slog.i(TAG, "Linking native library dir for " + path);
    final int[] userIds = sUserManager.getUserIds();
    synchronized (mInstallLock) {
        // if they already exist
        if (!TextUtils.isEmpty(pkg.volumeUuid)) {
            for (int userId : userIds) {
                if (userId != 0) {
                    mInstaller.createUserData(pkg.volumeUuid, pkg.packageName, UserHandle.getUid(userId, pkg.applicationInfo.uid), userId, pkg.applicationInfo.seinfo);
                }
            }
        }
        // this symlink for 64 bit libraries.
        if (pkg.applicationInfo.primaryCpuAbi != null && !VMRuntime.is64BitAbi(pkg.applicationInfo.primaryCpuAbi)) {
            final String nativeLibPath = pkg.applicationInfo.nativeLibraryDir;
            for (int userId : userIds) {
                if (mInstaller.linkNativeLibraryDirectory(pkg.volumeUuid, pkg.packageName, nativeLibPath, userId) < 0) {
                    throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, "Failed linking native library dir (user=" + userId + ")");
                }
            }
        }
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package: " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, true);
    }
    if ((scanFlags & SCAN_NO_DEX) == 0) {
        int result = mPackageDexOptimizer.performDexOpt(pkg, null, /* instruction sets */
        forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, /* inclDependencies */
        (scanFlags & SCAN_BOOTING) == 0);
        if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
            throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI");
        }
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    ArrayList<PackageParser.Package> clientLibPkgs = null;
    // writer
    synchronized (mPackages) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can add new shared libraries.
            if (pkg.libraryNames != null) {
                for (int i = 0; i < pkg.libraryNames.size(); i++) {
                    String name = pkg.libraryNames.get(i);
                    boolean allowed = false;
                    if (pkg.isUpdatedSystemApp()) {
                        // New library entries can only be added through the
                        // system image.  This is important to get rid of a lot
                        // of nasty edge cases: for example if we allowed a non-
                        // system update of the app to add a library, then uninstalling
                        // the update would make the library go away, and assumptions
                        // we made such as through app install filtering would now
                        // have allowed apps on the device which aren't compatible
                        // with it.  Better to just have the restriction here, be
                        // conservative, and create many fewer cases that can negatively
                        // impact the user experience.
                        final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                        if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                            for (int j = 0; j < sysPs.pkg.libraryNames.size(); j++) {
                                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                                    allowed = true;
                                    allowed = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        allowed = true;
                    }
                    if (allowed) {
                        if (!mSharedLibraries.containsKey(name)) {
                            mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));
                        } else if (!name.equals(pkg.packageName)) {
                            Slog.w(TAG, "Package " + pkg.packageName + " library " + name + " already exists; skipping");
                        }
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " declares lib " + name + " that is not declared on system image; skipping");
                    }
                }
                if ((scanFlags & SCAN_BOOTING) == 0) {
                    // If we are not booting, we need to update any applications
                    // that are clients of our shared library.  If we are booting,
                    // this will all be done once the scan is complete.
                    clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                }
            }
        }
    }
    // result in some apps being broken.
    if (clientLibPkgs != null) {
        if ((scanFlags & SCAN_NO_DEX) == 0) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                int result = mPackageDexOptimizer.performDexOpt(clientPkg, null, /* instruction sets */
                forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, (scanFlags & SCAN_BOOTING) == 0);
                if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
                    throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI failed to dexopt clientLibPkgs");
                }
            }
        }
    }
    // version of the application while the new one gets installed.
    if ((scanFlags & SCAN_REPLACING) != 0) {
        killApplication(pkg.applicationInfo.packageName, pkg.applicationInfo.uid, "replace pkg");
    }
    // Also need to kill any apps that are dependent on the library.
    if (clientLibPkgs != null) {
        for (int i = 0; i < clientLibPkgs.size(); i++) {
            PackageParser.Package clientPkg = clientLibPkgs.get(i);
            killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
        }
    }
    // Make sure we're not adding any bogus keyset info
    KeySetManagerService ksms = mSettings.mKeySetManagerService;
    ksms.assertScannedPackageValid(pkg);
    // writer
    synchronized (mPackages) {
        // We don't expect installation to fail beyond this point
        // Add the new setting to mSettings
        mSettings.insertPackageSettingLPw(pkgSetting, pkg);
        // Themes: handle case where app was installed after icon mapping applied
        if (mIconPackHelper != null) {
            int id = mIconPackHelper.getResourceIdForApp(pkg.packageName);
            pkg.applicationInfo.themedIcon = id;
        }
        // Add the new setting to mPackages
        mPackages.put(pkg.applicationInfo.packageName, pkg);
        // Make sure we don't accidentally delete its data.
        final Iterator<PackageCleanItem> iter = mSettings.mPackagesToBeCleaned.iterator();
        while (iter.hasNext()) {
            PackageCleanItem item = iter.next();
            if (pkgName.equals(item.packageName)) {
                iter.remove();
            }
        }
        // Take care of first install / last update times.
        if (currentTime != 0) {
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
            } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else if (pkgSetting.firstInstallTime == 0) {
            // We need *something*.  Take time time stamp of the file.
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
        } else if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
            if (scanFileTime != pkgSetting.timeStamp) {
                // A package on the system image has changed; consider this
                // to be an update.
                pkgSetting.lastUpdateTime = scanFileTime;
            }
        }
        // Add the package's KeySets to the global KeySetManagerService
        ksms.addScannedPackageLPw(pkg);
        int N = pkg.providers.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < N; i++) {
            PackageParser.Provider p = pkg.providers.get(i);
            p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid);
            mProviders.addProvider(p);
            p.syncable = p.info.isSyncable;
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                p.info.authority = null;
                for (int j = 0; j < names.length; j++) {
                    if (j == 1 && p.syncable) {
                        // We only want the first authority for a provider to possibly be
                        // syncable, so if we already added this provider using a different
                        // authority clear the syncable flag. We copy the provider before
                        // changing it because the mProviders object contains a reference
                        // to a provider that we don't want to change.
                        // Only do this for the second authority since the resulting provider
                        // object can be the same for all future authorities for this provider.
                        p = new PackageParser.Provider(p);
                        p.syncable = false;
                    }
                    if (!mProvidersByAuthority.containsKey(names[j])) {
                        mProvidersByAuthority.put(names[j], p);
                        if (p.info.authority == null) {
                            p.info.authority = names[j];
                        } else {
                            p.info.authority = p.info.authority + ";" + names[j];
                        }
                        if (DEBUG_PACKAGE_SCANNING) {
                            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                                Log.d(TAG, "Registered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    } else {
                        PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                        Slog.w(TAG, "Skipping provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + "): name already used by " + ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
                    }
                }
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(p.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Providers: " + r);
        }
        N = pkg.services.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Service s = pkg.services.get(i);
            s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid);
            mServices.addService(s);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(s.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Services: " + r);
        }
        N = pkg.receivers.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.receivers.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mReceivers.addActivity(a, "receiver");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Receivers: " + r);
        }
        N = pkg.activities.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.activities.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            // Themes: handle case where app was installed after icon mapping applied
            if (mIconPackHelper != null) {
                a.info.themedIcon = mIconPackHelper.getResourceIdForActivityIcon(a.info);
            }
            mActivities.addActivity(a, "activity");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Activities: " + r);
        }
        N = pkg.permissionGroups.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i);
            PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name);
            if (cur == null) {
                mPermissionGroups.put(pg.info.name, pg);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(pg.info.name);
                }
            } else {
                Slog.w(TAG, "Permission group " + pg.info.name + " from package " + pg.info.packageName + " ignored: original from " + cur.info.packageName);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append("DUP:");
                    r.append(pg.info.name);
                }
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permission Groups: " + r);
        }
        N = pkg.permissions.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Permission p = pkg.permissions.get(i);
            // Assume by default that we did not install this permission into the system.
            p.info.flags &= ~PermissionInfo.FLAG_INSTALLED;
            // to be in a group defined by another app (before this had no implications).
            if (pkg.applicationInfo.targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
                p.group = mPermissionGroups.get(p.info.group);
                // Warn for a permission in an unknown group.
                if (p.info.group != null && p.group == null) {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " in an unknown group " + p.info.group);
                }
            }
            ArrayMap<String, BasePermission> permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
            BasePermission bp = permissionMap.get(p.info.name);
            // Allow system apps to redefine non-system permissions
            if (bp != null && !Objects.equals(bp.sourcePackage, p.info.packageName)) {
                final boolean currentOwnerIsSystem = (bp.perm != null && isSystemApp(bp.perm.owner));
                if (isSystemApp(p.owner)) {
                    if (bp.type == BasePermission.TYPE_BUILTIN && bp.perm == null) {
                        // It's a built-in permission and no owner, take ownership now
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        bp.allowViaWhitelist = p.info.allowViaWhitelist;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                    } else if (!currentOwnerIsSystem) {
                        String msg = "New decl " + p.owner + " of permission  " + p.info.name + " is system; overriding " + bp.sourcePackage;
                        reportSettingsProblem(Log.WARN, msg);
                        bp = null;
                    }
                }
            }
            if (bp == null) {
                bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL);
                bp.allowViaWhitelist = p.info.allowViaWhitelist;
                permissionMap.put(p.info.name, bp);
            }
            if (bp.perm == null) {
                if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
                    BasePermission tree = findPermissionTreeLP(p.info.name);
                    if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        bp.allowViaWhitelist = p.info.allowViaWhitelist;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(p.info.name);
                        }
                    } else {
                        Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: base tree " + tree.name + " is from package " + tree.sourcePackage);
                    }
                } else {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: original from " + bp.sourcePackage);
                }
            } else if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append("DUP:");
                r.append(p.info.name);
            }
            if (bp.perm == p) {
                bp.protectionLevel = p.info.protectionLevel;
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permissions: " + r);
        }
        N = pkg.instrumentation.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            a.info.packageName = pkg.applicationInfo.packageName;
            a.info.sourceDir = pkg.applicationInfo.sourceDir;
            a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
            a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
            a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
            a.info.dataDir = pkg.applicationInfo.dataDir;
            // TODO: Update instrumentation.nativeLibraryDir as well ? Does it
            // need other information about the application, like the ABI and what not ?
            a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
            mInstrumentation.put(a.getComponentName(), a);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Instrumentation: " + r);
        }
        if (pkg.protectedBroadcasts != null) {
            N = pkg.protectedBroadcasts.size();
            for (i = 0; i < N; i++) {
                mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        final boolean isBootScan = (scanFlags & SCAN_BOOTING) != 0;
        // in background)
        if (pkg.mOverlayTargets.isEmpty() && mOverlays.containsKey(pkg.packageName)) {
            ArrayMap<String, PackageParser.Package> themes = mOverlays.get(pkg.packageName);
            final IActivityManager am = ActivityManagerNative.getDefault();
            ThemeConfig themeConfig = null;
            try {
                if (am != null) {
                    themeConfig = am.getConfiguration().themeConfig;
                } else {
                    Log.e(TAG, "ActivityManager getDefault() " + "returned null, cannot compile app's theme");
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Failed to get the theme config ", e);
            }
            ThemeConfig config = isBootScan ? mBootThemeConfig : themeConfig;
            for (PackageParser.Package themePkg : themes.values()) {
                if (config != null && (themePkg.packageName.equals(config.getOverlayPkgName()) || themePkg.packageName.equals(config.getOverlayPkgNameForApp(pkg.packageName)))) {
                    try {
                        compileResourcesAndIdmapIfNeeded(pkg, themePkg);
                    } catch (Exception e) {
                        // Do not stop a pkg installation just because of one bad theme
                        // Also we don't break here because we should try to compile other
                        // themes
                        Slog.w(TAG, "Unable to compile " + themePkg.packageName + " for target " + pkg.packageName, e);
                        themePkg.mOverlayTargets.remove(pkg.packageName);
                    }
                }
            }
        }
        // remove this package from mAvailableCommonResources.
        if (!isBootScan && pkg.mOverlayTargets.size() > 0) {
            mAvailableCommonResources.remove(pkg.packageName);
        }
        // Generate Idmaps and res tables if pkg is a theme
        Iterator<String> iterator = pkg.mOverlayTargets.iterator();
        while (iterator.hasNext()) {
            String target = iterator.next();
            Exception failedException = null;
            insertIntoOverlayMap(target, pkg);
            if (isBootScan && mBootThemeConfig != null && (pkg.packageName.equals(mBootThemeConfig.getOverlayPkgName()) || pkg.packageName.equals(mBootThemeConfig.getOverlayPkgNameForApp(target)))) {
                try {
                    compileResourcesAndIdmapIfNeeded(mPackages.get(target), pkg);
                } catch (IdmapException e) {
                    failedException = e;
                } catch (AaptException e) {
                    failedException = e;
                } catch (Exception e) {
                    failedException = e;
                }
                if (failedException != null) {
                    Slog.w(TAG, "Unable to process theme " + pkgName + " for " + target, failedException);
                    // remove target from mOverlayTargets
                    iterator.remove();
                }
            }
        }
        // Icon Packs need aapt too
        if (isBootScan && (mBootThemeConfig != null && pkg.packageName.equals(mBootThemeConfig.getIconPackPkgName()))) {
            if (isIconCompileNeeded(pkg)) {
                try {
                    ThemeUtils.createCacheDirIfNotExists();
                    ThemeUtils.createIconDirIfNotExists(pkg.packageName);
                    compileIconPack(pkg);
                } catch (Exception e) {
                    uninstallThemeForAllApps(pkg);
                    deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
                    throw new PackageManagerException(PackageManager.INSTALL_FAILED_THEME_AAPT_ERROR, "Unable to process theme " + pkgName);
                }
            }
        }
    }
    return pkg;
}
#method_after
private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    final File scanFile = new File(pkg.codePath);
    if (pkg.applicationInfo.getCodePath() == null || pkg.applicationInfo.getResourcePath() == null) {
        // Bail out. The resource and code paths haven't been set.
        throw new PackageManagerException(INSTALL_FAILED_INVALID_APK, "Code and resource paths haven't been set correctly");
    }
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
    } else {
        // Only allow system apps to be flagged as core apps.
        pkg.coreApp = false;
    }
    if ((parseFlags & PackageParser.PARSE_IS_PRIVILEGED) != 0) {
        pkg.applicationInfo.privateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
    }
    if (mCustomResolverComponentName != null && mCustomResolverComponentName.getPackageName().equals(pkg.packageName)) {
        setUpCustomResolverActivity(pkg);
    }
    if (pkg.packageName.equals("android")) {
        synchronized (mPackages) {
            if (mAndroidApplication != null) {
                Slog.w(TAG, "*************************************************");
                Slog.w(TAG, "Core android package being redefined.  Skipping.");
                Slog.w(TAG, " file=" + scanFile);
                Slog.w(TAG, "*************************************************");
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Core android package being redefined.  Skipping.");
            }
            // Set up information for our fall-back user intent resolution activity.
            mPlatformPackage = pkg;
            pkg.mVersionCode = mSdkVersion;
            mAndroidApplication = pkg.applicationInfo;
            if (!mResolverReplaced) {
                mResolveActivity.applicationInfo = mAndroidApplication;
                mResolveActivity.name = ResolverActivity.class.getName();
                mResolveActivity.packageName = mAndroidApplication.packageName;
                mResolveActivity.processName = "system:ui";
                mResolveActivity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
                mResolveActivity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NEVER;
                mResolveActivity.flags = ActivityInfo.FLAG_EXCLUDE_FROM_RECENTS;
                mResolveActivity.theme = R.style.Theme_Holo_Dialog_Alert;
                mResolveActivity.exported = true;
                mResolveActivity.enabled = true;
                mResolveInfo.activityInfo = mResolveActivity;
                mResolveInfo.priority = 0;
                mResolveInfo.preferredOrder = 0;
                mResolveInfo.match = 0;
                mResolveComponentName = new ComponentName(mAndroidApplication.packageName, mResolveActivity.name);
            }
        }
    }
    if (DEBUG_PACKAGE_SCANNING) {
        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
            Log.d(TAG, "Scanning package " + pkg.packageName);
    }
    if (mPackages.containsKey(pkg.packageName) || mSharedLibraries.containsKey(pkg.packageName)) {
        throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Application package " + pkg.packageName + " already installed.  Skipping duplicate.");
    }
    // user-installed version of the application will be ignored.
    if ((scanFlags & SCAN_REQUIRE_KNOWN) != 0) {
        if (mExpectingBetter.containsKey(pkg.packageName)) {
            logCriticalInfo(Log.WARN, "Relax SCAN_REQUIRE_KNOWN requirement for package " + pkg.packageName);
        } else {
            PackageSetting known = mSettings.peekPackageLPr(pkg.packageName);
            if (known != null) {
                if (DEBUG_PACKAGE_SCANNING) {
                    Log.d(TAG, "Examining " + pkg.codePath + " and requiring known paths " + known.codePathString + " & " + known.resourcePathString);
                }
                if (!pkg.applicationInfo.getCodePath().equals(known.codePathString) || !pkg.applicationInfo.getResourcePath().equals(known.resourcePathString)) {
                    throw new PackageManagerException(INSTALL_FAILED_PACKAGE_CHANGED, "Application package " + pkg.packageName + " found at " + pkg.applicationInfo.getCodePath() + " but expected at " + known.codePathString + "; ignoring.");
                }
            }
        }
    }
    if (Build.TAGS.equals("test-keys") && !pkg.applicationInfo.sourceDir.startsWith(Environment.getRootDirectory().getPath()) && !pkg.applicationInfo.sourceDir.startsWith("/vendor")) {
        Object obj = mSettings.getUserIdLPr(1000);
        Signature[] s1 = null;
        if (obj instanceof SharedUserSetting) {
            s1 = ((SharedUserSetting) obj).signatures.mSignatures;
        }
        if ((compareSignatures(pkg.mSignatures, s1) == PackageManager.SIGNATURE_MATCH)) {
            throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install platform packages to user storage!");
        }
    }
    // Initialize package source and resource directories
    File destCodeFile = new File(pkg.applicationInfo.getCodePath());
    File destResourceFile = new File(pkg.applicationInfo.getResourcePath());
    SharedUserSetting suid = null;
    PackageSetting pkgSetting = null;
    if (!isSystemApp(pkg)) {
        // Only system apps can use these features.
        pkg.mOriginalPackages = null;
        pkg.mRealPackage = null;
        pkg.mAdoptPermissions = null;
    }
    // collect manifest digest which includes getting manifest hash code for themes
    if (pkg.manifestDigest == null || pkg.manifestHashCode == 0) {
        PackageParser pp = new PackageParser();
        try {
            pp.collectManifestDigest(pkg);
        } catch (PackageParserException e) {
            Slog.w(TAG, "Unable to collect manifest digest", e);
        }
    }
    // writer
    synchronized (mPackages) {
        if (pkg.mSharedUserId != null) {
            suid = mSettings.getSharedUserLPw(pkg.mSharedUserId, 0, 0, true);
            if (suid == null) {
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " for shared user failed");
            }
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.d(TAG, "Shared UserID " + pkg.mSharedUserId + " (uid=" + suid.userId + "): packages=" + suid.packages);
            }
        }
        // Check if we are renaming from an original package name.
        PackageSetting origPackage = null;
        String realName = null;
        if (pkg.mOriginalPackages != null) {
            // This package may need to be renamed to a previously
            // installed name.  Let's check on that...
            final String renamed = mSettings.mRenamedPackages.get(pkg.mRealPackage);
            if (pkg.mOriginalPackages.contains(renamed)) {
                // This package had originally been installed as the
                // original name, and we have already taken care of
                // transitioning to the new one.  Just update the new
                // one to continue using the old name.
                realName = pkg.mRealPackage;
                if (!pkg.packageName.equals(renamed)) {
                    // Callers into this function may have already taken
                    // care of renaming the package; only do it here if
                    // it is not already done.
                    pkg.setPackageName(renamed);
                }
            } else {
                for (int i = pkg.mOriginalPackages.size() - 1; i >= 0; i--) {
                    if ((origPackage = mSettings.peekPackageLPr(pkg.mOriginalPackages.get(i))) != null) {
                        // original name...  should we use it?
                        if (!verifyPackageUpdateLPr(origPackage, pkg)) {
                            // New package is not compatible with original.
                            origPackage = null;
                            continue;
                        } else if (origPackage.sharedUser != null) {
                            // Make sure uid is compatible between packages.
                            if (!origPackage.sharedUser.name.equals(pkg.mSharedUserId)) {
                                Slog.w(TAG, "Unable to migrate data from " + origPackage.name + " to " + pkg.packageName + ": old uid " + origPackage.sharedUser.name + " differs from " + pkg.mSharedUserId);
                                origPackage = null;
                                continue;
                            }
                        } else {
                            if (DEBUG_UPGRADE)
                                Log.v(TAG, "Renaming new package " + pkg.packageName + " to old name " + origPackage.name);
                        }
                        break;
                    }
                }
            }
        }
        if (mTransferedPackages.contains(pkg.packageName)) {
            Slog.w(TAG, "Package " + pkg.packageName + " was transferred to another, but its .apk remains");
        }
        // Just create the setting, don't add it yet. For already existing packages
        // the PkgSetting exists already and doesn't have to be created.
        pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile, destResourceFile, pkg.applicationInfo.nativeLibraryRootDir, pkg.applicationInfo.primaryCpuAbi, pkg.applicationInfo.secondaryCpuAbi, pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags, user, false);
        if (pkgSetting == null) {
            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Creating application package " + pkg.packageName + " failed");
        }
        if (pkgSetting.origPackage != null) {
            // If we are first transitioning from an original package,
            // fix up the new package's name now.  We need to do this after
            // looking up the package under its new name, so getPackageLP
            // can take care of fiddling things correctly.
            pkg.setPackageName(origPackage.name);
            // File a report about this.
            String msg = "New package " + pkgSetting.realName + " renamed to replace old package " + pkgSetting.name;
            reportSettingsProblem(Log.WARN, msg);
            // Make a note of it.
            mTransferedPackages.add(origPackage.name);
            // No longer need to retain this.
            pkgSetting.origPackage = null;
        }
        if (realName != null) {
            // Make a note of it.
            mTransferedPackages.add(pkg.packageName);
        }
        if (mSettings.isDisabledSystemPackageLPr(pkg.packageName)) {
            pkg.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
            // Check all shared libraries and map to their actual file path.
            // We only do this here for apps not on a system dir, because those
            // are the only ones that can fail an install due to this.  We
            // will take care of the system apps by updating all of their
            // library paths after the scan is done.
            updateSharedLibrariesLPw(pkg, null);
        }
        if (mFoundPolicyFile) {
            SELinuxMMAC.assignSeinfoValue(pkg);
        }
        pkg.applicationInfo.uid = pkgSetting.appId;
        pkg.mExtras = pkgSetting;
        if (shouldCheckUpgradeKeySetLP(pkgSetting, scanFlags)) {
            if (checkUpgradeKeySetLP(pkgSetting, pkg)) {
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } else {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw new PackageManagerException(INSTALL_FAILED_UPDATE_INCOMPATIBLE, "Package " + pkg.packageName + " upgrade keys do not match the " + "previously installed version");
                } else {
                    pkgSetting.signatures.mSignatures = pkg.mSignatures;
                    String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                    reportSettingsProblem(Log.WARN, msg);
                }
            }
        } else {
            try {
                verifySignaturesLP(pkgSetting, pkg);
                // We just determined the app is signed correctly, so bring
                // over the latest parsed certs.
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
            } catch (PackageManagerException e) {
                if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
                    throw e;
                }
                // The signature has changed, but this package is in the system
                // image...  let's recover!
                pkgSetting.signatures.mSignatures = pkg.mSignatures;
                // that unreasonable.
                if (pkgSetting.sharedUser != null) {
                    if (compareSignatures(pkgSetting.sharedUser.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
                        throw new PackageManagerException(INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES, "Signature mismatch for shared user : " + pkgSetting.sharedUser);
                    }
                }
                // File a report about this.
                String msg = "System package " + pkg.packageName + " signature changed; retaining data.";
                reportSettingsProblem(Log.WARN, msg);
            }
        }
        // things that are installed.
        if ((scanFlags & SCAN_NEW_INSTALL) != 0) {
            final int N = pkg.providers.size();
            int i;
            for (i = 0; i < N; i++) {
                PackageParser.Provider p = pkg.providers.get(i);
                if (p.info.authority != null) {
                    String[] names = p.info.authority.split(";");
                    for (int j = 0; j < names.length; j++) {
                        if (mProvidersByAuthority.containsKey(names[j])) {
                            PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                            final String otherPackageName = ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?");
                            throw new PackageManagerException(INSTALL_FAILED_CONFLICTING_PROVIDER, "Can't install because provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + ") is already used by " + otherPackageName);
                        }
                    }
                }
            }
        }
        if (pkg.mAdoptPermissions != null) {
            // another package.
            for (int i = pkg.mAdoptPermissions.size() - 1; i >= 0; i--) {
                final String origName = pkg.mAdoptPermissions.get(i);
                final PackageSetting orig = mSettings.peekPackageLPr(origName);
                if (orig != null) {
                    if (verifyPackageUpdateLPr(orig, pkg)) {
                        Slog.i(TAG, "Adopting permissions from " + origName + " to " + pkg.packageName);
                        mSettings.transferPermissionsLPw(origName, pkg.packageName);
                    }
                }
            }
        }
    }
    final String pkgName = pkg.packageName;
    final long scanFileTime = scanFile.lastModified();
    final boolean forceDex = (scanFlags & SCAN_FORCE_DEX) != 0;
    pkg.applicationInfo.processName = fixProcessName(pkg.applicationInfo.packageName, pkg.applicationInfo.processName, pkg.applicationInfo.uid);
    File dataPath;
    if (mPlatformPackage == pkg) {
        // The system package is special.
        dataPath = new File(Environment.getDataDirectory(), "system");
        pkg.applicationInfo.dataDir = dataPath.getPath();
    } else {
        // This is a normal package, need to make its data directory.
        dataPath = Environment.getDataUserPackageDirectory(pkg.volumeUuid, UserHandle.USER_OWNER, pkg.packageName);
        boolean uidError = false;
        if (dataPath.exists()) {
            int currentUid = 0;
            try {
                StructStat stat = Os.stat(dataPath.getPath());
                currentUid = stat.st_uid;
            } catch (ErrnoException e) {
                Slog.e(TAG, "Couldn't stat path " + dataPath.getPath(), e);
            }
            // If we have mismatched owners for the data path, we have a problem.
            if (currentUid != pkg.applicationInfo.uid) {
                boolean recovered = false;
                if (currentUid == 0) {
                    // The directory somehow became owned by root.  Wow.
                    // This is probably because the system was stopped while
                    // installd was in the middle of messing with its libs
                    // directory.  Ask installd to fix that.
                    int ret = mInstaller.fixUid(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.uid);
                    if (ret >= 0) {
                        recovered = true;
                        String msg = "Package " + pkg.packageName + " unexpectedly changed to uid 0; recovered to " + +pkg.applicationInfo.uid;
                        reportSettingsProblem(Log.WARN, msg);
                    }
                }
                if (!recovered && ((parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 || (scanFlags & SCAN_BOOTING) != 0)) {
                    // If this is a system app, we can at least delete its
                    // current data so the application will still work.
                    int ret = removeDataDirsLI(pkg.volumeUuid, pkgName);
                    if (ret >= 0) {
                        // TODO: Kill the processes first
                        // Old data gone!
                        String prefix = (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0 ? "System package " : "Third party package ";
                        String msg = prefix + pkg.packageName + " has changed from uid: " + currentUid + " to " + pkg.applicationInfo.uid + "; old data erased";
                        reportSettingsProblem(Log.WARN, msg);
                        recovered = true;
                        // And now re-install the app.
                        ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
                        if (ret == -1) {
                            // Ack should not happen!
                            msg = prefix + pkg.packageName + " could not have data directory re-created after delete.";
                            reportSettingsProblem(Log.WARN, msg);
                            throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, msg);
                        }
                    }
                    if (!recovered) {
                        mHasSystemUidErrors = true;
                    }
                } else if (!recovered) {
                    // Abort, abort!
                    throw new PackageManagerException(INSTALL_FAILED_UID_CHANGED, "scanPackageLI");
                }
                if (!recovered) {
                    pkg.applicationInfo.dataDir = "/mismatched_uid/settings_" + pkg.applicationInfo.uid + "/fs_" + currentUid;
                    pkg.applicationInfo.nativeLibraryDir = pkg.applicationInfo.dataDir;
                    pkg.applicationInfo.nativeLibraryRootDir = pkg.applicationInfo.dataDir;
                    String msg = "Package " + pkg.packageName + " has mismatched uid: " + currentUid + " on disk, " + pkg.applicationInfo.uid + " in settings";
                    // writer
                    synchronized (mPackages) {
                        mSettings.mReadMessages.append(msg);
                        mSettings.mReadMessages.append('\n');
                        uidError = true;
                        if (!pkgSetting.uidError) {
                            reportSettingsProblem(Log.ERROR, msg);
                        }
                    }
                }
            }
            pkg.applicationInfo.dataDir = dataPath.getPath();
            if (mShouldRestoreconData) {
                Slog.i(TAG, "SELinux relabeling of " + pkg.packageName + " issued.");
                mInstaller.restoreconData(pkg.volumeUuid, pkg.packageName, pkg.applicationInfo.seinfo, pkg.applicationInfo.uid);
            }
        } else {
            if (DEBUG_PACKAGE_SCANNING) {
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                    Log.v(TAG, "Want this data dir: " + dataPath);
            }
            // invoke installer to do the actual installation
            int ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo);
            if (ret < 0) {
                // Error from installer
                throw new PackageManagerException(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Unable to create data dirs [errorCode=" + ret + "]");
            }
            if (dataPath.exists()) {
                pkg.applicationInfo.dataDir = dataPath.getPath();
            } else {
                Slog.w(TAG, "Unable to create data directory: " + dataPath);
                pkg.applicationInfo.dataDir = null;
            }
        }
        pkgSetting.uidError = uidError;
    }
    final String path = scanFile.getPath();
    final String cpuAbiOverride = deriveAbiOverride(pkg.cpuAbiOverride, pkgSetting);
    if ((scanFlags & SCAN_NEW_INSTALL) == 0) {
        derivePackageAbi(pkg, scanFile, cpuAbiOverride, true, /* extract libs */
        parseFlags);
        // structure. Try to detect abi based on directory structure.
        if (isSystemApp(pkg) && !pkg.isUpdatedSystemApp() && pkg.applicationInfo.primaryCpuAbi == null) {
            setBundledAppAbisAndRoots(pkg, pkgSetting);
            setNativeLibraryPaths(pkg, parseFlags);
        }
    } else {
        if ((scanFlags & SCAN_MOVE) != 0) {
            // We haven't run dex-opt for this move (since we've moved the compiled output too)
            // but we already have this packages package info in the PackageSetting. We just
            // use that and derive the native library path based on the new codepath.
            pkg.applicationInfo.primaryCpuAbi = pkgSetting.primaryCpuAbiString;
            pkg.applicationInfo.secondaryCpuAbi = pkgSetting.secondaryCpuAbiString;
        }
        // Set native library paths again. For moves, the path will be updated based on the
        // ABIs we've determined above. For non-moves, the path will be updated based on the
        // ABIs we determined during compilation, but the path will depend on the final
        // package path (after the rename away from the stage path).
        setNativeLibraryPaths(pkg, parseFlags);
    }
    if (DEBUG_INSTALL)
        Slog.i(TAG, "Linking native library dir for " + path);
    final int[] userIds = sUserManager.getUserIds();
    synchronized (mInstallLock) {
        // if they already exist
        if (!TextUtils.isEmpty(pkg.volumeUuid)) {
            for (int userId : userIds) {
                if (userId != 0) {
                    mInstaller.createUserData(pkg.volumeUuid, pkg.packageName, UserHandle.getUid(userId, pkg.applicationInfo.uid), userId, pkg.applicationInfo.seinfo);
                }
            }
        }
        // this symlink for 64 bit libraries.
        if (pkg.applicationInfo.primaryCpuAbi != null && !VMRuntime.is64BitAbi(pkg.applicationInfo.primaryCpuAbi)) {
            final String nativeLibPath = pkg.applicationInfo.nativeLibraryDir;
            for (int userId : userIds) {
                if (mInstaller.linkNativeLibraryDirectory(pkg.volumeUuid, pkg.packageName, nativeLibPath, userId) < 0) {
                    throw new PackageManagerException(INSTALL_FAILED_INTERNAL_ERROR, "Failed linking native library dir (user=" + userId + ")");
                }
            }
        }
    }
    // the same UID correctly.
    if (mPlatformPackage == pkg) {
        pkg.applicationInfo.primaryCpuAbi = VMRuntime.getRuntime().is64Bit() ? Build.SUPPORTED_64_BIT_ABIS[0] : Build.SUPPORTED_32_BIT_ABIS[0];
    }
    // account.
    if ((scanFlags & SCAN_NO_DEX) == 0 && (scanFlags & SCAN_NEW_INSTALL) != 0) {
        if (cpuAbiOverride == null && pkgSetting.cpuAbiOverrideString != null) {
            Slog.w(TAG, "Ignoring persisted ABI override " + cpuAbiOverride + " for package: " + pkg.packageName);
        }
    }
    pkgSetting.primaryCpuAbiString = pkg.applicationInfo.primaryCpuAbi;
    pkgSetting.secondaryCpuAbiString = pkg.applicationInfo.secondaryCpuAbi;
    pkgSetting.cpuAbiOverrideString = cpuAbiOverride;
    // Copy the derived override back to the parsed package, so that we can
    // update the package settings accordingly.
    pkg.cpuAbiOverride = cpuAbiOverride;
    if (DEBUG_ABI_SELECTION) {
        Slog.d(TAG, "Resolved nativeLibraryRoot for " + pkg.applicationInfo.packageName + " to root=" + pkg.applicationInfo.nativeLibraryRootDir + ", isa=" + pkg.applicationInfo.nativeLibraryRootRequiresIsa);
    }
    // Push the derived path down into PackageSettings so we know what to
    // clean up at uninstall time.
    pkgSetting.legacyNativeLibraryPathString = pkg.applicationInfo.nativeLibraryRootDir;
    if (DEBUG_ABI_SELECTION) {
        Log.d(TAG, "Abis for package[" + pkg.packageName + "] are" + " primary=" + pkg.applicationInfo.primaryCpuAbi + " secondary=" + pkg.applicationInfo.secondaryCpuAbi);
    }
    if ((scanFlags & SCAN_BOOTING) == 0 && pkgSetting.sharedUser != null) {
        // We don't do this here during boot because we can do it all
        // at once after scanning all existing packages.
        // 
        // We also do this *before* we perform dexopt on this package, so that
        // we can avoid redundant dexopts, and also to make sure we've got the
        // code and package path correct.
        adjustCpuAbisForSharedUserLPw(pkgSetting.sharedUser.packages, pkg, forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, true);
    }
    if ((scanFlags & SCAN_NO_DEX) == 0) {
        int result = mPackageDexOptimizer.performDexOpt(pkg, null, /* instruction sets */
        forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, /* inclDependencies */
        (scanFlags & SCAN_BOOTING) == 0);
        if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
            throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI");
        }
    }
    if (mFactoryTest && pkg.requestedPermissions.contains(android.Manifest.permission.FACTORY_TEST)) {
        pkg.applicationInfo.flags |= ApplicationInfo.FLAG_FACTORY_TEST;
    }
    ArrayList<PackageParser.Package> clientLibPkgs = null;
    // writer
    synchronized (mPackages) {
        if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
            // Only system apps can add new shared libraries.
            if (pkg.libraryNames != null) {
                for (int i = 0; i < pkg.libraryNames.size(); i++) {
                    String name = pkg.libraryNames.get(i);
                    boolean allowed = false;
                    if (pkg.isUpdatedSystemApp()) {
                        // New library entries can only be added through the
                        // system image.  This is important to get rid of a lot
                        // of nasty edge cases: for example if we allowed a non-
                        // system update of the app to add a library, then uninstalling
                        // the update would make the library go away, and assumptions
                        // we made such as through app install filtering would now
                        // have allowed apps on the device which aren't compatible
                        // with it.  Better to just have the restriction here, be
                        // conservative, and create many fewer cases that can negatively
                        // impact the user experience.
                        final PackageSetting sysPs = mSettings.getDisabledSystemPkgLPr(pkg.packageName);
                        if (sysPs.pkg != null && sysPs.pkg.libraryNames != null) {
                            for (int j = 0; j < sysPs.pkg.libraryNames.size(); j++) {
                                if (name.equals(sysPs.pkg.libraryNames.get(j))) {
                                    allowed = true;
                                    allowed = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        allowed = true;
                    }
                    if (allowed) {
                        if (!mSharedLibraries.containsKey(name)) {
                            mSharedLibraries.put(name, new SharedLibraryEntry(null, pkg.packageName));
                        } else if (!name.equals(pkg.packageName)) {
                            Slog.w(TAG, "Package " + pkg.packageName + " library " + name + " already exists; skipping");
                        }
                    } else {
                        Slog.w(TAG, "Package " + pkg.packageName + " declares lib " + name + " that is not declared on system image; skipping");
                    }
                }
                if ((scanFlags & SCAN_BOOTING) == 0) {
                    // If we are not booting, we need to update any applications
                    // that are clients of our shared library.  If we are booting,
                    // this will all be done once the scan is complete.
                    clientLibPkgs = updateAllSharedLibrariesLPw(pkg);
                }
            }
        }
    }
    // result in some apps being broken.
    if (clientLibPkgs != null) {
        if ((scanFlags & SCAN_NO_DEX) == 0) {
            for (int i = 0; i < clientLibPkgs.size(); i++) {
                PackageParser.Package clientPkg = clientLibPkgs.get(i);
                int result = mPackageDexOptimizer.performDexOpt(clientPkg, null, /* instruction sets */
                forceDex, (scanFlags & SCAN_DEFER_DEX) != 0, false, (scanFlags & SCAN_BOOTING) == 0);
                if (result == PackageDexOptimizer.DEX_OPT_FAILED) {
                    throw new PackageManagerException(INSTALL_FAILED_DEXOPT, "scanPackageLI failed to dexopt clientLibPkgs");
                }
            }
        }
    }
    // version of the application while the new one gets installed.
    if ((scanFlags & SCAN_REPLACING) != 0) {
        killApplication(pkg.applicationInfo.packageName, pkg.applicationInfo.uid, "replace pkg");
    }
    // Also need to kill any apps that are dependent on the library.
    if (clientLibPkgs != null) {
        for (int i = 0; i < clientLibPkgs.size(); i++) {
            PackageParser.Package clientPkg = clientLibPkgs.get(i);
            killApplication(clientPkg.applicationInfo.packageName, clientPkg.applicationInfo.uid, "update lib");
        }
    }
    // Make sure we're not adding any bogus keyset info
    KeySetManagerService ksms = mSettings.mKeySetManagerService;
    ksms.assertScannedPackageValid(pkg);
    // writer
    synchronized (mPackages) {
        // We don't expect installation to fail beyond this point
        // Add the new setting to mSettings
        mSettings.insertPackageSettingLPw(pkgSetting, pkg);
        // Themes: handle case where app was installed after icon mapping applied
        if (mIconPackHelper != null) {
            int id = mIconPackHelper.getResourceIdForApp(pkg.packageName);
            pkg.applicationInfo.themedIcon = id;
        }
        // Add the new setting to mPackages
        mPackages.put(pkg.applicationInfo.packageName, pkg);
        // Make sure we don't accidentally delete its data.
        final Iterator<PackageCleanItem> iter = mSettings.mPackagesToBeCleaned.iterator();
        while (iter.hasNext()) {
            PackageCleanItem item = iter.next();
            if (pkgName.equals(item.packageName)) {
                iter.remove();
            }
        }
        // Take care of first install / last update times.
        if (currentTime != 0) {
            if (pkgSetting.firstInstallTime == 0) {
                pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = currentTime;
            } else if ((scanFlags & SCAN_UPDATE_TIME) != 0) {
                pkgSetting.lastUpdateTime = currentTime;
            }
        } else if (pkgSetting.firstInstallTime == 0) {
            // We need *something*.  Take time time stamp of the file.
            pkgSetting.firstInstallTime = pkgSetting.lastUpdateTime = scanFileTime;
        } else if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0) {
            if (scanFileTime != pkgSetting.timeStamp) {
                // A package on the system image has changed; consider this
                // to be an update.
                pkgSetting.lastUpdateTime = scanFileTime;
            }
        }
        // Add the package's KeySets to the global KeySetManagerService
        ksms.addScannedPackageLPw(pkg);
        int N = pkg.providers.size();
        StringBuilder r = null;
        int i;
        for (i = 0; i < N; i++) {
            PackageParser.Provider p = pkg.providers.get(i);
            p.info.processName = fixProcessName(pkg.applicationInfo.processName, p.info.processName, pkg.applicationInfo.uid);
            mProviders.addProvider(p);
            p.syncable = p.info.isSyncable;
            if (p.info.authority != null) {
                String[] names = p.info.authority.split(";");
                p.info.authority = null;
                for (int j = 0; j < names.length; j++) {
                    if (j == 1 && p.syncable) {
                        // We only want the first authority for a provider to possibly be
                        // syncable, so if we already added this provider using a different
                        // authority clear the syncable flag. We copy the provider before
                        // changing it because the mProviders object contains a reference
                        // to a provider that we don't want to change.
                        // Only do this for the second authority since the resulting provider
                        // object can be the same for all future authorities for this provider.
                        p = new PackageParser.Provider(p);
                        p.syncable = false;
                    }
                    if (!mProvidersByAuthority.containsKey(names[j])) {
                        mProvidersByAuthority.put(names[j], p);
                        if (p.info.authority == null) {
                            p.info.authority = names[j];
                        } else {
                            p.info.authority = p.info.authority + ";" + names[j];
                        }
                        if (DEBUG_PACKAGE_SCANNING) {
                            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0)
                                Log.d(TAG, "Registered content provider: " + names[j] + ", className = " + p.info.name + ", isSyncable = " + p.info.isSyncable);
                        }
                    } else {
                        PackageParser.Provider other = mProvidersByAuthority.get(names[j]);
                        Slog.w(TAG, "Skipping provider name " + names[j] + " (in package " + pkg.applicationInfo.packageName + "): name already used by " + ((other != null && other.getComponentName() != null) ? other.getComponentName().getPackageName() : "?"));
                    }
                }
            }
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(p.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Providers: " + r);
        }
        N = pkg.services.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Service s = pkg.services.get(i);
            s.info.processName = fixProcessName(pkg.applicationInfo.processName, s.info.processName, pkg.applicationInfo.uid);
            mServices.addService(s);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(s.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Services: " + r);
        }
        N = pkg.receivers.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.receivers.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            mReceivers.addActivity(a, "receiver");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Receivers: " + r);
        }
        N = pkg.activities.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Activity a = pkg.activities.get(i);
            a.info.processName = fixProcessName(pkg.applicationInfo.processName, a.info.processName, pkg.applicationInfo.uid);
            // Themes: handle case where app was installed after icon mapping applied
            if (mIconPackHelper != null) {
                a.info.themedIcon = mIconPackHelper.getResourceIdForActivityIcon(a.info);
            }
            mActivities.addActivity(a, "activity");
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Activities: " + r);
        }
        N = pkg.permissionGroups.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.PermissionGroup pg = pkg.permissionGroups.get(i);
            PackageParser.PermissionGroup cur = mPermissionGroups.get(pg.info.name);
            if (cur == null) {
                mPermissionGroups.put(pg.info.name, pg);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append(pg.info.name);
                }
            } else {
                Slog.w(TAG, "Permission group " + pg.info.name + " from package " + pg.info.packageName + " ignored: original from " + cur.info.packageName);
                if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                    if (r == null) {
                        r = new StringBuilder(256);
                    } else {
                        r.append(' ');
                    }
                    r.append("DUP:");
                    r.append(pg.info.name);
                }
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permission Groups: " + r);
        }
        N = pkg.permissions.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Permission p = pkg.permissions.get(i);
            // Assume by default that we did not install this permission into the system.
            p.info.flags &= ~PermissionInfo.FLAG_INSTALLED;
            // to be in a group defined by another app (before this had no implications).
            if (pkg.applicationInfo.targetSdkVersion > Build.VERSION_CODES.LOLLIPOP_MR1) {
                p.group = mPermissionGroups.get(p.info.group);
                // Warn for a permission in an unknown group.
                if (p.info.group != null && p.group == null) {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " in an unknown group " + p.info.group);
                }
            }
            ArrayMap<String, BasePermission> permissionMap = p.tree ? mSettings.mPermissionTrees : mSettings.mPermissions;
            BasePermission bp = permissionMap.get(p.info.name);
            // Allow system apps to redefine non-system permissions
            if (bp != null && !Objects.equals(bp.sourcePackage, p.info.packageName)) {
                final boolean currentOwnerIsSystem = (bp.perm != null && isSystemApp(bp.perm.owner));
                if (isSystemApp(p.owner)) {
                    if (bp.type == BasePermission.TYPE_BUILTIN && bp.perm == null) {
                        // It's a built-in permission and no owner, take ownership now
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        bp.allowViaWhitelist = p.info.allowViaWhitelist;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                    } else if (!currentOwnerIsSystem) {
                        String msg = "New decl " + p.owner + " of permission  " + p.info.name + " is system; overriding " + bp.sourcePackage;
                        reportSettingsProblem(Log.WARN, msg);
                        bp = null;
                    }
                }
            }
            if (bp == null) {
                bp = new BasePermission(p.info.name, p.info.packageName, BasePermission.TYPE_NORMAL);
                bp.allowViaWhitelist = p.info.allowViaWhitelist;
                permissionMap.put(p.info.name, bp);
            }
            if (bp.perm == null) {
                if (bp.sourcePackage == null || bp.sourcePackage.equals(p.info.packageName)) {
                    BasePermission tree = findPermissionTreeLP(p.info.name);
                    if (tree == null || tree.sourcePackage.equals(p.info.packageName)) {
                        bp.packageSetting = pkgSetting;
                        bp.perm = p;
                        bp.uid = pkg.applicationInfo.uid;
                        bp.sourcePackage = p.info.packageName;
                        bp.allowViaWhitelist = p.info.allowViaWhitelist;
                        p.info.flags |= PermissionInfo.FLAG_INSTALLED;
                        if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                            if (r == null) {
                                r = new StringBuilder(256);
                            } else {
                                r.append(' ');
                            }
                            r.append(p.info.name);
                        }
                    } else {
                        Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: base tree " + tree.name + " is from package " + tree.sourcePackage);
                    }
                } else {
                    Slog.w(TAG, "Permission " + p.info.name + " from package " + p.info.packageName + " ignored: original from " + bp.sourcePackage);
                }
            } else if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append("DUP:");
                r.append(p.info.name);
            }
            if (bp.perm == p) {
                bp.protectionLevel = p.info.protectionLevel;
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Permissions: " + r);
        }
        N = pkg.instrumentation.size();
        r = null;
        for (i = 0; i < N; i++) {
            PackageParser.Instrumentation a = pkg.instrumentation.get(i);
            a.info.packageName = pkg.applicationInfo.packageName;
            a.info.sourceDir = pkg.applicationInfo.sourceDir;
            a.info.publicSourceDir = pkg.applicationInfo.publicSourceDir;
            a.info.splitSourceDirs = pkg.applicationInfo.splitSourceDirs;
            a.info.splitPublicSourceDirs = pkg.applicationInfo.splitPublicSourceDirs;
            a.info.dataDir = pkg.applicationInfo.dataDir;
            // TODO: Update instrumentation.nativeLibraryDir as well ? Does it
            // need other information about the application, like the ABI and what not ?
            a.info.nativeLibraryDir = pkg.applicationInfo.nativeLibraryDir;
            mInstrumentation.put(a.getComponentName(), a);
            if ((parseFlags & PackageParser.PARSE_CHATTY) != 0) {
                if (r == null) {
                    r = new StringBuilder(256);
                } else {
                    r.append(' ');
                }
                r.append(a.info.name);
            }
        }
        if (r != null) {
            if (DEBUG_PACKAGE_SCANNING)
                Log.d(TAG, "  Instrumentation: " + r);
        }
        if (pkg.protectedBroadcasts != null) {
            N = pkg.protectedBroadcasts.size();
            for (i = 0; i < N; i++) {
                mProtectedBroadcasts.add(pkg.protectedBroadcasts.get(i));
            }
        }
        pkgSetting.setTimeStamp(scanFileTime);
        final boolean isBootScan = (scanFlags & SCAN_BOOTING) != 0;
        // in background)
        if (pkg.mOverlayTargets.isEmpty() && mOverlays.containsKey(pkg.packageName)) {
            ArrayMap<String, PackageParser.Package> themes = mOverlays.get(pkg.packageName);
            final IActivityManager am = ActivityManagerNative.getDefault();
            ThemeConfig themeConfig = null;
            try {
                if (am != null) {
                    themeConfig = am.getConfiguration().themeConfig;
                } else {
                    Log.e(TAG, "ActivityManager getDefault() " + "returned null, cannot compile app's theme");
                }
            } catch (RemoteException e) {
                Log.e(TAG, "Failed to get the theme config ", e);
            }
            ThemeConfig config = isBootScan ? mBootThemeConfig : themeConfig;
            if (config != null) {
                for (PackageParser.Package themePkg : themes.values()) {
                    if (themePkg.packageName.equals(config.getOverlayPkgName()) || themePkg.packageName.equals(config.getOverlayPkgNameForApp(pkg.packageName))) {
                        try {
                            compileResourcesAndIdmapIfNeeded(pkg, themePkg);
                        } catch (Exception e) {
                            // Do not stop a pkg installation just because of one bad theme
                            // Also we don't break here because we should try to compile other
                            // themes
                            Slog.w(TAG, "Unable to compile " + themePkg.packageName + " for target " + pkg.packageName, e);
                            themePkg.mOverlayTargets.remove(pkg.packageName);
                        }
                    }
                }
            }
        }
        // remove this package from mAvailableCommonResources.
        if (!isBootScan && pkg.mOverlayTargets.size() > 0) {
            mAvailableCommonResources.remove(pkg.packageName);
        }
        // Generate Idmaps and res tables if pkg is a theme
        Iterator<String> iterator = pkg.mOverlayTargets.iterator();
        while (iterator.hasNext()) {
            String target = iterator.next();
            Exception failedException = null;
            insertIntoOverlayMap(target, pkg);
            if (isBootScan && mBootThemeConfig != null && (pkg.packageName.equals(mBootThemeConfig.getOverlayPkgName()) || pkg.packageName.equals(mBootThemeConfig.getOverlayPkgNameForApp(target)))) {
                try {
                    compileResourcesAndIdmapIfNeeded(mPackages.get(target), pkg);
                } catch (IdmapException e) {
                    failedException = e;
                } catch (AaptException e) {
                    failedException = e;
                } catch (Exception e) {
                    failedException = e;
                }
                if (failedException != null) {
                    Slog.w(TAG, "Unable to process theme " + pkgName + " for " + target, failedException);
                    // remove target from mOverlayTargets
                    iterator.remove();
                }
            }
        }
        // Icon Packs need aapt too
        if (isBootScan && (mBootThemeConfig != null && pkg.packageName.equals(mBootThemeConfig.getIconPackPkgName()))) {
            if (isIconCompileNeeded(pkg)) {
                try {
                    ThemeUtils.createCacheDirIfNotExists();
                    ThemeUtils.createIconDirIfNotExists(pkg.packageName);
                    compileIconPack(pkg);
                } catch (Exception e) {
                    uninstallThemeForAllApps(pkg);
                    deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
                    throw new PackageManagerException(PackageManager.INSTALL_FAILED_THEME_AAPT_ERROR, "Unable to process theme " + pkgName);
                }
            }
        }
    }
    return pkg;
}
#end_block

#method_before
@Override
public void onSensorChanged(SensorEvent event) {
    int proposedRotation;
    int oldProposedRotation;
    synchronized (mLock) {
        // The vector given in the SensorEvent points straight up (towards the sky) under
        // ideal conditions (the phone is not accelerating).  I'll call this up vector
        // elsewhere.
        float x = event.values[ACCELEROMETER_DATA_X];
        float y = event.values[ACCELEROMETER_DATA_Y];
        float z = event.values[ACCELEROMETER_DATA_Z];
        if (LOG) {
            Slog.v(TAG, "Raw acceleration vector: " + "x=" + x + ", y=" + y + ", z=" + z + ", magnitude=" + Math.sqrt(x * x + y * y + z * z));
        }
        // Apply a low-pass filter to the acceleration up vector in cartesian space.
        // Reset the orientation listener state if the samples are too far apart in time
        // or when we see values of (0, 0, 0) which indicates that we polled the
        // accelerometer too soon after turning it on and we don't have any data yet.
        final long now;
        if (museSystemClockforSensors) {
            now = SystemClock.elapsedRealtimeNanos();
        } else {
            now = event.timestamp;
        }
        final long then = mLastFilteredTimestampNanos;
        final float timeDeltaMS = (now - then) * 0.000001f;
        final boolean skipSample;
        if (now < then || now > then + MAX_FILTER_DELTA_TIME_NANOS || (x == 0 && y == 0 && z == 0)) {
            if (LOG) {
                Slog.v(TAG, "Resetting orientation listener.");
            }
            resetLocked();
            skipSample = true;
        } else {
            final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
            x = alpha * (x - mLastFilteredX) + mLastFilteredX;
            y = alpha * (y - mLastFilteredY) + mLastFilteredY;
            z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
            if (LOG) {
                Slog.v(TAG, "Filtered acceleration vector: " + "x=" + x + ", y=" + y + ", z=" + z + ", magnitude=" + Math.sqrt(x * x + y * y + z * z));
            }
            skipSample = false;
        }
        mLastFilteredTimestampNanos = now;
        mLastFilteredX = x;
        mLastFilteredY = y;
        mLastFilteredZ = z;
        boolean isAccelerating = false;
        boolean isFlat = false;
        boolean isSwinging = false;
        if (!skipSample) {
            // Calculate the magnitude of the acceleration vector.
            final float magnitude = (float) Math.sqrt(x * x + y * y + z * z);
            if (magnitude < NEAR_ZERO_MAGNITUDE) {
                if (LOG) {
                    Slog.v(TAG, "Ignoring sensor data, magnitude too close to zero.");
                }
                clearPredictedRotationLocked();
            } else {
                // acceleration.
                if (isAcceleratingLocked(magnitude)) {
                    isAccelerating = true;
                    mAccelerationTimestampNanos = now;
                }
                // Calculate the tilt angle.
                // This is the angle between the up vector and the x-y plane (the plane of
                // the screen) in a range of [-90, 90] degrees.
                // -90 degrees: screen horizontal and facing the ground (overhead)
                // 0 degrees: screen vertical
                // 90 degrees: screen horizontal and facing the sky (on table)
                final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
                addTiltHistoryEntryLocked(now, tiltAngle);
                // Determine whether the device appears to be flat or swinging.
                if (isFlatLocked(now)) {
                    isFlat = true;
                    mFlatTimestampNanos = now;
                }
                if (isSwingingLocked(now, tiltAngle)) {
                    isSwinging = true;
                    mSwingTimestampNanos = now;
                }
                // the orientation angle of the screen.
                if (tiltAngle <= TILT_OVERHEAD_ENTER) {
                    mOverhead = true;
                } else if (tiltAngle >= TILT_OVERHEAD_EXIT) {
                    mOverhead = false;
                }
                if (mOverhead) {
                    if (LOG) {
                        Slog.v(TAG, "Ignoring sensor data, device is overhead: " + "tiltAngle=" + tiltAngle);
                    }
                    clearPredictedRotationLocked();
                } else if (Math.abs(tiltAngle) > MAX_TILT) {
                    if (LOG) {
                        Slog.v(TAG, "Ignoring sensor data, tilt angle too high: " + "tiltAngle=" + tiltAngle);
                    }
                    clearPredictedRotationLocked();
                } else {
                    // Calculate the orientation angle.
                    // This is the angle between the x-y projection of the up vector onto
                    // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                    int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                    if (orientationAngle < 0) {
                        // atan2 returns [-180, 180]; normalize to [0, 360]
                        orientationAngle += 360;
                    }
                    // Find the nearest rotation.
                    int nearestRotation = (orientationAngle + 45) / 90;
                    if (nearestRotation == 4) {
                        nearestRotation = 0;
                    }
                    // Determine the predicted orientation.
                    if (isTiltAngleAcceptableLocked(nearestRotation, tiltAngle) && isOrientationAngleAcceptableLocked(nearestRotation, orientationAngle)) {
                        updatePredictedRotationLocked(now, nearestRotation);
                        if (LOG) {
                            Slog.v(TAG, "Predicted: " + "tiltAngle=" + tiltAngle + ", orientationAngle=" + orientationAngle + ", predictedRotation=" + mPredictedRotation + ", predictedRotationAgeMS=" + ((now - mPredictedRotationTimestampNanos) * 0.000001f));
                        }
                    } else {
                        if (LOG) {
                            Slog.v(TAG, "Ignoring sensor data, no predicted rotation: " + "tiltAngle=" + tiltAngle + ", orientationAngle=" + orientationAngle);
                        }
                        clearPredictedRotationLocked();
                    }
                }
            }
        }
        mFlat = isFlat;
        mSwinging = isSwinging;
        mAccelerating = isAccelerating;
        // Determine new proposed rotation.
        oldProposedRotation = mProposedRotation;
        if (mPredictedRotation < 0 || isPredictedRotationAcceptableLocked(now)) {
            mProposedRotation = mPredictedRotation;
        }
        proposedRotation = mProposedRotation;
        // Write final statistics about where we are in the orientation detection process.
        if (LOG) {
            Slog.v(TAG, "Result: currentRotation=" + mCurrentRotation + ", proposedRotation=" + proposedRotation + ", predictedRotation=" + mPredictedRotation + ", timeDeltaMS=" + timeDeltaMS + ", isAccelerating=" + isAccelerating + ", isFlat=" + isFlat + ", isSwinging=" + isSwinging + ", isOverhead=" + mOverhead + ", isTouched=" + mTouched + ", timeUntilSettledMS=" + remainingMS(now, mPredictedRotationTimestampNanos + PROPOSAL_SETTLE_TIME_NANOS) + ", timeUntilAccelerationDelayExpiredMS=" + remainingMS(now, mAccelerationTimestampNanos + PROPOSAL_MIN_TIME_SINCE_ACCELERATION_ENDED_NANOS) + ", timeUntilFlatDelayExpiredMS=" + remainingMS(now, mFlatTimestampNanos + PROPOSAL_MIN_TIME_SINCE_FLAT_ENDED_NANOS) + ", timeUntilSwingDelayExpiredMS=" + remainingMS(now, mSwingTimestampNanos + PROPOSAL_MIN_TIME_SINCE_SWING_ENDED_NANOS) + ", timeUntilTouchDelayExpiredMS=" + remainingMS(now, mTouchEndedTimestampNanos + PROPOSAL_MIN_TIME_SINCE_TOUCH_END_NANOS));
        }
    }
    // Tell the listener.
    if (proposedRotation != oldProposedRotation && proposedRotation >= 0) {
        if (LOG) {
            Slog.v(TAG, "Proposed rotation changed!  proposedRotation=" + proposedRotation + ", oldProposedRotation=" + oldProposedRotation);
        }
        onProposedRotationChanged(proposedRotation);
    }
}
#method_after
@Override
public void onSensorChanged(SensorEvent event) {
    int proposedRotation;
    int oldProposedRotation;
    synchronized (mLock) {
        // The vector given in the SensorEvent points straight up (towards the sky) under
        // ideal conditions (the phone is not accelerating).  I'll call this up vector
        // elsewhere.
        float x = event.values[ACCELEROMETER_DATA_X];
        float y = event.values[ACCELEROMETER_DATA_Y];
        float z = event.values[ACCELEROMETER_DATA_Z];
        if (LOG) {
            Slog.v(TAG, "Raw acceleration vector: " + "x=" + x + ", y=" + y + ", z=" + z + ", magnitude=" + Math.sqrt(x * x + y * y + z * z));
        }
        // Apply a low-pass filter to the acceleration up vector in cartesian space.
        // Reset the orientation listener state if the samples are too far apart in time
        // or when we see values of (0, 0, 0) which indicates that we polled the
        // accelerometer too soon after turning it on and we don't have any data yet.
        final long now = mUseSystemClockforSensors ? SystemClock.elapsedRealtimeNanos() : event.timestamp;
        final long then = mLastFilteredTimestampNanos;
        final float timeDeltaMS = (now - then) * 0.000001f;
        final boolean skipSample;
        if (now < then || now > then + MAX_FILTER_DELTA_TIME_NANOS || (x == 0 && y == 0 && z == 0)) {
            if (LOG) {
                Slog.v(TAG, "Resetting orientation listener.");
            }
            resetLocked();
            skipSample = true;
        } else {
            final float alpha = timeDeltaMS / (FILTER_TIME_CONSTANT_MS + timeDeltaMS);
            x = alpha * (x - mLastFilteredX) + mLastFilteredX;
            y = alpha * (y - mLastFilteredY) + mLastFilteredY;
            z = alpha * (z - mLastFilteredZ) + mLastFilteredZ;
            if (LOG) {
                Slog.v(TAG, "Filtered acceleration vector: " + "x=" + x + ", y=" + y + ", z=" + z + ", magnitude=" + Math.sqrt(x * x + y * y + z * z));
            }
            skipSample = false;
        }
        mLastFilteredTimestampNanos = now;
        mLastFilteredX = x;
        mLastFilteredY = y;
        mLastFilteredZ = z;
        boolean isAccelerating = false;
        boolean isFlat = false;
        boolean isSwinging = false;
        if (!skipSample) {
            // Calculate the magnitude of the acceleration vector.
            final float magnitude = (float) Math.sqrt(x * x + y * y + z * z);
            if (magnitude < NEAR_ZERO_MAGNITUDE) {
                if (LOG) {
                    Slog.v(TAG, "Ignoring sensor data, magnitude too close to zero.");
                }
                clearPredictedRotationLocked();
            } else {
                // acceleration.
                if (isAcceleratingLocked(magnitude)) {
                    isAccelerating = true;
                    mAccelerationTimestampNanos = now;
                }
                // Calculate the tilt angle.
                // This is the angle between the up vector and the x-y plane (the plane of
                // the screen) in a range of [-90, 90] degrees.
                // -90 degrees: screen horizontal and facing the ground (overhead)
                // 0 degrees: screen vertical
                // 90 degrees: screen horizontal and facing the sky (on table)
                final int tiltAngle = (int) Math.round(Math.asin(z / magnitude) * RADIANS_TO_DEGREES);
                addTiltHistoryEntryLocked(now, tiltAngle);
                // Determine whether the device appears to be flat or swinging.
                if (isFlatLocked(now)) {
                    isFlat = true;
                    mFlatTimestampNanos = now;
                }
                if (isSwingingLocked(now, tiltAngle)) {
                    isSwinging = true;
                    mSwingTimestampNanos = now;
                }
                // the orientation angle of the screen.
                if (tiltAngle <= TILT_OVERHEAD_ENTER) {
                    mOverhead = true;
                } else if (tiltAngle >= TILT_OVERHEAD_EXIT) {
                    mOverhead = false;
                }
                if (mOverhead) {
                    if (LOG) {
                        Slog.v(TAG, "Ignoring sensor data, device is overhead: " + "tiltAngle=" + tiltAngle);
                    }
                    clearPredictedRotationLocked();
                } else if (Math.abs(tiltAngle) > MAX_TILT) {
                    if (LOG) {
                        Slog.v(TAG, "Ignoring sensor data, tilt angle too high: " + "tiltAngle=" + tiltAngle);
                    }
                    clearPredictedRotationLocked();
                } else {
                    // Calculate the orientation angle.
                    // This is the angle between the x-y projection of the up vector onto
                    // the +y-axis, increasing clockwise in a range of [0, 360] degrees.
                    int orientationAngle = (int) Math.round(-Math.atan2(-x, y) * RADIANS_TO_DEGREES);
                    if (orientationAngle < 0) {
                        // atan2 returns [-180, 180]; normalize to [0, 360]
                        orientationAngle += 360;
                    }
                    // Find the nearest rotation.
                    int nearestRotation = (orientationAngle + 45) / 90;
                    if (nearestRotation == 4) {
                        nearestRotation = 0;
                    }
                    // Determine the predicted orientation.
                    if (isTiltAngleAcceptableLocked(nearestRotation, tiltAngle) && isOrientationAngleAcceptableLocked(nearestRotation, orientationAngle)) {
                        updatePredictedRotationLocked(now, nearestRotation);
                        if (LOG) {
                            Slog.v(TAG, "Predicted: " + "tiltAngle=" + tiltAngle + ", orientationAngle=" + orientationAngle + ", predictedRotation=" + mPredictedRotation + ", predictedRotationAgeMS=" + ((now - mPredictedRotationTimestampNanos) * 0.000001f));
                        }
                    } else {
                        if (LOG) {
                            Slog.v(TAG, "Ignoring sensor data, no predicted rotation: " + "tiltAngle=" + tiltAngle + ", orientationAngle=" + orientationAngle);
                        }
                        clearPredictedRotationLocked();
                    }
                }
            }
        }
        mFlat = isFlat;
        mSwinging = isSwinging;
        mAccelerating = isAccelerating;
        // Determine new proposed rotation.
        oldProposedRotation = mProposedRotation;
        if (mPredictedRotation < 0 || isPredictedRotationAcceptableLocked(now)) {
            mProposedRotation = mPredictedRotation;
        }
        proposedRotation = mProposedRotation;
        // Write final statistics about where we are in the orientation detection process.
        if (LOG) {
            Slog.v(TAG, "Result: currentRotation=" + mCurrentRotation + ", proposedRotation=" + proposedRotation + ", predictedRotation=" + mPredictedRotation + ", timeDeltaMS=" + timeDeltaMS + ", isAccelerating=" + isAccelerating + ", isFlat=" + isFlat + ", isSwinging=" + isSwinging + ", isOverhead=" + mOverhead + ", isTouched=" + mTouched + ", timeUntilSettledMS=" + remainingMS(now, mPredictedRotationTimestampNanos + PROPOSAL_SETTLE_TIME_NANOS) + ", timeUntilAccelerationDelayExpiredMS=" + remainingMS(now, mAccelerationTimestampNanos + PROPOSAL_MIN_TIME_SINCE_ACCELERATION_ENDED_NANOS) + ", timeUntilFlatDelayExpiredMS=" + remainingMS(now, mFlatTimestampNanos + PROPOSAL_MIN_TIME_SINCE_FLAT_ENDED_NANOS) + ", timeUntilSwingDelayExpiredMS=" + remainingMS(now, mSwingTimestampNanos + PROPOSAL_MIN_TIME_SINCE_SWING_ENDED_NANOS) + ", timeUntilTouchDelayExpiredMS=" + remainingMS(now, mTouchEndedTimestampNanos + PROPOSAL_MIN_TIME_SINCE_TOUCH_END_NANOS));
        }
    }
    // Tell the listener.
    if (proposedRotation != oldProposedRotation && proposedRotation >= 0) {
        if (LOG) {
            Slog.v(TAG, "Proposed rotation changed!  proposedRotation=" + proposedRotation + ", oldProposedRotation=" + oldProposedRotation);
        }
        onProposedRotationChanged(proposedRotation);
    }
}
#end_block

#method_before
@Override
protected void entryRemoved(boolean evicted, Key k, Value oldVal, Value newVal) {
    // When a token has been removed, clean up the associated Evictor.
    if (oldVal != null && newVal == null) {
        /*
                 * This is recursive, but it won't spiral out of control because LruCache is
                 * thread safe and the Evictor can only be removed once.
                 */
        Pair<String, String> pair = new Pair<>(k.account.type, oldVal.token);
        Evictor evictor = mTokenEvictors.remove(pair);
        if (evictor != null) {
            evictor.evict();
        }
    }
}
#method_after
@Override
protected void entryRemoved(boolean evicted, Key k, Value oldVal, Value newVal) {
    // When a token has been removed, clean up the associated Evictor.
    if (oldVal != null && newVal == null) {
        /*
                 * This is recursive, but it won't spiral out of control because LruCache is
                 * thread safe and the Evictor can only be removed once.
                 */
        Evictor evictor = mTokenEvictors.remove(new Pair<>(k.account.type, oldVal.token));
        if (evictor != null) {
            evictor.evict();
        }
    }
}
#end_block

#method_before
public void evict(String accountType, String token) {
    Pair<String, String> pair = new Pair<>(accountType, token);
    Evictor evictor = mTokenEvictors.get(pair);
    if (evictor != null) {
        evictor.evict();
    }
}
#method_after
public void evict(String accountType, String token) {
    Evictor evictor = mTokenEvictors.get(new Pair<>(accountType, token));
    if (evictor != null) {
        evictor.evict();
    }
}
#end_block

#method_before
private static boolean isEmergencyNumberForCurrentIso(String number, String country, int slotId) {
    Rlog.w(LOG_TAG, "isEmergencyNumberForCurrentIso: number=" + number + " country=" + country);
    String mccEccIso = "";
    String mccEccIsoProp = (slotId == 0) ? "ril.mcc.ecc.iso" : ("ril.mcc.ecc.iso" + slotId);
    mccEccIso = SystemProperties.get(mccEccIsoProp, "");
    if (TextUtils.isEmpty(mccEccIso) || TextUtils.isEmpty(country) || slotId < 0 || isEmergencyIsoMatchCountryIso(mccEccIso, country)) {
        Rlog.w(LOG_TAG, "MCC/ISO is empty or does match, so same region as ECC#'s set from RIL database");
        return true;
    }
    String mccEccList = "";
    String mccEccListProp = (slotId == 0) ? "ril.mcc.ecclist" : ("ril.mcc.ecclist" + slotId);
    mccEccList = SystemProperties.get(mccEccListProp, "");
    if (!TextUtils.isEmpty(mccEccList)) {
        for (String emergencyNum : mccEccList.split(",")) {
            if (number.equals(emergencyNum)) {
                Rlog.w(LOG_TAG, "Number " + number + " matches to the MCC_ECC_LIST " + emergencyNum);
                return false;
            }
        }
    }
    return true;
}
#method_after
private static boolean isEmergencyNumberForCurrentIso(String number, String country, int slotId) {
    Rlog.w(LOG_TAG, "isEmergencyNumberForCurrentIso: number =" + number + " iso=" + country);
    String mccEccIso = "";
    String mccEccIsoProp = (slotId == 0) ? "ril.mcc.ecc.iso" : ("ril.mcc.ecc.iso" + slotId);
    mccEccIso = SystemProperties.get(mccEccIsoProp, "");
    if (TextUtils.isEmpty(mccEccIso) || TextUtils.isEmpty(country) || slotId < 0 || isEmergencyIsoMatchCountryIso(mccEccIso, country)) {
        Rlog.w(LOG_TAG, "MCC/ISO is empty or matches region for ECC#'s set via RIL db");
        return true;
    }
    String mccEccList = "";
    String mccEccListProp = (slotId == 0) ? "ril.mcc.ecclist" : ("ril.mcc.ecclist" + slotId);
    mccEccList = SystemProperties.get(mccEccListProp, "");
    if (!TextUtils.isEmpty(mccEccList)) {
        for (String emergencyNum : mccEccList.split(",")) {
            if (number.equals(emergencyNum)) {
                Rlog.w(LOG_TAG, "Number " + number + " matches with  " + mccEccListProp);
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    parseFlags |= mDefParseFlags;
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
    if ((parseFlags & PackageParser.PARSE_IS_PREBUNDLED_DIR) != 0) {
        synchronized (mPackages) {
            PackageSetting existingSettings = mSettings.peekPackageLPr(pkg.packageName);
            // If the settings exist, the version code is higher, and its currently installed
            // for the given user, then it is a valid update.
            final boolean isUpdatedPrebundle = existingSettings != null && existingSettings.versionCode > pkg.mVersionCode && existingSettings.getInstalled(user.getIdentifier());
            if (mSettings.wasPrebundledPackageInstalledLPr(user.getIdentifier(), pkg.packageName) && !isUpdatedPrebundle) {
                // currently installed or isn't a newer version, skip reinstalling it
                throw new PackageManagerException(INSTALL_FAILED_UNINSTALLED_PREBUNDLE, "skip reinstall for " + pkg.packageName);
            } else if (!mSettings.shouldPrebundledPackageBeInstalled(mContext.getResources(), pkg.packageName, mCustomResources)) {
                // skip installing it
                throw new PackageManagerException(INSTALL_FAILED_REGION_LOCKED_PREBUNDLE, "skip install for " + pkg.packageName);
            } else if (existingSettings != null && existingSettings.versionCode >= pkg.mVersionCode && !existingSettings.codePathString.contains(Environment.getPrebundledDirectory().getPath())) {
                // This app is installed in a location that is not the prebundled location
                // and has a higher (or same) version as the prebundled one.  Skip
                // installing the prebundled version.
                Slog.d(TAG, pkg.packageName + " already installed at " + existingSettings.codePathString);
                // return null so we still mark package as installed
                return null;
            }
        }
    }
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.peekPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.peekPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
    }
    boolean updatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg : " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                updatedPkgBetter = true;
            }
        }
    }
    if (updatedPkg != null) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        parseFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    // TODO: extend to support forward-locked splits
    String resourcePath = null;
    String baseResourcePath = null;
    if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for pkg : " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(resourcePath);
    pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName);
        }
    }
    return scannedPkg;
}
#method_after
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    parseFlags |= mDefParseFlags;
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
    if ((parseFlags & PackageParser.PARSE_IS_PREBUNDLED_DIR) != 0) {
        synchronized (mPackages) {
            PackageSetting existingSettings = mSettings.peekPackageLPr(pkg.packageName);
            boolean isInstalledForUser = (existingSettings != null && existingSettings.getInstalled(user.getIdentifier()));
            if (mSettings.wasPrebundledPackageInstalledLPr(user.getIdentifier(), pkg.packageName) && !isInstalledForUser) {
                // currently installed for the user, skip reinstalling it
                throw new PackageManagerException(INSTALL_FAILED_UNINSTALLED_PREBUNDLE, "skip reinstall for " + pkg.packageName);
            } else if (!mSettings.shouldPrebundledPackageBeInstalled(mContext.getResources(), pkg.packageName, mCustomResources)) {
                // skip installing it
                throw new PackageManagerException(INSTALL_FAILED_REGION_LOCKED_PREBUNDLE, "skip install for " + pkg.packageName);
            } else if (existingSettings != null && existingSettings.versionCode >= pkg.mVersionCode && !existingSettings.codePathString.contains(Environment.getPrebundledDirectory().getPath())) {
                // This app is installed in a location that is not the prebundled location
                // and has a higher (or same) version as the prebundled one.  Skip
                // installing the prebundled version.
                Slog.d(TAG, pkg.packageName + " already installed at " + existingSettings.codePathString);
                // return null so we still mark package as installed
                return null;
            }
        }
    }
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.peekPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.peekPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
    }
    boolean updatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg : " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                updatedPkgBetter = true;
            }
        }
    }
    if (updatedPkg != null) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        parseFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    // TODO: extend to support forward-locked splits
    String resourcePath = null;
    String baseResourcePath = null;
    if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for pkg : " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(resourcePath);
    pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName);
        }
    }
    return scannedPkg;
}
#end_block

#method_before
public void updateLightsLocked() {
    // mBatteryProps could be null on startup (called by SettingsObserver)
    if (mBatteryProps == null) {
        Slog.w(TAG, "updateLightsLocked: mBatteryProps is null; skipping");
        return;
    }
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    final int brightness = mUseBatteryLevelAsBrightness ? level : mNotificationLedBrightnessLevel;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        mBatteryLight.turnOff();
    } else if (level < mLowBatteryWarningLevel) {
        mBatteryLight.setModes(brightness, mMultipleLedsEnabled);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Battery is charging and low
            mBatteryLight.setColor(mBatteryLowARGB);
        } else if (mLedPulseEnabled) {
            // Battery is low and not charging
            mBatteryLight.setFlashing(mBatteryLowARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        } else {
            // "Pulse low battery light" is disabled, no lights.
            mBatteryLight.turnOff();
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        mBatteryLight.setModes(brightness, mMultipleLedsEnabled);
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            // Battery is full or charging and nearly full
            mBatteryLight.setColor(mBatteryFullARGB);
        } else {
            if (isHvdcpPresent()) {
                // Blinking orange if HVDCP charger
                mBatteryLight.setFlashing(mBatteryMediumARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOn);
            } else {
                // Battery is charging and halfway full
                mBatteryLight.setColor(mBatteryMediumARGB);
            }
        }
    } else {
        // No lights if not charging and not low
        mBatteryLight.turnOff();
    }
}
#method_after
public void updateLightsLocked() {
    // mBatteryProps could be null on startup (called by SettingsObserver)
    if (mBatteryProps == null) {
        Slog.w(TAG, "updateLightsLocked: mBatteryProps is null; skipping");
        return;
    }
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        mBatteryLight.turnOff();
    } else if (mUseSegmentedBatteryLed && (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL)) {
        mBatteryLight.setColor(level);
    } else if (level < mLowBatteryWarningLevel) {
        mBatteryLight.setModes(mNotificationLedBrightnessLevel, mMultipleLedsEnabled);
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Battery is charging and low
            mBatteryLight.setColor(mBatteryLowARGB);
        } else if (mLedPulseEnabled) {
            // Battery is low and not charging
            mBatteryLight.setFlashing(mBatteryLowARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        } else {
            // "Pulse low battery light" is disabled, no lights.
            mBatteryLight.turnOff();
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        mBatteryLight.setModes(mNotificationLedBrightnessLevel, mMultipleLedsEnabled);
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            // Battery is full or charging and nearly full
            mBatteryLight.setColor(mBatteryFullARGB);
        } else {
            if (isHvdcpPresent()) {
                // Blinking orange if HVDCP charger
                mBatteryLight.setFlashing(mBatteryMediumARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOn);
            } else {
                // Battery is charging and halfway full
                mBatteryLight.setColor(mBatteryMediumARGB);
            }
        }
    } else {
        // No lights if not charging and not low
        mBatteryLight.turnOff();
    }
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mHeader = (StatusBarHeaderView) findViewById(R.id.header);
    mHeader.setOnClickListener(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) findViewById(R.id.keyguard_header);
    mKeyguardStatusView = (KeyguardStatusView) findViewById(R.id.keyguard_status_view);
    mQsContainer = (QSContainer) findViewById(R.id.quick_settings_container);
    mQsPanel = (QSDragPanel) findViewById(R.id.quick_settings_panel);
    mClockView = (TextView) findViewById(R.id.clock_view);
    mScrollView = (ObservableScrollView) findViewById(R.id.scroll_view);
    mScrollView.setFocusable(false);
    mReserveNotificationSpace = findViewById(R.id.reserve_notification_space);
    mNotificationContainerParent = (NotificationsQuickSettingsContainer) findViewById(R.id.notification_container_parent);
    mNotificationStackScroller = (NotificationStackScrollLayout) findViewById(R.id.notification_stack_scroller);
    mNotificationStackScroller.setOnHeightChangedListener(this);
    mNotificationStackScroller.setOverscrollTopChangedListener(this);
    mNotificationStackScroller.setOnEmptySpaceClickListener(this);
    mNotificationStackScroller.setScrollView(mScrollView);
    mFastOutSlowInInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.fast_out_slow_in);
    mFastOutLinearInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.fast_out_linear_in);
    mDozeAnimationInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.linear_out_slow_in);
    mViewLinker = new ViewLinker<NotificationStackScrollLayout>(mNotificationStackScroller, new ViewLinker.LinkInfo(mKeyguardStatusBar, ViewLinker.LINK_ALPHA), new ViewLinker.LinkInfo(mKeyguardStatusView, ViewLinker.LINK_ALPHA | ViewLinker.LINK_TRANSLATION));
    mKeyguardBottomArea = (KeyguardBottomAreaView) View.inflate(getContext(), R.layout.keyguard_bottom_area, null);
    /**
     * Keyguard bottom area lives in a separate window, and as such,
     * we must redirect its touch events through the proper flow
     */
    mKeyguardBottomArea.setOnInterceptTouchListener(new KeyguardBottomAreaView.OnInterceptTouchEventListener() {

        @Override
        public boolean onInterceptTouchEvent(MotionEvent e) {
            boolean intercept;
            if (mShowingExternalKeyguard) {
                // Handles swipe up to fade/dismiss when showing
                // live lock screen
                intercept = mGestureDetector.onTouchEvent(e);
            } else {
                intercept = NotificationPanelView.this.onInterceptTouchEvent(e);
            }
            return intercept;
        }
    });
    mKeyguardBottomArea.setOnTouchListener(new OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent e) {
            int action = e.getAction();
            boolean isCancelOrUp = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
            if (isCancelOrUp) {
                mKeyguardBottomArea.setBackground(null);
            }
            boolean intercept = false;
            if (mShowingExternalKeyguard) {
                intercept = mGestureDetector.onTouchEvent(e);
                if (isCancelOrUp) {
                    mKeyguardBottomArea.expand(false);
                }
            } else {
                intercept = NotificationPanelView.this.onTouchEvent(e);
            }
            return intercept;
        }
    });
    mQsNavbarScrim = findViewById(R.id.qs_navbar_scrim);
    mAfforanceHelper = new KeyguardAffordanceHelper(this, getContext());
    mLastOrientation = getResources().getConfiguration().orientation;
    // recompute internal state when qspanel height changes
    mQsContainer.addOnLayoutChangeListener(new OnLayoutChangeListener() {

        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            final int height = bottom - top;
            final int oldHeight = oldBottom - oldTop;
            if (height != oldHeight) {
                onScrollChanged();
            }
        }
    });
}
#method_after
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mHeader = (StatusBarHeaderView) findViewById(R.id.header);
    mHeader.setOnClickListener(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) findViewById(R.id.keyguard_header);
    mKeyguardStatusView = (KeyguardStatusView) findViewById(R.id.keyguard_status_view);
    mQsContainer = (QSContainer) findViewById(R.id.quick_settings_container);
    mQsPanel = (QSDragPanel) findViewById(R.id.quick_settings_panel);
    mClockView = (TextView) findViewById(R.id.clock_view);
    mScrollView = (ObservableScrollView) findViewById(R.id.scroll_view);
    mScrollView.setFocusable(false);
    mReserveNotificationSpace = findViewById(R.id.reserve_notification_space);
    mNotificationContainerParent = (NotificationsQuickSettingsContainer) findViewById(R.id.notification_container_parent);
    mNotificationStackScroller = (NotificationStackScrollLayout) findViewById(R.id.notification_stack_scroller);
    mNotificationStackScroller.setOnHeightChangedListener(this);
    mNotificationStackScroller.setOverscrollTopChangedListener(this);
    mNotificationStackScroller.setOnEmptySpaceClickListener(this);
    mNotificationStackScroller.setScrollView(mScrollView);
    mFastOutSlowInInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.fast_out_slow_in);
    mFastOutLinearInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.fast_out_linear_in);
    mDozeAnimationInterpolator = AnimationUtils.loadInterpolator(getContext(), android.R.interpolator.linear_out_slow_in);
    mViewLinker = new ViewLinker<NotificationStackScrollLayout>(mNotificationStackScroller, new ViewLinker.LinkInfo(mKeyguardStatusBar, ViewLinker.LINK_ALPHA), new ViewLinker.LinkInfo(mKeyguardStatusView, ViewLinker.LINK_ALPHA | ViewLinker.LINK_TRANSLATION));
    mKeyguardBottomArea = (KeyguardBottomAreaView) View.inflate(getContext(), R.layout.keyguard_bottom_area, null);
    /**
     * Keyguard bottom area lives in a separate window, and as such,
     * we must redirect its touch events through the proper flow
     */
    mKeyguardBottomArea.setOnInterceptTouchListener(new KeyguardBottomAreaView.OnInterceptTouchEventListener() {

        @Override
        public boolean onInterceptTouchEvent(MotionEvent e) {
            boolean intercept = false;
            if (mShowingExternalKeyguard) {
                // Handles swipe up to fade/dismiss when showing
                // live lock screen
                intercept = mAfforanceHelper.onInterceptTouchEvent(e);
                if (!intercept) {
                    intercept = mGestureDetector.onTouchEvent(e);
                }
            } else {
                intercept = NotificationPanelView.this.onInterceptTouchEvent(e);
            }
            return intercept;
        }
    });
    mKeyguardBottomArea.setOnTouchListener(new OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent e) {
            int action = e.getAction();
            boolean isCancelOrUp = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
            if (isCancelOrUp) {
                mKeyguardBottomArea.setBackground(null);
            }
            boolean intercept = false;
            if (mShowingExternalKeyguard) {
                intercept = mAfforanceHelper.onTouchEvent(e);
                if (isCancelOrUp) {
                    mKeyguardBottomArea.expand(false);
                }
                if (!intercept) {
                    intercept = mGestureDetector.onTouchEvent(e);
                }
            } else {
                intercept = NotificationPanelView.this.onTouchEvent(e);
            }
            return intercept;
        }
    });
    mQsNavbarScrim = findViewById(R.id.qs_navbar_scrim);
    mAfforanceHelper = new KeyguardAffordanceHelper(this, getContext());
    mLastOrientation = getResources().getConfiguration().orientation;
    // recompute internal state when qspanel height changes
    mQsContainer.addOnLayoutChangeListener(new OnLayoutChangeListener() {

        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            final int height = bottom - top;
            final int oldHeight = oldBottom - oldTop;
            if (height != oldHeight) {
                onScrollChanged();
            }
        }
    });
}
#end_block

#method_before
@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    // Reset locked direction
    mLockedDirection = SwipeLockedDirection.UNKNOWN;
    mCanDismissKeyguard = true;
    if (mBlockTouches) {
        return false;
    }
    initDownStates(event);
    if (mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
        mIsExpansionFromHeadsUp = true;
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN, 1);
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN_PEEK, 1);
        return true;
    }
    if (mQsPanel.isOnSettingsPage() && isInQsArea(event.getX(), event.getY(), false) && mQsExpanded) {
        mIntercepting = false;
        // to be collapsed when grabbed below the qs settings page as well.
        return false;
    }
    if (!isFullyCollapsed() && onQsIntercept(event)) {
        return true;
    }
    if (isKeyguardInteractiveAndShowing()) {
        return super.onInterceptTouchEvent(event);
    }
    // We want both, we really do
    return mSwipeHelper.onInterceptTouchEvent(event) & super.onInterceptTouchEvent(event);
}
#method_after
@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    // Reset locked direction
    mLockedDirection = SwipeLockedDirection.UNKNOWN;
    mCanDismissKeyguard = true;
    if (mBlockTouches) {
        return false;
    }
    initDownStates(event);
    if (mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
        mIsExpansionFromHeadsUp = true;
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN, 1);
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN_PEEK, 1);
        return true;
    }
    if (mQsPanel.isOnSettingsPage() && isInQsArea(event.getX(), event.getY(), false) && mQsExpanded) {
        mIntercepting = false;
        // to be collapsed when grabbed below the qs settings page as well.
        return false;
    }
    if (!isFullyCollapsed() && onQsIntercept(event)) {
        return true;
    }
    if (isKeyguardInteractiveAndShowing() || mStatusBar.isKeyguardShowingMedia()) {
        return super.onInterceptTouchEvent(event);
    }
    // We want both, we really do
    return mSwipeHelper.onInterceptTouchEvent(event) & super.onInterceptTouchEvent(event);
}
#end_block

#method_before
@Override
public boolean onTouchEvent(MotionEvent event) {
    if (mBlockTouches) {
        return false;
    }
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
        mKeyguardBottomArea.setBackground(null);
    }
    if (mDoubleTapToSleepEnabled && mStatusBarState == StatusBarState.KEYGUARD && event.getY() < mStatusBarHeaderHeight) {
        mDoubleTapGesture.onTouchEvent(event);
    }
    initDownStates(event);
    if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp() && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
        mIsExpansionFromHeadsUp = true;
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN_PEEK, 1);
    }
    if ((!mIsExpanding || mHintAnimationRunning) && !mQsExpanded && (mStatusBar.getBarState() != StatusBarState.SHADE || mShowingExternalKeyguard)) {
        mAfforanceHelper.onTouchEvent(event);
    }
    if (mOnlyAffordanceInThisMotion) {
        return true;
    }
    mHeadsUpTouchHelper.onTouchEvent(event);
    if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
        return true;
    }
    if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN, 1);
        updateVerticalPanelPosition(event.getX());
    }
    if (isKeyguardInteractiveAndShowing()) {
        super.onTouchEvent(event);
        return true;
    }
    if ((!mIsExpanding || mHintAnimationRunning) && !mQsExpanded && mLockedDirection != SwipeLockedDirection.VERTICAL && mStatusBar.getBarState() != StatusBarState.SHADE) {
        mSwipeHelper.onTouchEvent(event);
        if (mSwipeHelper.isDragging()) {
            mLockedDirection = SwipeLockedDirection.HORIZONTAL;
        }
        if (mLockedDirection == SwipeLockedDirection.HORIZONTAL) {
            requestDisallowInterceptTouchEvent(true);
            return true;
        }
    }
    if (super.onTouchEvent(event)) {
        mLockedDirection = SwipeLockedDirection.VERTICAL;
    }
    return true;
}
#method_after
@Override
public boolean onTouchEvent(MotionEvent event) {
    if (mBlockTouches) {
        return false;
    }
    int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
        mKeyguardBottomArea.setBackground(null);
    }
    if (mDoubleTapToSleepEnabled && mStatusBarState == StatusBarState.KEYGUARD && event.getY() < mStatusBarHeaderHeight) {
        mDoubleTapGesture.onTouchEvent(event);
    }
    initDownStates(event);
    if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp() && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
        mIsExpansionFromHeadsUp = true;
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN_PEEK, 1);
    }
    if ((!mIsExpanding || mHintAnimationRunning) && !mQsExpanded && (mStatusBar.getBarState() != StatusBarState.SHADE || mShowingExternalKeyguard)) {
        mAfforanceHelper.onTouchEvent(event);
    }
    if (mOnlyAffordanceInThisMotion) {
        return true;
    }
    mHeadsUpTouchHelper.onTouchEvent(event);
    if (!mHeadsUpTouchHelper.isTrackingHeadsUp() && handleQsTouch(event)) {
        return true;
    }
    if (event.getActionMasked() == MotionEvent.ACTION_DOWN && isFullyCollapsed()) {
        MetricsLogger.count(mContext, COUNTER_PANEL_OPEN, 1);
        updateVerticalPanelPosition(event.getX());
    }
    if (isKeyguardInteractiveAndShowing() || mStatusBar.isKeyguardShowingMedia()) {
        super.onTouchEvent(event);
        return true;
    }
    if ((!mIsExpanding || mHintAnimationRunning) && !mQsExpanded && mLockedDirection != SwipeLockedDirection.VERTICAL && mStatusBar.getBarState() != StatusBarState.SHADE) {
        mSwipeHelper.onTouchEvent(event);
        if (mSwipeHelper.isDragging()) {
            mLockedDirection = SwipeLockedDirection.HORIZONTAL;
        }
        if (mLockedDirection == SwipeLockedDirection.HORIZONTAL) {
            requestDisallowInterceptTouchEvent(true);
            return true;
        }
    }
    if (super.onTouchEvent(event)) {
        mLockedDirection = SwipeLockedDirection.VERTICAL;
    }
    return true;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
public void show(boolean resetSecuritySelection) {
    ensureView();
    if (resetSecuritySelection) {
        // showPrimarySecurityScreen() updates the current security method. This is needed in
        // case we are already showing and the current security method changed.
        mKeyguardView.showPrimarySecurityScreen();
    }
    if (mRoot.getVisibility() == View.VISIBLE || mShowingSoon) {
        return;
    }
    mPhoneStatusBar.getScrimController().forceHideScrims(false);
    // Keyguard. If we need to authenticate, show the bouncer.
    if (!mKeyguardView.dismiss()) {
        mShowingSoon = true;
        // Split up the work over multiple frames.
        DejankUtils.postAfterTraversal(mShowRunnable);
    }
}
#method_after
public void show(boolean resetSecuritySelection) {
    ensureView();
    if (resetSecuritySelection) {
        // showPrimarySecurityScreen() updates the current security method. This is needed in
        // case we are already showing and the current security method changed.
        mKeyguardView.showPrimarySecurityScreen();
    }
    if (mRoot.getVisibility() == View.VISIBLE || mShowingSoon) {
        return;
    }
    mPhoneStatusBar.getScrimController().forceHideScrims(false);
    // will take care of setting it invisible.
    if (!mPhoneStatusBar.mNotificationPanel.isLaunchTransitionRunning()) {
        mPhoneStatusBar.mKeyguardBottomArea.setVisibility(View.GONE);
    }
    // Keyguard. If we need to authenticate, show the bouncer.
    if (!mKeyguardView.dismiss()) {
        mShowingSoon = true;
        // Split up the work over multiple frames.
        DejankUtils.postAfterTraversal(mShowRunnable);
    }
}
#end_block

#method_before
public void answerCall(String callId, int videoState, int callWaitingResponseType) {
    try {
        mAdapter.answerCallRevised(callId, videoState, callWaitingResponseType);
    } catch (RemoteException e) {
    }
}
#method_after
public void answerCall(String callId, int videoState, int callWaitingResponseType) {
    try {
        mAdapter.answerCallWithCallWaitingResponse(callId, videoState, callWaitingResponseType);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void handleHotwordInput(boolean listening) {
    final IBinder b = ServiceManager.getService(android.content.Context.AUDIO_SERVICE);
    final IAudioService ias = IAudioService.Stub.asInterface(b);
    try {
        // before AUDIO_SERVICE has started, IAudioService may not be available.
        if (ias != null) {
            ias.handleHotwordInput(listening);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to AudioService when handling hotword input.", e);
    }
}
#method_after
private void handleHotwordInput(boolean listening) {
    final IBinder b = ServiceManager.getService(android.content.Context.AUDIO_SERVICE);
    final IAudioService ias = IAudioService.Stub.asInterface(b);
    try {
        // before AUDIO_SERVICE has started, IAudioService may not be available.
        if (ias != null) {
            ias.handleHotwordInput(listening);
        } else {
            Log.e(TAG, "Error talking to AudioService when handling hotword input, " + "AudioService unavailable");
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to AudioService when handling hotword input.", e);
    }
}
#end_block

#method_before
private void handleSandman(boolean fromDreamService) {
    // runs on handler thread
    // Handle preconditions.
    final boolean startDreaming;
    final int wakefulness;
    synchronized (mLock) {
        mSandmanScheduled = false;
        wakefulness = mWakefulness;
        if (mSandmanSummoned && mDisplayReady) {
            startDreaming = canDreamLocked() || canDozeLocked();
            mSandmanSummoned = false;
        } else {
            startDreaming = false;
        }
        // to start.
        if (mDreamManager != null) {
            if (startDreaming) {
                if (!mHoldingDreamSuspendBlocker) {
                    mDreamSuspendBlocker.acquire();
                    mHoldingDreamSuspendBlocker = true;
                    Message msg = mHandler.obtainMessage(MSG_SANDMAN_TIMEOUT);
                    msg.setAsynchronous(true);
                    mHandler.sendMessageDelayed(msg, SANDMAN_RESPONSE_TIMEOUT);
                }
            } else if (fromDreamService) {
                mHandler.removeMessages(MSG_SANDMAN_TIMEOUT);
                if (mHoldingDreamSuspendBlocker) {
                    mDreamSuspendBlocker.release();
                    mHoldingDreamSuspendBlocker = false;
                }
            }
        }
    }
    // Start dreaming if needed.
    // We only control the dream on the handler thread, so we don't need to worry about
    // concurrent attempts to start or stop the dream.
    final boolean isDreaming;
    if (mDreamManager != null) {
        // Restart the dream whenever the sandman is summoned.
        if (startDreaming) {
            mDreamManager.stopDream(false);
            mDreamManager.startDream(wakefulness == WAKEFULNESS_DOZING);
        }
        isDreaming = mDreamManager.isDreaming();
    } else {
        isDreaming = false;
    }
    // Update dream state.
    synchronized (mLock) {
        // Remember the initial battery level when the dream started.
        if (startDreaming && isDreaming) {
            mBatteryLevelWhenDreamStarted = mBatteryLevel;
            if (wakefulness == WAKEFULNESS_DOZING) {
                Slog.i(TAG, "Dozing...");
            } else {
                Slog.i(TAG, "Dreaming...");
            }
        }
        // whether the dream should continue (or be restarted).
        if (mSandmanSummoned || mWakefulness != wakefulness) {
            // wait for next cycle
            return;
        }
        // Determine whether the dream should continue.
        if (wakefulness == WAKEFULNESS_DREAMING) {
            if (isDreaming && canDreamLocked()) {
                if (mDreamsBatteryLevelDrainCutoffConfig >= 0 && mBatteryLevel < mBatteryLevelWhenDreamStarted - mDreamsBatteryLevelDrainCutoffConfig && !isBeingKeptAwakeLocked()) {
                    // If the user activity timeout expired and the battery appears
                    // to be draining faster than it is charging then stop dreaming
                    // and go to sleep.
                    Slog.i(TAG, "Stopping dream because the battery appears to " + "be draining faster than it is charging.  " + "Battery level when dream started: " + mBatteryLevelWhenDreamStarted + "%.  " + "Battery level now: " + mBatteryLevel + "%.");
                } else {
                    // continue dreaming
                    return;
                }
            }
            // Dream has ended or will be stopped.  Update the power state.
            if (isItBedTimeYetLocked() && !mDreamsActivatedOnSleepByDefaultConfig) {
                goToSleepNoUpdateLocked(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, 0, Process.SYSTEM_UID);
                updatePowerStateLocked();
            } else {
                wakeUpNoUpdateLocked(SystemClock.uptimeMillis(), "android.server.power:DREAM", Process.SYSTEM_UID, mContext.getOpPackageName(), Process.SYSTEM_UID);
                updatePowerStateLocked();
            }
        } else if (wakefulness == WAKEFULNESS_DOZING) {
            if (isDreaming) {
                // continue dozing
                return;
            }
            // Doze has ended or will be stopped.  Update the power state.
            reallyGoToSleepNoUpdateLocked(SystemClock.uptimeMillis(), Process.SYSTEM_UID);
            updatePowerStateLocked();
        }
    }
    // Stop dream.
    if (isDreaming) {
        mDreamManager.stopDream(false);
    }
}
#method_after
private void handleSandman(boolean fromDreamService) {
    // runs on handler thread
    // Handle preconditions.
    final boolean startDreaming;
    final int wakefulness;
    synchronized (mLock) {
        mSandmanScheduled = false;
        wakefulness = mWakefulness;
        if (mSandmanSummoned && mDisplayReady) {
            startDreaming = canDreamLocked() || canDozeLocked();
            mSandmanSummoned = false;
        } else {
            startDreaming = false;
        }
        // to start.
        if (mDreamManager != null) {
            if (startDreaming) {
                if (!mHoldingDreamSuspendBlocker) {
                    mDreamSuspendBlocker.acquire();
                    mHoldingDreamSuspendBlocker = true;
                    Message msg = mHandler.obtainMessage(MSG_SANDMAN_TIMEOUT);
                    msg.setAsynchronous(true);
                    mHandler.sendMessageDelayed(msg, SANDMAN_RESPONSE_TIMEOUT);
                    mDirty |= DIRTY_SANDMAN_STATE;
                    updatePowerStateLocked();
                }
            } else if (fromDreamService) {
                mHandler.removeMessages(MSG_SANDMAN_TIMEOUT);
                if (mHoldingDreamSuspendBlocker) {
                    mDreamSuspendBlocker.release();
                    mHoldingDreamSuspendBlocker = false;
                }
            }
        }
    }
    // Start dreaming if needed.
    // We only control the dream on the handler thread, so we don't need to worry about
    // concurrent attempts to start or stop the dream.
    final boolean isDreaming;
    if (mDreamManager != null) {
        // Restart the dream whenever the sandman is summoned.
        if (startDreaming) {
            mDreamManager.stopDream(false);
            mDreamManager.startDream(wakefulness == WAKEFULNESS_DOZING);
        }
        isDreaming = mDreamManager.isDreaming();
    } else {
        isDreaming = false;
    }
    // Update dream state.
    synchronized (mLock) {
        // Remember the initial battery level when the dream started.
        if (startDreaming && isDreaming) {
            mBatteryLevelWhenDreamStarted = mBatteryLevel;
            if (wakefulness == WAKEFULNESS_DOZING) {
                Slog.i(TAG, "Dozing...");
            } else {
                Slog.i(TAG, "Dreaming...");
            }
        }
        // whether the dream should continue (or be restarted).
        if (mSandmanSummoned || mWakefulness != wakefulness) {
            // wait for next cycle
            return;
        }
        // Determine whether the dream should continue.
        if (wakefulness == WAKEFULNESS_DREAMING) {
            if (isDreaming && canDreamLocked()) {
                if (mDreamsBatteryLevelDrainCutoffConfig >= 0 && mBatteryLevel < mBatteryLevelWhenDreamStarted - mDreamsBatteryLevelDrainCutoffConfig && !isBeingKeptAwakeLocked()) {
                    // If the user activity timeout expired and the battery appears
                    // to be draining faster than it is charging then stop dreaming
                    // and go to sleep.
                    Slog.i(TAG, "Stopping dream because the battery appears to " + "be draining faster than it is charging.  " + "Battery level when dream started: " + mBatteryLevelWhenDreamStarted + "%.  " + "Battery level now: " + mBatteryLevel + "%.");
                } else {
                    // continue dreaming
                    return;
                }
            }
            // Dream has ended or will be stopped.  Update the power state.
            if (isItBedTimeYetLocked() && !mDreamsActivatedOnSleepByDefaultConfig) {
                goToSleepNoUpdateLocked(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, 0, Process.SYSTEM_UID);
                updatePowerStateLocked();
            } else {
                wakeUpNoUpdateLocked(SystemClock.uptimeMillis(), "android.server.power:DREAM", Process.SYSTEM_UID, mContext.getOpPackageName(), Process.SYSTEM_UID);
                updatePowerStateLocked();
            }
        } else if (wakefulness == WAKEFULNESS_DOZING) {
            if (isDreaming) {
                // continue dozing
                return;
            }
            // Doze has ended or will be stopped.  Update the power state.
            reallyGoToSleepNoUpdateLocked(SystemClock.uptimeMillis(), Process.SYSTEM_UID);
            updatePowerStateLocked();
        }
    }
    // Stop dream.
    if (isDreaming) {
        mDreamManager.stopDream(false);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_USER_ACTIVITY_TIMEOUT:
            handleUserActivityTimeout();
            break;
        case MSG_SANDMAN:
            handleSandman(msg.arg1 == 1);
            break;
        case MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT:
            handleScreenBrightnessBoostTimeout();
            break;
        case MSG_WAKE_UP:
            cleanupProximity();
            ((Runnable) msg.obj).run();
            break;
        case MSG_SANDMAN_TIMEOUT:
            Slog.e(TAG, "Sandman unresponsive, releasing suspend blocker");
            handleSandman(true);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_USER_ACTIVITY_TIMEOUT:
            handleUserActivityTimeout();
            break;
        case MSG_SANDMAN:
            boolean fromDreamService = msg.arg1 == 1;
            handleSandman(fromDreamService);
            break;
        case MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT:
            handleScreenBrightnessBoostTimeout();
            break;
        case MSG_WAKE_UP:
            cleanupProximity();
            ((Runnable) msg.obj).run();
            break;
        case MSG_SANDMAN_TIMEOUT:
            Slog.w(TAG, "Sandman unresponsive, releasing suspend blocker");
            handleSandman(true);
            break;
    }
}
#end_block

#method_before
// Checks if a package that was installed and currently isn't installed for the owner
public void testPrebundledSecondaryUserAccept() {
    final Settings settings = new Settings(getContext().getFilesDir());
    final String expectedPackageToBeInstalled = "org.cyanogenmod.secondaryuser.package";
    final PackageSetting packageSetting = generateFakePackageSetting(expectedPackageToBeInstalled);
    final int userOwner = UserHandle.USER_OWNER;
    final int userSecondary = 1000;
    // Return true that the package was installed for the owner at some point
    Mockito.when(settings.wasPrebundledPackageInstalledLPr(userOwner, expectedPackageToBeInstalled)).thenReturn(true);
    // Return false that the package was installed for the secondary user at some point
    Mockito.when(settings.wasPrebundledPackageInstalledLPr(userSecondary, expectedPackageToBeInstalled)).thenReturn(false);
    // Return false that the package is currently not installed for the owner
    Mockito.when(packageSetting.getInstalled(userOwner)).thenReturn(false);
    // Return false that the package is currently not installed for the secondary user
    Mockito.when(packageSetting.getInstalled(userSecondary)).thenReturn(false);
    assertFalse(settings.shouldPrebundledPackageBeInstalledForUser(packageSetting, userSecondary, expectedPackageToBeInstalled));
}
#method_after
// Checks if a package that was installed and currently isn't installed for the owner
public void testPrebundledSecondaryUserAccept() {
    Settings settings = new Settings(getContext().getFilesDir());
    String expectedPackageToBeInstalled = "org.cyanogenmod.secondaryuser.package";
    PackageSetting packageSetting = generateFakePackageSetting(expectedPackageToBeInstalled);
    int userOwner = UserHandle.USER_OWNER;
    int userSecondary = 1000;
    // Return true that the package was installed for the owner at some point
    settings.markPrebundledPackageInstalledLPr(userOwner, expectedPackageToBeInstalled);
    assertTrue(settings.wasPrebundledPackageInstalledLPr(userOwner, expectedPackageToBeInstalled));
    // Return false that the package was installed for the secondary user at some point
    // DON'T MARK PREBUNDLED PACKAGE INSTALLED
    // Return false that the package is currently not installed for the owner
    packageSetting.setInstalled(false, userOwner);
    assertFalse(packageSetting.getInstalled(userOwner));
    // Return false that the package is currently not installed for the secondary user
    packageSetting.setInstalled(false, userSecondary);
    assertFalse(packageSetting.getInstalled(userSecondary));
    assertFalse(settings.shouldPrebundledPackageBeInstalledForUserLPr(packageSetting, userSecondary, expectedPackageToBeInstalled));
}
#end_block

#method_before
// Checks if a package that was installed for a secondary user and currently isn't installed
public void testPrebundledSecondaryUserReinstallAccept() {
    final Settings settings = new Settings(getContext().getFilesDir());
    final String expectedPackageToBeInstalled = "org.cyanogenmod.secondaryuser.package";
    final PackageSetting packageSetting = generateFakePackageSetting(expectedPackageToBeInstalled);
    final int userSecondary = 1000;
    // Return true that the package was installed for the secondary user at some point
    Mockito.when(settings.wasPrebundledPackageInstalledLPr(userSecondary, expectedPackageToBeInstalled)).thenReturn(true);
    // Return false that the package is currently not installed for the secondary user
    Mockito.when(packageSetting.getInstalled(userSecondary)).thenReturn(false);
    assertFalse(settings.shouldPrebundledPackageBeInstalledForUser(packageSetting, userSecondary, expectedPackageToBeInstalled));
}
#method_after
// Checks if a package that was installed for a secondary user and currently isn't installed
public void testPrebundledSecondaryUserReinstallAccept() {
    Settings settings = new Settings(getContext().getFilesDir());
    String expectedPackageToBeInstalled = "org.cyanogenmod.secondaryuser.package";
    PackageSetting packageSetting = generateFakePackageSetting(expectedPackageToBeInstalled);
    int userSecondary = 1000;
    // Return true that the package was installed for the secondary user at some point
    settings.markPrebundledPackageInstalledLPr(userSecondary, expectedPackageToBeInstalled);
    assertTrue(settings.wasPrebundledPackageInstalledLPr(userSecondary, expectedPackageToBeInstalled));
    // Return false that the package is currently not installed for the secondary user
    packageSetting.setInstalled(false, userSecondary);
    assertFalse(packageSetting.getInstalled(userSecondary));
    assertFalse(settings.shouldPrebundledPackageBeInstalledForUserLPr(packageSetting, userSecondary, expectedPackageToBeInstalled));
}
#end_block

#method_before
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    parseFlags |= mDefParseFlags;
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
    if ((parseFlags & PackageParser.PARSE_IS_PREBUNDLED_DIR) != 0) {
        synchronized (mPackages) {
            PackageSetting existingSettings = mSettings.peekPackageLPr(pkg.packageName);
            if (!mSettings.shouldPrebundledPackageBeInstalledForUser(existingSettings, user.getIdentifier(), pkg.packageName)) {
                // currently installed for the owner, dont install it for a new user
                throw new PackageManagerException(INSTALL_FAILED_UNINSTALLED_PREBUNDLE, "skip reinstall for " + pkg.packageName);
            } else if (!mSettings.shouldPrebundledPackageBeInstalledForRegion(mContext.getResources(), pkg.packageName, mCustomResources)) {
                // skip installing it
                throw new PackageManagerException(INSTALL_FAILED_REGION_LOCKED_PREBUNDLE, "skip install for " + pkg.packageName);
            } else if (existingSettings != null && existingSettings.versionCode >= pkg.mVersionCode && !existingSettings.codePathString.contains(Environment.getPrebundledDirectory().getPath())) {
                // This app is installed in a location that is not the prebundled location
                // and has a higher (or same) version as the prebundled one.  Skip
                // installing the prebundled version.
                Slog.d(TAG, pkg.packageName + " already installed at " + existingSettings.codePathString);
                // return null so we still mark package as installed
                return null;
            }
        }
    }
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.peekPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.peekPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
    }
    boolean updatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg : " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                updatedPkgBetter = true;
            }
        }
    }
    if (updatedPkg != null) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        parseFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    // TODO: extend to support forward-locked splits
    String resourcePath = null;
    String baseResourcePath = null;
    if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for pkg : " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(resourcePath);
    pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName);
        }
    }
    return scannedPkg;
}
#method_after
private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
    if (DEBUG_INSTALL)
        Slog.d(TAG, "Parsing: " + scanFile);
    parseFlags |= mDefParseFlags;
    PackageParser pp = new PackageParser();
    pp.setSeparateProcesses(mSeparateProcesses);
    pp.setOnlyCoreApps(mOnlyCore);
    pp.setDisplayMetrics(mMetrics);
    if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
        parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
    }
    final PackageParser.Package pkg;
    try {
        pkg = pp.parsePackage(scanFile, parseFlags);
    } catch (PackageParserException e) {
        throw PackageManagerException.from(e);
    }
    if ((parseFlags & PackageParser.PARSE_IS_PREBUNDLED_DIR) != 0) {
        synchronized (mPackages) {
            PackageSetting existingSettings = mSettings.peekPackageLPr(pkg.packageName);
            if (!mSettings.shouldPrebundledPackageBeInstalledForUserLPr(existingSettings, user.getIdentifier(), pkg.packageName)) {
                // current installed for the user, so skip reinstalling it
                throw new PackageManagerException(INSTALL_FAILED_UNINSTALLED_PREBUNDLE, "skip reinstall for " + pkg.packageName);
            } else if (!mSettings.shouldPrebundledPackageBeInstalledForRegion(mContext.getResources(), pkg.packageName, mCustomResources)) {
                // skip installing it
                throw new PackageManagerException(INSTALL_FAILED_REGION_LOCKED_PREBUNDLE, "skip install for " + pkg.packageName);
            } else if (existingSettings != null && existingSettings.versionCode >= pkg.mVersionCode && !existingSettings.codePathString.contains(Environment.getPrebundledDirectory().getPath())) {
                // This app is installed in a location that is not the prebundled location
                // and has a higher (or same) version as the prebundled one.  Skip
                // installing the prebundled version.
                Slog.d(TAG, pkg.packageName + " already installed at " + existingSettings.codePathString);
                // return null so we still mark package as installed
                return null;
            }
        }
    }
    PackageSetting ps = null;
    PackageSetting updatedPkg;
    // reader
    synchronized (mPackages) {
        // Look to see if we already know about this package.
        String oldName = mSettings.mRenamedPackages.get(pkg.packageName);
        if (pkg.mOriginalPackages != null && pkg.mOriginalPackages.contains(oldName)) {
            // This package has been renamed to its original name.  Let's
            // use that.
            ps = mSettings.peekPackageLPr(oldName);
        }
        // If there was no original package, see one for the real package name.
        if (ps == null) {
            ps = mSettings.peekPackageLPr(pkg.packageName);
        }
        // Check to see if this package could be hiding/updating a system
        // package.  Must look for it either under the original or real
        // package name depending on our state.
        updatedPkg = mSettings.getDisabledSystemPkgLPr(ps != null ? ps.name : pkg.packageName);
        if (DEBUG_INSTALL && updatedPkg != null)
            Slog.d(TAG, "updatedPkg = " + updatedPkg);
    }
    boolean updatedPkgBetter = false;
    // First check if this is a system package that may involve an update
    if (updatedPkg != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM) != 0) {
        // it needs to drop FLAG_PRIVILEGED.
        if (locationIsPrivileged(scanFile)) {
            updatedPkg.pkgPrivateFlags |= ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        } else {
            updatedPkg.pkgPrivateFlags &= ~ApplicationInfo.PRIVATE_FLAG_PRIVILEGED;
        }
        if (ps != null && !ps.codePath.equals(scanFile)) {
            // what to do.
            if (DEBUG_INSTALL)
                Slog.d(TAG, "Path changing from " + ps.codePath);
            if (pkg.mVersionCode <= ps.versionCode) {
                // Ignore entry. Skip it.
                if (DEBUG_INSTALL)
                    Slog.i(TAG, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
                if (!updatedPkg.codePath.equals(scanFile)) {
                    Slog.w(PackageManagerService.TAG, "Code path for hidden system pkg : " + ps.name + " changing from " + updatedPkg.codePathString + " to " + scanFile);
                    updatedPkg.codePath = scanFile;
                    updatedPkg.codePathString = scanFile.toString();
                    updatedPkg.resourcePath = scanFile;
                    updatedPkg.resourcePathString = scanFile.toString();
                }
                updatedPkg.pkg = pkg;
                throw new PackageManagerException(INSTALL_FAILED_DUPLICATE_PACKAGE, "Package " + ps.name + " at " + scanFile + " ignored: updated version " + ps.versionCode + " better than this " + pkg.mVersionCode);
            } else {
                // writer
                synchronized (mPackages) {
                    // Just remove the loaded entries from package lists.
                    mPackages.remove(ps.name);
                }
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
                synchronized (mPackages) {
                    mSettings.enableSystemPackageLPw(ps.name);
                }
                updatedPkgBetter = true;
            }
        }
    }
    if (updatedPkg != null) {
        // An updated system app will not have the PARSE_IS_SYSTEM flag set
        // initially
        parseFlags |= PackageParser.PARSE_IS_SYSTEM;
        // flag set initially
        if ((updatedPkg.pkgPrivateFlags & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
            parseFlags |= PackageParser.PARSE_IS_PRIVILEGED;
        }
    }
    // Verify certificates against what was last scanned
    collectCertificatesLI(pp, ps, pkg, scanFile, parseFlags);
    /*
         * A new system app appeared, but we already had a non-system one of the
         * same name installed earlier.
         */
    boolean shouldHideSystemApp = false;
    if (updatedPkg == null && ps != null && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
        /*
             * Check to make sure the signatures match first. If they don't,
             * wipe the installed application and its data.
             */
        if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures) != PackageManager.SIGNATURE_MATCH) {
            logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but" + " signatures don't match existing userdata copy; removing");
            deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
            ps = null;
        } else {
            /*
                 * If the newly-added system app is an older version than the
                 * already installed version, hide it. It will be scanned later
                 * and re-added like an update.
                 */
            if (pkg.mVersionCode <= ps.versionCode) {
                shouldHideSystemApp = true;
                logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile + " but new version " + pkg.mVersionCode + " better than installed " + ps.versionCode + "; hiding system");
            } else {
                /*
                     * The newly found system app is a newer version that the
                     * one previously installed. Simply remove the
                     * already-installed application and replace it with our own
                     * while keeping the application data.
                     */
                logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile + " reverting from " + ps.codePathString + ": new version " + pkg.mVersionCode + " better than installed " + ps.versionCode);
                InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps), ps.codePathString, ps.resourcePathString, getAppDexInstructionSets(ps));
                synchronized (mInstallLock) {
                    args.cleanUpResourcesLI();
                }
            }
        }
    }
    // TODO grab this value from PackageSettings
    if ((parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) == 0) {
        if (ps != null && !ps.codePath.equals(ps.resourcePath)) {
            parseFlags |= PackageParser.PARSE_FORWARD_LOCK;
        }
    }
    // TODO: extend to support forward-locked splits
    String resourcePath = null;
    String baseResourcePath = null;
    if ((parseFlags & PackageParser.PARSE_FORWARD_LOCK) != 0 && !updatedPkgBetter) {
        if (ps != null && ps.resourcePathString != null) {
            resourcePath = ps.resourcePathString;
            baseResourcePath = ps.resourcePathString;
        } else {
            // Should not happen at all. Just log an error.
            Slog.e(TAG, "Resource path not set for pkg : " + pkg.packageName);
        }
    } else {
        resourcePath = pkg.codePath;
        baseResourcePath = pkg.baseCodePath;
    }
    // Set application objects path explicitly.
    pkg.applicationInfo.volumeUuid = pkg.volumeUuid;
    pkg.applicationInfo.setCodePath(pkg.codePath);
    pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
    pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
    pkg.applicationInfo.setResourcePath(resourcePath);
    pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
    pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
    // Note that we invoke the following method only if we are about to unpack an application
    PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);
    /*
         * If the system app should be overridden by a previously installed
         * data, hide the system app now and let the /data/app scan pick it up
         * again.
         */
    if (shouldHideSystemApp) {
        synchronized (mPackages) {
            mSettings.disableSystemPackageLPw(pkg.packageName);
        }
    }
    return scannedPkg;
}
#end_block

#method_before
@Override
public boolean isComponentProtected(String callingPackage, ComponentName componentName, int userId) {
    if (DEBUG_PROTECTED)
        Log.d(TAG, "Checking if component is protected " + componentName.flattenToShortString() + " from calling package " + callingPackage);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
    // Allow managers full access
    List<String> protectedComponentManagers = CMSettings.Secure.getDelimitedStringAsList(mContext.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENT_MANAGERS, "|");
    if (protectedComponentManagers.contains(callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is a protected manager, allow");
        return false;
    }
    String packageName = componentName.getPackageName();
    String className = componentName.getClassName();
    // If this component is launched from the same package, allow it.
    if (TextUtils.equals(packageName, callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is same as target, allow");
        return false;
    }
    if (TextUtils.equals(PROTECTED_APPS_TARGET_VALIDATION_COMPONENT, componentName.flattenToString())) {
        return false;
    }
    PackageSetting pkgSetting;
    ArraySet<String> components;
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null) {
            if (className == null) {
                throw new IllegalArgumentException("Unknown package: " + packageName);
            }
            throw new IllegalArgumentException("Unknown component: " + packageName + "/" + className);
        }
        // Get all the protected components
        components = pkgSetting.getProtectedComponents(userId);
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Got " + components.size() + " protected components");
        return components.size() > 0;
    }
}
#method_after
@Override
public boolean isComponentProtected(String callingPackage, ComponentName componentName, int userId) {
    if (DEBUG_PROTECTED)
        Log.d(TAG, "Checking if component is protected " + componentName.flattenToShortString() + " from calling package " + callingPackage);
    enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "set protected");
    // Allow managers full access
    List<String> protectedComponentManagers = CMSettings.Secure.getDelimitedStringAsList(mContext.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENT_MANAGERS, "|");
    if (protectedComponentManagers.contains(callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is a protected manager, allow");
        return false;
    }
    String packageName = componentName.getPackageName();
    String className = componentName.getClassName();
    // If this component is launched from the same package, allow it.
    if (TextUtils.equals(packageName, callingPackage)) {
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Calling package is same as target, allow");
        return false;
    }
    if (TextUtils.equals(PROTECTED_APPS_TARGET_VALIDATION_COMPONENT, componentName.flattenToString())) {
        return false;
    }
    PackageSetting pkgSetting;
    ArraySet<String> components;
    synchronized (mPackages) {
        pkgSetting = mSettings.mPackages.get(packageName);
        if (pkgSetting == null || className == null) {
            return false;
        }
        // Get all the protected components
        components = pkgSetting.getProtectedComponents(userId);
        if (DEBUG_PROTECTED)
            Log.d(TAG, "Got " + components.size() + " protected components");
        return components.size() > 0;
    }
}
#end_block

#method_before
private void updateCurrentAccessory() {
    // We are entering accessory mode if we have received a request from the host
    // and the request has not timed out yet.
    boolean enteringAccessoryMode = mAccessoryModeRequestTime > 0 && SystemClock.elapsedRealtime() < mAccessoryModeRequestTime + ACCESSORY_REQUEST_TIMEOUT;
    if (mConfigured && enteringAccessoryMode) {
        // successfully entered accessory mode
        if (mCurrentAccessory != null) {
            Slog.w(TAG, "USB accessory re-attached. detach was not announced!");
            if (mBootCompleted) {
                getCurrentSettings().accessoryDetached(mCurrentAccessory);
            }
            mCurrentAccessory = null;
        }
        if (mAccessoryStrings != null) {
            mCurrentAccessory = new UsbAccessory(mAccessoryStrings);
            Slog.d(TAG, "entering USB accessory mode: " + mCurrentAccessory);
            // defer accessoryAttached if system is not ready
            if (mBootCompleted) {
                getCurrentSettings().accessoryAttached(mCurrentAccessory);
            }
        // else handle in boot completed
        } else {
            Slog.e(TAG, "nativeGetAccessoryStrings failed");
        }
    } else if (!enteringAccessoryMode) {
        // make sure accessory mode is off
        // and restore default functions
        Slog.d(TAG, "exited USB accessory mode");
        setEnabledFunctions(null, false);
        if (mCurrentAccessory != null) {
            if (mBootCompleted) {
                getCurrentSettings().accessoryDetached(mCurrentAccessory);
            }
            mCurrentAccessory = null;
            mAccessoryStrings = null;
        }
    }
}
#method_after
private void updateCurrentAccessory() {
    // We are entering accessory mode if we have received a request from the host
    // and the request has not timed out yet.
    boolean enteringAccessoryMode = mAccessoryModeRequestTime > 0 && SystemClock.elapsedRealtime() < mAccessoryModeRequestTime + ACCESSORY_REQUEST_TIMEOUT;
    if (mConfigured && enteringAccessoryMode) {
        // successfully entered accessory mode
        if (mCurrentAccessory != null) {
            Slog.w(TAG, "USB accessory re-attached, detach was not announced!");
            if (mBootCompleted) {
                getCurrentSettings().accessoryDetached(mCurrentAccessory);
            }
            mCurrentAccessory = null;
        }
        if (mAccessoryStrings != null) {
            mCurrentAccessory = new UsbAccessory(mAccessoryStrings);
            Slog.d(TAG, "entering USB accessory mode: " + mCurrentAccessory);
            // defer accessoryAttached if system is not ready
            if (mBootCompleted) {
                getCurrentSettings().accessoryAttached(mCurrentAccessory);
            }
        // else handle in boot completed
        } else {
            Slog.e(TAG, "nativeGetAccessoryStrings failed");
        }
    } else if (!enteringAccessoryMode) {
        // make sure accessory mode is off
        // and restore default functions
        Slog.d(TAG, "exited USB accessory mode");
        setEnabledFunctions(null, false);
        if (mCurrentAccessory != null) {
            if (mBootCompleted) {
                getCurrentSettings().accessoryDetached(mCurrentAccessory);
            }
            mCurrentAccessory = null;
            mAccessoryStrings = null;
        }
    }
}
#end_block

#method_before
public void startObserving() {
    mContext.getContentResolver().registerContentObserver(Settings.Secure.getUriFor(CMSettings.Secure.PERFORMANCE_PROFILE), false, this);
}
#method_after
public void startObserving() {
    mContext.getContentResolver().registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.PERFORMANCE_PROFILE), false, this);
}
#end_block

#method_before
@Override
public View createDetailView(Context context, View convertView, ViewGroup parent) {
    // Filter out unsupported profiles
    Resources res = mContext.getResources();
    final int[] perfProfileValues = res.getIntArray(org.cyanogenmod.platform.internal.R.array.perf_profile_values);
    final String[] entries = res.getStringArray(org.cyanogenmod.platform.internal.R.array.perf_profile_entries);
    final String[] descriptionEntries = res.getStringArray(R.array.perf_profile_description);
    final String[] announcementEntries = res.getStringArray(R.array.perf_profile_announcement);
    int i = 0;
    for (int j = 0; j < perfProfileValues.length; j++) {
        if (perfProfileValues[j] < mNumPerfProfiles) {
            mPerfProfileValues[i] = perfProfileValues[i];
            mEntries[i] = entries[i];
            mDescriptionEntries[i] = descriptionEntries[i];
            mAnnouncementEntries[i] = announcementEntries[i];
            i++;
        }
    }
    mItems = QSDetailItemsList.convertOrInflate(context, convertView, parent);
    ArrayAdapter adapter = new ArrayAdapter<String>(mContext, android.R.layout.simple_list_item_single_choice, mEntries);
    ListView listView = mItems.getListView();
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    listView.setAdapter(adapter);
    listView.setOnItemClickListener(this);
    listView.setDivider(null);
    listView.setItemChecked(getCurrentProfileIndex(), true);
    return mItems;
}
#method_after
@Override
public View createDetailView(Context context, View convertView, ViewGroup parent) {
    mItems = QSDetailItemsList.convertOrInflate(context, convertView, parent);
    ArrayAdapter adapter = new ArrayAdapter<String>(mContext, android.R.layout.simple_list_item_single_choice, mEntries);
    ListView listView = mItems.getListView();
    listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    listView.setAdapter(adapter);
    listView.setOnItemClickListener(this);
    listView.setDivider(null);
    listView.setItemChecked(getCurrentProfileIndex(), true);
    return mItems;
}
#end_block

#method_before
public void run() {
    BroadcastReceiver br = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            // We don't allow apps to cancel this, so ignore the result.
            actionDone();
        }
    };
    /*
         * Write a system property in case the system_server reboots before we
         * get to the actual hardware restart. If that happens, we'll retry at
         * the beginning of the SystemServer startup.
         */
    {
        String reason = (mReboot ? "1" : "0") + (mRebootReason != null ? mRebootReason : "");
        SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
    }
    /*
         * If we are rebooting into safe mode, write a system property
         * indicating so.
         */
    if (mRebootSafeMode) {
        SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, "1");
    }
    Log.i(TAG, "Sending shutdown broadcast...");
    // First send the high-level shut down broadcast.
    mActionDone = false;
    Intent intent = new Intent(Intent.ACTION_SHUTDOWN);
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, null, br, mHandler, 0, null, null);
    final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (!mActionDone) {
            long delay = endTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown broadcast timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_BROADCAST_TIME - delay) * 1.0 * BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down activity manager...");
    final IActivityManager am = ActivityManagerNative.asInterface(ServiceManager.checkService("activity"));
    if (am != null) {
        try {
            am.shutdown(MAX_BROADCAST_TIME);
        } catch (RemoteException e) {
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down package manager...");
    final PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm != null) {
        pm.shutdown();
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);
    }
    String shutDownFile = null;
    // music and animation properly
    if (checkAnimationFileExist()) {
        lockDevice();
        showShutdownAnimation();
        if (!isSilentMode() && (shutDownFile = getShutdownMusicFilePath()) != null) {
            isShutdownMusicPlaying = true;
            shutdownMusicHandler.obtainMessage(0, shutDownFile).sendToTarget();
        }
    }
    Log.i(TAG, "wait for shutdown music");
    final long endTimeForMusic = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (isShutdownMusicPlaying) {
            long delay = endTimeForMusic - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "play shutdown music timeout!");
                break;
            }
            try {
                mActionDoneSync.wait(delay);
            } catch (InterruptedException e) {
            }
        }
        if (!isShutdownMusicPlaying) {
            Log.i(TAG, "play shutdown music complete.");
        }
    }
    // Shutdown radios.
    shutdownRadios(MAX_RADIO_WAIT_TIME);
    if (mRebootUpdate) {
        sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);
    }
    // Shutdown MountService to ensure media is in a safe state
    IMountShutdownObserver observer = new IMountShutdownObserver.Stub() {

        public void onShutDownComplete(int statusCode) throws RemoteException {
            Log.w(TAG, "Result code " + statusCode + " from MountService.shutdown");
            actionDone();
        }
    };
    final String cryptoStatus = SystemProperties.get("ro.crypto.state", "unsupported");
    final boolean isEncrypted = "encrypted".equalsIgnoreCase(cryptoStatus);
    if (isEncrypted) {
        if (mRebootUpdate) {
            sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);
            // If it's to reboot to install update, invoke uncrypt via init service.
            uncrypt();
        }
    }
    Log.i(TAG, "Shutting down MountService");
    // Set initial variables and time out time.
    mActionDone = false;
    final long endShutTime = SystemClock.elapsedRealtime() + MAX_SHUTDOWN_WAIT_TIME;
    synchronized (mActionDoneSync) {
        try {
            final IMountService mount = IMountService.Stub.asInterface(ServiceManager.checkService("mount"));
            if (mount != null) {
                mount.shutdown(observer);
            } else {
                Log.w(TAG, "MountService unavailable for shutdown");
            }
        } catch (Exception e) {
            Log.e(TAG, "Exception during MountService shutdown", e);
        }
        while (!mActionDone) {
            long delay = endShutTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown wait timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_SHUTDOWN_WAIT_TIME - delay) * 1.0 * (MOUNT_SERVICE_STOP_PERCENT - RADIO_STOP_PERCENT) / MAX_SHUTDOWN_WAIT_TIME);
                status += RADIO_STOP_PERCENT;
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    rebootOrShutdown(mContext, mReboot, mRebootReason);
}
#method_after
public void run() {
    BroadcastReceiver br = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            // We don't allow apps to cancel this, so ignore the result.
            actionDone();
        }
    };
    /*
         * Write a system property in case the system_server reboots before we
         * get to the actual hardware restart. If that happens, we'll retry at
         * the beginning of the SystemServer startup.
         */
    {
        String reason = (mReboot ? "1" : "0") + (mRebootReason != null ? mRebootReason : "");
        SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
    }
    /*
         * If we are rebooting into safe mode, write a system property
         * indicating so.
         */
    if (mRebootSafeMode) {
        SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, "1");
    }
    Log.i(TAG, "Sending shutdown broadcast...");
    // First send the high-level shut down broadcast.
    mActionDone = false;
    Intent intent = new Intent(Intent.ACTION_SHUTDOWN);
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, null, br, mHandler, 0, null, null);
    final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (!mActionDone) {
            long delay = endTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown broadcast timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_BROADCAST_TIME - delay) * 1.0 * BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down activity manager...");
    final IActivityManager am = ActivityManagerNative.asInterface(ServiceManager.checkService("activity"));
    if (am != null) {
        try {
            am.shutdown(MAX_BROADCAST_TIME);
        } catch (RemoteException e) {
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down package manager...");
    final PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm != null) {
        pm.shutdown();
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);
    }
    String shutDownFile = null;
    // music and animation properly
    if (checkAnimationFileExist()) {
        lockDevice();
        showShutdownAnimation();
        if (!isSilentMode() && (shutDownFile = getShutdownMusicFilePath()) != null) {
            isShutdownMusicPlaying = true;
            shutdownMusicHandler.obtainMessage(0, shutDownFile).sendToTarget();
        }
    }
    Log.i(TAG, "wait for shutdown music");
    final long endTimeForMusic = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (isShutdownMusicPlaying) {
            long delay = endTimeForMusic - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "play shutdown music timeout!");
                break;
            }
            try {
                mActionDoneSync.wait(delay);
            } catch (InterruptedException e) {
            }
        }
        if (!isShutdownMusicPlaying) {
            Log.i(TAG, "play shutdown music complete.");
        }
    }
    // Shutdown radios.
    shutdownRadios(MAX_RADIO_WAIT_TIME);
    if (mRebootUpdate) {
        sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);
    }
    // Shutdown MountService to ensure media is in a safe state
    IMountShutdownObserver observer = new IMountShutdownObserver.Stub() {

        public void onShutDownComplete(int statusCode) throws RemoteException {
            Log.w(TAG, "Result code " + statusCode + " from MountService.shutdown");
            actionDone();
        }
    };
    final String cryptoStatus = SystemProperties.get("ro.crypto.state", "unsupported");
    final boolean isEncrypted = "encrypted".equalsIgnoreCase(cryptoStatus);
    if (mRebootUpdate && isEncrypted) {
        sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);
        // If it's to reboot to install update, invoke uncrypt via init service.
        uncrypt();
    }
    Log.i(TAG, "Shutting down MountService");
    // Set initial variables and time out time.
    mActionDone = false;
    final long endShutTime = SystemClock.elapsedRealtime() + MAX_SHUTDOWN_WAIT_TIME;
    synchronized (mActionDoneSync) {
        try {
            final IMountService mount = IMountService.Stub.asInterface(ServiceManager.checkService("mount"));
            if (mount != null) {
                mount.shutdown(observer);
            } else {
                Log.w(TAG, "MountService unavailable for shutdown");
            }
        } catch (Exception e) {
            Log.e(TAG, "Exception during MountService shutdown", e);
        }
        while (!mActionDone) {
            long delay = endShutTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown wait timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_SHUTDOWN_WAIT_TIME - delay) * 1.0 * (MOUNT_SERVICE_STOP_PERCENT - RADIO_STOP_PERCENT) / MAX_SHUTDOWN_WAIT_TIME);
                status += RADIO_STOP_PERCENT;
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    rebootOrShutdown(mContext, mReboot, mRebootReason);
}
#end_block

#method_before
private int noteOperationUnchecked(int code, int uid, String packageName, int proxyUid, String proxyPackageName) {
    final PermissionDialogReq req;
    synchronized (this) {
        Ops ops = getOpsLocked(uid, packageName, true);
        if (ops == null) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: no op for code " + code + " uid " + uid + " package " + packageName);
            return AppOpsManager.MODE_ERRORED;
        }
        Op op = getOpLocked(ops, code, true);
        if (isOpRestricted(uid, code, packageName)) {
            op.ignoredCount++;
            return AppOpsManager.MODE_IGNORED;
        }
        if (op.duration == -1) {
            Slog.w(TAG, "Noting op not finished: uid " + uid + " pkg " + packageName + " code " + code + " time=" + op.time + " duration=" + op.duration);
        }
        op.duration = 0;
        final int switchCode = AppOpsManager.opToSwitch(code);
        UidState uidState = ops.uidState;
        if (uidState.opModes != null) {
            final int uidMode = uidState.opModes.get(switchCode);
            if (uidMode != AppOpsManager.MODE_ALLOWED) {
                if (DEBUG)
                    Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
                op.rejectTime = System.currentTimeMillis();
                return uidMode;
            }
        }
        final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
        if (switchOp.mode != AppOpsManager.MODE_ALLOWED && switchOp.mode != AppOpsManager.MODE_ASK) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
            op.rejectTime = System.currentTimeMillis();
            op.ignoredCount++;
            return switchOp.mode;
        } else if (switchOp.mode == AppOpsManager.MODE_ALLOWED) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: allowing code " + code + " uid " + uid + " package " + packageName);
            op.time = System.currentTimeMillis();
            op.rejectTime = 0;
            op.proxyUid = proxyUid;
            op.proxyPackageName = proxyPackageName;
            op.allowedCount++;
            broadcastOpIfNeeded(code);
            return AppOpsManager.MODE_ALLOWED;
        } else {
            if (Looper.myLooper() == mLooper) {
                Log.e(TAG, "noteOperation: This method will deadlock if called from the main thread. (Code: " + code + " uid: " + uid + " package: " + packageName + ")");
                return switchOp.mode;
            }
            if (DEBUG) {
                Log.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount + " requests and " + op.startOpCount + " start requests with " + op.ignoredCount + " ignored at " + op.time + " with a duration of " + op.duration + " while being delayed " + op.delayedCount + " times");
                Log.d(TAG, "Total pkops for " + op.packageName + " " + ops.uidState.pkgOps.size());
            }
            // limiting.
            if (ops.uidState.pkgOps.size() < AppOpsPolicy.RATE_LIMIT_OPS_TOTAL_PKG_COUNT && op.noteOpCount < AppOpsPolicy.RATE_LIMIT_OP_COUNT || op.delayedCount > AppOpsPolicy.RATE_LIMIT_OP_DELAY_CEILING) {
                // Reset delayed count, most ops will never need this
                if (op.delayedCount > 0) {
                    if (DEBUG)
                        Log.d(TAG, "Resetting delayed count for " + op.packageName);
                    op.delayedCount = 0;
                }
                op.noteOpCount++;
                req = askOperationLocked(code, uid, packageName, switchOp);
            } else {
                op.delayedCount++;
                op.ignoredCount++;
                return AppOpsManager.MODE_IGNORED;
            }
        }
    }
    int result = req.get();
    broadcastOpIfNeeded(code);
    return result;
}
#method_after
private int noteOperationUnchecked(int code, int uid, String packageName, int proxyUid, String proxyPackageName) {
    final PermissionDialogReq req;
    synchronized (this) {
        Ops ops = getOpsLocked(uid, packageName, true);
        if (ops == null) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: no op for code " + code + " uid " + uid + " package " + packageName);
            return AppOpsManager.MODE_ERRORED;
        }
        Op op = getOpLocked(ops, code, true);
        if (isOpRestricted(uid, code, packageName)) {
            op.ignoredCount++;
            return AppOpsManager.MODE_IGNORED;
        }
        if (op.duration == -1) {
            Slog.w(TAG, "Noting op not finished: uid " + uid + " pkg " + packageName + " code " + code + " time=" + op.time + " duration=" + op.duration);
        }
        op.duration = 0;
        final int switchCode = AppOpsManager.opToSwitch(code);
        UidState uidState = ops.uidState;
        if (uidState.opModes != null) {
            final int uidMode = uidState.opModes.get(switchCode);
            if (uidMode != AppOpsManager.MODE_ALLOWED) {
                if (DEBUG)
                    Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
                op.rejectTime = System.currentTimeMillis();
                return uidMode;
            }
        }
        final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
        if (switchOp.mode != AppOpsManager.MODE_ALLOWED && switchOp.mode != AppOpsManager.MODE_ASK) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
            op.rejectTime = System.currentTimeMillis();
            op.ignoredCount++;
            return switchOp.mode;
        } else if (switchOp.mode == AppOpsManager.MODE_ALLOWED) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: allowing code " + code + " uid " + uid + " package " + packageName);
            op.time = System.currentTimeMillis();
            op.rejectTime = 0;
            op.proxyUid = proxyUid;
            op.proxyPackageName = proxyPackageName;
            op.allowedCount++;
            broadcastOpIfNeeded(code);
            return AppOpsManager.MODE_ALLOWED;
        } else {
            if (Looper.myLooper() == mLooper) {
                Log.e(TAG, "noteOperation: This method will deadlock if called from the main thread. (Code: " + code + " uid: " + uid + " package: " + packageName + ")");
                return switchOp.mode;
            }
            if (DEBUG) {
                Log.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount + " requests and " + op.startOpCount + " start requests with " + op.ignoredCount + " ignored at " + op.time + " with a duration of " + op.duration + " while being delayed " + op.delayedCount + " times");
                Log.d(TAG, "Total pkops for " + ops.packageName + " " + ops.uidState.pkgOps.size());
            }
            // limiting.
            if (ops.uidState.pkgOps.size() < AppOpsPolicy.RATE_LIMIT_OPS_TOTAL_PKG_COUNT && op.noteOpCount < AppOpsPolicy.RATE_LIMIT_OP_COUNT || op.delayedCount > AppOpsPolicy.RATE_LIMIT_OP_DELAY_CEILING) {
                // Reset delayed count, most ops will never need this
                if (op.delayedCount > 0) {
                    if (DEBUG)
                        Log.d(TAG, "Resetting delayed count for " + op.packageName);
                    op.delayedCount = 0;
                }
                op.noteOpCount++;
                req = askOperationLocked(code, uid, packageName, switchOp);
            } else {
                op.delayedCount++;
                op.ignoredCount++;
                return AppOpsManager.MODE_IGNORED;
            }
        }
    }
    int result = req.get();
    broadcastOpIfNeeded(code);
    return result;
}
#end_block

#method_before
private int noteOperationUnchecked(int code, int uid, String packageName, int proxyUid, String proxyPackageName) {
    final PermissionDialogReq req;
    synchronized (this) {
        Ops ops = getOpsLocked(uid, packageName, true);
        if (ops == null) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: no op for code " + code + " uid " + uid + " package " + packageName);
            return AppOpsManager.MODE_ERRORED;
        }
        Op op = getOpLocked(ops, code, true);
        if (isOpRestricted(uid, code, packageName)) {
            op.ignoredCount++;
            return AppOpsManager.MODE_IGNORED;
        }
        if (op.duration == -1) {
            Slog.w(TAG, "Noting op not finished: uid " + uid + " pkg " + packageName + " code " + code + " time=" + op.time + " duration=" + op.duration);
        }
        op.duration = 0;
        final int switchCode = AppOpsManager.opToSwitch(code);
        UidState uidState = ops.uidState;
        if (uidState.opModes != null) {
            final int uidMode = uidState.opModes.get(switchCode);
            if (uidMode != AppOpsManager.MODE_ALLOWED) {
                if (DEBUG)
                    Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
                op.rejectTime = System.currentTimeMillis();
                return uidMode;
            }
        }
        final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
        if (switchOp.mode != AppOpsManager.MODE_ALLOWED && switchOp.mode != AppOpsManager.MODE_ASK) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
            op.rejectTime = System.currentTimeMillis();
            op.ignoredCount++;
            return switchOp.mode;
        } else if (switchOp.mode == AppOpsManager.MODE_ALLOWED) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: allowing code " + code + " uid " + uid + " package " + packageName);
            op.time = System.currentTimeMillis();
            op.rejectTime = 0;
            op.proxyUid = proxyUid;
            op.proxyPackageName = proxyPackageName;
            op.allowedCount++;
            broadcastOpIfNeeded(code);
            return AppOpsManager.MODE_ALLOWED;
        } else {
            if (Looper.myLooper() == mLooper) {
                Log.e(TAG, "noteOperation: This method will deadlock if called from the main thread. (Code: " + code + " uid: " + uid + " package: " + packageName + ")");
                return switchOp.mode;
            }
            if (DEBUG) {
                Log.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount + " requests and " + op.startOpCount + " start requests with " + op.ignoredCount + " ignored at " + op.time + " with a duration of " + op.duration + " while being delayed " + op.delayedCount + " times");
                Log.d(TAG, "Total pkops for " + ops.packageName + " " + ops.uidState.pkgOps.size());
            }
            // limiting.
            if (mPowerManager.isInteractive() && (ops.uidState.pkgOps.size() < AppOpsPolicy.RATE_LIMIT_OPS_TOTAL_PKG_COUNT && op.noteOpCount < AppOpsPolicy.RATE_LIMIT_OP_COUNT || op.delayedCount > AppOpsPolicy.RATE_LIMIT_OP_DELAY_CEILING)) {
                // Reset delayed count, most ops will never need this
                if (op.delayedCount > 0) {
                    if (DEBUG)
                        Log.d(TAG, "Resetting delayed count for " + op.packageName);
                    op.delayedCount = 0;
                }
                op.noteOpCount++;
                req = askOperationLocked(code, uid, packageName, switchOp);
            } else {
                op.delayedCount++;
                op.ignoredCount++;
                return AppOpsManager.MODE_IGNORED;
            }
        }
    }
    int result = req.get();
    broadcastOpIfNeeded(code);
    return result;
}
#method_after
private int noteOperationUnchecked(int code, int uid, String packageName, int proxyUid, String proxyPackageName) {
    final PermissionDialogReq req;
    synchronized (this) {
        Ops ops = getOpsLocked(uid, packageName, true);
        if (ops == null) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: no op for code " + code + " uid " + uid + " package " + packageName);
            return AppOpsManager.MODE_ERRORED;
        }
        Op op = getOpLocked(ops, code, true);
        if (isOpRestricted(uid, code, packageName)) {
            op.ignoredCount++;
            return AppOpsManager.MODE_IGNORED;
        }
        if (op.duration == -1) {
            Slog.w(TAG, "Noting op not finished: uid " + uid + " pkg " + packageName + " code " + code + " time=" + op.time + " duration=" + op.duration);
        }
        op.duration = 0;
        final int switchCode = AppOpsManager.opToSwitch(code);
        UidState uidState = ops.uidState;
        if (uidState.opModes != null) {
            final int uidMode = uidState.opModes.get(switchCode);
            if (uidMode != AppOpsManager.MODE_ALLOWED) {
                if (DEBUG)
                    Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
                op.rejectTime = System.currentTimeMillis();
                return uidMode;
            }
        }
        final Op switchOp = switchCode != code ? getOpLocked(ops, switchCode, true) : op;
        if (switchOp.mode != AppOpsManager.MODE_ALLOWED && switchOp.mode != AppOpsManager.MODE_ASK) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: reject #" + op.mode + " for code " + switchCode + " (" + code + ") uid " + uid + " package " + packageName);
            op.rejectTime = System.currentTimeMillis();
            op.ignoredCount++;
            return switchOp.mode;
        } else if (switchOp.mode == AppOpsManager.MODE_ALLOWED) {
            if (DEBUG)
                Log.d(TAG, "noteOperation: allowing code " + code + " uid " + uid + " package " + packageName);
            op.time = System.currentTimeMillis();
            op.rejectTime = 0;
            op.proxyUid = proxyUid;
            op.proxyPackageName = proxyPackageName;
            op.allowedCount++;
            broadcastOpIfNeeded(code);
            return AppOpsManager.MODE_ALLOWED;
        } else {
            if (Looper.myLooper() == mLooper) {
                Log.e(TAG, "noteOperation: This method will deadlock if called from the main thread. (Code: " + code + " uid: " + uid + " package: " + packageName + ")");
                return switchOp.mode;
            }
            if (DEBUG) {
                Log.d(TAG, "Package " + op.packageName + " has " + op.noteOpCount + " requests and " + op.startOpCount + " start requests with " + op.ignoredCount + " ignored at " + op.time + " with a duration of " + op.duration + " while being delayed " + op.delayedCount + " times");
                Log.d(TAG, "Total pkops for " + ops.packageName + " " + ops.uidState.pkgOps.size());
            }
            // First drop all request events if the device is not interactive, next
            // check what the global pkg ops count for the package,
            // then check op scoped count. High frequency request ops will be delayed until
            // their delay count ceiling is met. This is to mitigate the overloading the
            // main activity manager service handler and having watchdog kill our service.
            // Google play services likes to share its uid with numerous packages to avoid
            // having to grant permissions from the users perspective and thus is the worst
            // example of overloading this queue -- so, to not encourage bad behavior,
            // we move them to the back of the line. NOTE: these values are magic, and may need
            // tuning. Ideally we'd want a ringbuffer or token bucket here to do proper rate
            // limiting.
            final boolean isInteractive = mPowerManager.isInteractive();
            if (isInteractive && (ops.uidState.pkgOps.size() < AppOpsPolicy.RATE_LIMIT_OPS_TOTAL_PKG_COUNT && op.noteOpCount < AppOpsPolicy.RATE_LIMIT_OP_COUNT || op.delayedCount > AppOpsPolicy.RATE_LIMIT_OP_DELAY_CEILING)) {
                // Reset delayed count, most ops will never need this
                if (op.delayedCount > 0) {
                    if (DEBUG)
                        Log.d(TAG, "Resetting delayed count for " + op.packageName);
                    op.delayedCount = 0;
                }
                op.noteOpCount++;
                req = askOperationLocked(code, uid, packageName, switchOp);
            } else {
                if (isInteractive) {
                    op.delayedCount++;
                }
                op.ignoredCount++;
                return AppOpsManager.MODE_IGNORED;
            }
        }
    }
    int result = req.get();
    broadcastOpIfNeeded(code);
    return result;
}
#end_block

#method_before
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String externalServer = context.getResources().getString(org.cyanogenmod.platform.internal.R.string.config_externalSystemServer);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                mSystemServiceManager.startService(ThermalObserver.class);
            }
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    final Class<?> serverClazz;
    try {
        serverClazz = Class.forName(externalServer);
        final Constructor<?> constructor = serverClazz.getDeclaredConstructor(Context.class);
        constructor.setAccessible(true);
        final Object baseObject = constructor.newInstance(mSystemContext);
        final Method method = baseObject.getClass().getDeclaredMethod("run");
        method.setAccessible(true);
        method.invoke(baseObject);
    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) {
        Slog.wtf(TAG, "Unable to start  " + externalServer);
        Slog.wtf(TAG, e);
    }
    // It is now time to start up the app processes...
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            // valid NfcAdapter from NfcManager
            try {
                startNfcService(context);
            } catch (Throwable e) {
                // Don't crash. Nfc is an optional service. Just annotate that isn't ready
                Slog.e(TAG, "Nfc service didn't start. Nfc will not be available.", e);
            }
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#method_after
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String externalServer = context.getResources().getString(org.cyanogenmod.platform.internal.R.string.config_externalSystemServer);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                mSystemServiceManager.startService(ThermalObserver.class);
            }
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    final Class<?> serverClazz;
    try {
        serverClazz = Class.forName(externalServer);
        final Constructor<?> constructor = serverClazz.getDeclaredConstructor(Context.class);
        constructor.setAccessible(true);
        final Object baseObject = constructor.newInstance(mSystemContext);
        final Method method = baseObject.getClass().getDeclaredMethod("run");
        method.setAccessible(true);
        method.invoke(baseObject);
    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) {
        Slog.wtf(TAG, "Unable to start  " + externalServer);
        Slog.wtf(TAG, e);
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            // valid NfcAdapter from NfcManager
            try {
                startNfcService(context);
            } catch (Throwable e) {
                // Don't crash. Nfc is an optional service. Just annotate that isn't ready
                Slog.e(TAG, "Nfc service didn't start. Nfc will not be available.", e);
            }
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#end_block

#method_before
@Override
ResolveListAdapter createAdapter(Context context, List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList, int launchedFromUid, boolean filterLastUsed) {
    ProxyListAdapter adapter = _createAdapter(context, payloadIntents, initialIntents, rList, launchedFromUid, filterLastUsed);
    return (adapter != null) ? adapter : super.createAdapter(context, payloadIntents, initialIntents, rList, launchedFromUid, filterLastUsed);
}
#method_after
@Override
ResolveListAdapter createAdapter(Context context, List<Intent> payloadIntents, Intent[] initialIntents, List<ResolveInfo> rList, int launchedFromUid, boolean filterLastUsed) {
    ProxyListAdapter adapter = createProxyAdapter(context, payloadIntents, initialIntents, rList, launchedFromUid, filterLastUsed);
    return (adapter != null) ? adapter : super.createAdapter(context, payloadIntents, initialIntents, rList, launchedFromUid, filterLastUsed);
}
#end_block

#method_before
public void run() {
    BroadcastReceiver br = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            // We don't allow apps to cancel this, so ignore the result.
            actionDone();
        }
    };
    /*
         * Write a system property in case the system_server reboots before we
         * get to the actual hardware restart. If that happens, we'll retry at
         * the beginning of the SystemServer startup.
         */
    {
        String reason = (mReboot ? "1" : "0") + (mRebootReason != null ? mRebootReason : "");
        SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
    }
    /*
         * If we are rebooting into safe mode, write a system property
         * indicating so.
         */
    if (mRebootSafeMode) {
        SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, "1");
    }
    Log.i(TAG, "Sending shutdown broadcast...");
    // First send the high-level shut down broadcast.
    mActionDone = false;
    Intent intent = new Intent(Intent.ACTION_SHUTDOWN);
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, null, br, mHandler, 0, null, null);
    final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (!mActionDone) {
            long delay = endTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown broadcast timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_BROADCAST_TIME - delay) * 1.0 * BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down activity manager...");
    final IActivityManager am = ActivityManagerNative.asInterface(ServiceManager.checkService("activity"));
    if (am != null) {
        try {
            am.shutdown(MAX_BROADCAST_TIME);
        } catch (RemoteException e) {
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down package manager...");
    final PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm != null) {
        pm.shutdown();
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);
    }
    String shutDownFile = null;
    // music and animation properly
    if (checkAnimationFileExist()) {
        lockDevice();
        showShutdownAnimation();
        if (!isSilentMode() && (shutDownFile = getShutdownMusicFilePath()) != null) {
            isShutdownMusicPlaying = true;
            shutdownMusicHandler.obtainMessage(0, shutDownFile).sendToTarget();
        }
    }
    Log.i(TAG, "wait for shutdown music");
    final long endTimeForMusic = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (isShutdownMusicPlaying) {
            long delay = endTimeForMusic - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "play shutdown music timeout!");
                break;
            }
            try {
                mActionDoneSync.wait(delay);
            } catch (InterruptedException e) {
            }
        }
        if (!isShutdownMusicPlaying) {
            Log.i(TAG, "play shutdown music complete.");
        }
    }
    // Shutdown radios.
    shutdownRadios(MAX_RADIO_WAIT_TIME);
    if (mRebootUpdate) {
        sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);
    }
    // Shutdown MountService to ensure media is in a safe state
    IMountShutdownObserver observer = new IMountShutdownObserver.Stub() {

        public void onShutDownComplete(int statusCode) throws RemoteException {
            Log.w(TAG, "Result code " + statusCode + " from MountService.shutdown");
            actionDone();
        }
    };
    Log.i(TAG, "Shutting down MountService");
    // Set initial variables and time out time.
    mActionDone = false;
    final long endShutTime = SystemClock.elapsedRealtime() + MAX_SHUTDOWN_WAIT_TIME;
    synchronized (mActionDoneSync) {
        try {
            final IMountService mount = IMountService.Stub.asInterface(ServiceManager.checkService("mount"));
            if (mount != null) {
                mount.shutdown(observer);
            } else {
                Log.w(TAG, "MountService unavailable for shutdown");
            }
        } catch (Exception e) {
            Log.e(TAG, "Exception during MountService shutdown", e);
        }
        while (!mActionDone) {
            long delay = endShutTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown wait timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_SHUTDOWN_WAIT_TIME - delay) * 1.0 * (MOUNT_SERVICE_STOP_PERCENT - RADIO_STOP_PERCENT) / MAX_SHUTDOWN_WAIT_TIME);
                status += RADIO_STOP_PERCENT;
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);
        // If it's to reboot to install update, invoke uncrypt via init service.
        uncrypt();
    }
    rebootOrShutdown(mContext, mReboot, mRebootReason);
}
#method_after
public void run() {
    BroadcastReceiver br = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            // We don't allow apps to cancel this, so ignore the result.
            actionDone();
        }
    };
    /*
         * Write a system property in case the system_server reboots before we
         * get to the actual hardware restart. If that happens, we'll retry at
         * the beginning of the SystemServer startup.
         */
    {
        String reason = (mReboot ? "1" : "0") + (mRebootReason != null ? mRebootReason : "");
        SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
    }
    /*
         * If we are rebooting into safe mode, write a system property
         * indicating so.
         */
    if (mRebootSafeMode) {
        SystemProperties.set(REBOOT_SAFEMODE_PROPERTY, "1");
    }
    Log.i(TAG, "Sending shutdown broadcast...");
    // First send the high-level shut down broadcast.
    mActionDone = false;
    Intent intent = new Intent(Intent.ACTION_SHUTDOWN);
    intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    mContext.sendOrderedBroadcastAsUser(intent, UserHandle.ALL, null, br, mHandler, 0, null, null);
    final long endTime = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (!mActionDone) {
            long delay = endTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown broadcast timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_BROADCAST_TIME - delay) * 1.0 * BROADCAST_STOP_PERCENT / MAX_BROADCAST_TIME);
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(BROADCAST_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down activity manager...");
    final IActivityManager am = ActivityManagerNative.asInterface(ServiceManager.checkService("activity"));
    if (am != null) {
        try {
            am.shutdown(MAX_BROADCAST_TIME);
        } catch (RemoteException e) {
        }
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(ACTIVITY_MANAGER_STOP_PERCENT, null);
    }
    Log.i(TAG, "Shutting down package manager...");
    final PackageManagerService pm = (PackageManagerService) ServiceManager.getService("package");
    if (pm != null) {
        pm.shutdown();
    }
    if (mRebootUpdate) {
        sInstance.setRebootProgress(PACKAGE_MANAGER_STOP_PERCENT, null);
    }
    String shutDownFile = null;
    // music and animation properly
    if (checkAnimationFileExist()) {
        lockDevice();
        showShutdownAnimation();
        if (!isSilentMode() && (shutDownFile = getShutdownMusicFilePath()) != null) {
            isShutdownMusicPlaying = true;
            shutdownMusicHandler.obtainMessage(0, shutDownFile).sendToTarget();
        }
    }
    Log.i(TAG, "wait for shutdown music");
    final long endTimeForMusic = SystemClock.elapsedRealtime() + MAX_BROADCAST_TIME;
    synchronized (mActionDoneSync) {
        while (isShutdownMusicPlaying) {
            long delay = endTimeForMusic - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "play shutdown music timeout!");
                break;
            }
            try {
                mActionDoneSync.wait(delay);
            } catch (InterruptedException e) {
            }
        }
        if (!isShutdownMusicPlaying) {
            Log.i(TAG, "play shutdown music complete.");
        }
    }
    // Shutdown radios.
    shutdownRadios(MAX_RADIO_WAIT_TIME);
    if (mRebootUpdate) {
        sInstance.setRebootProgress(RADIO_STOP_PERCENT, null);
    }
    // Shutdown MountService to ensure media is in a safe state
    IMountShutdownObserver observer = new IMountShutdownObserver.Stub() {

        public void onShutDownComplete(int statusCode) throws RemoteException {
            Log.w(TAG, "Result code " + statusCode + " from MountService.shutdown");
            actionDone();
        }
    };
    final String cryptoStatus = SystemProperties.get("ro.crypto.state", "unsupported");
    final boolean isEncrypted = "encrypted".equalsIgnoreCase(cryptoStatus);
    if (mRebootUpdate && isEncrypted) {
        sInstance.setRebootProgress(MOUNT_SERVICE_STOP_PERCENT, null);
        // If it's to reboot to install update, invoke uncrypt via init service.
        uncrypt();
    }
    Log.i(TAG, "Shutting down MountService");
    // Set initial variables and time out time.
    mActionDone = false;
    final long endShutTime = SystemClock.elapsedRealtime() + MAX_SHUTDOWN_WAIT_TIME;
    synchronized (mActionDoneSync) {
        try {
            final IMountService mount = IMountService.Stub.asInterface(ServiceManager.checkService("mount"));
            if (mount != null) {
                mount.shutdown(observer);
            } else {
                Log.w(TAG, "MountService unavailable for shutdown");
            }
        } catch (Exception e) {
            Log.e(TAG, "Exception during MountService shutdown", e);
        }
        while (!mActionDone) {
            long delay = endShutTime - SystemClock.elapsedRealtime();
            if (delay <= 0) {
                Log.w(TAG, "Shutdown wait timed out");
                break;
            } else if (mRebootUpdate) {
                int status = (int) ((MAX_SHUTDOWN_WAIT_TIME - delay) * 1.0 * (MOUNT_SERVICE_STOP_PERCENT - RADIO_STOP_PERCENT) / MAX_SHUTDOWN_WAIT_TIME);
                status += RADIO_STOP_PERCENT;
                sInstance.setRebootProgress(status, null);
            }
            try {
                mActionDoneSync.wait(Math.min(delay, PHONE_STATE_POLL_SLEEP_MSEC));
            } catch (InterruptedException e) {
            }
        }
    }
    rebootOrShutdown(mContext, mReboot, mRebootReason);
}
#end_block

#method_before
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String[] externalServices = context.getResources().getStringArray(org.cyanogenmod.platform.internal.R.array.config_externalCMServices);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                mSystemServiceManager.startService(ThermalObserver.class);
            }
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    for (String service : externalServices) {
        try {
            Slog.i(TAG, service);
            mSystemServiceManager.startService(service);
        } catch (Throwable e) {
            reportWtf("starting " + service, e);
        }
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            // valid NfcAdapter from NfcManager
            try {
                startNfcService(context);
            } catch (Throwable e) {
                // Don't crash. Nfc is an optional service. Just annotate that isn't ready
                Slog.e(TAG, "Nfc service didn't start. Nfc will not be available.", e);
            }
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#method_after
private void startOtherServices() {
    final Context context = mSystemContext;
    AccountManagerService accountManager = null;
    ContentService contentService = null;
    VibratorService vibrator = null;
    IAlarmManager alarm = null;
    IMountService mountService = null;
    NetworkManagementService networkManagement = null;
    NetworkStatsService networkStats = null;
    NetworkPolicyManagerService networkPolicy = null;
    ConnectivityService connectivity = null;
    NetworkScoreService networkScore = null;
    NsdService serviceDiscovery = null;
    WindowManagerService wm = null;
    UsbService usb = null;
    SerialService serial = null;
    NetworkTimeUpdateService networkTimeUpdater = null;
    CommonTimeManagementService commonTimeMgmtService = null;
    InputManagerService inputManager = null;
    TelephonyRegistry telephonyRegistry = null;
    ConsumerIrService consumerIr = null;
    AudioService audioService = null;
    MmsServiceBroker mmsService = null;
    EntropyMixer entropyMixer = null;
    CameraService cameraService = null;
    boolean disableStorage = SystemProperties.getBoolean("config.disable_storage", false);
    boolean disableBluetooth = SystemProperties.getBoolean("config.disable_bluetooth", false);
    boolean disableLocation = SystemProperties.getBoolean("config.disable_location", false);
    boolean disableSystemUI = SystemProperties.getBoolean("config.disable_systemui", false);
    boolean disableNonCoreServices = SystemProperties.getBoolean("config.disable_noncore", false);
    boolean disableNetwork = SystemProperties.getBoolean("config.disable_network", false);
    boolean disableNetworkTime = SystemProperties.getBoolean("config.disable_networktime", false);
    boolean isEmulator = SystemProperties.get("ro.kernel.qemu").equals("1");
    String externalServer = context.getResources().getString(org.cyanogenmod.platform.internal.R.string.config_externalSystemServer);
    try {
        Slog.i(TAG, "Reading configuration...");
        SystemConfig.getInstance();
        Slog.i(TAG, "Scheduling Policy");
        ServiceManager.addService("scheduling_policy", new SchedulingPolicyService());
        mSystemServiceManager.startService(TelecomLoaderService.class);
        Slog.i(TAG, "Telephony Registry");
        telephonyRegistry = new TelephonyRegistry(context);
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        Slog.i(TAG, "Entropy Mixer");
        entropyMixer = new EntropyMixer(context);
        mContentResolver = context.getContentResolver();
        Slog.i(TAG, "Camera Service");
        mSystemServiceManager.startService(CameraService.class);
        // The AccountManager must come before the ContentService
        try {
            // TODO: seems like this should be disable-able, but req'd by ContentService
            Slog.i(TAG, "Account Manager");
            accountManager = new AccountManagerService(context);
            ServiceManager.addService(Context.ACCOUNT_SERVICE, accountManager);
        } catch (Throwable e) {
            Slog.e(TAG, "Failure starting Account Manager", e);
        }
        Slog.i(TAG, "Content Manager");
        contentService = ContentService.main(context, mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL);
        Slog.i(TAG, "System Content Providers");
        mActivityManagerService.installSystemProviders();
        Slog.i(TAG, "Vibrator Service");
        vibrator = new VibratorService(context);
        ServiceManager.addService("vibrator", vibrator);
        Slog.i(TAG, "Consumer IR Service");
        consumerIr = new ConsumerIrService(context);
        ServiceManager.addService(Context.CONSUMER_IR_SERVICE, consumerIr);
        mSystemServiceManager.startService(AlarmManagerService.class);
        alarm = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
        Slog.i(TAG, "Init Watchdog");
        final Watchdog watchdog = Watchdog.getInstance();
        watchdog.init(context, mActivityManagerService);
        Slog.i(TAG, "Input Manager");
        inputManager = new InputManagerService(context);
        Slog.i(TAG, "Window Manager");
        wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, true, mOnlyCore);
        ServiceManager.addService(Context.WINDOW_SERVICE, wm);
        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);
        mActivityManagerService.setWindowManager(wm);
        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());
        inputManager.start();
        // TODO: Use service dependencies instead.
        mDisplayManagerService.windowManagerAndInputReady();
        // support Bluetooth - see bug 988521
        if (isEmulator) {
            Slog.i(TAG, "No Bluetooh Service (emulator)");
        } else if (mFactoryTestMode == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            Slog.i(TAG, "No Bluetooth Service (factory test)");
        } else if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            Slog.i(TAG, "No Bluetooth Service (Bluetooth Hardware Not Present)");
        } else if (disableBluetooth) {
            Slog.i(TAG, "Bluetooth Service disabled by config");
        } else {
            Slog.i(TAG, "Bluetooth Service");
            mSystemServiceManager.startService(BluetoothService.class);
        }
    } catch (RuntimeException e) {
        Slog.e("System", "******************************************");
        Slog.e("System", "************ Failure starting core service", e);
    }
    StatusBarManagerService statusBar = null;
    INotificationManager notification = null;
    InputMethodManagerService imm = null;
    WallpaperManagerService wallpaper = null;
    LocationManagerService location = null;
    CountryDetectorService countryDetector = null;
    TextServicesManagerService tsms = null;
    LockSettingsService lockSettings = null;
    AssetAtlasService atlas = null;
    MediaRouterService mediaRouter = null;
    GestureService gestureService = null;
    // Bring up services needed for UI.
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        try {
            Slog.i(TAG, "Input Method Service");
            imm = new InputMethodManagerService(context, wm);
            ServiceManager.addService(Context.INPUT_METHOD_SERVICE, imm);
        } catch (Throwable e) {
            reportWtf("starting Input Manager Service", e);
        }
        try {
            Slog.i(TAG, "Accessibility Manager");
            ServiceManager.addService(Context.ACCESSIBILITY_SERVICE, new AccessibilityManagerService(context));
        } catch (Throwable e) {
            reportWtf("starting Accessibility Manager", e);
        }
    }
    try {
        wm.displayReady();
    } catch (Throwable e) {
        reportWtf("making display ready", e);
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableStorage && !"0".equals(SystemProperties.get("system_init.startmountservice"))) {
            try {
                /*
                     * NotificationManagerService is dependant on MountService,
                     * (for media / usb notifications) so we must start MountService first.
                     */
                mSystemServiceManager.startService(MOUNT_SERVICE_CLASS);
                mountService = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
            } catch (Throwable e) {
                reportWtf("starting Mount Service", e);
            }
        }
    }
    // We start this here so that we update our configuration to set watch or television
    // as appropriate.
    mSystemServiceManager.startService(UiModeManagerService.class);
    try {
        mPackageManagerService.performBootDexOpt();
    } catch (Throwable e) {
        reportWtf("performing boot dexopt", e);
    }
    try {
        ActivityManagerNative.getDefault().showBootMessage(context.getResources().getText(com.android.internal.R.string.android_upgrading_starting_apps), false);
    } catch (RemoteException e) {
    }
    if (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "LockSettingsService");
                lockSettings = new LockSettingsService(context);
                ServiceManager.addService("lock_settings", lockSettings);
            } catch (Throwable e) {
                reportWtf("starting LockSettingsService service", e);
            }
            if (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals("")) {
                mSystemServiceManager.startService(PersistentDataBlockService.class);
            }
            mSystemServiceManager.startService(DeviceIdleController.class);
            // Always start the Device Policy Manager, so that the API is compatible with
            // API8.
            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);
        }
        if (!disableSystemUI) {
            try {
                Slog.i(TAG, "Status Bar");
                statusBar = new StatusBarManagerService(context, wm);
                ServiceManager.addService(Context.STATUS_BAR_SERVICE, statusBar);
            } catch (Throwable e) {
                reportWtf("starting StatusBarManagerService", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Clipboard Service");
                ServiceManager.addService(Context.CLIPBOARD_SERVICE, new ClipboardService(context));
            } catch (Throwable e) {
                reportWtf("starting Clipboard Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "NetworkManagement Service");
                networkManagement = NetworkManagementService.create(context);
                ServiceManager.addService(Context.NETWORKMANAGEMENT_SERVICE, networkManagement);
            } catch (Throwable e) {
                reportWtf("starting NetworkManagement Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Text Service Manager Service");
                tsms = new TextServicesManagerService(context);
                ServiceManager.addService(Context.TEXT_SERVICES_MANAGER_SERVICE, tsms);
            } catch (Throwable e) {
                reportWtf("starting Text Service Manager Service", e);
            }
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "Network Score Service");
                networkScore = new NetworkScoreService(context);
                ServiceManager.addService(Context.NETWORK_SCORE_SERVICE, networkScore);
            } catch (Throwable e) {
                reportWtf("starting Network Score Service", e);
            }
            try {
                Slog.i(TAG, "NetworkStats Service");
                networkStats = new NetworkStatsService(context, networkManagement, alarm);
                ServiceManager.addService(Context.NETWORK_STATS_SERVICE, networkStats);
            } catch (Throwable e) {
                reportWtf("starting NetworkStats Service", e);
            }
            try {
                Slog.i(TAG, "NetworkPolicy Service");
                networkPolicy = new NetworkPolicyManagerService(context, mActivityManagerService, (IPowerManager) ServiceManager.getService(Context.POWER_SERVICE), networkStats, networkManagement);
                ServiceManager.addService(Context.NETWORK_POLICY_SERVICE, networkPolicy);
            } catch (Throwable e) {
                reportWtf("starting NetworkPolicy Service", e);
            }
            mSystemServiceManager.startService(WIFI_P2P_SERVICE_CLASS);
            mSystemServiceManager.startService(WIFI_SERVICE_CLASS);
            mSystemServiceManager.startService("com.android.server.wifi.WifiScanningService");
            mSystemServiceManager.startService("com.android.server.wifi.RttService");
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Connectivity Service");
                connectivity = new ConnectivityService(context, networkManagement, networkStats, networkPolicy);
                ServiceManager.addService(Context.CONNECTIVITY_SERVICE, connectivity);
                networkStats.bindConnectivityManager(connectivity);
                networkPolicy.bindConnectivityManager(connectivity);
            } catch (Throwable e) {
                reportWtf("starting Connectivity Service", e);
            }
            try {
                Slog.i(TAG, "Network Service Discovery Service");
                serviceDiscovery = NsdService.create(context);
                ServiceManager.addService(Context.NSD_SERVICE, serviceDiscovery);
            } catch (Throwable e) {
                reportWtf("starting Service Discovery Service", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "UpdateLock Service");
                ServiceManager.addService(Context.UPDATE_LOCK_SERVICE, new UpdateLockService(context));
            } catch (Throwable e) {
                reportWtf("starting UpdateLockService", e);
            }
        }
        /*
             * MountService has a few dependencies: Notification Manager and
             * AppWidget Provider. Make sure MountService is completely started
             * first before continuing.
             */
        if (mountService != null && !mOnlyCore) {
            try {
                mountService.waitForAsecScan();
            } catch (RemoteException ignored) {
            }
        }
        try {
            if (accountManager != null)
                accountManager.systemReady();
        } catch (Throwable e) {
            reportWtf("making Account Manager Service ready", e);
        }
        try {
            if (contentService != null)
                contentService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Content Service ready", e);
        }
        mSystemServiceManager.startService(NotificationManagerService.class);
        notification = INotificationManager.Stub.asInterface(ServiceManager.getService(Context.NOTIFICATION_SERVICE));
        networkPolicy.bindNotificationManager(notification);
        mSystemServiceManager.startService(DeviceStorageMonitorService.class);
        if (!disableLocation) {
            try {
                Slog.i(TAG, "Location Manager");
                location = new LocationManagerService(context);
                ServiceManager.addService(Context.LOCATION_SERVICE, location);
            } catch (Throwable e) {
                reportWtf("starting Location Manager", e);
            }
            try {
                Slog.i(TAG, "Country Detector");
                countryDetector = new CountryDetectorService(context);
                ServiceManager.addService(Context.COUNTRY_DETECTOR, countryDetector);
            } catch (Throwable e) {
                reportWtf("starting Country Detector", e);
            }
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Search Service");
                ServiceManager.addService(Context.SEARCH_SERVICE, new SearchManagerService(context));
            } catch (Throwable e) {
                reportWtf("starting Search Service", e);
            }
        }
        try {
            Slog.i(TAG, "DropBox Service");
            ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File("/data/system/dropbox")));
        } catch (Throwable e) {
            reportWtf("starting DropBoxManagerService", e);
        }
        if (!disableNonCoreServices && context.getResources().getBoolean(R.bool.config_enableWallpaperService)) {
            try {
                Slog.i(TAG, "Wallpaper Service");
                wallpaper = new WallpaperManagerService(context);
                ServiceManager.addService(Context.WALLPAPER_SERVICE, wallpaper);
            } catch (Throwable e) {
                reportWtf("starting Wallpaper Service", e);
            }
        }
        try {
            Slog.i(TAG, "Audio Service");
            audioService = new AudioService(context);
            ServiceManager.addService(Context.AUDIO_SERVICE, audioService);
        } catch (Throwable e) {
            reportWtf("starting Audio Service", e);
        }
        if (!disableNonCoreServices) {
            mSystemServiceManager.startService(DockObserver.class);
            if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                mSystemServiceManager.startService(ThermalObserver.class);
            }
        }
        try {
            Slog.i(TAG, "Wired Accessory Manager");
            // Listen for wired headset changes
            inputManager.setWiredAccessoryCallbacks(new WiredAccessoryManager(context, inputManager));
        } catch (Throwable e) {
            reportWtf("starting WiredAccessoryManager", e);
        }
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_MIDI)) {
                // Start MIDI Manager service
                mSystemServiceManager.startService(MIDI_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST) || mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY)) {
                // Manage USB host and device support
                mSystemServiceManager.startService(USB_SERVICE_CLASS);
            }
            try {
                Slog.i(TAG, "Serial Service");
                // Serial port support
                serial = new SerialService(context);
                ServiceManager.addService(Context.SERIAL_SERVICE, serial);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting SerialService", e);
            }
        }
        mSystemServiceManager.startService(TwilightService.class);
        mSystemServiceManager.startService(JobSchedulerService.class);
        if (!disableNonCoreServices) {
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BACKUP)) {
                mSystemServiceManager.startService(BACKUP_MANAGER_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
                mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS);
            }
            if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_VOICE_RECOGNIZERS)) {
                mSystemServiceManager.startService(VOICE_RECOGNITION_MANAGER_SERVICE_CLASS);
            }
            if (GestureLauncherService.isGestureLauncherEnabled(context.getResources())) {
                Slog.i(TAG, "Gesture Launcher Service");
                mSystemServiceManager.startService(GestureLauncherService.class);
            }
        }
        try {
            Slog.i(TAG, "DiskStats Service");
            ServiceManager.addService("diskstats", new DiskStatsService(context));
        } catch (Throwable e) {
            reportWtf("starting DiskStats Service", e);
        }
        try {
            // need to add this service even if SamplingProfilerIntegration.isEnabled()
            // is false, because it is this service that detects system property change and
            // turns on SamplingProfilerIntegration. Plus, when sampling profiler doesn't work,
            // there is little overhead for running this service.
            Slog.i(TAG, "SamplingProfiler Service");
            ServiceManager.addService("samplingprofiler", new SamplingProfilerService(context));
        } catch (Throwable e) {
            reportWtf("starting SamplingProfiler Service", e);
        }
        if (!disableNetwork && !disableNetworkTime) {
            try {
                Slog.i(TAG, "NetworkTimeUpdateService");
                networkTimeUpdater = new NetworkTimeUpdateService(context);
            } catch (Throwable e) {
                reportWtf("starting NetworkTimeUpdate service", e);
            }
        }
        try {
            Slog.i(TAG, "CommonTimeManagementService");
            commonTimeMgmtService = new CommonTimeManagementService(context);
            ServiceManager.addService("commontime_management", commonTimeMgmtService);
        } catch (Throwable e) {
            reportWtf("starting CommonTimeManagementService service", e);
        }
        if (!disableNetwork) {
            try {
                Slog.i(TAG, "CertBlacklister");
                CertBlacklister blacklister = new CertBlacklister(context);
            } catch (Throwable e) {
                reportWtf("starting CertBlacklister", e);
            }
        }
        if (!disableNonCoreServices) {
            // Dreams (interactive idle-time views, a/k/a screen savers, and doze mode)
            mSystemServiceManager.startService(DreamManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Assets Atlas Service");
                atlas = new AssetAtlasService(context);
                ServiceManager.addService(AssetAtlasService.ASSET_ATLAS_SERVICE, atlas);
            } catch (Throwable e) {
                reportWtf("starting AssetAtlasService", e);
            }
        }
        if (!disableNonCoreServices) {
            ServiceManager.addService(GraphicsStatsService.GRAPHICS_STATS_SERVICE, new GraphicsStatsService(context));
        }
        if (context.getResources().getBoolean(com.android.internal.R.bool.config_enableGestureService)) {
            try {
                Slog.i(TAG, "Gesture Sensor Service");
                gestureService = new GestureService(context, inputManager);
                ServiceManager.addService("gesture", gestureService);
            } catch (Throwable e) {
                Slog.e(TAG, "Failure starting Gesture Sensor Service", e);
            }
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PRINTING)) {
            mSystemServiceManager.startService(PRINT_MANAGER_SERVICE_CLASS);
        }
        mSystemServiceManager.startService(RestrictionsManagerService.class);
        mSystemServiceManager.startService(MediaSessionService.class);
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_HDMI_CEC)) {
            mSystemServiceManager.startService(HdmiControlService.class);
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_LIVE_TV)) {
            mSystemServiceManager.startService(TvInputManagerService.class);
        }
        if (!disableNonCoreServices) {
            try {
                Slog.i(TAG, "Media Router Service");
                mediaRouter = new MediaRouterService(context);
                ServiceManager.addService(Context.MEDIA_ROUTER_SERVICE, mediaRouter);
            } catch (Throwable e) {
                reportWtf("starting MediaRouterService", e);
            }
            mSystemServiceManager.startService(TrustManagerService.class);
            mSystemServiceManager.startService(FingerprintService.class);
            try {
                Slog.i(TAG, "BackgroundDexOptService");
                BackgroundDexOptService.schedule(context, 0);
            } catch (Throwable e) {
                reportWtf("starting BackgroundDexOptService", e);
            }
        }
        mSystemServiceManager.startService(LauncherAppsService.class);
    }
    if (!disableNonCoreServices) {
        mSystemServiceManager.startService(MediaProjectionManagerService.class);
    }
    // make sure the ADB_ENABLED setting value matches the secure property value
    CMSettings.Secure.putInt(mContentResolver, CMSettings.Secure.ADB_PORT, Integer.parseInt(SystemProperties.get("service.adb.tcp.port", "-1")));
    // register observer to listen for settings changes
    mContentResolver.registerContentObserver(CMSettings.Secure.getUriFor(CMSettings.Secure.ADB_PORT), false, new AdbPortObserver());
    // Before things start rolling, be sure we have decided whether
    // we are in safe mode.
    final boolean safeMode = wm.detectSafeMode();
    if (safeMode) {
        mActivityManagerService.enterSafeMode();
        // Disable the JIT for the system_server process
        VMRuntime.getRuntime().disableJitCompilation();
    } else {
        // Enable the JIT for the system_server process
        VMRuntime.getRuntime().startJitCompilation();
    }
    // MMS service broker
    mmsService = mSystemServiceManager.startService(MmsServiceBroker.class);
    final Class<?> serverClazz;
    try {
        serverClazz = Class.forName(externalServer);
        final Constructor<?> constructor = serverClazz.getDeclaredConstructor(Context.class);
        constructor.setAccessible(true);
        final Object baseObject = constructor.newInstance(mSystemContext);
        final Method method = baseObject.getClass().getDeclaredMethod("run");
        method.setAccessible(true);
        method.invoke(baseObject);
    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | InstantiationException | NoSuchMethodException e) {
        Slog.wtf(TAG, "Unable to start  " + externalServer);
        Slog.wtf(TAG, e);
    }
    try {
        vibrator.systemReady();
    } catch (Throwable e) {
        reportWtf("making Vibrator Service ready", e);
    }
    if (lockSettings != null) {
        try {
            lockSettings.systemReady();
        } catch (Throwable e) {
            reportWtf("making Lock Settings Service ready", e);
        }
    }
    // Needed by DevicePolicyManager for initialization
    mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);
    mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);
    try {
        wm.systemReady();
    } catch (Throwable e) {
        reportWtf("making Window Manager Service ready", e);
    }
    if (safeMode) {
        mActivityManagerService.showSafeModeOverlay();
    }
    // Update the configuration for this context by hand, because we're going
    // to start using it before the config change done in wm.systemReady() will
    // propagate to it.
    Configuration config = wm.computeNewConfiguration();
    DisplayMetrics metrics = new DisplayMetrics();
    WindowManager w = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    w.getDefaultDisplay().getMetrics(metrics);
    context.getResources().updateConfiguration(config, metrics);
    // The system context's theme may be configuration-dependent.
    final Theme systemTheme = context.getTheme();
    if (systemTheme.getChangingConfigurations() != 0) {
        systemTheme.rebase();
    }
    try {
        // TODO: use boot phase
        mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());
    } catch (Throwable e) {
        reportWtf("making Power Manager Service ready", e);
    }
    try {
        mPackageManagerService.systemReady();
    } catch (Throwable e) {
        reportWtf("making Package Manager Service ready", e);
    }
    try {
        // TODO: use boot phase and communicate these flags some other way
        mDisplayManagerService.systemReady(safeMode, mOnlyCore);
    } catch (Throwable e) {
        reportWtf("making Display Manager Service ready", e);
    }
    if (gestureService != null) {
        try {
            gestureService.systemReady();
        } catch (Throwable e) {
            reportWtf("making Gesture Sensor Service ready", e);
        }
    }
    // These are needed to propagate to the runnable below.
    final NetworkManagementService networkManagementF = networkManagement;
    final NetworkStatsService networkStatsF = networkStats;
    final NetworkPolicyManagerService networkPolicyF = networkPolicy;
    final ConnectivityService connectivityF = connectivity;
    final NetworkScoreService networkScoreF = networkScore;
    final WallpaperManagerService wallpaperF = wallpaper;
    final InputMethodManagerService immF = imm;
    final LocationManagerService locationF = location;
    final CountryDetectorService countryDetectorF = countryDetector;
    final NetworkTimeUpdateService networkTimeUpdaterF = networkTimeUpdater;
    final CommonTimeManagementService commonTimeMgmtServiceF = commonTimeMgmtService;
    final TextServicesManagerService textServiceManagerServiceF = tsms;
    final StatusBarManagerService statusBarF = statusBar;
    final AssetAtlasService atlasF = atlas;
    final InputManagerService inputManagerF = inputManager;
    final TelephonyRegistry telephonyRegistryF = telephonyRegistry;
    final MediaRouterService mediaRouterF = mediaRouter;
    final AudioService audioServiceF = audioService;
    final MmsServiceBroker mmsServiceF = mmsService;
    // We now tell the activity manager it is okay to run third party
    // code.  It will call back into us once it has gotten to the state
    // where third party code can really run (but before it has actually
    // started launching the initial applications), for us to complete our
    // initialization.
    mActivityManagerService.systemReady(new Runnable() {

        @Override
        public void run() {
            Slog.i(TAG, "Making services ready");
            mSystemServiceManager.startBootPhase(SystemService.PHASE_ACTIVITY_MANAGER_READY);
            try {
                mActivityManagerService.startObservingNativeCrashes();
            } catch (Throwable e) {
                reportWtf("observing native crashes", e);
            }
            Slog.i(TAG, "WebViewFactory preparation");
            WebViewFactory.prepareWebViewInSystemServer();
            try {
                startSystemUi(context);
            } catch (Throwable e) {
                reportWtf("starting System UI", e);
            }
            try {
                if (networkScoreF != null)
                    networkScoreF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Score Service ready", e);
            }
            try {
                if (networkManagementF != null)
                    networkManagementF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Managment Service ready", e);
            }
            try {
                if (networkStatsF != null)
                    networkStatsF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Stats Service ready", e);
            }
            try {
                if (networkPolicyF != null)
                    networkPolicyF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Network Policy Service ready", e);
            }
            try {
                if (connectivityF != null)
                    connectivityF.systemReady();
            } catch (Throwable e) {
                reportWtf("making Connectivity Service ready", e);
            }
            try {
                if (audioServiceF != null)
                    audioServiceF.systemReady();
            } catch (Throwable e) {
                reportWtf("Notifying AudioService running", e);
            }
            Watchdog.getInstance().start();
            // It is now okay to let the various system services start their
            // third party code...
            mSystemServiceManager.startBootPhase(SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);
            try {
                if (wallpaperF != null)
                    wallpaperF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying WallpaperService running", e);
            }
            try {
                if (immF != null)
                    immF.systemRunning(statusBarF);
            } catch (Throwable e) {
                reportWtf("Notifying InputMethodService running", e);
            }
            try {
                if (locationF != null)
                    locationF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying Location Service running", e);
            }
            try {
                if (countryDetectorF != null)
                    countryDetectorF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying CountryDetectorService running", e);
            }
            try {
                if (networkTimeUpdaterF != null)
                    networkTimeUpdaterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying NetworkTimeService running", e);
            }
            try {
                if (commonTimeMgmtServiceF != null) {
                    commonTimeMgmtServiceF.systemRunning();
                }
            } catch (Throwable e) {
                reportWtf("Notifying CommonTimeManagementService running", e);
            }
            try {
                if (textServiceManagerServiceF != null)
                    textServiceManagerServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TextServicesManagerService running", e);
            }
            try {
                if (atlasF != null)
                    atlasF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying AssetAtlasService running", e);
            }
            try {
                // TODO(BT) Pass parameter to input manager
                if (inputManagerF != null)
                    inputManagerF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying InputManagerService running", e);
            }
            try {
                if (telephonyRegistryF != null)
                    telephonyRegistryF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying TelephonyRegistry running", e);
            }
            try {
                if (mediaRouterF != null)
                    mediaRouterF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MediaRouterService running", e);
            }
            try {
                if (mmsServiceF != null)
                    mmsServiceF.systemRunning();
            } catch (Throwable e) {
                reportWtf("Notifying MmsService running", e);
            }
        }
    });
}
#end_block

#method_before
boolean isUserSetupComplete() {
    return Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0, UserHandle.USER_CURRENT) != 0 && CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.CM_SETUP_WIZARD_COMPLETED, 0, UserHandle.USER_CURRENT) != 0;
}
#method_after
boolean isUserSetupComplete() {
    return CMSettings.Secure.getIntForUser(mContext.getContentResolver(), CMSettings.Secure.CM_SETUP_WIZARD_COMPLETED, 0, UserHandle.USER_CURRENT) != 0;
}
#end_block

#method_before
private void wakeUpFromPowerKey(long eventTime) {
    wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER", true);
}
#method_after
private void wakeUpFromPowerKey(long eventTime) {
    wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER");
}
#end_block

#method_before
@Override
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
    final int callingUid = Binder.getCallingUid();
    userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, ALLOW_FULL_ONLY, "getRecentTasks", null);
    final boolean includeProfiles = (flags & ActivityManager.RECENT_INCLUDE_PROFILES) != 0;
    final boolean withExcluded = (flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0;
    synchronized (this) {
        final boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
        final boolean detailed = checkCallingPermission(android.Manifest.permission.GET_DETAILED_TASKS) == PackageManager.PERMISSION_GRANTED;
        final int recentsCount = mRecentTasks.size();
        ArrayList<ActivityManager.RecentTaskInfo> res = new ArrayList<>(maxNum < recentsCount ? maxNum : recentsCount);
        final Set<Integer> includedUsers;
        if (includeProfiles) {
            includedUsers = getProfileIdsLocked(userId);
        } else {
            includedUsers = new HashSet<>();
        }
        includedUsers.add(Integer.valueOf(userId));
        for (int i = 0; i < recentsCount && maxNum > 0; i++) {
            TaskRecord tr = mRecentTasks.get(i);
            // Only add calling user or related users recent tasks
            if (!includedUsers.contains(Integer.valueOf(tr.userId))) {
                if (DEBUG_RECENTS)
                    Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                continue;
            }
            if (i == 0 || withExcluded || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
                if (!allowed) {
                    // allow them to see a small subset of tasks -- their own and home.
                    if (!tr.isHomeTask() && tr.effectiveUid != callingUid) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != 0) {
                    if (tr.stack != null && tr.stack.isHomeStack()) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, home stack task: " + tr);
                        continue;
                    }
                }
                if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                    // Don't include auto remove tasks that are finished or finishing.
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                    continue;
                }
                if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0 && !tr.isAvailable) {
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                    continue;
                }
                IPackageManager pm = AppGlobals.getPackageManager();
                try {
                    if (tr.origActivity != null) {
                        if (pm.getApplicationInfo(tr.origActivity.getPackageName(), STOCK_PM_FLAGS, userId).protect) {
                            if (DEBUG_RECENTS)
                                Slog.d(TAG_RECENTS, "Skipping, protected app: " + tr);
                            continue;
                        }
                    } else {
                        Slog.d(TAG_RECENTS, "null component: " + tr);
                    }
                } catch (RemoteException ex) {
                // pm is in same process, this will never happen.
                }
                ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                if (!detailed) {
                    rti.baseIntent.replaceExtras((Bundle) null);
                }
                res.add(rti);
                maxNum--;
            }
        }
        return res;
    }
}
#method_after
@Override
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
    final int callingUid = Binder.getCallingUid();
    userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, ALLOW_FULL_ONLY, "getRecentTasks", null);
    final boolean includeProfiles = (flags & ActivityManager.RECENT_INCLUDE_PROFILES) != 0;
    final boolean withExcluded = (flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0;
    synchronized (this) {
        final boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
        final boolean detailed = checkCallingPermission(android.Manifest.permission.GET_DETAILED_TASKS) == PackageManager.PERMISSION_GRANTED;
        final int recentsCount = mRecentTasks.size();
        ArrayList<ActivityManager.RecentTaskInfo> res = new ArrayList<>(maxNum < recentsCount ? maxNum : recentsCount);
        final Set<Integer> includedUsers;
        if (includeProfiles) {
            includedUsers = getProfileIdsLocked(userId);
        } else {
            includedUsers = new HashSet<>();
        }
        includedUsers.add(Integer.valueOf(userId));
        for (int i = 0; i < recentsCount && maxNum > 0; i++) {
            TaskRecord tr = mRecentTasks.get(i);
            // Only add calling user or related users recent tasks
            if (!includedUsers.contains(Integer.valueOf(tr.userId))) {
                if (DEBUG_RECENTS)
                    Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                continue;
            }
            if (i == 0 || withExcluded || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
                if (!allowed) {
                    // allow them to see a small subset of tasks -- their own and home.
                    if (!tr.isHomeTask() && tr.effectiveUid != callingUid) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != 0) {
                    if (tr.stack != null && tr.stack.isHomeStack()) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, home stack task: " + tr);
                        continue;
                    }
                }
                if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                    // Don't include auto remove tasks that are finished or finishing.
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                    continue;
                }
                if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0 && !tr.isAvailable) {
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                    continue;
                }
                ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                if (!detailed) {
                    rti.baseIntent.replaceExtras((Bundle) null);
                }
                res.add(rti);
                maxNum--;
            }
        }
        return res;
    }
}
#end_block

#method_before
public void systemReady(final Runnable goingCallback) {
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        // Make sure we have the current profile info, since it is needed for
        // security checks.
        updateCurrentProfileIdsLocked();
        mRecentTasks.clear();
        mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());
        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
        mTaskPersister.startPersisting();
        // Check to see if there are any update receivers to run.
        if (!mDidUpdate) {
            if (mWaitingUpdate) {
                return;
            }
            final ArrayList<ComponentName> doneReceivers = new ArrayList<ComponentName>();
            mWaitingUpdate = deliverPreBootCompleted(new Runnable() {

                public void run() {
                    synchronized (ActivityManagerService.this) {
                        mDidUpdate = true;
                    }
                    showBootMessage(mContext.getText(R.string.android_upgrading_complete), false);
                    writeLastDonePreBootReceivers(doneReceivers);
                    systemReady(goingCallback);
                }
            }, doneReceivers, UserHandle.USER_OWNER);
            if (mWaitingUpdate) {
                return;
            }
            mDidUpdate = true;
        }
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    loadResourcesOnSystemReady();
    synchronized (this) {
        readGrantedUriPermissionsLocked();
    }
    if (goingCallback != null)
        goingCallback.run();
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mSystemServiceManager.startUser(mCurrentUserId);
    synchronized (this) {
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            try {
                List apps = AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
                if (apps != null) {
                    int N = apps.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        ApplicationInfo info = (ApplicationInfo) apps.get(i);
                        if (info != null && !info.packageName.equals("android")) {
                            addAppLocked(info, false, null);
                        }
                    }
                }
            } catch (RemoteException ex) {
            // pm is in same process, this will never happen.
            }
        }
        // Start up initial activity.
        mBooting = true;
        startHomeActivityLocked(mCurrentUserId, "systemReady");
        // start the power off alarm by boot mode
        boolean isAlarmBoot = SystemProperties.getBoolean("ro.alarm_boot", false);
        if (isAlarmBoot) {
            startAlarmActivityLocked();
        }
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, mCurrentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeTopActivitiesLocked();
        sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);
    }
}
#method_after
public void systemReady(final Runnable goingCallback) {
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        // Make sure we have the current profile info, since it is needed for
        // security checks.
        updateCurrentProfileIdsLocked();
        mRecentTasks.clear();
        mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());
        cleanupProtectedComponentTasksLocked();
        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
        mTaskPersister.startPersisting();
        // Check to see if there are any update receivers to run.
        if (!mDidUpdate) {
            if (mWaitingUpdate) {
                return;
            }
            final ArrayList<ComponentName> doneReceivers = new ArrayList<ComponentName>();
            mWaitingUpdate = deliverPreBootCompleted(new Runnable() {

                public void run() {
                    synchronized (ActivityManagerService.this) {
                        mDidUpdate = true;
                    }
                    showBootMessage(mContext.getText(R.string.android_upgrading_complete), false);
                    writeLastDonePreBootReceivers(doneReceivers);
                    systemReady(goingCallback);
                }
            }, doneReceivers, UserHandle.USER_OWNER);
            if (mWaitingUpdate) {
                return;
            }
            mDidUpdate = true;
        }
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    loadResourcesOnSystemReady();
    synchronized (this) {
        readGrantedUriPermissionsLocked();
    }
    if (goingCallback != null)
        goingCallback.run();
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mSystemServiceManager.startUser(mCurrentUserId);
    synchronized (this) {
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            try {
                List apps = AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
                if (apps != null) {
                    int N = apps.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        ApplicationInfo info = (ApplicationInfo) apps.get(i);
                        if (info != null && !info.packageName.equals("android")) {
                            addAppLocked(info, false, null);
                        }
                    }
                }
            } catch (RemoteException ex) {
            // pm is in same process, this will never happen.
            }
        }
        // Start up initial activity.
        mBooting = true;
        startHomeActivityLocked(mCurrentUserId, "systemReady");
        // start the power off alarm by boot mode
        boolean isAlarmBoot = SystemProperties.getBoolean("ro.alarm_boot", false);
        if (isAlarmBoot) {
            startAlarmActivityLocked();
        }
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, mCurrentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeTopActivitiesLocked();
        sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);
    }
}
#end_block

#method_before
private final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    if (userId != UserHandle.USER_ALL && !isUserRunningLocked(userId, false)) {
        if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " is stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    BroadcastOptions brOptions = null;
    if (options != null) {
        brOptions = new BroadcastOptions(options);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
    }
    /*
         * Prevent non-system code (defined here to be non-persistent
         * processes) from sending protected broadcasts.
         */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingAppId == Process.NFC_UID || callingUid == 0) {
    // Always okay.
    } else if (callerApp == null || !callerApp.persistent) {
        try {
            if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
                String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from pid=" + callingPid + ", uid=" + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
                // just limit it to the caller.
                if (callerApp == null) {
                    String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from unknown caller.";
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                } else if (intent.getComponent() != null) {
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
                        String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " to " + intent.getComponent().getPackageName() + " from " + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                } else {
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                }
            }
        } catch (RemoteException e) {
            Slog.w(TAG, "Remote exception", e);
            return ActivityManager.BROADCAST_SUCCESS;
        }
    }
    final String action = intent.getAction();
    if (action != null) {
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final Bundle intentExtras = intent.getExtras();
                        final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            boolean fullUninstall = removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            if (killProcess) {
                                forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                            }
                            if (removed) {
                                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                                    removeTasksByPackageNameLocked(ssp, userId);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_ADDED:
                // Special case for adding a package: by default turn on compatibility mode.
                Uri data = intent.getData();
                String ssp;
                if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                    final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                    try {
                        ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
                        mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                    } catch (RemoteException e) {
                    }
                }
                break;
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // If the user set the time, let all running processes know.
                final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1 : 0;
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
                break;
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mStartedUserArray;
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            UserManagerService ums = getUserManagerLocked();
            for (int i = 0; i < users.length; i++) {
                if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // If we are not serializing this broadcast, then send the
        // registered receivers separately so they don't wait for the
        // components to be launched.
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#method_after
private final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    if (userId != UserHandle.USER_ALL && !isUserRunningLocked(userId, false)) {
        if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " is stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    BroadcastOptions brOptions = null;
    if (options != null) {
        brOptions = new BroadcastOptions(options);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
    }
    /*
         * Prevent non-system code (defined here to be non-persistent
         * processes) from sending protected broadcasts.
         */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingAppId == Process.NFC_UID || callingUid == 0) {
    // Always okay.
    } else if (callerApp == null || !callerApp.persistent) {
        try {
            if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
                String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from pid=" + callingPid + ", uid=" + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
                // just limit it to the caller.
                if (callerApp == null) {
                    String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from unknown caller.";
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                } else if (intent.getComponent() != null) {
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
                        String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " to " + intent.getComponent().getPackageName() + " from " + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                } else {
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                }
            }
        } catch (RemoteException e) {
            Slog.w(TAG, "Remote exception", e);
            return ActivityManager.BROADCAST_SUCCESS;
        }
    }
    final String action = intent.getAction();
    if (action != null) {
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final Bundle intentExtras = intent.getExtras();
                        final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            boolean fullUninstall = removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            if (killProcess) {
                                forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                            }
                            if (removed) {
                                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                                    removeTasksByPackageNameLocked(ssp, userId);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_ADDED:
                // Special case for adding a package: by default turn on compatibility mode.
                Uri data = intent.getData();
                String ssp;
                if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                    final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                    try {
                        ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
                        mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                    } catch (RemoteException e) {
                    }
                }
                break;
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // If the user set the time, let all running processes know.
                final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1 : 0;
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
                break;
            case cyanogenmod.content.Intent.ACTION_PROTECTED_CHANGED:
                final boolean state = intent.getBooleanExtra(cyanogenmod.content.Intent.EXTRA_PROTECTED_STATE, false);
                if (state == PackageManager.COMPONENT_PROTECTED_STATUS) {
                    cleanupProtectedComponentTasksLocked();
                }
                break;
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mStartedUserArray;
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            UserManagerService ums = getUserManagerLocked();
            for (int i = 0; i < users.length; i++) {
                if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // If we are not serializing this broadcast, then send the
        // registered receivers separately so they don't wait for the
        // components to be launched.
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#end_block

#method_before
private void updateDisableDucking() {
    if (!mSystemReady) {
        return;
    }
    final MediaSessionManager mediaSessionManager = (MediaSessionManager) getContext().getSystemService(Context.MEDIA_SESSION_SERVICE);
    mediaSessionManager.removeOnActiveSessionsChangedListener(mSessionListener);
    resetControllerCallbacks();
    if (mDisableDuckingWhileMedia) {
        mediaSessionManager.addOnActiveSessionsChangedListener(mSessionListener, null);
    }
}
#method_after
private void updateDisableDucking() {
    if (!mSystemReady) {
        return;
    }
    try {
        getContext().unregisterReceiver(mMediaSessionReceiver);
    } catch (IllegalArgumentException e) {
    // Never registered
    }
    if (mDisableDuckingWhileMedia) {
        updateForActiveSessions();
        IntentFilter intentFilter = new IntentFilter(CMAudioManager.ACTION_AUDIO_SESSIONS_CHANGED);
        getContext().registerReceiver(mMediaSessionReceiver, intentFilter);
    }
}
#end_block

#method_before
@Override
public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) {
    switch(attrs.type) {
        case TYPE_SYSTEM_OVERLAY:
        case TYPE_SECURE_SYSTEM_OVERLAY:
            // These types of windows can't receive input events.
            attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            attrs.flags &= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
            break;
        case TYPE_STATUS_BAR:
            // See {@link #processKeyguardSetHiddenResultLw}.
            if (mKeyguardHidden) {
                attrs.flags &= ~WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
                attrs.privateFlags &= ~WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
            }
            break;
    }
    if (attrs.type != TYPE_STATUS_BAR) {
        // The status bar is the only window allowed to exhibit keyguard behavior.
        attrs.privateFlags &= ~WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
    }
    if (ActivityManager.isHighEndGfx() && (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0) {
        attrs.subtreeSystemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
    }
    if ((attrs.privateFlags & (WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_SYSTEM_KEYS | WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY)) != 0) {
        mContext.enforceCallingOrSelfPermission("android.permission.PREVENT_SYSTEM_KEYS", "No permission to prevent system key");
    }
}
#method_after
@Override
public void adjustWindowParamsLw(WindowManager.LayoutParams attrs) {
    switch(attrs.type) {
        case TYPE_SYSTEM_OVERLAY:
        case TYPE_SECURE_SYSTEM_OVERLAY:
            // These types of windows can't receive input events.
            attrs.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            attrs.flags &= ~WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;
            break;
        case TYPE_STATUS_BAR:
            // See {@link #processKeyguardSetHiddenResultLw}.
            if (mKeyguardHidden) {
                attrs.flags &= ~WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
                attrs.privateFlags &= ~WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
            }
            break;
    }
    if (attrs.type != TYPE_STATUS_BAR) {
        // The status bar is the only window allowed to exhibit keyguard behavior.
        attrs.privateFlags &= ~WindowManager.LayoutParams.PRIVATE_FLAG_KEYGUARD;
    }
    if (ActivityManager.isHighEndGfx() && (attrs.flags & FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) != 0) {
        attrs.subtreeSystemUiVisibility |= View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
    }
    if ((attrs.privateFlags & (WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_SYSTEM_KEYS | WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY)) != 0) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.PREVENT_SYSTEM_KEYS, "No permission to prevent system key");
    }
}
#end_block

#method_before
void getTasksLocked(List<RunningTaskInfo> list, int callingUid, boolean allowed) {
    boolean focusedStack = mStackSupervisor.getFocusedStack() == this;
    boolean topTask = true;
    for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
        final TaskRecord task = mTaskHistory.get(taskNdx);
        if (task.getTopActivity() == null) {
            continue;
        }
        ActivityRecord r = null;
        ActivityRecord top = null;
        ActivityRecord tmp;
        int numActivities = 0;
        int numRunning = 0;
        final ArrayList<ActivityRecord> activities = task.mActivities;
        if (!allowed && !task.isHomeTask() && task.effectiveUid != callingUid) {
            continue;
        }
        for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
            tmp = activities.get(activityNdx);
            if (tmp.finishing) {
                continue;
            }
            r = tmp;
            // Initialize state for next task if needed.
            if (top == null || (top.state == ActivityState.INITIALIZING)) {
                top = r;
                numActivities = numRunning = 0;
            }
            // Add 'r' into the current task.
            numActivities++;
            if (r.app != null && r.app.thread != null) {
                numRunning++;
            }
            if (DEBUG_ALL)
                Slog.v(TAG, r.intent.getComponent().flattenToShortString() + ": task=" + r.task);
        }
        RunningTaskInfo ci = new RunningTaskInfo();
        ci.id = task.taskId;
        ci.baseActivity = r.intent.getComponent();
        ci.topActivity = top.intent.getComponent();
        ci.lastActiveTime = task.lastActiveTime;
        if (focusedStack && topTask) {
            // Give the latest time to ensure foreground task can be sorted
            // at the first, because lastActiveTime of creating task is 0.
            // Maybe The user changed the time.
            // When this happened ,don't update lastActiveTime.
            long currentTime = System.currentTimeMillis();
            if (ci.lastActiveTime < currentTime) {
                ci.lastActiveTime = currentTime;
            }
            topTask = false;
        }
        if (top.task != null) {
            ci.description = top.task.lastDescription;
        }
        ci.numActivities = numActivities;
        ci.numRunning = numRunning;
        list.add(ci);
    }
}
#method_after
void getTasksLocked(List<RunningTaskInfo> list, int callingUid, boolean allowed) {
    boolean focusedStack = mStackSupervisor.getFocusedStack() == this;
    boolean topTask = true;
    for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
        final TaskRecord task = mTaskHistory.get(taskNdx);
        if (task.getTopActivity() == null) {
            continue;
        }
        ActivityRecord r = null;
        ActivityRecord top = null;
        ActivityRecord tmp;
        int numActivities = 0;
        int numRunning = 0;
        final ArrayList<ActivityRecord> activities = task.mActivities;
        if (!allowed && !task.isHomeTask() && task.effectiveUid != callingUid) {
            continue;
        }
        for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
            tmp = activities.get(activityNdx);
            if (tmp.finishing) {
                continue;
            }
            r = tmp;
            // Initialize state for next task if needed.
            if (top == null || (top.state == ActivityState.INITIALIZING)) {
                top = r;
                numActivities = numRunning = 0;
            }
            // Add 'r' into the current task.
            numActivities++;
            if (r.app != null && r.app.thread != null) {
                numRunning++;
            }
            if (DEBUG_ALL)
                Slog.v(TAG, r.intent.getComponent().flattenToShortString() + ": task=" + r.task);
        }
        RunningTaskInfo ci = new RunningTaskInfo();
        ci.id = task.taskId;
        ci.baseActivity = r.intent.getComponent();
        ci.topActivity = top.intent.getComponent();
        ci.lastActiveTime = task.lastActiveTime;
        if (focusedStack && topTask) {
            // Give the latest time to ensure foreground task can be sorted
            // at the first, because lastActiveTime of creating task is 0.
            // Only do this if the clock didn't run backwards, though.
            ci.lastActiveTime = Math.max(ci.lastActiveTime, System.currentTimeMillis());
            topTask = false;
        }
        if (top.task != null) {
            ci.description = top.task.lastDescription;
        }
        ci.numActivities = numActivities;
        ci.numRunning = numRunning;
        list.add(ci);
    }
}
#end_block

