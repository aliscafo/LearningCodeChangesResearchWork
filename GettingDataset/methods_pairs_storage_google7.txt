891
#method_before
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToOneNode(String project, String ref, URIish uri, RefPushResult status) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replicate ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" to ");
    sb.append(resolveNodeName(uri));
    sb.append(", ");
    switch(status) {
        case SUCCEEDED:
            sb.append("Succeeded!");
            break;
        case FAILED:
            sb.append("FAILED!");
            hasError.compareAndSet(false, true);
            break;
        case NOT_ATTEMPTED:
            sb.append("NOT ATTEMPTED!");
            break;
        default:
            sb.append("UNKNOWN RESULT!");
            break;
    }
    writeStdOut(sb.toString());
}
#end_block

#method_before
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#method_after
@Override
void onRefReplicatedToAllNodes(String project, String ref, int nodesCount) {
    StringBuilder sb = new StringBuilder();
    sb.append("Replication of ");
    sb.append(project);
    sb.append(" ref ");
    sb.append(ref);
    sb.append(" completed to ");
    sb.append(nodesCount);
    sb.append(" nodes, ");
    writeStdOut(sb.toString());
}
#end_block

#method_before
public void increasePushTaskCount(String project, String ref) {
    getRefReplicationInfo(project, ref).nodesToReplicateCount.incrementAndGet();
    totalPushTasksCount.incrementAndGet();
}
#method_after
public void increasePushTaskCount(String project, String ref) {
    countingLock.lock();
    try {
        getRefStatus(project, ref).nodesToReplicateCount++;
        totalPushTasksCount++;
    } finally {
        countingLock.unlock();
    }
}
#end_block

#method_before
public boolean hasPushTask() {
    return totalPushTasksCount.get() != 0;
}
#method_after
public boolean hasPushTask() {
    return totalPushTasksCount != 0;
}
#end_block

#method_before
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationInfo refReplicationInfo = getRefReplicationInfo(project, ref);
    refReplicationInfo.replicatedNodesCount.incrementAndGet();
    if (allScheduled && refReplicationInfo.nodesToReplicateCount.get() == refReplicationInfo.replicatedNodesCount.get()) {
        fireOnRefReplicatedToAllNodes(project, ref);
    }
    finishedPushTasksCount.incrementAndGet();
    verifyAllPushTasksCompleted();
}
#method_after
public void notifyRefReplicated(String project, String ref, URIish uri, RefPushResult status) {
    pushResultProcessing.onRefReplicatedToOneNode(project, ref, uri, status);
    RefReplicationStatus completedRefStatus = null;
    boolean allPushTaksCompleted = false;
    countingLock.lock();
    try {
        RefReplicationStatus refStatus = getRefStatus(project, ref);
        refStatus.replicatedNodesCount++;
        finishedPushTasksCount++;
        if (allScheduled) {
            if (refStatus.allDone()) {
                completedRefStatus = statusByProjectRef.remove(project, ref);
            }
            allPushTaksCompleted = finishedPushTasksCount == totalPushTasksCount;
        }
    } finally {
        countingLock.unlock();
    }
    if (completedRefStatus != null) {
        doRefPushTasksCompleted(completedRefStatus);
    }
    if (allPushTaksCompleted) {
        doAllPushTasksCompleted();
    }
}
#end_block

#method_before
public void markAllPushTasksScheduled() {
    allScheduled = true;
    verifyAllPushTasksCompleted();
}
#method_after
public void markAllPushTasksScheduled() {
    countingLock.lock();
    try {
        allScheduled = true;
        if (finishedPushTasksCount < totalPushTasksCount) {
            return;
        }
    } finally {
        countingLock.unlock();
    }
    doAllPushTasksCompleted();
}
#end_block

#method_before
private void fireRemainingOnRefReplicatedToAllNodes() {
    // Some could be remaining if replication of a ref is completed before all tasks are scheduled
    for (SimpleEntry<String, String> projectRefKey : replicationInfoPerProjectRef.keySet()) {
        fireOnRefReplicatedToAllNodes(projectRefKey.getKey(), projectRefKey.getValue());
    }
}
#method_after
private void fireRemainingOnRefReplicatedToAllNodes() {
    for (RefReplicationStatus refStatus : statusByProjectRef.values()) {
        doRefPushTasksCompleted(refStatus);
    }
}
#end_block

#method_before
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToStrict(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireOneReplicationEventWhenNothingToReplicate() {
    resetToDefault(pushResultProcessingMock);
    // expected event
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(0);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.markAllPushTasksScheduled();
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToOneNode() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri = new URIish("git://someHost/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 1);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(1);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri, RefPushResult.SUCCEEDED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToStrict(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#method_after
@Test
public void shouldFireEventsForReplicationOfOneRefToMultipleNodes() throws URISyntaxException {
    resetToDefault(pushResultProcessingMock);
    URIish uri1 = new URIish("git://someHost1/someRepo.git");
    URIish uri2 = new URIish("git://someHost2/someRepo.git");
    // expected events
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    pushResultProcessingMock.onRefReplicatedToOneNode("someProject", "someRef", uri2, RefPushResult.FAILED);
    pushResultProcessingMock.onRefReplicatedToAllNodes("someProject", "someRef", 2);
    pushResultProcessingMock.onAllRefsReplicatedToAllNodes(2);
    replay(pushResultProcessingMock);
    // actual test
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.increasePushTaskCount("someProject", "someRef");
    replicationState.markAllPushTasksScheduled();
    replicationState.notifyRefReplicated("someProject", "someRef", uri1, RefPushResult.SUCCEEDED);
    replicationState.notifyRefReplicated("someProject", "someRef", uri2, RefPushResult.FAILED);
    verify(pushResultProcessingMock);
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final DocInfo item) {
    return item.url();
}
#method_after
@Override
protected Object getRowItemKey(DocInfo item) {
    return item.url();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final DocInfo d = getRowItem(row);
    Gerrit.display("/" + d.url());
}
#method_after
@Override
protected void onOpenRow(int row) {
    DocInfo d = getRowItem(row);
    Window.Location.assign(d.getFullUrl());
}
#end_block

#method_before
private void insertNoneRow(final int row) {
    insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setColSpan(row, 0, columns);
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#method_after
private void insertNoneRow(int row) {
    table.insertRow(row);
    table.setText(row, 0, Util.C.docTableNone());
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.setStyleName(row, 0, Gerrit.RESOURCES.css().emptySection());
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#method_after
@Override
protected void applyDataRowStyle(int row) {
    super.applyDataRowStyle(row);
    CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_TITLE, Gerrit.RESOURCES.css().cSUBJECT());
}
#end_block

#method_before
private void populateDocRow(final int row, final DocInfo d) {
    String title = com.google.gerrit.client.changes.Util.cropSubject(d.title());
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#method_after
private void populateDocRow(int row, DocInfo d) {
    table.setWidget(row, C_TITLE, new DocLink(d));
    setRowItem(row, d);
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/doc/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void docSearch(final String token) {
    Gerrit.display(token, new DocScreen(skip(token)));
}
#method_after
private static void docSearch(final String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, new DocScreen(skip(token)));
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable() {

        {
            keysNavigation.add(new KeyCommand(0, 'R', Util.C.keyReloadSearch()) {

                @Override
                public void onKeyPress(final KeyPressEvent event) {
                    Gerrit.display(getToken());
                }
            });
        }
    };
    section = new DocTable.Section();
    table.addSection(section);
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    table = new DocTable();
    table.setSavePointerId(query);
    add(table);
    setWindowTitle(Util.M.docQueryWindowTitle(query));
    setPageTitle(Util.M.docQueryPageTitle(query));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    docs.query(loadCallback(), query);
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    doQuery();
}
#end_block

#method_before
protected AsyncCallback<DocList> loadCallback() {
    return new GerritCallback<DocList>() {

        @Override
        public final void onSuccess(DocList result) {
            display(result);
            DocScreen.this.display();
        }
    };
}
#method_after
private AsyncCallback<JsArray<DocInfo>> loadCallback() {
    return new GerritCallback<JsArray<DocInfo>>() {

        @Override
        public void onSuccess(JsArray<DocInfo> result) {
            displayResults(result);
            display();
        }
    };
}
#end_block

#method_before
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX + PLUGINS_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#method_after
@Override
public synchronized void init(ServletConfig config) throws ServletException {
    super.init(config);
    String path = config.getServletContext().getContextPath();
    base = Strings.nullToEmpty(path) + PLUGINS_PREFIX;
    authorizedBase = Strings.nullToEmpty(path) + AUTHORIZED_PREFIX;
    for (Plugin plugin : pending) {
        install(plugin);
    }
    pending = null;
}
#end_block

#method_before
private boolean isAuthorizedCall(HttpServletRequest req) {
    if (Strings.isNullOrEmpty(req.getServletPath())) {
        return false;
    }
    if (AUTHORIZED_PATTERN.matcher(req.getServletPath()).matches()) {
        return true;
    }
    return false;
}
#method_after
private boolean isAuthorizedCall(HttpServletRequest req) {
    return !Strings.isNullOrEmpty(req.getServletPath()) && req.getServletPath().startsWith(AUTHORIZED_PREFIX);
}
#end_block

#method_before
private File getSiteFromReviewDb(Connection conn) {
    try {
        Statement stmt = conn.createStatement();
        try {
            ResultSet rs = stmt.executeQuery("SELECT site_path FROM system_config");
            try {
                if (rs.next()) {
                    return new File(rs.getString(1));
                }
            } finally {
                rs.close();
            }
        } finally {
            stmt.close();
        }
        return null;
    } catch (SQLException e) {
        return null;
    }
}
#method_after
private File getSiteFromReviewDb(Connection conn) {
    try {
        Statement stmt = conn.createStatement();
        try {
            ResultSet rs = stmt.executeQuery("SELECT site_path FROM system_config");
            if (rs.next()) {
                return new File(rs.getString(1));
            }
        } finally {
            stmt.close();
        }
        return null;
    } catch (SQLException e) {
        return null;
    }
}
#end_block

#method_before
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        throw new ServiceMayNotContinueException().initCause(e);
    }
}
#method_after
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repository, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        return filter(repository.getRefDatabase().getRefs(RefDatabase.ALL));
    } catch (ServiceMayNotContinueException e) {
        throw e;
    } catch (IOException e) {
        ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
        ex.initCause(e);
        throw ex;
    }
}
#end_block

#method_before
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            throw new ServiceMayNotContinueException().initCause(e);
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#method_after
@Override
public void advertiseRefs(BaseReceivePack rp) throws ServiceMayNotContinueException {
    Map<String, Ref> oldRefs = rp.getAdvertisedRefs();
    if (oldRefs == null) {
        try {
            oldRefs = rp.getRepository().getRefDatabase().getRefs(ALL);
        } catch (ServiceMayNotContinueException e) {
            throw e;
        } catch (IOException e) {
            ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
            ex.initCause(e);
            throw ex;
        }
    }
    Map<String, Ref> r = Maps.newHashMapWithExpectedSize(oldRefs.size());
    for (Map.Entry<String, Ref> e : oldRefs.entrySet()) {
        String name = e.getKey();
        if (!skip(name)) {
            r.put(name, e.getValue());
        }
    }
    rp.setAdvertisedRefs(r, advertiseHistory(r.values(), rp));
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, ProjectsTable.C_GIT_WEB_LINK, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, ProjectsTable.C_GIT_WEB_LINK, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, ProjectsTable.C_GIT_WEB_LINK, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), subname));
            table.setWidget(row, ProjectsTable.C_NAME, fp);
            table.setText(row, ProjectsTable.C_DESCRIPTION, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, ProjectsTable.C_GIT_WEB_LINK, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, ProjectsTable.C_REPO_BROWSER, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), subname));
            table.setWidget(row, ProjectsTable.C_NAME, fp);
            table.setText(row, ProjectsTable.C_DESCRIPTION, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, ProjectsTable.C_REPO_BROWSER, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        shellInjector = createShellInjector();
        manager.add(dbInjector, cfgInjector, sysInjector, shellInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (shell) {
            InteractiveShell interp = shellInjector.getInstance(InteractiveShell.class);
            interp.set("m", manager);
            interp.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = new File(new File(getSitePath(), "logs"), "gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    if (slave && httpd) {
        throw die("Cannot combine --slave and --enable-httpd");
    }
    manager.add(GarbageCollectionLogFile.start(getSitePath()));
    if (consoleLog) {
    } else {
        manager.add(ErrorLogFile.start(getSitePath()));
    }
    try {
        dbInjector = createDbInjector(MULTI_USER);
        cfgInjector = createCfgInjector();
        sysInjector = createSysInjector();
        sysInjector.getInstance(PluginGuiceEnvironment.class).setCfgInjector(cfgInjector);
        manager.add(dbInjector, cfgInjector, sysInjector);
        if (sshd) {
            initSshd();
        }
        if (httpd) {
            initHttpd();
        }
        manager.start();
        RuntimeShutdown.add(new Runnable() {

            @Override
            public void run() {
                log.info("caught shutdown, cleaning up");
                if (runId != null) {
                    runFile.delete();
                }
                manager.stop();
            }
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                runFile.createNewFile();
                runFile.setReadable(true, false);
                FileOutputStream out = new FileOutputStream(runFile);
                try {
                    out.write((runId + "\n").getBytes("UTF-8"));
                } finally {
                    out.close();
                }
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new EhcachePoolImpl.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PushReplication.Module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getIndexType(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule();
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initSshd() {
    sshInjector = createSshInjector();
    manager.add(sshInjector);
}
#method_after
private void initSshd() {
    sshInjector = createSshInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setSshInjector(sshInjector);
    manager.add(sshInjector);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new SshModule());
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(sysInjector.getInstance(SshModule.class));
        if (slave) {
            modules.add(new SlaveCommandModule());
        } else {
            modules.add(new MasterCommandModule());
        }
    } else {
        modules.add(new NoSshModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#method_after
private void initHttpd() {
    webInjector = createWebInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setHttpInjector(webInjector);
    sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
    httpdInjector = createHttpdInjector();
    manager.add(webInjector, httpdInjector);
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
        modules.add(new ProjectQoSFilter.Module());
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<Module>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(AllRequestFilter.module());
    modules.add(CacheBasedWebSession.module());
    modules.add(HttpContactStoreConnection.module());
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
protected Object runMethod0(Class klazz, Object instance, String name, Class[] sig, Object[] args) throws InvocationTargetException {
    Method interpMethod;
    try {
        interpMethod = klazz.getMethod(name, sig);
        return interpMethod.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod0(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) throws InvocationTargetException {
    try {
        Method m;
        m = klazz.getMethod(name, sig);
        return m.invoke(instance, args);
    } catch (NoSuchMethodException e) {
        throw cannotStart(e);
    } catch (SecurityException e) {
        throw cannotStart(e);
    } catch (IllegalArgumentException e) {
        throw cannotStart(e);
    } catch (IllegalAccessException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runMethod(Class klazz, Object instance, String name, Class[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#method_after
protected Object runMethod(Class<?> klazz, Object instance, String name, Class<?>[] sig, Object[] args) {
    try {
        return runMethod0(klazz, instance, name, sig, args);
    } catch (InvocationTargetException e) {
        throw cannotStart(e);
    }
}
#end_block

#method_before
protected Object runInterpreter(String name, Class[] sig, Object[] args) {
    return runMethod(console, interp, name, sig, args);
}
#method_after
protected Object runInterpreter(String name, Class<?>[] sig, Object[] args) {
    return runMethod(console, shell, name, sig, args);
}
#end_block

#method_before
private static Class findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#method_after
private static Class<?> findClass(String klazzname) {
    try {
        return Class.forName(klazzname);
    } catch (ClassNotFoundException e) {
        throw noShell("Class " + klazzname + " not found", e);
    }
}
#end_block

#method_before
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, interp, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#method_after
protected void execFile(final File parent, final String p) {
    try {
        File script = new File(parent, p);
        if (script.canExecute()) {
            runMethod0(console, shell, "execfile", new Class[] { String.class }, new Object[] { script.getAbsolutePath() });
        } else {
            log.info("User initialization file " + script.getAbsolutePath() + " is not found or not executable");
        }
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading file " + p + " : ", e);
    } catch (SecurityException e) {
        log.error("SecurityException occured while loading file " + p + " : ", e);
    }
}
#end_block

#method_before
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, interp, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#method_after
protected void execStream(final InputStream in, final String p) {
    try {
        runMethod0(console, shell, "execfile", new Class[] { InputStream.class, String.class }, new Object[] { in, p });
    } catch (InvocationTargetException e) {
        log.error("Exception occured while loading " + p + " : ", e);
    }
}
#end_block

#method_before
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final ArrayList<URL> jars = new ArrayList<URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith("WEB-INF/lib/")) {
                    final File tmp = createTempFile(safeName(ze), ".jar");
                    final FileOutputStream out = new FileOutputStream(tmp);
                    try {
                        final InputStream in = zf.getInputStream(ze);
                        try {
                            final byte[] buf = new byte[4096];
                            int n;
                            while ((n = in.read(buf, 0, buf.length)) > 0) {
                                out.write(buf, 0, n);
                            }
                        } finally {
                            in.close();
                        }
                    } finally {
                        out.close();
                    }
                    jars.add(tmp.toURI().toURL());
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    Collections.sort(jars, new Comparator<URL>() {

        public int compare(URL o1, URL o2) {
            return o1.toString().compareTo(o2.toString());
        }
    });
    return new URLClassLoader(jars.toArray(new URL[jars.size()]));
}
#method_after
private static ClassLoader libClassLoader() throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED == e.getMessage()) {
            // 
            return GerritLauncher.class.getClassLoader();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<String, URL>();
    try {
        final ZipFile zf = new ZipFile(path);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                } else if (ze.getName().startsWith("WEB-INF/lib/")) {
                    extractJar(zf, ze, jars);
                } else if (ze.getName().startsWith("WEB-INF/pgm-lib/")) {
                    extractJar(zf, ze, jars);
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<URL>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#end_block

#method_before
private static File tmproot() {
    // Use $HOME/.gerritcodereview/tmp for our temporary file area.
    // 
    final File tmp = new File(getHomeDirectory(), "tmp");
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#method_after
private static File tmproot() {
    File tmp;
    String gerritTemp = System.getenv("GERRIT_TMP");
    if (gerritTemp != null && gerritTemp.length() > 0) {
        tmp = new File(gerritTemp);
    } else {
        tmp = new File(getHomeDirectory(), "tmp");
    }
    if (!tmp.exists() && !tmp.mkdirs()) {
        System.err.println("warning: cannot create " + tmp.getAbsolutePath());
        System.err.println("warning: using system temporary directory instead");
        return null;
    }
    // Try to clean up any stale empty directories. Assume any empty
    // directory that is older than 7 days is one of these dead ones
    // that we can clean up.
    // 
    final File[] tmpEntries = tmp.listFiles();
    if (tmpEntries != null) {
        final long now = System.currentTimeMillis();
        final long expired = now - MILLISECONDS.convert(7, DAYS);
        for (final File tmpEntry : tmpEntries) {
            if (tmpEntry.isDirectory() && tmpEntry.lastModified() < expired) {
                final String[] all = tmpEntry.list();
                if (all == null || all.length == 0) {
                    tmpEntry.delete();
                }
            }
        }
    }
    try {
        return tmp.getCanonicalFile();
    } catch (IOException e) {
        return tmp;
    }
}
#end_block

#method_before
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s: %s", docResult.title, docResult.url));
    }
}
#method_after
@Override
public void run() throws Exception {
    List<QueryDocumentationExecutor.DocResult> res = searcher.doQuery(q);
    for (DocResult docResult : res) {
        stdout.println(String.format("%s:\n%s%s\n", docResult.title, url, docResult.url));
    }
}
#end_block

#method_before
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Not initialized");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#method_after
public List<DocResult> doQuery(String q) throws DocQueryException {
    if (parser == null || searcher == null) {
        throw new DocQueryException("Documentation search not available");
    }
    try {
        Query query = parser.parse(q);
        TopDocs results = searcher.search(query, Integer.MAX_VALUE);
        ScoreDoc[] hits = results.scoreDocs;
        int totalHits = results.totalHits;
        List<DocResult> out = Lists.newArrayListWithCapacity(totalHits);
        for (int i = 0; i < totalHits; i++) {
            DocResult result = new DocResult();
            Document doc = searcher.doc(hits[i].doc);
            result.url = doc.get(Constants.URL_FIELD);
            result.title = doc.get(Constants.TITLE_FIELD);
            out.add(result);
        }
        return out;
    } catch (IOException e) {
        throw new DocQueryException(e);
    } catch (ParseException e) {
        throw new DocQueryException(e);
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    bind(DocQueryProcessor.class).to(DocQueryLucene.class);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?docsearch/(.*)$").with(DocSearchRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?tools/(.*)$").with(ToolServlet.class);
    serveRegex("^/(?:a/)?access/(.*)$").with(AccessRestApiServlet.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?config/(.*)$").with(ConfigRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    filter("/Documentation/").through(QueryDocumentationFilter.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
    serve("/robots.txt").with(RobotsServlet.class);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DocQueryLucene.DOC_FIELD, reader));
        doc.add(new StringField(DocQueryLucene.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(DocQueryLucene.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    if (meta == null) {
        emptyFile = true;
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(String.valueOf(r._number()), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r._number() == revision.get()) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(String.valueOf(r._number()), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r._number() == revision.get()) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
}
#end_block

#method_before
private Anchor createDownloadLink() {
    if (Patch.COMMIT_MSG.equals(path) || emptyFile) {
        return null;
    }
    PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
    String sideURL = (idActive == null) ? "1" : "0";
    String base = GWT.getHostPageBaseURL() + "cat/";
    Image image = new Image(Gerrit.RESOURCES.downloadIcon());
    Anchor anchor = new Anchor();
    anchor.setHref(base + KeyUtil.encode(id.toString() + "," + path) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    DOM.insertBefore(anchor.getElement(), image.getElement(), DOM.getFirstChild(anchor.getElement()));
    return anchor;
}
#method_after
private Anchor createDownloadLink() {
    PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
    String sideURL = (idActive == null) ? "1" : "0";
    String base = GWT.getHostPageBaseURL() + "cat/";
    Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.downloadIcon()), base + KeyUtil.encode(id + "," + path) + "^" + sideURL);
    anchor.setTitle(PatchUtil.C.download());
    return anchor;
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, UnprocessableEntityException, IOException {
    ProjectControl ctl = rsrc.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!user.getCapabilities().canAdministrateServer()) {
        throw new AuthException("not administrator");
    }
    if (rsrc.getNameKey().equals(allProjects)) {
        throw new ResourceConflictException("cannot set parent of " + allProjects.get());
    }
    input.parent = Strings.emptyToNull(input.parent);
    if (input.parent != null) {
        ProjectState parent = cache.get(new Project.NameKey(input.parent));
        if (parent == null) {
            throw new UnprocessableEntityException("parent project " + input.parent + " not found");
        }
        Set<Project.NameKey> grandParents = getGrandParents(parent.getProject());
        if (grandParents.contains(rsrc.getNameKey()) || rsrc.getNameKey().equals(parent.getProject().getNameKey())) {
            throw new ResourceConflictException("cycle exists between " + rsrc.getName() + " and " + parent.getProject().getName());
        }
    }
    try {
        MetaDataUpdate md = updateFactory.create(rsrc.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setParentName(input.parent);
            String msg = Strings.emptyToNull(input.commitMessage);
            if (msg == null) {
                msg = String.format("Changed parent to %s.\n", Objects.firstNonNull(project.getParentName(), allProjects.get()));
            } else if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            config.commit(md);
            cache.evict(ctl.getProject());
            Project.NameKey parentName = project.getParent(allProjects);
            return parentName != null ? parentName.get() : "";
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(rsrc.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#method_after
@Override
public String apply(final ProjectResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, UnprocessableEntityException, IOException {
    ProjectControl ctl = rsrc.getControl();
    IdentifiedUser user = (IdentifiedUser) ctl.getCurrentUser();
    if (!user.getCapabilities().canAdministrateServer()) {
        throw new AuthException("not administrator");
    }
    if (rsrc.getNameKey().equals(allProjects)) {
        throw new ResourceConflictException("cannot set parent of " + allProjects.get());
    }
    input.parent = Strings.emptyToNull(input.parent);
    if (input.parent != null) {
        ProjectState parent = cache.get(new Project.NameKey(input.parent));
        if (parent == null) {
            throw new UnprocessableEntityException("parent project " + input.parent + " not found");
        }
        if (Iterables.tryFind(parent.tree(), new Predicate<ProjectState>() {

            @Override
            public boolean apply(ProjectState input) {
                return input.getProject().getNameKey().equals(rsrc.getNameKey());
            }
        }).isPresent()) {
            throw new ResourceConflictException("cycle exists between " + rsrc.getName() + " and " + parent.getProject().getName());
        }
    }
    try {
        MetaDataUpdate md = updateFactory.create(rsrc.getNameKey());
        try {
            ProjectConfig config = ProjectConfig.read(md);
            Project project = config.getProject();
            project.setParentName(input.parent);
            String msg = Strings.emptyToNull(input.commitMessage);
            if (msg == null) {
                msg = String.format("Changed parent to %s.\n", Objects.firstNonNull(project.getParentName(), allProjects.get()));
            } else if (!msg.endsWith("\n")) {
                msg += "\n";
            }
            md.setAuthor(user);
            md.setMessage(msg);
            config.commit(md);
            cache.evict(ctl.getProject());
            Project.NameKey parentName = project.getParent(allProjects);
            return parentName != null ? parentName.get() : "";
        } finally {
            md.close();
        }
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(rsrc.getName());
    } catch (ConfigInvalidException e) {
        throw new ResourceConflictException(String.format("invalid project.config: %s", e.getMessage()));
    }
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                ChangeResource rsrc = new ChangeResource(changeControlFactory.controlFor(d.getChange()));
                eventFactory.currentreviewers(c, rsrc, includeApprovals ? d.approvalsMap(db).asMap() : null);
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (isDisabled()) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStatsAttribute stats = new QueryStatsAttribute();
            stats.runTimeMilliseconds = TimeUtil.nowMs();
            List<ChangeData> results = queryChanges(queryString);
            ChangeAttribute c = null;
            for (ChangeData d : results) {
                LabelTypes labelTypes = changeControlFactory.controlFor(d.getChange()).getLabelTypes();
                c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includeAllReviewers) {
                    eventFactory.addAllReviewers(c, d.getChange());
                }
                if (includeSubmitRecords) {
                    PatchSet.Id psId = d.getChange().currentPatchSetId();
                    PatchSet patchSet = db.get().patchSets().get(psId);
                    List<SubmitRecord> submitResult = // 
                    d.changeControl().canSubmit(db.get(), patchSet, null, false, true, true);
                    eventFactory.addSubmitRecords(c, submitResult);
                }
                if (includeCommitMessage) {
                    eventFactory.addCommitMessage(c, d.commitMessage(repoManager, db));
                }
                if (includePatchSets) {
                    if (includeFiles) {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, includeFiles, d.change(db), labelTypes);
                    } else {
                        eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db).asMap() : null, labelTypes);
                    }
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        eventFactory.addApprovals(c.currentPatchSet, d.currentApprovals(db), labelTypes);
                        if (includeFiles) {
                            eventFactory.addPatchSetFileNames(c.currentPatchSet, d.change(db), d.currentPatchSet(db));
                        }
                    }
                }
                if (includeComments) {
                    eventFactory.addComments(c, d.messages(db));
                    if (includePatchSets) {
                        for (PatchSetAttribute attribute : c.patchSets) {
                            eventFactory.addPatchSetComments(attribute, d.comments(db));
                        }
                    }
                }
                if (includeDependencies) {
                    eventFactory.addDependencies(c, d.getChange());
                }
                show(c);
            }
            stats.rowCount = results.size();
            if (moreResults) {
                stats.resumeSortKey = c.sortKey;
            }
            stats.runTimeMilliseconds = TimeUtil.nowMs() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        } catch (NoSuchChangeException e) {
            log.error("Missing change: " + e.getMessage(), e);
            ErrorMessage m = new ErrorMessage();
            m.message = "missing change " + e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), DownloadScheme.class);
    DynamicSet.setOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setInnerText(revision);
    formatLink(commit.author(), authorNameEmail, authorDate, change.owner(), change.status());
    format(commit.committer(), committerNameEmail, committerDate);
    commitMessageText.setInnerSafeHtml(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setInnerText(revision);
    formatLink(commit.author(), authorNameEmail, authorDate, change.status());
    formatLink(commit.committer(), committerNameEmail, committerDate, change.status());
    commitMessageText.setInnerSafeHtml(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    GitwebLink gw = Gerrit.getGitwebLink();
    if (gw != null && gw.canLink(revInfo)) {
        browserLink.setInnerText(gw.getLinkName());
        browserLink.setHref(gw.toRevision(change.project(), revision));
    } else {
        UIObject.setVisible(browserLink, false);
    }
}
#end_block

#method_before
private void formatLink(GitPerson person, InlineHyperlink name, Element date, AccountInfo a, Status status) {
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(AccountLinkPanel.owner(a), status));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, InlineHyperlink name, Element date, Status status) {
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), status));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectControl ctrl = projectControlFactory.controlFor(projectName, currentUser.get());
        return new ConfigInfo(ctrl, projectStateFactory.create(projectConfig), config, views, currentUser);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } catch (NoSuchProjectException err) {
        throw new ResourceConflictException("Cannot find project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            if (e.getCause() instanceof ConfigInvalidException) {
                throw new ResourceConflictException("Cannot update " + projectName + ": " + e.getCause().getMessage());
            } else {
                throw new ResourceConflictException("Cannot update " + projectName);
            }
        }
        ProjectState state = projectStateFactory.create(projectConfig);
        return new ConfigInfo(state.controlFor(currentUser.get()), state, config, views, currentUser);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return isAdmin() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#method_after
public boolean canDelete() {
    if (!canWrite() || (GitRepositoryManager.REF_CONFIG.equals(refName))) {
        // should be removed first.
        return false;
    }
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
        case SSH_COMMAND:
            return getCurrentUser().getCapabilities().canAdministrateServer() || (isOwner() && !isForceBlocked(Permission.PUSH)) || canPushWithForce();
        case GIT:
            return canPushWithForce();
        default:
            return false;
    }
}
#end_block

#method_before
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenus.DIFFERENCES.menuName);
    if (view instanceof PatchScreen) {
        patchScreen = (PatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#method_after
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenu.DIFFERENCES.menuName);
    if (view instanceof PatchScreen) {
        patchScreen = (PatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<String, LinkMenuBar>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenus.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenus.MY.menuName, m);
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenus.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenus.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenus.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenus.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenus.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<String, LinkMenuBar>();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, m);
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    final LinkMenuItem dashboardsMenuItem = addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar existingBar = menuBars.get(menu.getName());
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(menu.getName(), bar);
                    menuLeft.add(bar, menu.getName());
                }
            }
        }
    });
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    userSummaryPanel.add(new InlineLabel(" "));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new FileReader(file));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DOC_FIELD, reader));
        doc.add(new StringField(URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new StringField(TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    File tmp = Files.createTempDir();
    NIOFSDirectory directory = new NIOFSDirectory(tmp);
    IndexWriterConfig config = new IndexWriterConfig(LUCENE_VERSION, new StandardAnalyzer(LUCENE_VERSION, CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(DOC_FIELD, reader));
        doc.add(new StringField(URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(zipFile));
    AsciiDoctor.zipDir(tmp, "", zip);
    zip.close();
}
#end_block

#method_before
public void setCurrentFilePaths(List<String> filePaths) {
    currentFiles = Collections.unmodifiableList(filePaths);
}
#method_after
public void setCurrentFilePaths(List<String> filePaths) {
    currentFiles = ImmutableList.copyOf(filePaths);
}
#end_block

#method_before
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, message, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(cherryPickCommit.getTree(), mergeTip, cherryPickCommit.getAuthorIdent(), myIdent, message);
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public Change.Id cherryPick(final PatchSet.Id patchSetId, final String message, final String destinationBranch, final RefControl refControl) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, MergeException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (destinationBranch == null || destinationBranch.length() == 0) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = db.changes().get(changeId).getProject();
    final Repository git;
    try {
        git = gitManager.openRepository(project);
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        RevWalk revWalk = new RevWalk(git);
        try {
            Ref destRef = git.getRef(destinationBranch);
            if (destRef == null) {
                throw new InvalidChangeOperationException("Branch " + destinationBranch + " does not exist.");
            }
            final RevCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
            RevCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent committerIdent = currentUser.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
            final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), myIdent, message);
            String commitMessage = ChangeIdUtil.insertId(message, computedChangeId);
            RevCommit cherryPickCommit;
            ObjectInserter oi = git.newObjectInserter();
            try {
                ProjectState projectState = refControl.getProjectControl().getProjectState();
                cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            } finally {
                oi.release();
            }
            if (cherryPickCommit == null) {
                throw new MergeException("Could not create a merge commit during the cherry pick");
            }
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            List<Change> destChanges = db.changes().byBranchKey(new Branch.NameKey(db.changes().get(changeId).getProject(), destRef.getName()), changeKey).toList();
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " resides on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, destChanges.get(0), patchSetId, cherryPickCommit, refControl);
            } else {
                // change.
                return createNewChange(git, revWalk, changeKey, project, patchSetId, destRef, cherryPickCommit, refControl);
            }
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(patchSetId.getParentKey(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), newPatchSetId);
    cmsg.setMessage("Uploaded patch set " + newPatchSetId.get() + ".");
    inserter.setMessage(cmsg).insert();
    return change.getId();
}
#method_after
private Change.Id insertPatchSet(Repository git, RevWalk revWalk, Change change, PatchSet.Id patchSetId, RevCommit cherryPickCommit, RefControl refControl) throws InvalidChangeOperationException, IOException, OrmException, NoSuchChangeException {
    final PatchSetInserter inserter = patchSetInserterFactory.create(git, revWalk, refControl, currentUser, change, cherryPickCommit);
    final PatchSet.Id newPatchSetId = inserter.getPatchSetId();
    inserter.setMessage("Uploaded patch set " + newPatchSetId.get() + ".").insert();
    return change.getId();
}
#end_block

#method_before
private void createSkipLine(int row, SkippedLine line, boolean isWholeFile) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30 && isWholeFile) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else if (isWholeFile) {
        p.add(l1);
        p.add(all);
        p.add(l2);
    } else {
        p.add(l1);
        InlineLabel allLabel = new InlineLabel(" " + String.valueOf(line.getSize()) + " ");
        p.add(allLabel);
        p.add(l2);
        ;
    }
    table.setWidget(row, 1, p);
}
#method_after
private void createSkipLine(int row, SkippedLine line, boolean isWholeFile) {
    FlowPanel p = new FlowPanel();
    InlineLabel l1 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionStart() + " ");
    InlineLabel l2 = new InlineLabel(" " + PatchUtil.C.patchSkipRegionEnd() + " ");
    Anchor all = new Anchor(String.valueOf(line.getSize()));
    all.addClickHandler(expandAllListener);
    all.setStyleName(Gerrit.RESOURCES.css().skipLine());
    if (line.getSize() > 30 && isWholeFile) {
        // Only show the expand before/after if skipped more than 30 lines.
        Anchor b = new Anchor(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND), true);
        Anchor a = new Anchor(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND), true);
        b.addClickHandler(expandBeforeListener);
        a.addClickHandler(expandAfterListener);
        b.setStyleName(Gerrit.RESOURCES.css().skipLine());
        a.setStyleName(Gerrit.RESOURCES.css().skipLine());
        p.add(b);
        p.add(l1);
        p.add(all);
        p.add(l2);
        p.add(a);
    } else if (isWholeFile) {
        p.add(l1);
        p.add(all);
        p.add(l2);
    } else {
        p.add(l1);
        p.add(new InlineLabel(" " + line.getSize() + " "));
        p.add(l2);
    }
    table.setWidget(row, 1, p);
}
#end_block

#method_before
void build(Repository git, TagSet old, TagMatcher m) {
    if (old != null && m != null && refresh(old, m)) {
        return;
    }
    TagWalk rw = new TagWalk(git);
    rw.setRetainBody(false);
    try {
        for (Ref ref : git.getRefDatabase().getRefs(RefDatabase.ALL).values()) {
            if (skip(ref)) {
                continue;
            } else if (isTag(ref)) {
                // For a tag, remember where it points to.
                addTag(rw, git.peel(ref));
            } else {
                // New reference to include in the set.
                addRef(rw, ref);
            }
        }
        // Traverse the complete history. Copy any flags from a commit to
        // all of its ancestors. This automatically updates any Tag object
        // as the TagCommit and the stored Tag object share the same
        // underlying bit set.
        TagCommit c;
        while ((c = (TagCommit) rw.next()) != null) {
            BitSet mine = c.refFlags;
            int pCnt = c.getParentCount();
            for (int pIdx = 0; pIdx < pCnt; pIdx++) {
                ((TagCommit) c.getParent(pIdx)).refFlags.or(mine);
            }
        }
    } catch (IOException e) {
        log.warn("Repository " + projectName + " has corruption", e);
    } finally {
        rw.release();
    }
}
#method_after
void build(Repository git, TagSet old, TagMatcher m) {
    if (old != null && m != null && refresh(old, m)) {
        return;
    }
    TagWalk rw = new TagWalk(git);
    rw.setRetainBody(false);
    try {
        for (Ref ref : git.getRefDatabase().getRefs(RefDatabase.ALL).values()) {
            if (skip(ref)) {
                continue;
            } else if (isTag(ref)) {
                // For a tag, remember where it points to.
                addTag(rw, git.peel(ref));
            } else {
                // New reference to include in the set.
                addRef(rw, ref);
            }
        }
        // Traverse the complete history. Copy any flags from a commit to
        // all of its ancestors. This automatically updates any Tag object
        // as the TagCommit and the stored Tag object share the same
        // underlying bit set.
        TagCommit c;
        while ((c = (TagCommit) rw.next()) != null) {
            BitSet mine = c.refFlags;
            int pCnt = c.getParentCount();
            for (int pIdx = 0; pIdx < pCnt; pIdx++) {
                ((TagCommit) c.getParent(pIdx)).refFlags.or(mine);
            }
        }
    } catch (IOException e) {
        log.warn("Error building tags for repository " + projectName, e);
    } finally {
        rw.release();
    }
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    Account userAccount = null;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    Repository repo = null;
    try {
        repo = repoManager.openRepository(userProjectControl.getProject().getNameKey());
        Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
        for (final String ref : refsMap.keySet()) {
            if (!onlyRefsHeads || ref.startsWith(Branch.R_HEADS)) {
                stdout.println(ref);
            }
        }
    } catch (RepositoryNotFoundException e) {
        throw new UnloggedFailure("fatal: '" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw new UnloggedFailure("fatal: Error opening: '" + projectControl.getProject().getNameKey());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    Account userAccount = null;
    try {
        userAccount = accountResolver.find(userName);
    } catch (OrmException e) {
        throw die(e);
    }
    if (userAccount == null) {
        stdout.print("No single user could be found when searching for: " + userName + '\n');
        stdout.flush();
        return;
    }
    IdentifiedUser user = userFactory.create(userAccount.getId());
    ProjectControl userProjectControl = projectControl.forUser(user);
    Repository repo;
    try {
        repo = repoManager.openRepository(userProjectControl.getProject().getNameKey());
    } catch (RepositoryNotFoundException e) {
        throw new UnloggedFailure("fatal: '" + projectControl.getProject().getNameKey() + "': not a git archive");
    } catch (IOException e) {
        throw new UnloggedFailure("fatal: Error opening: '" + projectControl.getProject().getNameKey());
    }
    try {
        Map<String, Ref> refsMap = new VisibleRefFilter(tagCache, changeCache, repo, userProjectControl, db, true).filter(repo.getRefDatabase().getRefs(ALL), false);
        for (final String ref : refsMap.keySet()) {
            if (!onlyRefsHeads || ref.startsWith(Branch.R_HEADS)) {
                stdout.println(ref);
            }
        }
    } catch (IOException e) {
        throw new Failure(1, "fatal: Error reading refs: '" + projectControl.getProject().getNameKey(), e);
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            ReviewDb db = schemaFactory.open();
            try {
                Repository repo = repoManager.openRepository(project);
                try {
                    Map<String, Ref> refs = repo.getAllRefs();
                    for (Change c : db.changes().byProject(project)) {
                        Ref r = refs.get(c.currentPatchSetId().toRefName());
                        if (r != null) {
                            byId.put(r.getObjectId(), new ChangeData(c));
                        }
                    }
                    new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
                } finally {
                    repo.close();
                // TODO(dborowitz): Opening all repositories in a live server may be
                // wasteful; see if we can determine which ones it is safe to close
                // with RepositoryCache.close(repo).
                }
            } finally {
                db.close();
            }
            return null;
        }
    };
}
#method_after
private Callable<Void> reindexProject(final ChangeIndexer indexer, final Project.NameKey project, final Task done, final Task failed, final PrintWriter verboseWriter) {
    return new Callable<Void>() {

        @Override
        public Void call() throws Exception {
            Multimap<ObjectId, ChangeData> byId = ArrayListMultimap.create();
            Repository repo = repoManager.openRepository(project);
            try {
                Map<String, Ref> refs = repo.getAllRefs();
                for (Change c : db.get().changes().byProject(project)) {
                    Ref r = refs.get(c.currentPatchSetId().toRefName());
                    if (r != null) {
                        byId.put(r.getObjectId(), new ChangeData(c));
                    }
                }
                new ProjectIndexer(indexer, byId, repo, done, failed, verboseWriter).call();
            } finally {
                repo.close();
            // TODO(dborowitz): Opening all repositories in a live server may be
            // wasteful; see if we can determine which ones it is safe to close
            // with RepositoryCache.close(repo).
            }
            return null;
        }
    };
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                        indexer.indexAsync(chg);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMerged(chg, null);
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        } catch (IOException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.indexAsync(c);
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException, IOException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
    indexer.index(c);
}
#end_block

#method_before
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            Change change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
            indexer.indexAsync(change);
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(final Change c, final ChangeMessage msg, boolean makeNew) {
    PatchSetApproval submitter = null;
    try {
        submitter = getSubmitter(db, c.currentPatchSetId());
    } catch (Exception e) {
        log.error("Cannot get submitter", e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    Change change = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            db.changeMessages().insert(Collections.singleton(msg));
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        log.warn("Cannot record merge failure message", err);
    }
    CheckedFuture<?, IOException> indexFuture;
    if (change != null) {
        indexFuture = indexer.indexAsync(change);
    } else {
        indexFuture = null;
    }
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                final MergeFailSender cm = mergeFailSenderFactory.create(c);
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            log.error("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
    if (indexFuture != null) {
        try {
            indexFuture.checkedGet();
        } catch (IOException e) {
            log.error("Failed to index new change message", e);
        }
    }
}
#end_block

#method_before
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#method_after
@Override
public Object apply(ChangeResource req, Input input) throws BadRequestException, AuthException, ResourceConflictException, Exception {
    if (input == null) {
        input = new Input();
    }
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canEditTopicName()) {
        throw new AuthException("changing topic not permitted");
    }
    ReviewDb db = dbProvider.get();
    final String newTopicName = Strings.nullToEmpty(input.topic);
    String oldTopicName = Strings.nullToEmpty(change.getTopic());
    if (!oldTopicName.equals(newTopicName)) {
        String summary;
        if (oldTopicName.isEmpty()) {
            summary = "Topic set to \"" + newTopicName + "\".";
        } else if (newTopicName.isEmpty()) {
            summary = "Topic \"" + oldTopicName + "\" removed.";
        } else {
            summary = String.format("Topic updated from \"%s\" to \"%s\".", oldTopicName, newTopicName);
        }
        IdentifiedUser currentUser = ((IdentifiedUser) control.getCurrentUser());
        ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), change.currentPatchSetId());
        StringBuilder msgBuf = new StringBuilder(summary);
        if (!Strings.isNullOrEmpty(input.message)) {
            msgBuf.append("\n\n");
            msgBuf.append(input.message);
        }
        cmsg.setMessage(msgBuf.toString());
        db.changes().beginTransaction(change.getId());
        try {
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    change.setTopic(Strings.emptyToNull(newTopicName));
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
        } finally {
            db.rollback();
        }
        CheckedFuture<?, IOException> indexFuture = indexer.indexAsync(change);
        hooks.doTopicChangedHook(change, currentUser.getAccount(), oldTopicName, db);
        indexFuture.checkedGet();
    }
    return Strings.isNullOrEmpty(newTopicName) ? Response.none() : newTopicName;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = null;
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit && dirty) {
        indexWrite.checkedGet();
    }
    return output;
}
#method_after
@Override
public Object apply(RevisionResource revision, Input input) throws AuthException, BadRequestException, OrmException, UnprocessableEntityException, IOException {
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.changes().get(revision.getChange().getId());
        ChangeUtil.updated(change);
        timestamp = change.getLastUpdatedOn();
        dirty |= insertComments(revision, input.comments, input.drafts);
        dirty |= updateLabels(revision, input.labels);
        dirty |= insertMessage(revision, input.message);
        if (dirty) {
            db.changes().update(Collections.singleton(change));
            db.commit();
        }
    } finally {
        db.rollback();
    }
    CheckedFuture<?, IOException> indexWrite;
    if (dirty) {
        indexWrite = indexer.indexAsync(change);
    } else {
        indexWrite = Futures.<Void, IOException>immediateCheckedFuture(null);
    }
    if (input.notify.compareTo(NotifyHandling.NONE) > 0 && message != null) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
        fireCommentAddedHook(revision);
    }
    Output output = new Output();
    output.labels = input.labels;
    if (input.waitForCommit) {
        indexWrite.checkedGet();
    }
    return output;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    Provider<ReviewDb> db = dbRef.get();
                    if (db == null) {
                        try {
                            db = Providers.of(schemaFactory.open());
                        } catch (OrmException e) {
                            ProvisionException pe = new ProvisionException("error opening ReviewDb");
                            pe.initCause(e);
                            throw pe;
                        }
                        dbRef.set(db);
                    }
                    return db;
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            if (indexes != null) {
                for (ChangeIndex i : indexes.getWriteIndexes()) {
                    apply(i, cd);
                }
            } else {
                apply(index, cd);
            }
            return null;
        } finally {
            context.setContext(null);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder sb = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        sb.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            sb.append(", ");
        }
    }
    return sb;
}
#method_after
private SafeHtml formatList(JsArrayString l) {
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    int size = l.length();
    for (int i = 0; i < size; i++) {
        html.openSpan().addStyleName(style.includedInElement()).append(l.get(i)).closeSpan();
        if (i < size - 1) {
            html.append(", ");
        }
    }
    return html;
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status().isClosed()) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#method_after
@Override
protected void onLoad() {
    if (!loaded) {
        RestApi call = ChangeApi.detail(changeId.get());
        ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_COMMITS, ListChangesOption.ALL_REVISIONS, ListChangesOption.DRAFT_COMMENTS));
        call.get(new AsyncCallback<ChangeInfo>() {

            @Override
            public void onSuccess(ChangeInfo result) {
                render(result.revisions());
                loaded = true;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
}
#end_block

#method_before
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id()).append(r._number());
    if (r.has_draft_comments()) {
        sb.append(" ...");
    }
    if (r.draft()) {
        sb.append(" ").append(Resources.C.draft());
    }
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#method_after
private void revision(SafeHtmlBuilder sb, int index, RevisionInfo r) {
    CommitInfo c = r.commit();
    sb.openTr();
    if (revision.equals(r.name())) {
        sb.setStyleName(style.current());
    }
    sb.openTd().setStyleName(style.legacy_id()).append(r._number());
    if (r.draft()) {
        sb.append(" ").append(Resources.C.draft());
    }
    if (r.has_draft_comments()) {
        sb.append(" ").openSpan().addStyleName(style.draft_comment()).setAttribute("title", Resources.C.draftCommentsTooltip()).append(new ImageResourceRenderer().render(Gerrit.RESOURCES.draftComments())).closeSpan();
    }
    sb.closeTd();
    sb.openTd().setStyleName(style.commit()).openAnchor().setAttribute("href", "#" + url(r)).setAttribute("onclick", OPEN + "(event," + index + ")").append(r.name().substring(0, 10)).closeAnchor().closeTd();
    sb.openTd().append(FormatUtil.shortFormatDayTime(c.committer().date())).closeTd();
    String an = c.author() != null ? c.author().name() : null;
    String cn = c.committer() != null ? c.committer().name() : null;
    sb.openTd();
    sb.append(an);
    if (!"".equals(an) && !"".equals(cn) && !an.equals(cn)) {
        sb.append(" / ").append(cn);
    }
    sb.closeTd();
    sb.closeTr();
}
#end_block

#method_before
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change(db).currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(db), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        boolean hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext();
        out.draftComments = hasDraftComments ? true : null;
    }
    return out;
}
#method_after
private RevisionInfo toRevisionInfo(ChangeData cd, PatchSet in) throws OrmException {
    RevisionInfo out = new RevisionInfo();
    out.isCurrent = in.getId().equals(cd.change(db).currentPatchSetId());
    out._number = in.getId().get();
    out.draft = in.isDraft() ? true : null;
    out.fetch = makeFetchMap(cd, in);
    if (has(ALL_COMMITS) || (out.isCurrent && has(CURRENT_COMMIT))) {
        try {
            out.commit = toCommit(in);
        } catch (PatchSetInfoNotAvailableException e) {
            log.warn("Cannot load PatchSetInfo " + in.getId(), e);
        }
    }
    if (has(ALL_FILES) || (out.isCurrent && has(CURRENT_FILES))) {
        try {
            out.files = fileInfoJson.toFileInfoMap(cd.change(db), in);
            out.files.remove(Patch.COMMIT_MSG);
        } catch (PatchListNotAvailableException e) {
            log.warn("Cannot load PatchList " + in.getId(), e);
        }
    }
    if ((out.isCurrent || (out.draft != null && out.draft)) && has(CURRENT_ACTIONS) && userProvider.get().isIdentifiedUser()) {
        out.actions = Maps.newTreeMap();
        for (UiAction.Description d : UiActions.from(revisions, new RevisionResource(new ChangeResource(control(cd)), in), userProvider)) {
            out.actions.put(d.getId(), new ActionInfo(d));
        }
    }
    if (has(DRAFT_COMMENTS) && userProvider.get().isIdentifiedUser()) {
        IdentifiedUser user = (IdentifiedUser) userProvider.get();
        out.hasDraftComments = db.get().patchComments().draftByPatchSetAuthor(in.getId(), user.getAccountId()).iterator().hasNext() ? true : null;
    }
    return out;
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    linePublishedBoxesMap = new HashMap<LineHandle, List<PublishedBox>>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollingGlue = GWT.create(ScrollingGlue.class);
    scrollingGlue.init(diffTable, cmA, cmB, mapper);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    if (pref.isShowTabs()) {
        diffTable.addStyleName(DiffTable.style.showtabs());
    }
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    linePublishedBoxesMap = new HashMap<LineHandle, List<PublishedBox>>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    scrollingGlue = GWT.create(ScrollSynchronizer.class);
    scrollingGlue.init(diffTable, cmA, cmB, mapper);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    if (pref.isShowTabs()) {
        diffTable.addStyleName(DiffTable.style.showtabs());
    }
}
#end_block

#method_before
public boolean canCreate(Repository repo, RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && canReadCommit(repo, rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || (canPerform(Permission.CREATE) && projectControl.canReadCommit(rw, (RevCommit) object));
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

#method_before
public void insert(final Widget i, int beforeIndex) {
    if (body.getWidgetCount() > 0 && body.getWidgetCount() == beforeIndex) {
        add(i);
        return;
    }
    body.insert(i, beforeIndex);
}
#method_after
public void insert(final Widget i, int beforeIndex) {
    if (body.getWidgetCount() == 0 || body.getWidgetCount() <= beforeIndex) {
        add(i);
        return;
    }
    body.insert(i, beforeIndex);
}
#end_block

#method_before
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#method_after
public static <R extends RestResource> Iterable<UiAction.Description> from(DynamicMap<RestView<R>> views, final R resource) {
    return Iterables.filter(Iterables.transform(views, new Function<DynamicMap.Entry<RestView<R>>, UiAction.Description>() {

        @Override
        @Nullable
        public UiAction.Description apply(DynamicMap.Entry<RestView<R>> e) {
            int d = e.getExportName().indexOf('.');
            if (d < 0) {
                return null;
            }
            RestView<R> view;
            try {
                view = e.getProvider().get();
            } catch (RuntimeException err) {
                log.error(String.format("error creating view %s.%s", e.getPluginName(), e.getExportName()), err);
                return null;
            }
            if (!(view instanceof UiAction)) {
                return null;
            }
            UiAction.Description dsc = ((UiAction<R>) view).getDescription(resource);
            if (dsc == null || !dsc.isVisible()) {
                return null;
            }
            String name = e.getExportName().substring(d + 1);
            PrivateInternals_UiActionDescription.setMethod(dsc, e.getExportName().substring(0, d));
            PrivateInternals_UiActionDescription.setId(dsc, "gerrit".equals(e.getPluginName()) ? name : e.getPluginName() + '~' + name);
            return dsc;
        }
    }), Predicates.notNull());
}
#end_block

#method_before
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateCommands(final PatchSetDetail detail) {
    for (final UiCommandDetail cmd : detail.getCommands()) {
        final Button b = new Button();
        b.setText(cmd.label);
        b.setEnabled(cmd.enabled);
        b.setTitle(cmd.title);
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                AsyncCallback<NativeString> cb = new AsyncCallback<NativeString>() {

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        new ErrorDialog(caught).center();
                    }

                    @Override
                    public void onSuccess(NativeString msg) {
                        b.setEnabled(true);
                        if (msg != null && !msg.asString().isEmpty()) {
                            Window.alert(msg.asString());
                        }
                        Gerrit.display(PageLinks.toChange(patchSet.getId()));
                    }
                };
                RestApi api = ChangeApi.revision(patchSet.getId()).view(cmd.id);
                if ("PUT".equalsIgnoreCase(cmd.method)) {
                    api.put(JavaScriptObject.createObject(), cb);
                } else if ("DELETE".equalsIgnoreCase(cmd.method)) {
                    api.delete(cb);
                } else {
                    api.post(JavaScriptObject.createObject(), cb);
                }
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    if (hasUser) {
        a2b(actions, "abandon", abandon);
        a2b(actions, "/", deleteDraftChange);
        a2b(actions, "restore", restore);
        a2b(actions, "revert", revert);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#method_after
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    if (hasUser) {
        a2b(actions, "/", deleteChange);
        a2b(actions, "abandon", abandon);
        a2b(actions, "restore", restore);
        a2b(actions, "revert", revert);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            submit.setTitle(actions.get("submit").title());
        }
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "/", deleteDraftPatchSet);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    canSubmit = false;
    if (hasUser) {
        canSubmit = actions.containsKey("submit");
        if (canSubmit) {
            submit.setTitle(actions.get("submit").title());
        }
        a2b(actions, "/", deleteRevision);
        a2b(actions, "cherrypick", cherrypick);
        a2b(actions, "publish", publish);
        a2b(actions, "rebase", rebase);
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
static void publish(final Change.Id id, String revision) {
    ChangeApi.publish(id.get(), revision, cs(id));
}
#method_after
static void publish(Change.Id id, String revision) {
    ChangeApi.publish(id.get(), revision, cs(id));
}
#end_block

#method_before
static void delete(final Change.Id id, String revision) {
    ChangeApi.deleteDraftPatchSet(id.get(), revision, cs(id));
}
#method_after
static void delete(Change.Id id, String revision) {
    ChangeApi.deleteRevision(id.get(), revision, cs(id));
}
#end_block

#method_before
static void delete(final Change.Id id) {
    ChangeApi.deleteDraftChange(id.get(), mine());
}
#method_after
static void delete(Change.Id id) {
    ChangeApi.deleteChange(id.get(), mine());
}
#end_block

#method_before
private static GerritCallback<JavaScriptObject> cs(final Change.Id id) {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            redisplay();
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                redisplay();
            } else {
                super.onFailure(err);
            }
        }

        private void redisplay() {
            Gerrit.display(PageLinks.toChange2(id));
        }
    };
}
#method_after
private static GerritCallback<JavaScriptObject> cs(final Change.Id id) {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.toChange(id));
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.toChange(id));
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
private static AsyncCallback<JavaScriptObject> mine() {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            redisplay();
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                redisplay();
            } else {
                super.onFailure(err);
            }
        }

        private void redisplay() {
            Gerrit.display(PageLinks.MINE);
        }
    };
}
#method_after
private static AsyncCallback<JavaScriptObject> mine() {
    return new GerritCallback<JavaScriptObject>() {

        public void onSuccess(JavaScriptObject result) {
            Gerrit.display(PageLinks.MINE);
        }

        public void onFailure(Throwable err) {
            if (SubmitFailureDialog.isConflict(err)) {
                new SubmitFailureDialog(err.getMessage()).center();
                Gerrit.display(PageLinks.MINE);
            } else {
                super.onFailure(err);
            }
        }
    };
}
#end_block

#method_before
public static void copyLabels(ReviewDb db, LabelTypes labelTypes, Iterable<PatchSetApproval> sourceApprovals, PatchSet.Id source, PatchSet dest, ChangeKind changeKind) throws OrmException {
    List<PatchSetApproval> copied = Lists.newArrayList();
    List<String> labelsCopiedForTrivialRebase = Lists.newArrayList();
    List<String> labelsCopiedForCommitMessageOnlyChange = Lists.newArrayList();
    for (PatchSetApproval a : sourceApprovals) {
        if (source.equals(a.getPatchSetId())) {
            LabelType type = labelTypes.byLabel(a.getLabelId());
            if (type == null) {
                continue;
            } else if (type.isCopyMinScore() && type.isMaxNegative(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyMaxScore() && type.isMaxPositive(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnTrivialRebase() && ChangeKind.TRIVIAL_REBASE.equals(changeKind)) {
                labelsCopiedForTrivialRebase.add(type.getName());
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnCommitMessageOnlyChange() && ChangeKind.COMMIT_MESSAGE_ONLY.equals(changeKind)) {
                labelsCopiedForCommitMessageOnlyChange.add(type.getName());
                copied.add(new PatchSetApproval(dest.getId(), a));
            }
        }
    }
    addMessageForCopiedLabels(db, labelsCopiedForTrivialRebase, dest, "trivial rebase");
    addMessageForCopiedLabels(db, labelsCopiedForCommitMessageOnlyChange, dest, "commit message only change");
    db.patchSetApprovals().insert(copied);
}
#method_after
public static void copyLabels(ReviewDb db, LabelTypes labelTypes, Iterable<PatchSetApproval> sourceApprovals, PatchSet.Id source, PatchSet dest, ChangeKind changeKind) throws OrmException {
    List<PatchSetApproval> copied = Lists.newArrayList();
    for (PatchSetApproval a : sourceApprovals) {
        if (source.equals(a.getPatchSetId())) {
            LabelType type = labelTypes.byLabel(a.getLabelId());
            if (type == null) {
                continue;
            } else if (type.isCopyMinScore() && type.isMaxNegative(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyMaxScore() && type.isMaxPositive(a)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresOnTrivialRebase() && ChangeKind.TRIVIAL_REBASE.equals(changeKind)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            } else if (type.isCopyAllScoresIfNoCodeChange() && ChangeKind.NO_CODE_CHANGE.equals(changeKind)) {
                copied.add(new PatchSetApproval(dest.getId(), a));
            }
        }
    }
    db.patchSetApprovals().insert(copied);
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        rp.getRevWalk().parseBody(priorCommit);
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    changeKind = PatchSetInserter.getChangeKind(project.getNameKey(), repo, priorCommit, newCommit);
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit == priorCommit) {
        // Ignore requests to make the change its current state.
        skip = true;
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists");
        return false;
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        rp.getRevWalk().parseBody(priorCommit);
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    changeKind = PatchSetInserter.getChangeKind(mergeUtilFactory, projectControl.getProjectState(), repo, priorCommit, newCommit);
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (magicBranch != null && magicBranch.isDraft()) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresOnCommitMessageOnlyChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresOnCommitMessageOnlyChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_COMMIT_MESSAGE_ONLY_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresIfNoCodeChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            PatchSet priorPatchSet = db.patchSets().get(currentPatchSetId);
            ObjectId priorCommitId = ObjectId.fromString(priorPatchSet.getRevision().get());
            RevCommit priorCommit = revWalk.parseCommit(priorCommitId);
            ChangeKind changeKind = getChangeKind(change.getProject(), git, priorCommit, commit);
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, patchSet, changeKind);
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, updatedChange, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
        indexer.index(updatedChange);
        if (runHooks) {
            hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
        }
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            PatchSet priorPatchSet = db.patchSets().get(currentPatchSetId);
            ObjectId priorCommitId = ObjectId.fromString(priorPatchSet.getRevision().get());
            RevCommit priorCommit = revWalk.parseCommit(priorCommitId);
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            ChangeKind changeKind = getChangeKind(mergeUtilFactory, projectState, git, priorCommit, commit);
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, patchSet, changeKind);
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, updatedChange, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        if (sendMail) {
            try {
                PatchSetInfo info = patchSetInfoFactory.get(commit, patchSet.getId());
                ReplacePatchSetSender cm = replacePatchSetFactory.create(updatedChange);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(patchSet, info);
                cm.setChangeMessage(changeMessage);
                cm.addReviewers(oldReviewers);
                cm.addExtraCC(oldCC);
                cm.send();
            } catch (Exception err) {
                log.error("Cannot send email for new patch set on change " + updatedChange.getId(), err);
            }
        }
        indexer.index(updatedChange);
        if (runHooks) {
            hooks.doPatchsetCreatedHook(updatedChange, patchSet, db);
        }
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
public static ChangeKind getChangeKind(Project.NameKey project, Repository git, RevCommit prior, RevCommit next) {
    if (!next.getFullMessage().equals(prior.getFullMessage())) {
        if (next.getTree() == prior.getTree()) {
            return ChangeKind.COMMIT_MESSAGE_ONLY;
        } else {
            return ChangeKind.REWORK;
        }
    }
    if (next.getTree() == prior.getTree()) {
        return ChangeKind.TRIVIAL_REBASE;
    }
    if (next.getParentCount() != 1) {
        // Trivial rebases done by machine only work well on 1 parent.
        return ChangeKind.REWORK;
    }
    // cherry-picked onto the next commit's new first parent.
    try {
        ThreeWayMerger merger = MergeStrategy.RESOLVE.newMerger(git, true);
        merger.setBase(prior.getParent(0));
        if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
            return ChangeKind.TRIVIAL_REBASE;
        } else {
            return ChangeKind.REWORK;
        }
    } catch (IOException err) {
        log.warn("Cannot check trivial rebase of new patch set " + next.name() + " in " + project.get(), err);
        return ChangeKind.REWORK;
    }
}
#method_after
public static ChangeKind getChangeKind(MergeUtil.Factory mergeUtilFactory, ProjectState project, Repository git, RevCommit prior, RevCommit next) {
    if (!next.getFullMessage().equals(prior.getFullMessage())) {
        if (next.getTree() == prior.getTree() && prior.getParent(0).equals(next.getParent(0))) {
            return ChangeKind.NO_CODE_CHANGE;
        } else {
            return ChangeKind.REWORK;
        }
    }
    if (prior.getParentCount() != 1 || next.getParentCount() != 1) {
        // Trivial rebases done by machine only work well on 1 parent.
        return ChangeKind.REWORK;
    }
    if (next.getTree() == prior.getTree() && prior.getParent(0).equals(next.getParent(0))) {
        return ChangeKind.TRIVIAL_REBASE;
    }
    // cherry-picked onto the next commit's new first parent.
    try {
        MergeUtil mergeUtil = mergeUtilFactory.create(project);
        ThreeWayMerger merger = mergeUtil.newThreeWayMerger(git, mergeUtil.createDryRunInserter());
        merger.setBase(prior.getParent(0));
        if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
            return ChangeKind.TRIVIAL_REBASE;
        } else {
            return ChangeKind.REWORK;
        }
    } catch (IOException err) {
        log.warn("Cannot check trivial rebase of new patch set " + next.name() + " in " + project.getProject().getName(), err);
        return ChangeKind.REWORK;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(SchemaVersion.guessVersion(SchemaVersion.C) < 77 ? Schema73DatabaseDeleteHandler.class : Schema77DatabaseDeleteHandler.class);
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteAction.class);
        }
    });
}
#end_block

#method_before
private void loadPlugins(HostPageData hpd, final String token) {
    ApiGlue.init();
    if (hpd.plugins != null && !hpd.plugins.isEmpty()) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d;
                    if (reason instanceof CodeDownloadException) {
                        d = new ErrorDialog(M.cannotDownloadlPlugin(url));
                    } else {
                        d = new ErrorDialog(M.pluginFailed(url));
                    }
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    ApiGlue.init();
    if (hpd.plugins != null && !hpd.plugins.isEmpty()) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d;
                    if (reason instanceof CodeDownloadException) {
                        d = new ErrorDialog(M.cannotDownloadPlugin(url));
                    } else {
                        d = new ErrorDialog(M.pluginFailed(url));
                    }
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public void installPluginFromStream(String name, InputStream in) throws IOException, PluginInstallException {
    if (!name.endsWith(".jar")) {
        name += ".jar";
    }
    File jar = new File(pluginsDir, name);
    name = nameOf(jar);
    File old = new File(pluginsDir, ".last_" + name + ".zip");
    File tmp = asTemp(in, ".next_" + name, ".zip", pluginsDir);
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            log.info(String.format("Replacing plugin %s", name));
            old.delete();
            jar.renameTo(old);
        }
        // TODO(davido): the name-owned plugins can be renamed here,
        // do we care?
        new File(pluginsDir, name + ".jar.disabled").delete();
        tmp.renameTo(jar);
        try {
            Plugin plugin = runPlugin(name, jar, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            jar.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#method_after
public void installPluginFromStream(String originalName, InputStream in) throws IOException, PluginInstallException {
    String fileName = originalName;
    if (!fileName.endsWith(".jar")) {
        fileName += ".jar";
    }
    File tmp = asTemp(in, ".next_" + fileName + "_", ".tmp", pluginsDir);
    String name = Objects.firstNonNull(getGerritPluginName(tmp), nameOf(fileName));
    if (!originalName.equals(name)) {
        log.warn(String.format("Plugin provides its own name: <%s>," + " use it instead of the input name: <%s>", name, originalName));
    }
    File dst = new File(pluginsDir, name + ".jar");
    synchronized (this) {
        Plugin active = running.get(name);
        if (active != null) {
            fileName = active.getSrcFile().getName();
            log.info(String.format("Replacing plugin %s", active.getName()));
            File old = new File(pluginsDir, ".last_" + fileName);
            old.delete();
            active.getSrcFile().renameTo(old);
        }
        new File(pluginsDir, fileName + ".disabled").delete();
        tmp.renameTo(dst);
        try {
            Plugin plugin = runPlugin(name, dst, active);
            if (active == null) {
                log.info(String.format("Installed plugin %s", plugin.getName()));
            }
        } catch (PluginInstallException e) {
            dst.delete();
            throw e;
        }
        cleanInBackground();
    }
}
#end_block

#method_before
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
    files.remove(name);
}
#method_after
synchronized private void unloadPlugin(Plugin plugin) {
    String name = plugin.getName();
    log.info(String.format("Unloading plugin %s", name));
    plugin.stop(env);
    running.remove(name);
    disabled.remove(name);
    toCleanup.add(plugin);
}
#end_block

#method_before
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", name));
            File off = new File(pluginsDir, active.getName() + ".jar.disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", name), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#method_after
public void disablePlugins(Set<String> names) {
    synchronized (this) {
        for (String name : names) {
            Plugin active = running.get(name);
            if (active == null) {
                continue;
            }
            log.info(String.format("Disabling plugin %s", active.getName()));
            File off = new File(active.getSrcFile() + ".disabled");
            active.getSrcFile().renameTo(off);
            unloadPlugin(active);
            try {
                FileSnapshot snapshot = FileSnapshot.save(off);
                Plugin offPlugin = loadPlugin(name, off, snapshot);
                disabled.put(name, offPlugin);
            } catch (Throwable e) {
                // This shouldn't happen, as the plugin was loaded earlier.
                log.warn(String.format("Cannot load disabled plugin %s", active.getName()), e.getCause());
            }
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            File on = new File(pluginsDir, off.getName() + ".jar");
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#method_after
public void enablePlugins(Set<String> names) throws PluginInstallException {
    synchronized (this) {
        for (String name : names) {
            Plugin off = disabled.get(name);
            if (off == null) {
                continue;
            }
            log.info(String.format("Enabling plugin %s", name));
            String n = off.getSrcFile().getName();
            if (n.endsWith(".disabled")) {
                n = n.substring(0, n.lastIndexOf('.'));
            }
            File on = new File(pluginsDir, n);
            off.getSrcFile().renameTo(on);
            disabled.remove(name);
            runPlugin(name, on, null);
        }
        cleanInBackground();
    }
}
#end_block

#method_before
public synchronized void rescan() {
    List<File> jars = scanJarsInPluginsDirectory();
    stopRemovedPlugins(jars);
    dropRemovedDisabledPlugins(jars);
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            continue;
        }
        String name = nameOf(jar);
        if (files.containsKey(name)) {
            name = files.get(name);
        }
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s", name));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s", loadedPlugin.getName()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#method_after
public synchronized void rescan() {
    Multimap<String, File> jars = prunePlugins(pluginsDir);
    if (jars.isEmpty()) {
        return;
    }
    syncDisabledPlugins(jars);
    Map<String, File> activePlugins = filterDisabled(jars);
    for (String name : activePlugins.keySet()) {
        File jar = activePlugins.get(name);
        FileSnapshot brokenTime = broken.get(name);
        if (brokenTime != null && !brokenTime.isModified(jar)) {
            continue;
        }
        Plugin active = running.get(name);
        if (active != null && !active.isModified(jar)) {
            continue;
        }
        if (active != null) {
            log.info(String.format("Reloading plugin %s, version %s", active.getName(), active.getVersion()));
        }
        try {
            Plugin loadedPlugin = runPlugin(name, jar, active);
            if (active == null && !loadedPlugin.isDisabled()) {
                log.info(String.format("Loaded plugin %s, version %s", loadedPlugin.getName(), loadedPlugin.getVersion()));
            }
        } catch (PluginInstallException e) {
            log.warn(String.format("Cannot load plugin %s", name), e.getCause());
        }
    }
    cleanInBackground();
}
#end_block

#method_before
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        if (!newPlugin.getName().equals(name)) {
            files.put(name, newPlugin.getName());
        }
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(newPlugin.getName(), newPlugin);
        } else {
            disabled.put(newPlugin.getName(), newPlugin);
        }
        broken.remove(newPlugin.getName());
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#method_after
private Plugin runPlugin(String name, File jar, Plugin oldPlugin) throws PluginInstallException {
    FileSnapshot snapshot = FileSnapshot.save(jar);
    try {
        Plugin newPlugin = loadPlugin(name, jar, snapshot);
        boolean reload = oldPlugin != null && oldPlugin.canReload() && newPlugin.canReload();
        if (!reload && oldPlugin != null) {
            unloadPlugin(oldPlugin);
        }
        if (!newPlugin.isDisabled()) {
            newPlugin.start(env);
        }
        if (reload) {
            env.onReloadPlugin(oldPlugin, newPlugin);
            unloadPlugin(oldPlugin);
        } else if (!newPlugin.isDisabled()) {
            env.onStartPlugin(newPlugin);
        }
        if (!newPlugin.isDisabled()) {
            running.put(name, newPlugin);
        } else {
            disabled.put(name, newPlugin);
        }
        broken.remove(name);
        return newPlugin;
    } catch (Throwable err) {
        broken.put(name, snapshot);
        throw new PluginInstallException(err);
    }
}
#end_block

#method_before
private void stopRemovedPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (File jar : jars) {
        if (!jar.getName().endsWith(".disabled")) {
            String name = nameOf(jar);
            unload.remove(files.containsKey(name) ? files.get(name) : name);
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#method_after
private void stopRemovedPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(running.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (!file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        unloadPlugin(running.get(name));
    }
}
#end_block

#method_before
private void dropRemovedDisabledPlugins(List<File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (File jar : jars) {
        if (jar.getName().endsWith(".disabled")) {
            unload.remove(nameOf(jar));
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#method_after
private void dropRemovedDisabledPlugins(Multimap<String, File> jars) {
    Set<String> unload = Sets.newHashSet(disabled.keySet());
    for (Map.Entry<String, Collection<File>> entry : jars.asMap().entrySet()) {
        for (File file : entry.getValue()) {
            if (file.getName().endsWith(".disabled")) {
                unload.remove(entry.getKey());
            }
        }
    }
    for (String name : unload) {
        disabled.remove(name);
    }
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(File jar) {
    return nameOf(jar.getName());
}
#end_block

#method_before
private static String nameOf(File jar) {
    String name = jar.getName();
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#method_after
private static String nameOf(String name) {
    if (name.endsWith(".disabled")) {
        name = name.substring(0, name.lastIndexOf('.'));
    }
    int ext = name.lastIndexOf('.');
    return 0 < ext ? name.substring(0, ext) : name;
}
#end_block

#method_before
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String pluginName = main.getValue("Gerrit-PluginName");
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        if (!Strings.isNullOrEmpty(pluginName)) {
            name = pluginName;
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#method_after
private Plugin loadPlugin(String name, File srcJar, FileSnapshot snapshot) throws IOException, ClassNotFoundException, InvalidPluginException {
    File tmp;
    FileInputStream in = new FileInputStream(srcJar);
    try {
        tmp = asTemp(in, tempNameFor(name), ".jar", tmpDir);
    } finally {
        in.close();
    }
    JarFile jarFile = new JarFile(tmp);
    boolean keep = false;
    try {
        Manifest manifest = jarFile.getManifest();
        Plugin.ApiType type = Plugin.getApiType(manifest);
        Attributes main = manifest.getMainAttributes();
        String sysName = main.getValue("Gerrit-Module");
        String sshName = main.getValue("Gerrit-SshModule");
        String httpName = main.getValue("Gerrit-HttpModule");
        if (!Strings.isNullOrEmpty(sshName) && type != Plugin.ApiType.PLUGIN) {
            throw new InvalidPluginException(String.format("Using Gerrit-SshModule requires Gerrit-ApiType: %s", Plugin.ApiType.PLUGIN));
        }
        URL[] urls = { tmp.toURI().toURL() };
        ClassLoader parentLoader = parentFor(type);
        ClassLoader pluginLoader = new URLClassLoader(urls, parentLoader);
        Class<? extends Module> sysModule = load(sysName, pluginLoader);
        Class<? extends Module> sshModule = load(sshName, pluginLoader);
        Class<? extends Module> httpModule = load(httpName, pluginLoader);
        Plugin plugin = new JarPlugin(name, pluginUserFactory.create(name), srcJar, snapshot, jarFile, manifest, new File(dataDir, name), type, pluginLoader, sysModule, sshModule, httpModule);
        cleanupHandles.put(plugin, new CleanupHandle(tmp, jarFile));
        keep = true;
        return plugin;
    } finally {
        if (!keep) {
            jarFile.close();
        }
    }
}
#end_block

#method_before
private Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#method_after
private static Class<? extends Module> load(String name, ClassLoader pluginLoader) throws ClassNotFoundException {
    if (Strings.isNullOrEmpty(name)) {
        return null;
    }
    @SuppressWarnings("unchecked")
    Class<? extends Module> clazz = (Class<? extends Module>) Class.forName(name, false, pluginLoader);
    if (!Module.class.isAssignableFrom(clazz)) {
        throw new ClassCastException(String.format("Class %s does not implement %s", name, Module.class.getName()));
    }
    return clazz;
}
#end_block

#method_before
private List<File> scanJarsInPluginsDirectory() {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#method_after
private static List<File> scanJarsInPluginsDirectory(File pluginsDir) {
    if (pluginsDir == null || !pluginsDir.exists()) {
        return Collections.emptyList();
    }
    File[] matches = pluginsDir.listFiles(new FileFilter() {

        @Override
        public boolean accept(File pathname) {
            String n = pathname.getName();
            return (n.endsWith(".jar") || n.endsWith(".jar.disabled")) && !n.startsWith(".last_") && !n.startsWith(".next_") && pathname.isFile();
        }
    });
    if (matches == null) {
        log.error("Cannot list " + pluginsDir.getAbsolutePath());
        return Collections.emptyList();
    }
    return Arrays.asList(matches);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1 && !refControl.canUploadMerges(receiveEvent.command)) {
        throw new CommitValidationException("you are not allowed to upload merges");
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    if (receiveEvent.commit.getParentCount() > 1) {
        if (MagicBranch.isForReview(receiveEvent.command.getRefName())) {
            if (!refControl.canUploadMerges()) {
                throw new CommitValidationException("you are not allowed to upload merges for review");
            }
        } else {
            if (!refControl.canPushMerges()) {
                throw new CommitValidationException("you are not allowed to push merges directly bypassing code review");
            }
        }
    }
    return Collections.<CommitValidationMessage>emptyList();
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
            assert magicBranch.ctl != null;
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                walk.markUninteresting(walk.parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges(cmd) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && (MagicBranch.isForReview(cmd.getRefName()) ? ctl.canUploadMerges() : ctl.canPushMerges()) && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    boolean defaultName = Strings.isNullOrEmpty(currentUser.getAccount().getFullName());
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing, cmd.getRefName());
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
            if (defaultName && currentUser.getEmailAddresses().contains(c.getCommitterIdent().getEmailAddress())) {
                try {
                    Account a = db.accounts().get(currentUser.getAccountId());
                    if (a != null && Strings.isNullOrEmpty(a.getFullName())) {
                        a.setFullName(c.getCommitterIdent().getName());
                        db.accounts().update(Collections.singleton(a));
                        currentUser.getAccount().setFullName(a.getFullName());
                        accountCache.evict(a.getId());
                    }
                } catch (OrmException e) {
                    log.warn("Cannot default full_name", e);
                } finally {
                    defaultName = false;
                }
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
public boolean canUploadMerges(ReceiveCommand c) {
    String ref = getRefName();
    if (MagicBranch.isMagicBranch(c.getRefName())) {
        ref = "refs/for/" + ref;
    }
    return projectControl.controlForRef(ref).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#method_after
public boolean canUploadMerges() {
    return projectControl.controlForRef("refs/for/" + getRefName()).canPerform(Permission.PUSH_MERGE) && canWrite();
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static public PermissionRule grant(ProjectConfig project, String permissionName, int min, int max, AccountGroup.UUID group, String ref) {
    PermissionRule rule = newRule(project, group);
    rule.setMin(min);
    rule.setMax(max);
    return grant(project, permissionName, rule, ref);
}
#end_block

#method_before
static PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#method_after
static private PermissionRule grant(ProjectConfig project, String permissionName, PermissionRule rule, String ref) {
    // 
    project.getAccessSection(ref, true).getPermission(permissionName, // 
    true).add(rule);
    return rule;
}
#end_block

#method_before
private ProjectState newProjectState(ProjectConfig local) {
    PrologEnvironment.Factory envFactory = null;
    GitRepositoryManager gitMgr = null;
    ProjectControl.AssistedFactory projectControlFactory = null;
    RulesCache rulesCache = null;
    SitePaths sitePaths = null;
    List<CommentLinkInfo> commentLinks = null;
    all.put(local.getProject().getNameKey(), new ProjectState(sitePaths, projectCache, allProjectsName, projectControlFactory, envFactory, gitMgr, rulesCache, commentLinks, local));
    return all.get(local.getProject().getNameKey());
}
#method_after
private ProjectState newProjectState(ProjectConfig local) {
    add(local);
    return all.get(local.getProject().getNameKey());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    V.setRefPatterns(Arrays.asList("sameAsAccess"));
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grantLabel(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grantLabel(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    util = new Util();
    load("gerrit", "gerrit_common_test.pl", new AbstractModule() {

        @Override
        protected void configure() {
            bind(PrologEnvironment.Args.class).toInstance(new PrologEnvironment.Args(null, null, null, null, null, null));
        }
    });
    local = new ProjectConfig(localKey);
    local.createInMemory();
    Q.setRefPatterns(Arrays.asList("refs/heads/develop"));
    local.getLabelSections().put(V.getName(), V);
    local.getLabelSections().put(Q.getName(), Q);
    util.add(local);
    grant(local, LABEL + V.getName(), -1, +1, REGISTERED, "refs/heads/*");
    grant(local, LABEL + Q.getName(), -1, +1, REGISTERED, "refs/heads/master");
}
#end_block

#method_before
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    beforeInit(init);
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = isSkipPlugin();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    final SiteInit init = createSiteInit();
    beforeInit(init);
    init.flags.autoStart = getAutoStart() && init.site.isNew;
    init.flags.skipPlugins = skipPlugins();
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    afterInit(run);
    return 0;
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    Set<String> pluginSubsections = rc.getSubsections(PLUGIN);
    for (String plugin : pluginSubsections) {
        LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.putAll(name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void loadPluginSections(Config rc) {
    pluginConfigs = Maps.newHashMap();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public LinkedListMultimap<String, String> getPluginConfig(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = LinkedListMultimap.create();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return pluginConfig;
}
#method_after
public PluginConfig getPluginConfig(String pluginName) {
    Config pluginConfig = pluginConfigs.get(pluginName);
    if (pluginConfig == null) {
        pluginConfig = new Config();
        pluginConfigs.put(pluginName, pluginConfig);
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#end_block

#method_before
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, LinkedListMultimap<String, String>> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        LinkedListMultimap<String, String> pluginConfig = e.getValue();
        for (String name : pluginConfig.keySet()) {
            rc.setStringList(PLUGIN, plugin, name, pluginConfig.get(name));
        }
    }
}
#method_after
private void savePluginSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public PluginConfig get(String pluginName) {
    LinkedListMultimap<String, String> pluginConfig = LinkedListMultimap.create();
    for (String name : cfg.getNames(PLUGIN, pluginName)) {
        pluginConfig.putAll(name, Arrays.asList(cfg.getStringList(PLUGIN, pluginName, name)));
    }
    return new PluginConfig(pluginName, pluginConfig);
}
#method_after
public PluginConfig get(String pluginName) {
    return new PluginConfig(pluginName, cfg);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name) {
    return cfg.getString(PLUGIN, pluginName, name);
}
#end_block

#method_before
public String getString(String name, String defaultValue) {
    return getValue(name, Functions.<String>identity(), defaultValue);
}
#method_after
public String getString(String name, String defaultValue) {
    return Objects.firstNonNull(cfg.getString(PLUGIN, pluginName, name), defaultValue);
}
#end_block

#method_before
public int getInt(String name, int defaultValue) {
    return getValue(name, new Function<String, Integer>() {

        @Override
        public Integer apply(String stringVal) {
            return Integer.parseInt(stringVal);
        }
    }, defaultValue);
}
#method_after
public int getInt(String name, int defaultValue) {
    return cfg.getInt(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public long getLong(String name, long defaultValue) {
    return getValue(name, new Function<String, Long>() {

        @Override
        public Long apply(String stringVal) {
            return Long.parseLong(stringVal);
        }
    }, defaultValue);
}
#method_after
public long getLong(String name, long defaultValue) {
    return cfg.getLong(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public boolean getBoolean(String name, boolean defaultValue) {
    return getValue(name, new Function<String, Boolean>() {

        @Override
        public Boolean apply(String stringVal) {
            return Boolean.parseBoolean(stringVal);
        }
    }, defaultValue);
}
#method_after
public boolean getBoolean(String name, boolean defaultValue) {
    return cfg.getBoolean(PLUGIN, pluginName, name, defaultValue);
}
#end_block

#method_before
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project --empty-commit --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#method_after
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    createProject(s, name, parent, true);
}
#end_block

#method_before
public static void createProject(SshSession s, String name, Project.NameKey parent) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project --empty-commit --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#method_after
public static void createProject(SshSession s, String name, Project.NameKey parent, boolean emptyCommit) throws JSchException, IOException {
    StringBuilder b = new StringBuilder();
    b.append("gerrit create-project");
    if (emptyCommit) {
        b.append(" --empty-commit");
    }
    b.append(" --name \"");
    b.append(name);
    b.append("\"");
    if (parent != null) {
        b.append(" --parent \"");
        b.append(parent.get());
        b.append("\"");
    }
    s.exec(b.toString());
}
#end_block

#method_before
public static PushResult pushHead(Git git, String ref, boolean tags) throws GitAPIException {
    PushCommand pushCmd = git.push();
    pushCmd.setRefSpecs(new RefSpec("HEAD:" + ref));
    if (tags) {
        pushCmd.setPushTags();
    }
    Iterable<PushResult> r = pushCmd.call();
    return Iterables.getOnlyElement(r);
}
#method_after
public static PushResult pushHead(Git git, String ref, boolean pushTags) throws GitAPIException {
    PushCommand pushCmd = git.push();
    pushCmd.setRefSpecs(new RefSpec("HEAD:" + ref));
    if (pushTags) {
        pushCmd.setPushTags();
    }
    Iterable<PushResult> r = pushCmd.call();
    return Iterables.getOnlyElement(r);
}
#end_block

#method_before
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip, toMerge.get(submitType)), destBranch);
}
#method_after
private SubmitStrategy createStrategy(final SubmitType submitType) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(final CodeReviewCommit branchTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    Set<String> toMergeSha1 = new HashSet<String>();
    for (CodeReviewCommit rvc : toMerge) {
        toMergeSha1.add(rvc.getName());
    }
    try {
        for (final Ref r : repo.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS) || (r.getName().startsWith(Constants.R_TAGS) && !toMergeSha1.contains(r.getObjectId().getName()))) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Failed to determine already accepted commits.", e);
    }
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(final CodeReviewCommit branchTip) throws MergeException {
    final Set<RevCommit> alreadyAccepted = new HashSet<RevCommit>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (final Ref r : repo.getAllRefs().values()) {
            if (r.getName().startsWith(Constants.R_HEADS)) {
                try {
                    alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
                } catch (IncorrectObjectTypeException iote) {
                // Not a commit? Skip over it.
                }
            }
        }
    } catch (IOException e) {
        throw new MergeException("Failed to determine already accepted commits.", e);
    }
    return alreadyAccepted;
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
            final Project.NameKey newParent;
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, commit);
                newParent = cfg.getProject().getParent(allProjectsName);
            } catch (Exception e) {
                commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION));
                continue;
            }
            final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
            if (oldParent == null) {
                // update of the 'All-Projects' project
                if (newParent != null) {
                    commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT));
                    continue;
                }
            } else {
                if (!oldParent.equals(newParent)) {
                    final PatchSetApproval psa = getSubmitter(db, ps.getId());
                    if (psa == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                    if (!submitter.getCapabilities().canAdministrateServer()) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    if (projectCache.get(newParent) == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND));
                        continue;
                    }
                }
            }
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "admin@example.com", "Administrator", "Administrators");
    project = new Project.NameKey("p");
    initSsh(admin);
    SshSession sshSession = new SshSession(admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "admin@example.com", "Administrator", "Administrators");
    project = new Project.NameKey("p");
    initSsh(admin);
    SshSession sshSession = new SshSession(server, admin);
    createProject(sshSession, project.get());
    git = cloneProject(sshSession.getUrl() + "/" + project.get());
    sshSession.close();
    db = reviewDbProvider.open();
}
#end_block

#method_before
@Test
public void submitOnPushWithTag() throws GitAPIException, OrmException, IOException, ConfigInvalidException {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    PushOneCommit.Result r = pushWithTagTo("refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", PushOneCommit.TAG);
}
#method_after
@Test
public void submitOnPushWithTag() throws GitAPIException, OrmException, IOException, ConfigInvalidException {
    grant(Permission.SUBMIT, project, "refs/for/refs/heads/master");
    grant(Permission.CREATE, project, "refs/tags/*");
    final String tag = "v1.0";
    PushOneCommit push = new PushOneCommit(db, admin.getIdent());
    push.setTag(tag);
    PushOneCommit.Result r = push.to(git, "refs/for/master%submit");
    r.assertOkStatus();
    r.assertChange(Change.Status.MERGED, null, admin);
    assertSubmitApproval(r.getPatchSetId());
    assertCommit(project, "refs/heads/master");
    assertTag(project, "refs/heads/master", tag);
}
#end_block

#method_before
private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException {
    Repository r = repoManager.openRepository(project);
    try {
        RevWalk rw = new RevWalk(r);
        try {
            String commitSha1 = r.getRef(branch).getObjectId().getName();
            String tag = r.getRef(tagName).getObjectId().getName();
            assertEquals(commitSha1, tag);
        } finally {
            rw.release();
        }
    } finally {
        r.close();
    }
}
#method_after
private void assertTag(Project.NameKey project, String branch, String tagName) throws IOException {
    Repository r = repoManager.openRepository(project);
    try {
        ObjectId headCommit = r.getRef(branch).getObjectId();
        ObjectId taggedCommit = r.getRef(tagName).getObjectId();
        assertEquals(headCommit, taggedCommit);
    } finally {
        r.close();
    }
}
#end_block

#method_before
public Result to(Git git, String ref) throws GitAPIException, IOException {
    _to(git, ref);
    return new Result(db, ref, pushHead(git, ref, false), changeId, subject);
}
#method_after
public Result to(Git git, String ref) throws GitAPIException, IOException {
    add(git, fileName, content);
    if (changeId != null) {
        amendCommit(git, i, subject, changeId);
    } else {
        changeId = createCommit(git, i, subject);
    }
    if (tagName != null) {
        git.tag().setName(tagName).setAnnotated(false).call();
    }
    return new Result(db, ref, pushHead(git, ref, tagName != null), changeId, subject);
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (cd.getSubmitRecordLabels() != null && standard && !detailed) {
        // them.
        return labelsFromSavedState(cd.getSubmitRecordLabels());
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, labelTypes, standard, detailed);
    } else {
        return labelsForClosedChange(cd, labelTypes, standard, detailed);
    }
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    if (cd.getSubmitRecordLabels() != null && standard && !detailed) {
        // Use saved labels to avoid recomputing on the fly.
        return labelsFromSavedState(cd.getSubmitRecordLabels());
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    LabelTypes labelTypes = ctl.getLabelTypes();
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, labelTypes, standard, detailed);
    } else {
        return labelsForClosedChange(cd, labelTypes, standard, detailed);
    }
}
#end_block

#method_before
@Override
public byte[] get(ChangeData input, FieldDef.FillArgs args) throws OrmException {
    return toProto(CODEC, input.change(args.db));
}
#method_after
@Override
public byte[] get(ChangeData input, FieldDef.FillArgs args) throws OrmException {
    return CODEC.encodeToByteArray(input.change(args.db));
}
#end_block

#method_before
private static <T> List<byte[]> toProtos(ProtobufCodec<T> codec, Collection<T> objs) throws OrmException {
    List<byte[]> result = Lists.newArrayListWithCapacity(objs.size());
    ByteArrayOutputStream out = new ByteArrayOutputStream(256);
    for (T obj : objs) {
        out.reset();
        result.add(toProto(codec, obj, out));
    }
    return result;
}
#method_after
private static <T> List<byte[]> toProtos(ProtobufCodec<T> codec, Collection<T> objs) throws OrmException {
    List<byte[]> result = Lists.newArrayListWithCapacity(objs.size());
    ByteArrayOutputStream out = new ByteArrayOutputStream(256);
    try {
        for (T obj : objs) {
            out.reset();
            CodedOutputStream cos = CodedOutputStream.newInstance(out);
            codec.encode(obj, cos);
            cos.flush();
            result.add(out.toByteArray());
        }
    } catch (IOException e) {
        throw new OrmException(e);
    }
    return result;
}
#end_block

#method_before
static void call(Button b, final ChangeInfo info, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            if (info.status().isClosed()) {
                String cm = commitMessage.trim();
                String cmWithoutChangeId = cm.substring(0, cm.lastIndexOf("Change-Id"));
                String cmChangeId = cm.substring(cm.lastIndexOf("Change-Id"));
                message.setText(Util.M.cherryPickedChangeDefaultMessage(cmWithoutChangeId, revision, cmChangeId));
            } else {
                message.setText(commitMessage.trim());
            }
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(info.legacy_id().get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#method_after
static void call(Button b, final ChangeInfo info, final String revision, String project, final String commitMessage) {
    // TODO Replace CherryPickDialog with a nicer looking display.
    b.setEnabled(false);
    new CherryPickDialog(b, new Project.NameKey(project)) {

        {
            sendButton.setText(Util.C.buttonCherryPickChangeSend());
            if (info.status().isClosed()) {
                message.setText(Util.M.cherryPickedChangeDefaultMessage(commitMessage.trim(), revision));
            } else {
                message.setText(commitMessage.trim());
            }
        }

        @Override
        public void onSend() {
            ChangeApi.cherrypick(info.legacy_id().get(), revision, getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo result) {
                    sent = true;
                    hide();
                    Gerrit.display(PageLinks.toChange2(result.legacy_id()));
                }

                @Override
                public void onFailure(Throwable caught) {
                    enableButtons(true);
                    super.onFailure(caught);
                }
            });
        }
    }.center();
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        if (changeDetail.getChange().getStatus().isClosed()) {
                            String cm = detail.getInfo().getMessage().trim();
                            String cmWithoutChangeId = cm.substring(0, cm.lastIndexOf("Change-Id"));
                            String cmChangeId = cm.substring(cm.lastIndexOf("Change-Id"));
                            message.setText(Util.M.cherryPickedChangeDefaultMessage(cmWithoutChangeId, detail.getPatchSet().getRevision().get(), cmChangeId));
                        } else {
                            message.setText(detail.getInfo().getMessage().trim());
                        }
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        if (changeDetail.getChange().getStatus().isClosed()) {
                            message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                        } else {
                            message.setText(detail.getInfo().getMessage().trim());
                        }
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
private void collectPluginCapabilities(Map<String, CapabilityInfo> output) {
    for (String pluginName : pluginCapabilities.plugins()) {
        for (Map.Entry<String, Provider<CapabilityDefinition>> entry : pluginCapabilities.byPlugin(pluginName).entrySet()) {
            if (isPluginNameSane(pluginName)) {
                String id = String.format("%s-%s", pluginName, entry.getKey());
                output.put(id, new CapabilityInfo(id, entry.getValue().get().getDescription()));
            } else {
                log.warn(String.format("Plugin name is not sane: <%s> " + "dropping plugin owned capability %s; " + "consider to change the plugin file name.", pluginName, entry.getKey()));
            }
        }
    }
}
#method_after
private void collectPluginCapabilities(Map<String, CapabilityInfo> output) {
    for (String pluginName : pluginCapabilities.plugins()) {
        if (!isPluginNameSane(pluginName)) {
            log.warn(String.format("Plugin name %s must match [A-Za-z0-9-]+ to use capabilities;" + " rename the plugin", pluginName));
            continue;
        }
        for (Map.Entry<String, Provider<CapabilityDefinition>> entry : pluginCapabilities.byPlugin(pluginName).entrySet()) {
            String id = String.format("%s-%s", pluginName, entry.getKey());
            output.put(id, new CapabilityInfo(id, entry.getValue().get().getDescription()));
        }
    }
}
#end_block

#method_before
private PersonIdent createPersonIdent() {
    return ((IdentifiedUser) currentUser).newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#method_after
private PersonIdent createPersonIdent() {
    return identifiedUser.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(((IdentifiedUser) currentUser.get()).newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().publishedByPatchSet(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(new ChangeResource(control), patchSet), new Provider<CurrentUser>() {

        @Override
        public CurrentUser get() {
            return user;
        }
    }))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#method_after
@Override
public PatchSetDetail call() throws OrmException, NoSuchEntityException, PatchSetInfoNotAvailableException, NoSuchChangeException {
    if (control == null || patchSet == null) {
        control = changeControlFactory.validateFor(psIdNew.getParentKey());
        patchSet = db.patchSets().get(psIdNew);
        if (patchSet == null) {
            throw new NoSuchEntityException();
        }
    }
    projectKey = control.getProject().getNameKey();
    final PatchList list;
    try {
        if (psIdBase != null) {
            oldId = toObjectId(psIdBase);
            newId = toObjectId(psIdNew);
            list = listFor(keyFor(diffPrefs.getIgnoreWhitespace()));
        } else {
            // OK, means use base to compare
            list = patchListCache.get(control.getChange(), patchSet);
        }
    } catch (PatchListNotAvailableException e) {
        throw new NoSuchEntityException();
    }
    final List<Patch> patches = list.toPatchList(patchSet.getId());
    final Map<Patch.Key, Patch> byKey = new HashMap<Patch.Key, Patch>();
    for (final Patch p : patches) {
        byKey.put(p.getKey(), p);
    }
    for (final PatchLineComment c : db.patchComments().publishedByPatchSet(psIdNew)) {
        final Patch p = byKey.get(c.getKey().getParentKey());
        if (p != null) {
            p.setCommentCount(p.getCommentCount() + 1);
        }
    }
    detail = new PatchSetDetail();
    detail.setPatchSet(patchSet);
    detail.setProject(projectKey);
    detail.setInfo(infoFactory.get(db, psIdNew));
    detail.setPatches(patches);
    final CurrentUser user = control.getCurrentUser();
    if (user instanceof IdentifiedUser) {
        // If we are signed in, compute the number of draft comments by the
        // current user on each of these patch files. This way they can more
        // quickly locate where they have pending drafts, and review them.
        // 
        final Account.Id me = ((IdentifiedUser) user).getAccountId();
        for (final PatchLineComment c : db.patchComments().draftByPatchSetAuthor(psIdNew, me)) {
            final Patch p = byKey.get(c.getKey().getParentKey());
            if (p != null) {
                p.setDraftCount(p.getDraftCount() + 1);
            }
        }
        for (AccountPatchReview r : db.accountPatchReviews().byReviewer(me, psIdNew)) {
            final Patch p = byKey.get(r.getKey().getPatchKey());
            if (p != null) {
                p.setReviewedByCurrentUser(true);
            }
        }
    }
    detail.setCommands(Lists.newArrayList(Iterables.transform(UiActions.sorted(UiActions.plugins(UiActions.from(revisions, new RevisionResource(new ChangeResource(control), patchSet), Providers.of(user)))), new Function<UiAction.Description, UiCommandDetail>() {

        @Override
        public UiCommandDetail apply(UiAction.Description in) {
            UiCommandDetail r = new UiCommandDetail();
            r.method = in.getMethod();
            r.id = in.getId();
            r.label = in.getLabel();
            r.title = in.getTitle();
            r.enabled = in.isEnabled();
            return r;
        }
    })));
    return detail;
}
#end_block

#method_before
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    String pluginName = null;
    if (cmd instanceof BaseCommand) {
        pluginName = ((BaseCommand) cmd).getPluginName();
    }
    try {
        CapabilityUtils.checkRequiresCapability(currentUser, pluginName, cmd.getClass());
    } catch (AuthException e) {
        throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability");
    }
}
#method_after
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    String pluginName = null;
    if (cmd instanceof BaseCommand) {
        pluginName = ((BaseCommand) cmd).getPluginName();
    }
    try {
        CapabilityUtils.checkRequiresCapability(currentUser, pluginName, cmd.getClass());
    } catch (AuthException e) {
        throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, e.getMessage());
    }
}
#end_block

#method_before
private static <T extends Annotation> T getClassAnnotation(Class<?> clazz, Class<T> annotationClass) {
    if (clazz == null) {
        return null;
    }
    T annot = clazz.getAnnotation(annotationClass);
    if (annot == null) {
        annot = getClassAnnotation(clazz.getSuperclass(), annotationClass);
        if (annot != null) {
            return annot;
        }
    }
    return annot;
}
#method_after
private static <T extends Annotation> T getClassAnnotation(Class<?> clazz, Class<T> annotationClass) {
    for (; clazz != null; clazz = clazz.getSuperclass()) {
        T t = clazz.getAnnotation(annotationClass);
        if (t != null) {
            return t;
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            post(PROJECT_KIND, "delete-project").to(UiDeleteAction.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(CacheDeleteHandler.class);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
    bind(DatabaseDeleteHandler.class).to(registerDatabaseHandler());
    bind(FilesystemDeleteHandler.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            delete(PROJECT_KIND).to(DeleteProject.class);
            post(PROJECT_KIND, "delete").to(DeleteProject.class);
        }
    });
}
#end_block

#method_before
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#method_after
private Class<? extends DatabaseDeleteHandler> registerDatabaseHandler() {
    int schemaVersion = SchemaVersion.guessVersion(SchemaVersion.C);
    // Injection of version dependent database handlers
    Class<? extends DatabaseDeleteHandler> databaseDeleteHandlerClass = null;
    switch(schemaVersion) {
        case 73:
        case 74:
        case 75:
        case 76:
            databaseDeleteHandlerClass = Schema73DatabaseDeleteHandler.class;
            break;
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 83:
            databaseDeleteHandlerClass = Schema77DatabaseDeleteHandler.class;
            break;
        default:
            throw new RuntimeException("This version of the delete-project plugin is not " + "compatible with your current schema version (Version: " + schemaVersion + "). Please update the plugin.");
    }
    assert databaseDeleteHandlerClass != null : "No database handler set";
    return databaseDeleteHandlerClass;
}
#end_block

#method_before
@Override
public void assertCanDelete(Project project) throws CannotDeleteProjectException {
    try {
        if (db.submoduleSubscriptions().bySubmoduleProject(project.getNameKey()).iterator().hasNext()) {
            throw new CannotDeleteProjectException("Project is subscribed by other projects.");
        }
    } catch (OrmException e) {
        throw new CannotDeleteProjectException(e);
    }
}
#method_after
@Override
public void assertCanDelete(Project project) throws CannotDeleteProjectException, OrmException {
    if (db.submoduleSubscriptions().bySubmoduleProject(project.getNameKey()).iterator().hasNext()) {
        throw new CannotDeleteProjectException("Project is subscribed by other projects.");
    }
}
#end_block

#method_before
@Override
public void run() throws Failure {
    final Project project = projectControl.getProject();
    final String projectName = project.getName();
    // Don't let people delete All-Projects, that's stupid
    if (projectName.endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project);
    } catch (CannotDeleteProjectException e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        StringBuilder msgBuilder = new StringBuilder();
        msgBuilder.append("Really delete ");
        msgBuilder.append(projectName);
        msgBuilder.append("?\n");
        msgBuilder.append("This is an operation which permanently deletes ");
        msgBuilder.append("data. This cannot be undone!\n");
        msgBuilder.append("If you are sure you wish to delete this project, ");
        msgBuilder.append("re-run\n");
        msgBuilder.append("with the --yes-really-delete flag.\n");
        die(msgBuilder.toString());
    }
    if (!force) {
        Collection<String> warnings = null;
        try {
            warnings = databaseDeleteHandler.getWarnings(project);
        } catch (OrmException e) {
            die(e);
        }
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            die(msgBuilder.toString());
        }
    }
    try {
        databaseDeleteHandler.delete(project);
        filesystemDeleteHandler.delete(project, preserveGitRepository);
        cacheDeleteHandler.delete(project);
    } catch (OrmException e) {
        die(e);
    } catch (RepositoryNotFoundException e) {
        die(e);
    } catch (IOException e) {
        die(e);
    }
}
#method_after
@Override
public void run() throws Failure {
    final Project project = projectControl.getProject();
    final String projectName = project.getName();
    // Don't let people delete All-Projects, that's stupid
    if (projectName.endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project);
    } catch (CannotDeleteProjectException e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    } catch (OrmException e) {
        die(e);
    }
    if (!yesReallyDelete) {
        StringBuilder msgBuilder = new StringBuilder();
        msgBuilder.append("Really delete ");
        msgBuilder.append(projectName);
        msgBuilder.append("?\n");
        msgBuilder.append("This is an operation which permanently deletes ");
        msgBuilder.append("data. This cannot be undone!\n");
        msgBuilder.append("If you are sure you wish to delete this project, ");
        msgBuilder.append("re-run\n");
        msgBuilder.append("with the --yes-really-delete flag.\n");
        throw new UnloggedFailure(msgBuilder.toString());
    }
    if (!force) {
        Collection<String> warnings = null;
        try {
            warnings = databaseDeleteHandler.getWarnings(project);
        } catch (OrmException e) {
            die(e);
        }
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    try {
        databaseDeleteHandler.delete(project);
        filesystemDeleteHandler.delete(project, preserveGitRepository);
        cacheDeleteHandler.delete(project);
    } catch (OrmException e) {
        die(e);
    } catch (RepositoryNotFoundException e) {
        die(e);
    } catch (IOException e) {
        die(e);
    }
}
#end_block

#method_before
private void deleteGitRepository(final Repository repository) throws RepositoryNotFoundException {
    // Delete the repository from disk
    File parentFile = repository.getDirectory().getParentFile();
    if (!recursiveDelete(repository.getDirectory())) {
        throw new RepositoryNotFoundException("Error trying to delete " + repository.getDirectory().getAbsolutePath());
    }
    // Delete parent folders while they are (now) empty
    recursiveDeleteParent(parentFile, gitDir);
}
#method_after
private void deleteGitRepository(final Repository repository) throws IOException {
    // Delete the repository from disk
    File parentFile = repository.getDirectory().getParentFile();
    if (!recursiveDelete(repository.getDirectory())) {
        throw new IOException("Error trying to delete " + repository.getDirectory().getAbsolutePath());
    }
    // Delete parent folders while they are (now) empty
    recursiveDeleteParent(parentFile, gitDir);
}
#end_block

#method_before
@Override
public void assertCanDelete(Project project) throws CannotDeleteProjectException {
    final Connection conn = ((JdbcSchema) db).getConnection();
    final String projectName = project.getName();
    try {
        // TODO(mch): This is an ugly hack, ideally we could do it with SubmoduleSubscriptionAccess
        if (conn.createStatement().executeQuery("SELECT * FROM submodule_subscriptions WHERE " + "super_project_project_name = '" + projectName + "'").first()) {
            throw new CannotDeleteProjectException("Project has subscribed submodules.");
        }
        if (conn.createStatement().executeQuery("SELECT * FROM submodule_subscriptions WHERE " + "submodule_project_name = '" + projectName + "'").first()) {
            throw new CannotDeleteProjectException("Project is subscribed by other projects.");
        }
    } catch (SQLException e) {
        throw new CannotDeleteProjectException(e);
    }
}
#method_after
@Override
public void assertCanDelete(Project project) throws CannotDeleteProjectException, OrmException {
    final Connection conn = ((JdbcSchema) db).getConnection();
    final String projectName = project.getName();
    try {
        // TODO(mch): This is an ugly hack, ideally we could do it with SubmoduleSubscriptionAccess
        if (conn.createStatement().executeQuery("SELECT * FROM submodule_subscriptions WHERE " + "super_project_project_name = '" + projectName + "'").first()) {
            throw new CannotDeleteProjectException("Project has subscribed submodules.");
        }
        if (conn.createStatement().executeQuery("SELECT * FROM submodule_subscriptions WHERE " + "submodule_project_name = '" + projectName + "'").first()) {
            throw new CannotDeleteProjectException("Project is subscribed by other projects.");
        }
    } catch (SQLException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    final Project project = projectControl.getProject();
    final String projectName = project.getName();
    // Don't let people delete All-Projects, that's stupid
    if (projectName.endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project);
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        StringBuilder msgBuilder = new StringBuilder();
        msgBuilder.append("Really delete ");
        msgBuilder.append(projectName);
        msgBuilder.append("?\n");
        msgBuilder.append("This is an operation which permanently deletes");
        msgBuilder.append("data. This cannot be undone!\n");
        msgBuilder.append("If you are sure you wish to delete this project, ");
        msgBuilder.append("re-run\n");
        msgBuilder.append("with the --yes-really-delete flag.\n");
        throw new UnloggedFailure(msgBuilder.toString());
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project);
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project);
    filesystemDeleteHandler.delete(preserveGitRepository, project);
    cacheDeleteHandler.delete(project);
}
#method_after
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    final Project project = projectControl.getProject();
    final String projectName = project.getName();
    // Don't let people delete All-Projects, that's stupid
    if (projectName.endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project);
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        StringBuilder msgBuilder = new StringBuilder();
        msgBuilder.append("Really delete ");
        msgBuilder.append(projectName);
        msgBuilder.append("?\n");
        msgBuilder.append("This is an operation which permanently deletes");
        msgBuilder.append("data. This cannot be undone!\n");
        msgBuilder.append("If you are sure you wish to delete this project, ");
        msgBuilder.append("re-run\n");
        msgBuilder.append("with the --yes-really-delete flag.\n");
        throw new UnloggedFailure(msgBuilder.toString());
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project);
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project);
    filesystemDeleteHandler.delete(project);
    cacheDeleteHandler.delete(project);
}
#end_block

#method_before
public void delete(boolean preserveGitRepository, Project project) throws IOException, RepositoryNotFoundException, UnloggedFailure {
    // Remove from the jgit cache
    final Repository repository = repoManager.openRepository(project.getNameKey());
    if (repository == null) {
        throw new UnloggedFailure("There was an error finding the project.");
    }
    cleanCache(repository);
    if (!preserveGitRepository) {
        deleteGitRepository(repository);
    }
}
#method_after
public void delete(Project project) throws IOException, RepositoryNotFoundException, UnloggedFailure {
    // Remove from the jgit cache
    final Repository repository = repoManager.openRepository(project.getNameKey());
    if (repository == null) {
        throw new UnloggedFailure("There was an error finding the project.");
    }
    cleanCache(repository);
    deleteGitRepository(repository);
}
#end_block

#method_before
private void initEditMessageAction() {
    NativeMap<ActionInfo> actions = changeInfo.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(changeInfo.legacy_id(), revision, changeInfo.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#method_after
private void initEditMessageAction(ChangeInfo info, String revision) {
    NativeMap<ActionInfo> actions = info.revision(revision).actions();
    if (actions != null && actions.containsKey("message")) {
        editMessage.setVisible(true);
        editMessageAction = new EditMessageAction(info.legacy_id(), revision, info.revision(revision).commit().message(), style, editMessage, reply);
        keysAction.add(new KeyCommand(0, 'e', Util.C.keyEditMessage()) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                editMessageAction.onEdit();
            }
        });
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    downloadPatch.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderDownload(info, revision);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction(info, revision);
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    Collections.sort(Natives.asList(list), new Comparator<RevisionInfo>() {

        @Override
        public int compare(RevisionInfo a, RevisionInfo b) {
            return a._number() - b._number();
        }
    });
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#method_after
private void renderRevisions(ChangeInfo info) {
    if (info.revisions().size() == 1) {
        UIObject.setVisible(revisionParent, false);
        return;
    }
    JsArray<RevisionInfo> list = info.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(list);
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isReversePatchSetOrder()) {
        Collections.reverse(Natives.asList(list));
    }
    int selected = -1;
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        revisionList.addItem(r._number() + ": " + r.name().substring(0, 6), "" + r._number());
        if (revision.equals(r.name())) {
            selected = i;
        }
    }
    if (0 <= selected) {
        revisionList.setSelectedIndex(selected);
    }
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                }.setContentType("application/mbox").base64();
                if (download) {
                    bin.setAttachmentName(String.format("%s.diff.base64", rw.getObjectReader().abbreviate(commit, 8).name()));
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    Project.NameKey project = rsrc.getControl().getProject().getNameKey();
    boolean close = true;
    try {
        final Repository repo = repoManager.openRepository(project);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
                RevCommit[] parents = commit.getParents();
                if (parents.length > 1) {
                    throw new ResourceConflictException("Revision has more than 1 parent.");
                } else if (parents.length == 0) {
                    throw new ResourceConflictException("Revision has no parent.");
                }
                final RevCommit base = parents[0];
                rw.parseBody(base);
                BinaryResult bin = new BinaryResult() {

                    @Override
                    public void writeTo(OutputStream out) throws IOException {
                        if (zip) {
                            ZipOutputStream zos = new ZipOutputStream(out);
                            ZipEntry e = new ZipEntry(fileName(rw, commit));
                            e.setTime(commit.getCommitTime() * 1000L);
                            zos.putNextEntry(e);
                            format(zos);
                            zos.closeEntry();
                            zos.finish();
                        } else {
                            format(out);
                        }
                    }

                    private void format(OutputStream out) throws IOException {
                        out.write(formatEmailHeader(commit).getBytes(UTF_8));
                        DiffFormatter fmt = new DiffFormatter(out);
                        fmt.setRepository(repo);
                        fmt.format(base.getTree(), commit.getTree());
                        fmt.flush();
                    }

                    @Override
                    public void close() throws IOException {
                        rw.release();
                        repo.close();
                    }
                };
                if (zip) {
                    bin.disableGzip().setContentType("application/zip").setAttachmentName(fileName(rw, commit) + ".zip");
                } else {
                    bin.base64().setContentType("application/mbox").setAttachmentName(download ? fileName(rw, commit) + ".base64" : null);
                }
                close = false;
                return bin;
            } finally {
                if (close) {
                    rw.release();
                }
            }
        } finally {
            if (close) {
                repo.close();
            }
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException();
    }
}
#end_block

#method_before
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private ViewData view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return new ViewData(p.get(0), view);
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return new ViewData(null, core);
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        Map.Entry<String, RestView<RestResource>> entry = Iterables.getOnlyElement(r.entrySet());
        return new ViewData(entry.getKey(), entry.getValue());
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: %s", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Integer.valueOf(startLine).hashCode() + Integer.valueOf(startCharacter).hashCode() + Integer.valueOf(endLine).hashCode() + Integer.valueOf(endCharacter).hashCode();
}
#method_after
@Override
public int hashCode() {
    int h = startLine;
    h = h * 31 + startCharacter;
    h = h * 31 + endLine;
    h = h * 31 + endCharacter;
    return h;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbg = new CallbackGroup();
    AccessMap.get(getProjectKey(), cbg.add(new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            isOwner = result.isOwner();
            enableForm();
            saveProject.setVisible(isOwner);
        }
    }));
    ProjectApi.getParent(getProjectKey(), cbg.add(new GerritCallback<Project.NameKey>() {

        @Override
        public void onSuccess(Project.NameKey result) {
            parent = result;
        }
    }));
    ProjectApi.getConfig(getProjectKey(), cbg.add(new ScreenLoadCallback<ConfigInfo>(this) {

        @Override
        public void preDisplay(ConfigInfo result) {
            display(result);
        }
    }));
    cbg.done();
    savedPanel = INFO;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    Project.NameKey project = getProjectKey();
    CallbackGroup cbg = new CallbackGroup();
    AccessMap.get(project, cbg.add(new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            isOwner = result.isOwner();
            enableForm();
            saveProject.setVisible(isOwner);
        }
    }));
    ProjectApi.getParent(project, cbg.add(new GerritCallback<Project.NameKey>() {

        @Override
        public void onSuccess(Project.NameKey result) {
            parent = result;
        }
    }));
    ProjectApi.getConfig(project, cbg.addFinal(new ScreenLoadCallback<ConfigInfo>(this) {

        @Override
        public void preDisplay(ConfigInfo result) {
            display(result);
        }
    }));
    savedPanel = INFO;
}
#end_block

#method_before
@Override
public String apply(RevisionResource rev, Input input) {
    final String greeting = input.french ? "Bonjour" : "Hello";
    return String.format("%s %s!", greeting, Strings.isNullOrEmpty(input.message) ? Objects.firstNonNull(user.get().getUserName(), "world") : input.message);
}
#method_after
@Override
public String apply(RevisionResource rev, Input input) {
    final String greeting = input.french ? "Bonjour" : "Hello";
    return String.format("%s %s from change %s, patch set %d!", greeting, Strings.isNullOrEmpty(input.message) ? Objects.firstNonNull(user.get().getUserName(), "world") : input.message, rev.getChange().getId().toString(), rev.getPatchSet().getPatchSetId());
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Alt-N", diffChunkNav(cm, false)).on("Alt-P", diffChunkNav(cm, true)).on("Alt-O", new Runnable() {

        @Override
        public void run() {
            if (cm.hasActiveLine()) {
                List<PublishedBox> list = linePublishedBoxesMap.get(cm.getActiveLine());
                boolean open = false;
                for (PublishedBox box : list) {
                    if (!box.isOpen()) {
                        open = true;
                        break;
                    }
                }
                for (PublishedBox box : list) {
                    box.setOpen(open);
                }
            }
        }
    }).on("Shift-Left", flipCursorSide(cm, true)).on("Shift-Right", flipCursorSide(cm, false)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Alt-N", diffChunkNav(cm, false)).on("Alt-P", diffChunkNav(cm, true)).on("Shift-O", openClosePublished(cm)).on("Shift-Left", flipCursorSide(cm, true)).on("Shift-Right", flipCursorSide(cm, false)));
}
#end_block

#method_before
@Override
protected void configure() {
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DeleteProjectCapability.DELETE_PROJECT_CAPABILITY)).to(DeleteProjectCapability.class);
}
#method_after
@Override
protected void configure() {
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(DELETE_PROJECT)).to(DeleteProjectCapability.class);
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        return new ConfigInfo(projectStateFactory.create(projectConfig), config);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#method_after
@Override
public ConfigInfo apply(ProjectResource rsrc, Input input) throws ResourceNotFoundException, BadRequestException, ResourceConflictException {
    Project.NameKey projectName = rsrc.getNameKey();
    if (!rsrc.getControl().isOwner()) {
        throw new ResourceNotFoundException(projectName.get());
    }
    if (input == null) {
        throw new BadRequestException("config is required");
    }
    final MetaDataUpdate md;
    try {
        md = metaDataUpdateFactory.create(projectName);
    } catch (RepositoryNotFoundException notFound) {
        throw new ResourceNotFoundException(projectName.get());
    } catch (IOException e) {
        throw new ResourceNotFoundException(projectName.get(), e);
    }
    try {
        ProjectConfig projectConfig = ProjectConfig.read(md);
        Project p = projectConfig.getProject();
        p.setDescription(Strings.emptyToNull(input.description));
        if (input.useContributorAgreements != null) {
            p.setUseContributorAgreements(input.useContributorAgreements);
        }
        if (input.useContentMerge != null) {
            p.setUseContentMerge(input.useContentMerge);
        }
        if (input.useSignedOffBy != null) {
            p.setUseSignedOffBy(input.useSignedOffBy);
        }
        if (input.requireChangeId != null) {
            p.setRequireChangeID(input.requireChangeId);
        }
        if (input.maxObjectSizeLimit != null) {
            p.setMaxObjectSizeLimit(input.maxObjectSizeLimit);
        }
        if (input.submitType != null) {
            p.setSubmitType(input.submitType);
        }
        if (input.state != null) {
            p.setState(input.state);
        }
        md.setMessage("Modified project settings\n");
        try {
            projectConfig.commit(md);
            (new PerRequestProjectControlCache(projectCache, self.get())).evict(projectConfig.getProject());
        } catch (IOException e) {
            throw new ResourceConflictException("Cannot update " + projectName);
        }
        return new ConfigInfo(projectStateFactory.create(projectConfig), config);
    } catch (ConfigInvalidException err) {
        throw new ResourceConflictException("Cannot read project " + projectName, err);
    } catch (IOException err) {
        throw new ResourceConflictException("Cannot update project " + projectName, err);
    } finally {
        md.close();
    }
}
#end_block

#method_before
@UiHandler("editCommitMessage")
void onEditMessage(ClickEvent e) {
    if (Gerrit.isSignedIn()) {
        editCommitMessageAction.onEdit();
    } else {
        Gerrit.doSignIn(getToken());
    }
}
#method_after
@UiHandler("editMessage")
void onEditMessage(ClickEvent e) {
    editMessageAction.onEdit();
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    initEditCommitMessageAction();
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        initEditMessageAction();
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "edit_commit_message").to(EditCommitMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
        }
    });
}
#end_block

#method_before
@Override
public String apply(RevisionResource rev, Input input) {
    return String.format("%s %s!", "Hello", Objects.firstNonNull(cu.get().getUserName(), "world"));
}
#method_after
@Override
public String apply(RevisionResource rev, Input input) {
    return String.format("%s %s!", "Hello", Objects.firstNonNull(user.get().getUserName(), "world"));
}
#end_block

#method_before
@Override
public Description getDescription(RevisionResource resource) {
    return new Description().setLabel("Say hello").setTitle("Say hello in different languages").setVisible(cu.get() instanceof IdentifiedUser).setEnabled(true);
}
#method_after
@Override
public Description getDescription(RevisionResource resource) {
    return new Description().setLabel("Say hello").setTitle("Say hello in different languages").setVisible(user.get() instanceof IdentifiedUser);
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            removeActiveLineHighlight(cm);
            removeActiveLineHighlight(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.prev.isVisible() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.next.isVisible() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Alt-N", diffChunkNav(cm, false)).on("Alt-P", diffChunkNav(cm, true)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            removeActiveLineHighlight(cm);
            removeActiveLineHighlight(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Alt-N", diffChunkNav(cm, false)).on("Alt-P", diffChunkNav(cm, true)));
}
#end_block

#method_before
private void setupNav(InlineHyperlink link, int key, String help, FileInfo info) {
    if (info != null) {
        final String url = url(info);
        link.setTargetHistoryToken(url);
        link.setTitle(getFileName(info.path()));
        keys.add(new KeyCommand(0, key, help) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                Gerrit.display(url);
            }
        });
    } else {
        link.setVisible(false);
        keys.add(new UpToChangeCommand2(patchSetId, 0, key));
    }
}
#method_after
private void setupNav(InlineHyperlink link, int key, String help, FileInfo info) {
    if (info != null) {
        final String url = url(info);
        link.setTargetHistoryToken(url);
        link.setTitle(getFileName(info.path()));
        keys.add(new KeyCommand(0, key, help) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                Gerrit.display(url);
            }
        });
        if (link == prev) {
            hasPrev = true;
        } else {
            hasNext = true;
        }
    } else {
        link.getElement().getStyle().setVisibility(Visibility.HIDDEN);
        keys.add(new UpToChangeCommand2(patchSetId, 0, key));
    }
}
#end_block

#method_before
private void readEvalPrintLoop() {
    final StringBuilder buffer = new StringBuilder();
    boolean executed = false;
    for (; ; ) {
        if (outputFormat == OutputFormat.PRETTY) {
            print(buffer.length() == 0 || executed ? "gerrit> " : "     -> ");
        }
        String line = readLine();
        if (line == null) {
            return;
        }
        if (line.startsWith("\\")) {
            // Shell command, check the various cases we recognize
            // 
            line = line.substring(1);
            if (line.equals("h") || line.equals("?")) {
                showHelp();
            } else if (line.equals("q")) {
                if (outputFormat == OutputFormat.PRETTY) {
                    println("Bye");
                }
                return;
            } else if (line.equals("r")) {
                buffer.setLength(0);
                executed = false;
            } else if (line.equals("p")) {
                println(buffer.toString());
            } else if (line.equals("g")) {
                if (buffer.length() > 0) {
                    executeStatement(buffer.toString());
                    executed = true;
                }
            } else if (line.equals("d")) {
                listTables();
            } else if (line.startsWith("d ")) {
                showTable(line.substring(2).trim());
            } else {
                final String msg = "'\\" + line + "' not supported";
                switch(outputFormat) {
                    case JSON:
                        {
                            final JsonObject err = new JsonObject();
                            err.addProperty("type", "error");
                            err.addProperty("message", msg);
                            println(err.toString());
                            break;
                        }
                    case PRETTY:
                    default:
                        println("ERROR: " + msg);
                        println("");
                        showHelp();
                        break;
                }
            }
            continue;
        }
        if (executed) {
            buffer.setLength(0);
            executed = false;
        }
        if (buffer.length() > 0) {
            buffer.append('\n');
        }
        buffer.append(line);
        if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == ';') {
            executeStatement(buffer.toString());
            executed = true;
        }
    }
}
#method_after
private void readEvalPrintLoop() {
    final StringBuilder buffer = new StringBuilder();
    boolean executed = false;
    for (; ; ) {
        if (outputFormat == OutputFormat.PRETTY) {
            print(buffer.length() == 0 || executed ? "gerrit> " : "     -> ");
        }
        String line = readLine();
        if (line == null) {
            return;
        }
        if (line.startsWith("\\")) {
            // Shell command, check the various cases we recognize
            // 
            line = line.substring(1);
            if (line.equals("h") || line.equals("?")) {
                showHelp();
            } else if (line.equals("q")) {
                if (outputFormat == OutputFormat.PRETTY) {
                    println("Bye");
                }
                return;
            } else if (line.equals("r")) {
                buffer.setLength(0);
                executed = false;
            } else if (line.equals("p")) {
                println(buffer.toString());
            } else if (line.equals("g")) {
                if (buffer.length() > 0) {
                    executeStatement(buffer.toString());
                    executed = true;
                }
            } else if (line.equals("d")) {
                listTables();
            } else if (line.startsWith("d ")) {
                showTable(line.substring(2).trim());
            } else {
                final String msg = "'\\" + line + "' not supported";
                switch(outputFormat) {
                    case JSON_SINGLE:
                    case JSON:
                        {
                            final JsonObject err = new JsonObject();
                            err.addProperty("type", "error");
                            err.addProperty("message", msg);
                            println(err.toString());
                            break;
                        }
                    case PRETTY:
                    default:
                        println("ERROR: " + msg);
                        println("");
                        showHelp();
                        break;
                }
            }
            continue;
        }
        if (executed) {
            buffer.setLength(0);
            executed = false;
        }
        if (buffer.length() > 0) {
            buffer.append('\n');
        }
        buffer.append(line);
        if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == ';') {
            executeStatement(buffer.toString());
            executed = true;
        }
    }
}
#end_block

#method_before
private void listTables() {
    final DatabaseMetaData meta;
    try {
        meta = connection.getMetaData();
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        final String[] types = { "TABLE", "VIEW" };
        ResultSet rs = meta.getTables(null, null, null, types);
        try {
            if (outputFormat == OutputFormat.PRETTY) {
                println("                     List of relations");
            }
            showResultSet(// 
            rs, // 
            false, // 
            0, // 
            Identity.create(rs, "TABLE_SCHEM"), // 
            Identity.create(rs, "TABLE_NAME"), Identity.create(rs, "TABLE_TYPE"));
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
    }
    println("");
}
#method_after
private void listTables() {
    final DatabaseMetaData meta;
    try {
        meta = connection.getMetaData();
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        final String[] types = { "TABLE", "VIEW" };
        ResultSet rs = meta.getTables(null, null, null, types);
        try {
            if (outputFormat == OutputFormat.PRETTY) {
                println("                     List of relations");
            }
            showResultSet(rs, false, 0, Identity.create(rs, "TABLE_SCHEM"), Identity.create(rs, "TABLE_NAME"), Identity.create(rs, "TABLE_TYPE"));
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
    }
    println("");
}
#end_block

#method_before
private void showTable(String tableName) {
    final DatabaseMetaData meta;
    try {
        meta = connection.getMetaData();
        if (meta.storesUpperCaseIdentifiers()) {
            tableName = tableName.toUpperCase();
        } else if (meta.storesLowerCaseIdentifiers()) {
            tableName = tableName.toLowerCase();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        ResultSet rs = meta.getColumns(null, null, tableName, null);
        try {
            if (!rs.next()) {
                throw new SQLException("Table " + tableName + " not found");
            }
            if (outputFormat == OutputFormat.PRETTY) {
                println("                     Table " + tableName);
            }
            showResultSet(// 
            rs, // 
            true, // 
            0, // 
            Identity.create(rs, "COLUMN_NAME"), new Function("TYPE") {

                @Override
                String apply(final ResultSet rs) throws SQLException {
                    String type = rs.getString("TYPE_NAME");
                    switch(rs.getInt("DATA_TYPE")) {
                        case java.sql.Types.CHAR:
                        case java.sql.Types.VARCHAR:
                            type += "(" + rs.getInt("COLUMN_SIZE") + ")";
                            break;
                    }
                    String def = rs.getString("COLUMN_DEF");
                    if (def != null && !def.isEmpty()) {
                        type += " DEFAULT " + def;
                    }
                    int nullable = rs.getInt("NULLABLE");
                    if (nullable == DatabaseMetaData.columnNoNulls) {
                        type += " NOT NULL";
                    }
                    return type;
                }
            });
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        ResultSet rs = meta.getIndexInfo(null, null, tableName, false, true);
        try {
            Map<String, IndexInfo> indexes = new TreeMap<String, IndexInfo>();
            while (rs.next()) {
                final String indexName = rs.getString("INDEX_NAME");
                IndexInfo def = indexes.get(indexName);
                if (def == null) {
                    def = new IndexInfo();
                    def.name = indexName;
                    indexes.put(indexName, def);
                }
                if (!rs.getBoolean("NON_UNIQUE")) {
                    def.unique = true;
                }
                final int pos = rs.getInt("ORDINAL_POSITION");
                final String col = rs.getString("COLUMN_NAME");
                String desc = rs.getString("ASC_OR_DESC");
                if ("D".equals(desc)) {
                    desc = " DESC";
                } else {
                    desc = "";
                }
                def.addColumn(pos, col + desc);
                String filter = rs.getString("FILTER_CONDITION");
                if (filter != null && !filter.isEmpty()) {
                    def.filter.append(filter);
                }
            }
            if (outputFormat == OutputFormat.PRETTY) {
                println("");
                println("Indexes on " + tableName + ":");
                for (IndexInfo def : indexes.values()) {
                    println("  " + def);
                }
            }
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    println("");
}
#method_after
private void showTable(String tableName) {
    final DatabaseMetaData meta;
    try {
        meta = connection.getMetaData();
        if (meta.storesUpperCaseIdentifiers()) {
            tableName = tableName.toUpperCase();
        } else if (meta.storesLowerCaseIdentifiers()) {
            tableName = tableName.toLowerCase();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        ResultSet rs = meta.getColumns(null, null, tableName, null);
        try {
            if (!rs.next()) {
                throw new SQLException("Table " + tableName + " not found");
            }
            if (outputFormat == OutputFormat.PRETTY) {
                println("                     Table " + tableName);
            }
            showResultSet(rs, true, 0, Identity.create(rs, "COLUMN_NAME"), new Function("TYPE") {

                @Override
                String apply(final ResultSet rs) throws SQLException {
                    String type = rs.getString("TYPE_NAME");
                    switch(rs.getInt("DATA_TYPE")) {
                        case java.sql.Types.CHAR:
                        case java.sql.Types.VARCHAR:
                            type += "(" + rs.getInt("COLUMN_SIZE") + ")";
                            break;
                    }
                    String def = rs.getString("COLUMN_DEF");
                    if (def != null && !def.isEmpty()) {
                        type += " DEFAULT " + def;
                    }
                    int nullable = rs.getInt("NULLABLE");
                    if (nullable == DatabaseMetaData.columnNoNulls) {
                        type += " NOT NULL";
                    }
                    return type;
                }
            });
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        ResultSet rs = meta.getIndexInfo(null, null, tableName, false, true);
        try {
            Map<String, IndexInfo> indexes = new TreeMap<String, IndexInfo>();
            while (rs.next()) {
                final String indexName = rs.getString("INDEX_NAME");
                IndexInfo def = indexes.get(indexName);
                if (def == null) {
                    def = new IndexInfo();
                    def.name = indexName;
                    indexes.put(indexName, def);
                }
                if (!rs.getBoolean("NON_UNIQUE")) {
                    def.unique = true;
                }
                final int pos = rs.getInt("ORDINAL_POSITION");
                final String col = rs.getString("COLUMN_NAME");
                String desc = rs.getString("ASC_OR_DESC");
                if ("D".equals(desc)) {
                    desc = " DESC";
                } else {
                    desc = "";
                }
                def.addColumn(pos, col + desc);
                String filter = rs.getString("FILTER_CONDITION");
                if (filter != null && !filter.isEmpty()) {
                    def.filter.append(filter);
                }
            }
            if (outputFormat == OutputFormat.PRETTY) {
                println("");
                println("Indexes on " + tableName + ":");
                for (IndexInfo def : indexes.values()) {
                    println("  " + def);
                }
            }
        } finally {
            rs.close();
        }
    } catch (SQLException e) {
        error(e);
        return;
    }
    println("");
}
#end_block

#method_before
private void executeStatement(final String sql) {
    final long start = System.currentTimeMillis();
    final boolean hasResultSet;
    try {
        hasResultSet = statement.execute(sql);
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        if (hasResultSet) {
            final ResultSet rs = statement.getResultSet();
            try {
                showResultSet(rs, false, start);
            } finally {
                rs.close();
            }
        } else {
            final int updateCount = statement.getUpdateCount();
            final long ms = System.currentTimeMillis() - start;
            switch(outputFormat) {
                case JSON:
                    {
                        final JsonObject tail = new JsonObject();
                        tail.addProperty("type", "update-stats");
                        tail.addProperty("rowCount", updateCount);
                        tail.addProperty("runTimeMilliseconds", ms);
                        println(tail.toString());
                        break;
                    }
                case PRETTY:
                default:
                    println("UPDATE " + updateCount + "; " + ms + " ms");
                    break;
            }
        }
    } catch (SQLException e) {
        error(e);
    }
}
#method_after
private void executeStatement(final String sql) {
    final long start = System.currentTimeMillis();
    final boolean hasResultSet;
    try {
        hasResultSet = statement.execute(sql);
    } catch (SQLException e) {
        error(e);
        return;
    }
    try {
        if (hasResultSet) {
            final ResultSet rs = statement.getResultSet();
            try {
                showResultSet(rs, false, start);
            } finally {
                rs.close();
            }
        } else {
            final int updateCount = statement.getUpdateCount();
            final long ms = System.currentTimeMillis() - start;
            switch(outputFormat) {
                case JSON_SINGLE:
                case JSON:
                    {
                        final JsonObject tail = new JsonObject();
                        tail.addProperty("type", "update-stats");
                        tail.addProperty("rowCount", updateCount);
                        tail.addProperty("runTimeMilliseconds", ms);
                        println(tail.toString());
                        break;
                    }
                case PRETTY:
                default:
                    println("UPDATE " + updateCount + "; " + ms + " ms");
                    break;
            }
        }
    } catch (SQLException e) {
        error(e);
    }
}
#end_block

#method_before
private void showResultSet(final ResultSet rs, boolean alreadyOnRow, long start, Function... show) throws SQLException {
    switch(outputFormat) {
        case JSON:
            showResultSetJson(rs, alreadyOnRow, start, show);
            break;
        case PRETTY:
        default:
            showResultSetPretty(rs, alreadyOnRow, start, show);
            break;
    }
}
#method_after
private void showResultSet(final ResultSet rs, boolean alreadyOnRow, long start, Function... show) throws SQLException {
    switch(outputFormat) {
        case JSON_SINGLE:
        case JSON:
            showResultSetJson(rs, alreadyOnRow, start, show);
            break;
        case PRETTY:
        default:
            showResultSetPretty(rs, alreadyOnRow, start, show);
            break;
    }
}
#end_block

#method_before
private void showResultSetJson(final ResultSet rs, boolean alreadyOnRow, long start, Function... show) throws SQLException {
    JsonArray collector = new JsonArray();
    final ResultSetMetaData meta = rs.getMetaData();
    final Function[] columnMap;
    if (show != null && 0 < show.length) {
        columnMap = show;
    } else {
        final int colCnt = meta.getColumnCount();
        columnMap = new Function[colCnt];
        for (int colId = 0; colId < colCnt; colId++) {
            final int p = colId + 1;
            final String name = meta.getColumnLabel(p);
            columnMap[colId] = new Identity(p, name);
        }
    }
    int rowCnt = 0;
    final int colCnt = columnMap.length;
    while (alreadyOnRow || rs.next()) {
        final JsonObject row = new JsonObject();
        final JsonObject cols = new JsonObject();
        for (int c = 0; c < colCnt; c++) {
            String v = columnMap[c].apply(rs);
            if (v == null) {
                continue;
            }
            cols.addProperty(columnMap[c].name.toLowerCase(), v);
        }
        row.addProperty("type", "row");
        row.add("columns", cols);
        collector.add(row);
        alreadyOnRow = false;
        rowCnt++;
    }
    if (start != 0) {
        final JsonObject tail = new JsonObject();
        tail.addProperty("type", "query-stats");
        tail.addProperty("rowCount", rowCnt);
        final long ms = System.currentTimeMillis() - start;
        tail.addProperty("runTimeMilliseconds", ms);
        collector.add(tail);
    }
    println(collector.toString());
}
#method_after
private void showResultSetJson(final ResultSet rs, boolean alreadyOnRow, long start, Function... show) throws SQLException {
    JsonArray collector = new JsonArray();
    final ResultSetMetaData meta = rs.getMetaData();
    final Function[] columnMap;
    if (show != null && 0 < show.length) {
        columnMap = show;
    } else {
        final int colCnt = meta.getColumnCount();
        columnMap = new Function[colCnt];
        for (int colId = 0; colId < colCnt; colId++) {
            final int p = colId + 1;
            final String name = meta.getColumnLabel(p);
            columnMap[colId] = new Identity(p, name);
        }
    }
    int rowCnt = 0;
    final int colCnt = columnMap.length;
    while (alreadyOnRow || rs.next()) {
        final JsonObject row = new JsonObject();
        final JsonObject cols = new JsonObject();
        for (int c = 0; c < colCnt; c++) {
            String v = columnMap[c].apply(rs);
            if (v == null) {
                continue;
            }
            cols.addProperty(columnMap[c].name.toLowerCase(), v);
        }
        row.addProperty("type", "row");
        row.add("columns", cols);
        switch(outputFormat) {
            case JSON:
                println(row.toString());
                break;
            case JSON_SINGLE:
                collector.add(row);
                break;
            default:
                final JsonObject obj = new JsonObject();
                obj.addProperty("type", "error");
                obj.addProperty("message", "Unsupported Json variant");
                println(obj.toString());
                return;
        }
        alreadyOnRow = false;
        rowCnt++;
    }
    JsonObject tail = null;
    if (start != 0) {
        tail = new JsonObject();
        tail.addProperty("type", "query-stats");
        tail.addProperty("rowCount", rowCnt);
        final long ms = System.currentTimeMillis() - start;
        tail.addProperty("runTimeMilliseconds", ms);
    }
    switch(outputFormat) {
        case JSON:
            if (tail != null) {
                println(tail.toString());
            }
            break;
        case JSON_SINGLE:
            if (tail != null) {
                collector.add(tail);
            }
            println(collector.toString());
            break;
        default:
            final JsonObject obj = new JsonObject();
            obj.addProperty("type", "error");
            obj.addProperty("message", "Unsupported Json variant");
            println(obj.toString());
            return;
    }
}
#end_block

#method_before
private void warning(final String msg) {
    switch(outputFormat) {
        case JSON:
            {
                final JsonObject obj = new JsonObject();
                obj.addProperty("type", "warning");
                obj.addProperty("message", msg);
                println(obj.toString());
                break;
            }
        case PRETTY:
        default:
            println("WARNING: " + msg);
            break;
    }
}
#method_after
private void warning(final String msg) {
    switch(outputFormat) {
        case JSON_SINGLE:
        case JSON:
            {
                final JsonObject obj = new JsonObject();
                obj.addProperty("type", "warning");
                obj.addProperty("message", msg);
                println(obj.toString());
                break;
            }
        case PRETTY:
        default:
            println("WARNING: " + msg);
            break;
    }
}
#end_block

#method_before
private void error(final SQLException err) {
    switch(outputFormat) {
        case JSON:
            {
                final JsonObject obj = new JsonObject();
                obj.addProperty("type", "error");
                obj.addProperty("message", err.getMessage());
                println(obj.toString());
                break;
            }
        case PRETTY:
        default:
            println("ERROR: " + err.getMessage());
            break;
    }
}
#method_after
private void error(final SQLException err) {
    switch(outputFormat) {
        case JSON_SINGLE:
        case JSON:
            {
                final JsonObject obj = new JsonObject();
                obj.addProperty("type", "error");
                obj.addProperty("message", err.getMessage());
                println(obj.toString());
                break;
            }
        case PRETTY:
        default:
            println("ERROR: " + err.getMessage());
            break;
    }
}
#end_block

#method_before
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    clearRange();
    setRangeHighlight(false);
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, comment.line() - 1);
    getCm().focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(true)));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(DisplaySide.A, false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(DisplaySide.B, false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(DisplaySide.A, true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(DisplaySide.B, true)));
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#end_block

#method_before
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                addAllToCommentList(in, toDrafts);
            }
        }
    };
}
#method_after
private GerritCallback<NativeMap<JsArray<CommentInfo>>> getCommentCallback(final DisplaySide side, final boolean toDrafts) {
    return new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            JsArray<CommentInfo> in = result.get(path);
            if (in != null) {
                if (toDrafts) {
                    if (side == DisplaySide.A) {
                        draftsBase = in;
                    } else {
                        draftsRevision = in;
                    }
                } else {
                    if (side == DisplaySide.A) {
                        publishedBase = in;
                    } else {
                        publishedRevision = in;
                    }
                }
            }
        }
    };
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line()) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, null);
    }
}
#method_after
CommentInfo createReply(CommentInfo replyTo) {
    if (!replyTo.has_line() && replyTo.range() == null) {
        return CommentInfo.createFile(path, replyTo.side(), replyTo.id(), null);
    } else {
        return CommentInfo.createRange(path, replyTo.side(), replyTo.line(), replyTo.id(), null, replyTo.range());
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    Side side = info.side();
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info, DisplaySide side) {
    CodeMirror cm = getCmFromSide(side);
    final DraftBox box = new DraftBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    DisplaySide side = box.getSide();
    CodeMirror cm = getCmFromSide(side);
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(side, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(side, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#method_after
void removeDraft(DraftBox box, int line) {
    LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    diffTable.addFileCommentBox(box, side);
}
#method_after
void addFileCommentBox(CommentBox box) {
    diffTable.addFileCommentBox(box);
}
#end_block

#method_before
void removeFileCommentBox(DraftBox box, Side side) {
    diffTable.onRemoveDraftBox(box, side);
}
#method_after
void removeFileCommentBox(DraftBox box) {
    diffTable.onRemoveDraftBox(box);
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished(JsArray<CommentInfo> published) {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = published == publishedBase ? DisplaySide.A : DisplaySide.B;
        }
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts(JsArray<CommentInfo> drafts) {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = drafts == draftsBase ? DisplaySide.A : DisplaySide.B;
        }
        DraftBox box = new DraftBox(this, getCmFromSide(side), side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        if (publishedBase != null || publishedRevision != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private PatchSet.Id getPatchSetIdFromSide(Side side) {
    return side == Side.PARENT && base != null ? base : revision;
}
#method_after
private PatchSet.Id getPatchSetIdFromSide(DisplaySide side) {
    return side == DisplaySide.A && base != null ? base : revision;
}
#end_block

#method_before
private CodeMirror getCmFromSide(Side side) {
    return side == Side.PARENT ? cmA : cmB;
}
#method_after
private CodeMirror getCmFromSide(DisplaySide side) {
    return side == DisplaySide.A ? cmA : cmB;
}
#end_block

#method_before
private Side getSideFromCm(CodeMirror cm) {
    return cm == cmA ? Side.PARENT : Side.REVISION;
}
#method_after
private DisplaySide getSideFromCm(CodeMirror cm) {
    return cm == cmA ? DisplaySide.A : DisplaySide.B;
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            if (!(cm.hasActiveLine() && instance.getLineNumber(cm.getActiveLine()) == line)) {
                instance.setCursor(LineCharacter.create(line));
                instance.setActiveLine(cm.getLineHandle(line));
            }
            insertNewDraft(cm).run();
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addDraftBox(CommentInfo.createRange(path, getSideFromCm(cm), line + 1, null, null, cm.somethingSelected() ? CommentRange.fromFromTo(cm.getSelectedRange()) : null)));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            FromTo fromTo = cm.getSelectedRange();
            if (cm.somethingSelected()) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, fromTo.getTo().getLine() == line ? fromTo : null));
            } else if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line, null));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private DiffChunkInfo getDiffChunk(Side side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#method_after
private DiffChunkInfo getDiffChunk(DisplaySide side, int line) {
    for (DiffChunkInfo info : diffChunks) {
        if (info.getSide() == side && info.getStart() <= line && line <= info.getEnd()) {
            return info;
        }
    }
    return null;
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#method_after
void resizePaddingOnOtherSide(DisplaySide mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
private RenderLineHandler resizeLinePadding(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeLinePadding(final DisplaySide side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (lineActiveBoxMap.containsKey(handle)) {
                lineActiveBoxMap.get(handle).resizePaddingWidget();
            }
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
Side getSide() {
    return side;
}
#method_after
DisplaySide getSide() {
    return side;
}
#end_block

#method_before
public static FromTo create(LineCharacter from, LineCharacter to) {
    FromTo fromTo = createObject().cast();
    fromTo.setFrom(from);
    fromTo.setTo(to);
    return fromTo;
}
#method_after
public static FromTo create(CommentRange range) {
    return create(LineCharacter.create(range.start_line() - 1, range.start_character()), LineCharacter.create(range.end_line() - 1, range.end_character()));
}
#end_block

#method_before
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment), getSide());
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box, comment.side());
        }
    } else {
        openReplyBox();
    }
}
#method_after
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            parent.addFileCommentBox(box);
        }
    } else {
        openReplyBox();
    }
}
#end_block

#method_before
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result, getSide());
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box);
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#method_after
public static CommentRange create(FromTo fromTo) {
    if (fromTo == null) {
        return null;
    }
    LineCharacter from = fromTo.getFrom();
    LineCharacter to = fromTo.getTo();
    return create(from.getLine() + 1, from.getCh(), to.getLine() + 1, to.getCh());
}
#end_block

#method_before
private FileCommentPanel getPanelFromSide(Side side) {
    return side == Side.PARENT ? fileCommentPanelA : fileCommentPanelB;
}
#method_after
private FileCommentPanel getPanelFromSide(DisplaySide side) {
    return side == DisplaySide.A ? fileCommentPanelA : fileCommentPanelB;
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#method_after
void createOrEditFileComment(DisplaySide side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
void addFileCommentBox(CommentBox box, Side side) {
    getPanelFromSide(side).addFileComment(box);
}
#method_after
void addFileCommentBox(CommentBox box) {
    getPanelFromSide(box.getSide()).addFileComment(box);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box, Side side) {
    getPanelFromSide(side).onRemoveDraftBox(box);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    getPanelFromSide(box.getSide()).onRemoveDraftBox(box);
}
#end_block

#method_before
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(side, diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void run(final ReviewDb db) throws OrmException {
    try {
        final JdbcSchema schema = (JdbcSchema) db;
        final Connection c = schema.getConnection();
        final SqlDialect dialect = schema.getDialect();
        final Statement stmt = c.createStatement();
        try {
            for (String sql : commands) {
                try {
                    if (!dialect.canHandleStatementDelimiterInScript()) {
                        sql = CharMatcher.anyOf(";").trimTrailingFrom(sql);
                    }
                    stmt.execute(sql);
                } catch (SQLException e) {
                    throw new OrmException("Error in " + name + ":\n" + sql, e);
                }
            }
        } finally {
            stmt.close();
        }
    } catch (SQLException e) {
        throw new OrmException("Cannot run statements for " + name, e);
    }
}
#method_after
void run(final ReviewDb db) throws OrmException {
    try {
        final JdbcSchema schema = (JdbcSchema) db;
        final Connection c = schema.getConnection();
        final SqlDialect dialect = schema.getDialect();
        final Statement stmt = c.createStatement();
        try {
            for (String sql : commands) {
                try {
                    if (!dialect.isStatementDelimiterSupported()) {
                        sql = CharMatcher.is(';').trimTrailingFrom(sql);
                    }
                    stmt.execute(sql);
                } catch (SQLException e) {
                    throw new OrmException("Error in " + name + ":\n" + sql, e);
                }
            }
        } finally {
            stmt.close();
        }
    } catch (SQLException e) {
        throw new OrmException("Cannot run statements for " + name, e);
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "Administrators");
    session = new RestSession(admin);
    db = reviewDbProvider.open();
}
#method_after
@Before
public void setUp() throws Exception {
    admin = accounts.create("admin", "Administrators");
    session = new RestSession(server, admin);
    db = reviewDbProvider.open();
}
#end_block

#method_before
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    // 
    } else {
        upgradeFrom(ui, curr, db, toTargetVersion);
    }
}
#method_after
public final void check(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    if (curr.versionNbr == versionNbr) {
    // Nothing to do, we are at the correct schema.
    } else if (curr.versionNbr > versionNbr) {
        throw new OrmException("Cannot downgrade database schema from version " + curr.versionNbr + " to " + versionNbr + ".");
    } else {
        upgradeFrom(ui, curr, db);
    }
}
#end_block

#method_before
protected void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db, boolean toTargetVersion) throws OrmException, SQLException {
    final JdbcSchema s = (JdbcSchema) db;
    if (curr.versionNbr > versionNbr) {
        throw new OrmException("Cannot downgrade database schema from version " + curr.versionNbr + " to " + versionNbr + ".");
    }
    prior.get().check(ui, curr, db, false);
    ui.message("Upgrading database schema from version " + curr.versionNbr + " to " + versionNbr + " ...");
    preUpdateSchema(db);
    final JdbcExecutor e = new JdbcExecutor(s);
    try {
        s.updateSchema(e);
        migrateData(db, ui);
        if (toTargetVersion) {
            final List<String> pruneList = new ArrayList<String>();
            s.pruneSchema(new StatementExecutor() {

                public void execute(String sql) {
                    pruneList.add(sql);
                }
            });
            if (!pruneList.isEmpty()) {
                ui.pruneSchema(e, pruneList);
            }
        }
    } finally {
        e.close();
    }
    finish(curr, db);
}
#method_after
private void upgradeFrom(UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    List<SchemaVersion> pending = pending(curr.versionNbr);
    updateSchema(pending, ui, db);
    migrateData(pending, ui, curr, db);
    JdbcSchema s = (JdbcSchema) db;
    JdbcExecutor e = new JdbcExecutor(s);
    try {
        final List<String> pruneList = Lists.newArrayList();
        s.pruneSchema(new StatementExecutor() {

            public void execute(String sql) {
                pruneList.add(sql);
            }
        });
        if (!pruneList.isEmpty()) {
            ui.pruneSchema(e, pruneList);
        }
    } finally {
        e.close();
    }
}
#end_block

#method_before
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
}
#method_after
private void migrateData(List<SchemaVersion> pending, UpdateUI ui, CurrentSchemaVersion curr, ReviewDb db) throws OrmException, SQLException {
    for (SchemaVersion v : pending) {
        ui.message(String.format("Migrating data to schema %d ...", v.getVersionNbr()));
        v.migrateData(db, ui);
        v.finish(curr, db);
    }
}
#end_block

#method_before
@Override
public void initConfig(Section databaseSection) {
    final String defPort = "1521";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Server port", "port", defPort, true);
    databaseSection.string("Database name", "database", "xe");
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#method_after
@Override
public void initConfig(Section databaseSection) {
    final String defPort = "1521";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Server port", "port", defPort, false);
    databaseSection.string("Instance name", "instance", "xe");
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#end_block

#method_before
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:oracle:thin:@");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append(":");
    b.append(dbc.required("database"));
    return b.toString();
}
#method_after
@Override
public String getUrl() {
    final StringBuilder b = new StringBuilder();
    final ConfigSection dbc = new ConfigSection(cfg, "database");
    b.append("jdbc:oracle:thin:@");
    b.append(hostname(dbc.optional("hostname")));
    b.append(port(dbc.optional("port")));
    b.append(":");
    b.append(dbc.required("instance"));
    return b.toString();
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serve("/say-hello").with(HelloWorldServlet.class);
    serve("/say-hello/*").with(HelloWorldServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serve("/say-hello/*").with(HelloWorldServlet.class);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    doPost(req, rsp);
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding("UTF-8");
    final Writer out = rsp.getWriter();
    out.write("<html>");
    out.write("<body>");
    out.write("<h2>Hello world!</h2>");
    out.write("</body>");
    out.write("</html>");
    out.close();
}
#end_block

#method_before
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    if (all) {
        pushAllFactory.create(urlMatch).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch);
            } else {
                throw new UnloggedFailure(1, "error: '" + name + "': not a Gerrit project");
            }
        }
    }
}
#method_after
@Override
protected void run() throws Failure {
    if (all && projectNames.size() > 0) {
        throw new UnloggedFailure(1, "error: cannot combine --all and PROJECT");
    }
    ReplicationState state = new ReplicationState(ReplicationType.COMMAND, this);
    Future<?> future = null;
    if (all) {
        future = pushAllFactory.create(urlMatch, state).schedule(0, TimeUnit.SECONDS);
    } else {
        for (String name : projectNames) {
            Project.NameKey key = new Project.NameKey(name);
            if (projectCache.get(key) != null) {
                replication.scheduleFullSync(key, urlMatch, state);
            } else {
                writeStdErrSync("error: '" + name + "': not a Gerrit project");
            }
        }
        state.markAllPushTasksScheduled();
    }
    if (wait) {
        if (future != null) {
            try {
                future.get();
            } catch (InterruptedException e) {
                wrappedLog.error("Thread was interrupted while waiting for PushAll operation to finish", e, state);
                return;
            } catch (ExecutionException e) {
                wrappedLog.error("An exception was thrown in PushAll operation", e, state);
                return;
            }
        }
        if (state.hasPushTask()) {
            try {
                state.waitForReplication();
            } catch (InterruptedException e) {
                writeStdErrSync("We are interrupted while waiting replication to complete");
            }
        } else {
            writeStdOutSync("Nothing to replicate");
        }
    }
}
#end_block

#method_before
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
}
#method_after
@Test
public void testList() throws Exception {
    Map<String, CapabilityInfo> m = injector.getInstance(ListCapabilities.class).apply(new ConfigResource());
    for (String id : GlobalCapability.getAllNames()) {
        assertTrue("contains " + id, m.containsKey(id));
        assertEquals(id, m.get(id).id);
        assertNotNull(id + " has name", m.get(id).name);
    }
    String pluginCapability = "gerrit-printHello";
    assertTrue("contains " + pluginCapability, m.containsKey(pluginCapability));
    assertEquals(pluginCapability, m.get(pluginCapability).id);
    assertEquals("Print Hello", m.get(pluginCapability).name);
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(getName(), cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
private void checkRequiresCapability(String baseName, Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        if (!ctl.canPerform(rc.value()) && !ctl.canAdministrateServer()) {
            // then it must be a plugin-owned capability
            if (!GlobalCapability.isCapability(rc.value())) {
                if (ctl.canPerform(String.format("%s-%s", baseName, rc.value()))) {
                    return;
                }
            }
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), rc.value());
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#method_after
private void checkRequiresCapability(Command cmd) throws UnloggedFailure {
    RequiresCapability rc = cmd.getClass().getAnnotation(RequiresCapability.class);
    if (rc != null) {
        CurrentUser user = currentUser.get();
        CapabilityControl ctl = user.getCapabilities();
        String capability = rc.value();
        if (cmd instanceof BaseCommand) {
            String pluginName = ((BaseCommand) cmd).getPluginName();
            if (pluginName != null && !"gerrit".equals(pluginName) && (rc.scope() == CapabilityScope.PLUGIN || rc.scope() == CapabilityScope.CONTEXT)) {
                capability = String.format("%s-%s", pluginName, rc.value());
            } else if (rc.scope() == CapabilityScope.PLUGIN) {
                log.error(String.format("Class %s uses @%s(scope=%s), but is not within a plugin", cmd.getClass().getName(), RequiresCapability.class.getSimpleName(), CapabilityScope.PLUGIN.name()));
                throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, "fatal: cannot check capability");
            }
        }
        if (!ctl.canPerform(capability) && !ctl.canAdministrateServer()) {
            String msg = String.format("fatal: %s does not have \"%s\" capability.", user.getUserName(), capability);
            throw new UnloggedFailure(BaseCommand.STATUS_NOT_ADMIN, msg);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        // because it might be provided by plugin
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(varName));
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), parts.get(1));
}
#method_after
private static LabelValue parseLabelValue(String src) {
    List<String> parts = ImmutableList.copyOf(Splitter.on(CharMatcher.WHITESPACE).omitEmptyStrings().limit(2).split(src));
    if (parts.isEmpty()) {
        throw new IllegalArgumentException("empty value");
    }
    String valueText = parts.size() > 1 ? parts.get(1) : "";
    return new LabelValue(Shorts.checkedCast(PermissionRule.parseInt(parts.get(0))), valueText);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), defaultStateValue);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            // because it might be provided by plugin
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#method_after
private void saveAccessSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (!have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = Permission.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
}
#end_block

#method_before
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    }
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), in.line != null ? in.line : 0, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#method_after
@Override
public Response<CommentInfo> apply(RevisionResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    if (Strings.isNullOrEmpty(in.path)) {
        throw new BadRequestException("path must be non-empty");
    } else if (in.message == null || in.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (in.line != null && in.line <= 0) {
        throw new BadRequestException("line must be > 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.getEndLine() : 0;
    PatchLineComment c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), ChangeUtil.messageUUID(db.get())), line, rsrc.getAccountId(), Url.decode(in.inReplyTo));
    c.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    c.setMessage(in.message.trim());
    c.setRange(in.range);
    db.get().patchComments().insert(Collections.singleton(c));
    return Response.created(new CommentInfo(c, null));
}
#end_block

#method_before
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#method_after
@Override
public Object apply(DraftResource rsrc, Input in) throws AuthException, BadRequestException, ResourceConflictException, OrmException {
    PatchLineComment c = rsrc.getComment();
    if (in == null || in.message == null || in.message.trim().isEmpty()) {
        return delete.get().apply(rsrc, null);
    } else if (in.kind != null && !"gerritcodereview#comment".equals(in.kind)) {
        throw new BadRequestException("expected kind gerritcodereview#comment");
    } else if (in.id != null && !rsrc.getId().equals(in.id)) {
        throw new BadRequestException("id must match URL");
    } else if (in.line != null && in.line < 0) {
        throw new BadRequestException("line must be >= 0");
    } else if (in.line != null && in.range != null && in.line != in.range.getEndLine()) {
        throw new BadRequestException("range endLine must be on the same line as the comment");
    }
    if (in.path != null && !in.path.equals(c.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        db.get().patchComments().delete(Collections.singleton(c));
        c = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(rsrc.getPatchSet().getId(), in.path), c.getKey().get()), c.getLine(), rsrc.getAuthorId(), c.getParentUuid());
        db.get().patchComments().insert(Collections.singleton(update(c, in)));
    } else {
        db.get().patchComments().update(Collections.singleton(update(c, in)));
    }
    return new CommentInfo(c, null);
}
#end_block

#method_before
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.line != null) {
        e.setLine(in.line);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    e.setRange(in.range);
    e.updated();
    return e;
}
#method_after
private PatchLineComment update(PatchLineComment e, Input in) {
    if (in.side != null) {
        e.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    }
    if (in.inReplyTo != null) {
        e.setParentUuid(Url.decode(in.inReplyTo));
    }
    e.setMessage(in.message.trim());
    if (in.range != null || in.line != null) {
        e.setRange(in.range);
        e.setLine(in.range != null ? in.range.getEndLine() : in.line);
    }
    e.updated();
    return e;
}
#end_block

#method_before
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#method_after
@Override
public PatchLineComment call() throws NoSuchChangeException, OrmException {
    if (comment.getStatus() != PatchLineComment.Status.DRAFT) {
        throw new IllegalStateException("Comment published");
    }
    final Patch.Key patchKey = comment.getKey().getParentKey();
    final PatchSet.Id patchSetId = patchKey.getParentKey();
    final Change.Id changeId = patchKey.getParentKey().getParentKey();
    db.changes().beginTransaction(changeId);
    try {
        changeControlFactory.validateFor(changeId);
        if (db.patchSets().get(patchSetId) == null) {
            throw new NoSuchChangeException(changeId);
        }
        final Account.Id me = currentUser.getAccountId();
        if (comment.getKey().get() == null) {
            if (comment.getLine() < 0) {
                throw new IllegalStateException("Comment line must be >= 0, not " + comment.getLine());
            }
            if (comment.getParentUuid() != null) {
                final PatchLineComment parent = db.patchComments().get(new PatchLineComment.Key(patchKey, comment.getParentUuid()));
                if (parent == null || parent.getSide() != comment.getSide()) {
                    throw new IllegalStateException("Parent comment must be on same side");
                }
            }
            if (comment.getRange() != null && comment.getLine() != comment.getRange().getEndLine()) {
                throw new IllegalStateException("Range endLine must be on the same line as the comment");
            }
            final PatchLineComment nc = new PatchLineComment(new PatchLineComment.Key(patchKey, ChangeUtil.messageUUID(db)), comment.getLine(), me, comment.getParentUuid());
            nc.setSide(comment.getSide());
            nc.setMessage(comment.getMessage());
            nc.setRange(comment.getRange());
            db.patchComments().insert(Collections.singleton(nc));
            db.commit();
            return nc;
        } else {
            if (!me.equals(comment.getAuthor())) {
                throw new NoSuchChangeException(changeId);
            }
            comment.updated();
            db.patchComments().update(Collections.singleton(comment));
            db.commit();
            return comment;
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCh == other.startCh && endLine == other.endLine && endCh == other.endCh;
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof CommentRange) {
        CommentRange other = (CommentRange) obj;
        return startLine == other.startLine && startCharacter == other.startCharacter && endLine == other.endLine && endCharacter == other.endCharacter;
    }
    return false;
}
#end_block

#method_before
@Override
public String toString() {
    return "Range [startLine=" + startLine + ", startCh=" + startCh + ", endLine=" + endLine + ", endCh=" + endCh + "]";
}
#method_after
@Override
public String toString() {
    return "Range[startLine=" + startLine + ", startCharacter=" + startCharacter + ", endLine=" + endLine + ", endCharacter=" + endCharacter + "]";
}
#end_block

#method_before
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setLine(line);
    info.setRange(range);
    return info;
}
#method_after
public static CommentInfo createRange(String path, Side side, int line, String in_reply_to, String message, CommentRange range) {
    CommentInfo info = createFile(path, side, in_reply_to, message);
    info.setRange(range);
    info.setLine(range == null ? line : range.end_line());
    return info;
}
#end_block

#method_before
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.setStartLine(sl);
    r.setStartCh(sc);
    r.setEndLine(el);
    r.setEndCh(ec);
    return r;
}
#method_after
public static CommentRange create(int sl, int sc, int el, int ec) {
    CommentRange r = createObject().cast();
    r.set(sl, sc, el, ec);
    return r;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    Class.forName(org.postgresql.Driver.class.getName());
    // Oracle HR instance is available in express edition 11.g
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", "oracle.jdbc.driver.OracleDriver");
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE people");
}
#method_after
@Before
public void setUp() throws Exception {
    try {
        Class.forName(ORACLE_DRIVER);
    } catch (Exception e) {
        assumeNoException(e);
    }
    // Oracle instance name
    final String sid = "xe";
    // Oracle schema=user name=database
    final String user = "gwtorm";
    final String pass = "gwtorm";
    db = DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:" + sid, user, pass);
    executor = new JdbcExecutor(db);
    dialect = new DialectOracle().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", ORACLE_DRIVER);
    p.setProperty("url", db.getMetaData().getURL());
    p.setProperty("user", user);
    p.setProperty("password", pass);
    phoneBook = new Database<PhoneBookDb>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<PhoneBookDb2>(new SimpleDataSource(p), PhoneBookDb2.class);
    drop("SEQUENCE address_id");
    drop("SEQUENCE cnt");
    drop("TABLE addresses");
    drop("TABLE foo");
    drop("TABLE bar");
    drop("TABLE people");
}
#end_block

#method_before
@Override
public Set<String> listTables(final Connection db) throws SQLException {
    Statement s = db.createStatement();
    try {
        ResultSet rs = s.executeQuery("SELECT table_name FROM user_tables");
        try {
            HashSet<String> sequences = new HashSet<String>();
            while (rs.next()) {
                sequences.add(rs.getString(1).toLowerCase());
            }
            return sequences;
        } finally {
            rs.close();
        }
    } finally {
        s.close();
    }
}
#method_after
@Override
public Set<String> listTables(final Connection db) throws SQLException {
    Statement s = db.createStatement();
    try {
        ResultSet rs = s.executeQuery("SELECT table_name FROM user_tables");
        try {
            HashSet<String> tables = new HashSet<String>();
            while (rs.next()) {
                tables.add(rs.getString(1).toLowerCase());
            }
            return tables;
        } finally {
            rs.close();
        }
    } finally {
        s.close();
    }
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create(repo);
        try {
            mergeValidators.validatePreMerge(commit, destProject, destBranch);
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
public void validatePreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(new ProjectConfigValidator(repo, allProjectsName, db, ps, projectCache, identifiedUserFactory));
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
public void validatePreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    List<MergeValidationListener> validators = Lists.newLinkedList();
    validators.add(new PluginMergeValidationListener(mergeValidationListeners));
    validators.add(projectConfigValidatorFactory.create());
    for (MergeValidationListener validator : validators) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
@Override
public void onPreMerge(final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, ps.getId());
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#method_after
@Override
public void onPreMerge(final Repository repo, final CodeReviewCommit commit, final ProjectState destProject, final Branch.NameKey destBranch, final PatchSet.Id patchSetId) throws MergeValidationException {
    if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
        final Project.NameKey newParent;
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, commit);
            newParent = cfg.getProject().getParent(allProjectsName);
        } catch (Exception e) {
            throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION);
        }
        final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
        if (oldParent == null) {
            // update of the 'All-Projects' project
            if (newParent != null) {
                throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT);
            }
        } else {
            if (!oldParent.equals(newParent)) {
                final PatchSetApproval psa = getSubmitter(db, patchSetId);
                if (psa == null) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                if (!submitter.getCapabilities().canAdministrateServer()) {
                    throw new MergeValidationException(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN);
                }
                if (projectCache.get(newParent) == null) {
                    throw new MergeValidationException(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onPreMerge(CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(commit, destProject, destBranch);
    }
}
#method_after
@Override
public void onPreMerge(Repository repo, CodeReviewCommit commit, ProjectState destProject, Branch.NameKey destBranch, PatchSet.Id patchSetId) throws MergeValidationException {
    for (MergeValidationListener validator : mergeValidationListeners) {
        validator.onPreMerge(repo, commit, destProject, destBranch, patchSetId);
    }
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators commitValidators = commitValidatorsFactory.create(repo);
        try {
            commitValidators.validatePreMergeCommit(commit, destProject, destBranch);
        } catch (MergeValidationException cve) {
            commits.put(changeId, CodeReviewCommit.error(cve.getStatus()));
            continue;
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, Change> validateChangeList(final List<Change> submitted) throws MergeException {
    final ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    final Set<ObjectId> tips = new HashSet<ObjectId>();
    for (final Ref r : repo.getAllRefs().values()) {
        tips.add(r.getObjectId());
    }
    int commitOrder = 0;
    for (final Change chg : submitted) {
        final Change.Id changeId = chg.getId();
        if (chg.currentPatchSetId() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final PatchSet ps;
        try {
            ps = db.patchSets().get(chg.currentPatchSetId());
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        final String idstr = ps.getRevision().get();
        final ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_PATCH_SET));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        final CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            log.error("Invalid commit " + id.name() + " on " + chg.getKey(), e);
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.REVISION_GONE));
            continue;
        }
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            commits.put(changeId, CodeReviewCommit.error(mve.getStatus()));
            continue;
        }
        if (GitRepositoryManager.REF_CONFIG.equals(destBranch.get())) {
            final Project.NameKey newParent;
            try {
                ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
                cfg.load(repo, commit);
                newParent = cfg.getProject().getParent(allProjectsName);
            } catch (Exception e) {
                commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION));
                continue;
            }
            final Project.NameKey oldParent = destProject.getProject().getParent(allProjectsName);
            if (oldParent == null) {
                // update of the 'All-Projects' project
                if (newParent != null) {
                    commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT));
                    continue;
                }
            } else {
                if (!oldParent.equals(newParent)) {
                    final PatchSetApproval psa = getSubmitter(db, ps.getId());
                    if (psa == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    final IdentifiedUser submitter = identifiedUserFactory.create(psa.getAccountId());
                    if (!submitter.getCapabilities().canAdministrateServer()) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN));
                        continue;
                    }
                    if (projectCache.get(newParent) == null) {
                        commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND));
                        continue;
                    }
                }
            }
        }
        commit.change = chg;
        commit.patchsetId = ps.getId();
        commit.originalOrder = commitOrder++;
        commits.put(changeId, commit);
        if (branchTip != null) {
            // 
            try {
                if (rw.isMergedInto(commit, branchTip)) {
                    commit.statusCode = CommitMergeStatus.ALREADY_MERGED;
                    try {
                        setMergedPatchSet(chg.getId(), ps.getId());
                    } catch (OrmException e) {
                        log.error("Cannot mark change " + chg.getId() + " merged", e);
                    }
                    continue;
                }
            } catch (IOException err) {
                throw new MergeException("Cannot perform merge base test", err);
            }
        }
        final SubmitType submitType = getSubmitType(chg, ps);
        if (submitType == null) {
            commits.put(changeId, CodeReviewCommit.error(CommitMergeStatus.NO_SUBMIT_TYPE));
            continue;
        }
        commit.add(canMergeFlag);
        toMerge.put(submitType, commit);
        toSubmit.put(submitType, chg);
    }
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(final List<Change> submitted) {
    for (final Change c : submitted) {
        final CodeReviewCommit commit = commits.get(c.getId());
        final CommitMergeStatus s = commit != null ? commit.statusCode : null;
        if (s == null) {
            // 
            continue;
        }
        final String txt = s.getMessage();
        try {
            switch(s) {
                case CLEAN_MERGE:
                    setMerged(c, message(c, txt));
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    setMerged(c, message(c, txt + " as " + commit.name()));
                    break;
                case ALREADY_MERGED:
                    setMerged(c, null);
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(c, message(c, txt));
                    break;
                case MISSING_DEPENDENCY:
                    potentiallyStillSubmittable.add(commit);
                    break;
                default:
                    setNew(c, message(c, "Unspecified merge failure: " + s.name()));
                    break;
            }
        } catch (OrmException err) {
            log.warn("Error updating change status for " + c.getId(), err);
        }
        indexer.index(c);
    }
}
#end_block

#method_before
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#method_after
private void setMerged(final Change c, final ChangeMessage msg) throws OrmException {
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id merged = commit.change.currentPatchSetId();
        setMergedPatchSet(c.getId(), merged);
        PatchSetApproval submitter = saveApprovals(c, merged);
        addMergedMessage(submitter, msg);
        db.commit();
        sendMergedEmail(c, submitter);
        if (submitter != null) {
            try {
                hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(commit.patchsetId), db);
            } catch (OrmException ex) {
                log.error("Cannot run hook for submitted patch set " + c.getId(), ex);
            }
        }
    } finally {
        db.rollback();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
}
#end_block

#method_before
private void addColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    final SchemaModel model = dbDef.getSchemaModel();
    Set<String> have = // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase());
    for (final ColumnModel c : rel.getColumns()) {
        if (!have.contains(c.getColumnName().toLowerCase())) {
            dialect.addColumn(e, rel.getRelationName(), c);
        }
    }
}
#method_after
private void addColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    Set<String> have = // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase());
    for (final ColumnModel c : rel.getColumns()) {
        if (!have.contains(c.getColumnName().toLowerCase())) {
            dialect.addColumn(e, rel.getRelationName(), c);
        }
    }
}
#end_block

#method_before
public void renameTable(final StatementExecutor e, String from, String to) throws OrmException {
    try {
        final Statement s = getConnection().createStatement();
        try {
            getDialect().renameTable(e, from, to);
        } finally {
            s.close();
        }
    } catch (SQLException err) {
        throw new OrmException("Cannot rename table " + from + " to " + to, err);
    }
}
#method_after
public void renameTable(final StatementExecutor e, String from, String to) throws OrmException {
    Preconditions.checkNotNull(e);
    Preconditions.checkNotNull(from);
    Preconditions.checkNotNull(to);
    getDialect().renameTable(e, from, to);
}
#end_block

#method_before
public void renameField(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getField(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    try {
        final Statement s = getConnection().createStatement();
        try {
            getDialect().renameColumn(e, table, from, col);
        } finally {
            s.close();
        }
    } catch (SQLException err) {
        throw new OrmException("Cannot rename " + table + "." + from + " to " + to, err);
    }
}
#method_after
public void renameField(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getField(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    getDialect().renameColumn(e, table, from, col);
}
#end_block

#method_before
public void renameColumn(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getColumn(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    try {
        final Statement s = getConnection().createStatement();
        try {
            getDialect().renameColumn(e, table, from, col);
        } finally {
            s.close();
        }
    } catch (SQLException err) {
        throw new OrmException("Cannot rename " + table + "." + from + " to " + to, err);
    }
}
#method_after
public void renameColumn(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getColumn(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    getDialect().renameColumn(e, table, from, col);
}
#end_block

#method_before
private void pruneColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    final SchemaModel model = dbDef.getSchemaModel();
    HashSet<String> want = new HashSet<String>();
    for (final ColumnModel c : rel.getColumns()) {
        want.add(c.getColumnName().toLowerCase());
    }
    for (String column : // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase())) {
        if (!want.contains(column)) {
            dialect.dropColumn(e, rel.getRelationName(), column);
        }
    }
}
#method_after
private void pruneColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    HashSet<String> want = new HashSet<String>();
    for (final ColumnModel c : rel.getColumns()) {
        want.add(c.getColumnName().toLowerCase());
    }
    for (String column : // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase())) {
        if (!want.contains(column)) {
            dialect.dropColumn(e, rel.getRelationName(), column);
        }
    }
}
#end_block

#method_before
private void addColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    final SchemaModel model = dbDef.getSchemaModel();
    Set<String> have = // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase());
    for (final ColumnModel c : rel.getColumns()) {
        if (!have.contains(c.getColumnName().toLowerCase())) {
            dialect.addColumn(e, rel.getRelationName(), c);
        }
    }
}
#method_after
private void addColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    Set<String> have = // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase());
    for (final ColumnModel c : rel.getColumns()) {
        if (!have.contains(c.getColumnName().toLowerCase())) {
            dialect.addColumn(e, rel.getRelationName(), c);
        }
    }
}
#end_block

#method_before
public void renameTable(final StatementExecutor e, String from, String to) throws OrmException {
    try {
        final Statement s = getConnection().createStatement();
        try {
            getDialect().renameTable(e, from, to);
        } finally {
            s.close();
        }
    } catch (SQLException err) {
        throw new OrmException("Cannot rename table " + from + " to " + to, err);
    }
}
#method_after
public void renameTable(final StatementExecutor e, String from, String to) throws OrmException {
    Preconditions.checkNotNull(e);
    Preconditions.checkNotNull(from);
    Preconditions.checkNotNull(to);
    getDialect().renameTable(e, from, to);
}
#end_block

#method_before
public void renameField(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getField(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    try {
        final Statement s = getConnection().createStatement();
        try {
            getDialect().renameColumn(e, table, from, col);
        } finally {
            s.close();
        }
    } catch (SQLException err) {
        throw new OrmException("Cannot rename " + table + "." + from + " to " + to, err);
    }
}
#method_after
public void renameField(final StatementExecutor e, String table, String from, String to) throws OrmException {
    final RelationModel rel = findRelationModel(table);
    if (rel == null) {
        throw new OrmException("Relation " + table + " not defined");
    }
    final ColumnModel col = rel.getField(to);
    if (col == null) {
        throw new OrmException("Relation " + table + " does not have " + to);
    }
    getDialect().renameColumn(e, table, from, col);
}
#end_block

#method_before
private void pruneColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    final SchemaModel model = dbDef.getSchemaModel();
    HashSet<String> want = new HashSet<String>();
    for (final ColumnModel c : rel.getColumns()) {
        want.add(c.getColumnName().toLowerCase());
    }
    for (String column : // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase())) {
        if (!want.contains(column)) {
            dialect.dropColumn(e, rel.getRelationName(), column);
        }
    }
}
#method_after
private void pruneColumns(final StatementExecutor e, final RelationModel rel) throws SQLException, OrmException {
    final SqlDialect dialect = dbDef.getDialect();
    HashSet<String> want = new HashSet<String>();
    for (final ColumnModel c : rel.getColumns()) {
        want.add(c.getColumnName().toLowerCase());
    }
    for (String column : // 
    dialect.listColumns(getConnection(), rel.getRelationName().toLowerCase())) {
        if (!want.contains(column)) {
            dialect.dropColumn(e, rel.getRelationName(), column);
        }
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                published = m.get(path);
            }
        }));
    }
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            if (published == null) {
                published = m.get(path);
            } else {
                JsArray<CommentInfo> publishedInRevision = m.get(path);
                for (int i = 0; i < publishedInRevision.length(); i++) {
                    published.push(publishedInRevision.get(i));
                }
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

                @Override
                public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                    drafts = m.get(path);
                }
            }));
        }
        CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                if (drafts == null) {
                    drafts = m.get(path);
                } else {
                    JsArray<CommentInfo> draftsInRevision = m.get(path);
                    for (int i = 0; i < draftsInRevision.length(); i++) {
                        drafts.push(draftsInRevision.get(i));
                    }
                }
            }
        }));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(true)));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#end_block

#method_before
private void setupNav(Nav nav, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        if (nav == Nav.PREV) {
            prevUrl = url;
            prevLink.setHTML(Util.C.prevPatchLinkIcon() + fileName);
        } else {
            nextUrl = url;
            nextLink.setHTML(fileName + Util.C.nextPatchLinkIcon());
        }
    }
    if (keys != null) {
        if (cmds[nav.cmd] != null) {
            keys.remove(cmds[nav.cmd]);
        }
        if (url != null) {
            cmds[nav.cmd] = new KeyCommand(0, nav.key, nav.help) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    Gerrit.display(url);
                }
            };
        } else {
            cmds[nav.cmd] = new UpToChangeCommand2(patchSetId, 0, nav.key);
        }
        keys.add(cmds[nav.cmd]);
    }
}
#method_after
private void setupNav(Anchor anchor, int key, String help, FileInfo info) {
    final String url = url(info);
    if (info != null) {
        String fileName = getFileNameOnly(info.path());
        anchor.setHref("#" + url);
        if (anchor == prevLink) {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(Util.C.prevPatchLinkIcon())).append(SafeHtml.asis(fileName)).toSafeHtml());
        } else {
            anchor.setHTML(new SafeHtmlBuilder().append(SafeHtml.asis(fileName)).append(SafeHtml.asis(Util.C.nextPatchLinkIcon())).toSafeHtml());
        }
    }
    if (url != null) {
        keys.add(new KeyCommand(0, key, help) {

            @Override
            public void onKeyPress(KeyPressEvent event) {
                Gerrit.display(url);
            }
        });
    } else {
        keys.add(new UpToChangeCommand2(patchSetId, 0, key));
    }
}
#end_block

#method_before
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision)));
}
#method_after
@Override
public void onKeyPress(final KeyPressEvent event) {
    Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision.get())));
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    resizeCodeMirror();
    Window.enableScrolling(false);
    cmA.setOption("viewportMargin", 10);
    cmB.setOption("viewportMargin", 10);
    cmB.focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    cmA.getWrapperElement().removeFromParent();
    cmB.getWrapperElement().removeFromParent();
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0 || bLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, aLength == 0 ? SidePanel.GutterType.INSERT : SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
    allBoxes.remove(box);
}
#method_after
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            if (info.isAligned()) {
                LineHandle oLineHandle = other.getLineHandle(info.getLine());
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, MouseDownEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            instance.setCursor(LineCharacter.create(line));
            instance.setActiveLine(instance.getLineHandle(line));
            insertNewDraft(instance).run();
        }
    };
}
#end_block

#method_before
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        myChunkHeight -= myPadding.getOffsetHeight();
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPadding.getOffsetHeight();
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            setHeightInPx(myPadding, 0);
            setHeightInPx(otherPadding, delta);
        } else {
            setHeightInPx(myPadding, -delta);
            setHeightInPx(otherPadding, 0);
        }
        myWrapper.getWidget().changed();
    } else {
        setHeightInPx(otherPadding, myChunkHeight);
    }
    otherWrapper.getWidget().changed();
}
#method_after
void resizePaddingOnOtherSide(Side mySide, int line) {
    CodeMirror cm = getCmFromSide(mySide);
    LineHandle handle = cm.getLineHandle(line);
    final LinePaddingWidgetWrapper otherWrapper = linePaddingOnOtherSideMap.get(handle);
    double myChunkHeight = cm.heightAtLine(line + 1) - cm.heightAtLine(line - otherWrapper.getChunkLength() + 1);
    Element otherPadding = otherWrapper.getElement();
    int otherPaddingHeight = otherPadding.getOffsetHeight();
    CodeMirror otherCm = otherCm(cm);
    int otherLine = otherWrapper.getOtherLine();
    LineHandle other = otherCm.getLineHandle(otherLine);
    if (linePaddingOnOtherSideMap.containsKey(other)) {
        LinePaddingWidgetWrapper myWrapper = linePaddingOnOtherSideMap.get(other);
        Element myPadding = linePaddingOnOtherSideMap.get(other).getElement();
        int myPaddingHeight = myPadding.getOffsetHeight();
        myChunkHeight -= myPaddingHeight;
        double otherChunkHeight = otherCm.heightAtLine(otherLine + 1) - otherCm.heightAtLine(otherLine - myWrapper.getChunkLength() + 1) - otherPaddingHeight;
        double delta = myChunkHeight - otherChunkHeight;
        if (delta > 0) {
            if (myPaddingHeight != 0) {
                setHeightInPx(myPadding, 0);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != delta) {
                setHeightInPx(otherPadding, delta);
                otherWrapper.getWidget().changed();
            }
        } else {
            if (myPaddingHeight != -delta) {
                setHeightInPx(myPadding, -delta);
                myWrapper.getWidget().changed();
            }
            if (otherPaddingHeight != 0) {
                setHeightInPx(otherPadding, 0);
                otherWrapper.getWidget().changed();
            }
        }
    } else if (otherPaddingHeight != myChunkHeight) {
        setHeightInPx(otherPadding, myChunkHeight);
        otherWrapper.getWidget().changed();
    }
}
#end_block

#method_before
void resizeCodeMirror() {
    // TODO: Probably need horizontal resize
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    5;
    if (cmA != null) {
        cmA.setHeight(Window.getClientHeight() - h);
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.setHeight(Window.getClientHeight() - h);
        cmB.refresh();
    }
}
#method_after
void resizeCodeMirror() {
    if (cmA == null) {
        return;
    }
    int h = Gerrit.getHeaderFooterHeight() + reviewed.getOffsetHeight() + navLinks.getOffsetHeight() + diffTable.getHeaderHeight() + // Estimate
    10;
    cmA.setHeight(Window.getClientHeight() - h);
    cmA.refresh();
    cmB.setHeight(Window.getClientHeight() - h);
    cmB.refresh();
    diffTable.sidePanel.adjustGutters(cmB);
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        ChangeData cd = new ChangeData(change);
        a.commitMessage = cd.commitMessage(repoManager, db);
    } catch (OrmException e) {
    } catch (IOException e) {
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = new ChangeData(change).commitMessage(repoManager, db);
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
GutterWrapper addGutter(CodeMirror cm, int line, GutterType type) {
    Label gutter = new Label();
    GutterWrapper info = new GutterWrapper(this, gutter, cm, line, type);
    adjustGutter(info);
    Element ele = gutter.getElement();
    gutter.addStyleName(style.gutter());
    switch(type) {
        case COMMENT:
            gutter.addStyleName(style.comment());
            break;
        case DRAFT:
            gutter.addStyleName(style.draft());
            gutter.setText("*");
            break;
        case INSERT:
            gutter.addStyleName(style.insert());
            break;
        case DELETE:
            gutter.addStyleName(style.delete());
            break;
        case EDIT:
    }
    getElement().appendChild(ele);
    ((HTMLPanel) getWidget()).add(gutter);
    gutters.add(info);
    return info;
}
#method_after
GutterWrapper addGutter(CodeMirror cm, int line, GutterType type) {
    Label gutter = new Label();
    GutterWrapper info = new GutterWrapper(this, gutter, cm, line, type);
    adjustGutter(info);
    Element ele = gutter.getElement();
    gutter.addStyleName(style.gutter());
    switch(type) {
        case COMMENT:
            gutter.addStyleName(style.comment());
            break;
        case DRAFT:
            gutter.addStyleName(style.draft());
            gutter.setText("*");
            break;
        case INSERT:
            gutter.addStyleName(style.insert());
            break;
        case DELETE:
            gutter.addStyleName(style.delete());
            break;
        case EDIT:
            gutter.addStyleName(style.insert());
            Label labelLeft = new Label();
            labelLeft.addStyleName(style.halfGutter());
            gutter.getElement().appendChild(labelLeft.getElement());
    }
    getElement().appendChild(ele);
    ((HTMLPanel) getWidget()).add(gutter);
    gutters.add(info);
    return info;
}
#end_block

#method_before
void adjustGutters() {
    for (GutterWrapper info : gutters) {
        adjustGutter(info);
    }
}
#method_after
void adjustGutters(CodeMirror cmB) {
    this.cmB = cmB;
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (GutterWrapper info : gutters) {
                adjustGutter(info);
            }
        }
    });
}
#end_block

#method_before
private void adjustGutter(GutterWrapper wrapper) {
    final CodeMirror cm = wrapper.cm;
    final int line = wrapper.line;
    Label gutter = wrapper.gutter;
    final double height = cm.heightAtLine(line, "local");
    double top = (double) height / (double) cm.getSizer().getClientHeight() * cm.getScrollbarV().getClientHeight() + SideBySide2.HEADER;
    gutter.getElement().getStyle().setTop(top, Unit.PX);
    wrapper.replaceClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            cm.setCursor(LineCharacter.create(line));
            cm.scrollToY(height);
        }
    });
}
#method_after
private void adjustGutter(GutterWrapper wrapper) {
    if (cmB == null) {
        return;
    }
    final CodeMirror cm = wrapper.cm;
    final int line = wrapper.line;
    Label gutter = wrapper.gutter;
    final double height = cm.heightAtLine(line, "local");
    final double scrollbarHeight = cmB.getScrollbarV().getClientHeight();
    double top = height / (double) cmB.getSizer().getClientHeight() * scrollbarHeight + cmB.getScrollbarV().getAbsoluteTop();
    if (top == 0) {
        top = -10;
    }
    gutter.getElement().getStyle().setTop(top, Unit.PX);
    wrapper.replaceClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            cm.setCursor(LineCharacter.create(line));
            cm.scrollToY(Math.max(0, height - scrollbarHeight / 2));
            cm.focus();
        }
    });
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    for (CommentBox box : initialBoxes) {
        box.resizePaddingWidget();
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    resizeCodeMirror();
    Window.enableScrolling(false);
    cmA.setOption("viewportMargin", 10);
    cmB.setOption("viewportMargin", 10);
    cmB.focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    cmA.getWrapperElement().removeFromParent();
    cmB.getWrapperElement().removeFromParent();
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(cm));
    cm.on("update", new Runnable() {

        public void run() {
            diffTable.sidePanel.adjustGutters();
        }
    });
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    CodeMirror.defineVimEx("up", "u", upToChange());
    CodeMirror.defineVimEx("mark", "m", toggleReviewed());
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    /**
     * TODO: Work on a better way for customizing keybindings and remove
     * temporary navigation hacks.
     */
    for (String s : new String[] { "C", "J", "K", "O", "R", "U", "Ctrl-C", "Ctrl-F", "Enter" }) {
        CodeMirror.disableUnwantedKey("vim", s);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new NoOpKeyCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new NoOpKeyCommand(0, 'm', PatchUtil.C.toggleReviewed()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    int h = Gerrit.getHeaderFooterHeight() + 18;
    CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - h);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            if (aLength == 0 || bLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, aLength == 0 ? SidePanel.GutterType.INSERT : SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
            if (aLength == 0 || bLength == 0) {
                diffTable.sidePanel.addGutter(cmB, origLineB, aLength == 0 ? SidePanel.GutterType.INSERT : SidePanel.GutterType.DELETE);
            } else {
                diffTable.sidePanel.addGutter(cmB, origLineB, SidePanel.GutterType.EDIT);
            }
        }
    }
}
#end_block

#method_before
private DraftBox addNewDraft(CodeMirror cm, int line) {
    Side side = cm == cmA ? Side.PARENT : Side.REVISION;
    CommentInfo info = CommentInfo.create(path, side, line + 1, null, null);
    return addDraftBox(info, false);
}
#method_after
private DraftBox addNewDraft(CodeMirror cm, int line) {
    return addDraftBox(CommentInfo.createLine(path, getSideFromCm(cm), line + 1, null, null));
}
#end_block

#method_before
private DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave);
    addCommentBox(info, box);
    if (!doSave) {
        box.setEdit(true);
    }
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    final DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                box.setOpen(true);
                box.setEdit(true);
            }
        });
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 28, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 28, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box.isDraft() ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    DiffChunkInfo myChunk = getDiffChunk(mySide, line);
    DiffChunkInfo otherChunk = getDiffChunk(getSideFromCm(other), lineToPad);
    PaddingManager otherManager;
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        otherManager = linePaddingManagerMap.get(otherHandle);
    } else {
        otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
    }
    if ((myChunk == null && otherChunk == null) || (myChunk != null && otherChunk != null)) {
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (otherChunk == null) {
        box.setDiffChunkInfo(myChunk);
    }
    box.setGutterWrapper(diffTable.sidePanel.addGutter(cm, info.line() - 1, box instanceof DraftBox ? SidePanel.GutterType.DRAFT : SidePanel.GutterType.COMMENT));
    return box;
}
#end_block

#method_before
void removeDraft(Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#method_after
void removeDraft(DraftBox box, Side side, int line) {
    LineHandle handle = getCmFromSide(side).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        CodeMirror cm = getCmFromSide(info.side());
        PublishedBox box = new PublishedBox(this, cm, revision, info, commentLinkProcessor);
        box.setOpen(false);
        initialBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        DraftBox box = new DraftBox(this, getCmFromSide(info.side()), revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        initialBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(info.side()).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            continue;
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        skips.clear();
        return;
    }
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getCommentInfo();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, double height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#method_after
private PaddingWidgetWrapper addPaddingWidget(CodeMirror cm, String style, int line, double height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new PaddingWidgetWrapper(widget, div);
}
#end_block

#method_before
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.isScrollSetByOther()) {
                return;
            }
            other.scrollToY(cm.getScrollInfo().getTop());
            other.setScrollSetByOther(true);
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    other.setScrollSetByOther(false);
                    return false;
                }
            }, 0);
        }
    };
}
#method_after
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.getScrollSetAt() + 50 > System.currentTimeMillis()) {
                return;
            }
            ScrollInfo si = cm.getScrollInfo();
            if (si.getTop() == 0 && !Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(true);
                diffTable.updateFileCommentVisibility(false);
                resizeCodeMirror();
            } else if (si.getTop() > 0.5 * si.getClientHeight() && Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(false);
                diffTable.updateFileCommentVisibility(true);
                resizeCodeMirror();
            }
            /**
             * Since CM doesn't always take the height of line widgets into
             * account when calculating scrollInfo when scrolling too fast
             * (e.g. throw-scrolling), simply setting scrollTop to be the same
             * doesn't guarantee alignment, but should work in most cases. See the
             * hack in fixScroll();
             */
            other.scrollToY(si.getTop());
            other.setScrollSetAt(System.currentTimeMillis());
            (cm == cmA ? scrollTimerA : scrollTimerB).schedule(50);
        }
    };
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            if (info.isAligned()) {
                LineHandle oLineHandle = other.getLineHandle(info.getLine());
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) lineActiveBoxMap.get(handle)).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewedTop.setReviewed(!reviewedTop.isReviewed());
        }
    };
}
#method_after
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewed.setReviewed(!reviewed.isReviewed());
        }
    };
}
#end_block

#method_before
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getText().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#method_after
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getValue().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#end_block

#method_before
void setEdit(boolean edit) {
    if (edit) {
        setOpen(true);
        removeStyleName(draftStyle.view());
        addStyleName(draftStyle.edit());
        editArea.setText(getOriginal().message());
        expandText();
        editArea.setReadOnly(false);
        editArea.setFocus(true);
        disableClickFocusHandler();
    } else {
        expandTimer.cancel();
        editArea.setReadOnly(true);
        removeStyleName(draftStyle.edit());
        addStyleName(draftStyle.view());
        enableClickFocusHandler();
    }
    resizePaddingWidget();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    if (edit) {
        final String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        editArea.setFocus(true);
        cancel.setVisible(!isNew());
        expandText();
        if (msg.length() > 0) {
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    editArea.setCursorPos(msg.length());
                    return false;
                }
            }, 0);
        }
    } else {
        expandTimer.cancel();
    }
    resizePaddingWidget();
}
#end_block

#method_before
private void removeUI() {
    setEdit(false);
    expandTimer.cancel();
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    CommentInfo info = getOriginal();
    getDiffView().removeDraft(info.side(), info.line() - 1);
    removeFromParent();
    getSelfWidget().clear();
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    manager.resizePaddingWidget();
    getCm().focus();
    getGutterWrapper().remove();
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    cm.focus();
    getSelfWidgetWrapper().getWidget().clear();
    getGutterWrapper().remove();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent e) {
    setEdit(true);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent e) {
    e.stopPropagation();
    setEdit(true);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    onSave();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
private void onSave() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            if (result.message().length() < 70) {
                UIObject.setVisible(p_edit, false);
                setOpen(false);
            } else {
                setEdit(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    cm.focus();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    setEdit(false);
    getCm().focus();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    e.stopPropagation();
    if (isNew() && !isDirty()) {
        removeUI();
    } else {
        setEdit(false);
        cm.focus();
    }
}
#end_block

#method_before
@UiHandler("discard")
void onDiscard(ClickEvent e) {
    if (isNew) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(getPatchSetId(), getOriginal().id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#method_after
@UiHandler({ "discard1", "discard2" })
void onDiscard(ClickEvent e) {
    e.stopPropagation();
    if (isNew()) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(psId, comment.id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#end_block

#method_before
void resizePaddingWidget() {
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        public void execute() {
            if (selfWidget == null || widgetManager == null) {
                throw new IllegalStateException("resizePaddingWidget() called before setting up widgets");
            }
            selfWidget.changed();
            widgetManager.resizePaddingWidget();
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
    resizePaddingWidget();
}
#method_after
void setOpen(boolean open) {
    resizePaddingWidget();
}
#end_block

#method_before
void createOrEditFileComment() {
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.create(path, side, null, null, null);
        addFileComment(host.addDraftBox(info, false));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box.isDraft()) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox("", false));
        }
    }
}
#method_after
void createOrEditFileComment() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
        return;
    }
    if (boxes.isEmpty()) {
        CommentInfo info = CommentInfo.createFile(path, side, null, null);
        addFileComment(parent.addDraftBox(info));
    } else {
        CommentBox box = boxes.get(boxes.size() - 1);
        if (box instanceof DraftBox) {
            ((DraftBox) box).setEdit(true);
        } else {
            addFileComment(((PublishedBox) box).addReplyBox());
        }
    }
}
#end_block

#method_before
void addFileComment(CommentBox box) {
    boxes.add(box);
    table.updateVisibility(false);
    ((HTMLPanel) getWidget()).add(box);
    box.registerDiffTable(table);
}
#method_after
void addFileComment(CommentBox box) {
    boxes.add(box);
    body.add(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateVisibility(false);
}
#method_after
void onRemoveDraftBox(DraftBox box) {
    boxes.remove(box);
    table.updateFileCommentVisibility(false);
}
#end_block

#method_before
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    patchSelectBoxA.toggleVisible(true);
}
#method_after
void createOrEditFileComment(Side side) {
    getPanelFromSide(side).createOrEditFileComment();
    updateFileCommentVisibility(false);
}
#end_block

#method_before
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getText().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#method_after
private void expandText() {
    double cols = editArea.getCharacterWidth();
    int rows = 2;
    for (String line : editArea.getValue().split("\n")) {
        rows += Math.ceil((1.0 + line.length()) / cols);
    }
    rows = Math.max(INITIAL_LINES, Math.min(rows, MAX_LINES));
    if (editArea.getVisibleLines() != rows) {
        editArea.setVisibleLines(rows);
    }
    resizePaddingWidget();
}
#end_block

#method_before
void setEdit(boolean edit) {
    if (edit) {
        setOpen(true);
        removeStyleName(draftStyle.view());
        addStyleName(draftStyle.edit());
        editArea.setText(getOriginal().message());
        expandText();
        editArea.setReadOnly(false);
        editArea.setFocus(true);
        disableClickFocusHandler();
    } else {
        expandTimer.cancel();
        editArea.setReadOnly(true);
        removeStyleName(draftStyle.edit());
        addStyleName(draftStyle.view());
        enableClickFocusHandler();
    }
    resizePaddingWidget();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    if (edit) {
        final String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        editArea.setFocus(true);
        cancel.setVisible(!isNew());
        expandText();
        if (msg.length() > 0) {
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    editArea.setCursorPos(msg.length());
                    return false;
                }
            }, 0);
        }
    } else {
        expandTimer.cancel();
    }
    resizePaddingWidget();
}
#end_block

#method_before
private void removeUI() {
    setEdit(false);
    expandTimer.cancel();
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    removeFromParent();
    getCm().focus();
    if (isFileComment()) {
        getDiffTable().onRemoveDraftBox(this, getSide());
        return;
    }
    CommentInfo info = getOriginal();
    getDiffView().removeDraft(this, getSide(), info.line() - 1);
    getSelfWidget().clear();
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    manager.resizePaddingWidget();
}
#method_after
private void removeUI() {
    if (replyToBox != null) {
        replyToBox.unregisterReplyBox();
    }
    Side side = comment.side();
    removeFromParent();
    if (!getCommentInfo().has_line()) {
        parent.removeFileCommentBox(this, side);
        return;
    }
    PaddingManager manager = getPaddingManager();
    manager.remove(this);
    parent.removeDraft(this, side, comment.line() - 1);
    cm.focus();
    getSelfWidgetWrapper().getWidget().clear();
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            resizePaddingWidget();
        }
    });
}
#end_block

#method_before
@UiHandler("edit")
void onEdit(ClickEvent e) {
    setEdit(true);
}
#method_after
@UiHandler("edit")
void onEdit(ClickEvent e) {
    e.stopPropagation();
    setEdit(true);
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    e.stopPropagation();
    onSave();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    setEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
    getCm().focus();
}
#method_after
private void onSave() {
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo original = comment;
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    enableEdit(false);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            set(result);
            if (result.message().length() < 70) {
                UIObject.setVisible(p_edit, false);
                setOpen(false);
            } else {
                setEdit(false);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            super.onFailure(e);
        }
    };
    if (original.id() == null) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, original.id(), input, cb);
    }
    cm.focus();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    setEdit(false);
    getCm().focus();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    e.stopPropagation();
    if (isNew() && !isDirty()) {
        removeUI();
    } else {
        setEdit(false);
        cm.focus();
    }
}
#end_block

#method_before
@UiHandler("discard")
void onDiscard(ClickEvent e) {
    if (isNew) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(getPatchSetId(), getOriginal().id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#method_after
@UiHandler({ "discard1", "discard2" })
void onDiscard(ClickEvent e) {
    e.stopPropagation();
    if (isNew()) {
        removeUI();
    } else {
        setEdit(false);
        CommentApi.deleteDraft(psId, comment.id(), new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                removeUI();
            }
        });
    }
}
#end_block

#method_before
DraftBox addReplyBox(String initMessage, boolean doSave) {
    DraftBox box = getDiffView().addReply(getOriginal(), initMessage, doSave);
    registerReplyBox(box);
    return box;
}
#method_after
DraftBox addReplyBox() {
    DraftBox box = parent.addDraftBox(parent.createReply(comment));
    registerReplyBox(box);
    return box;
}
#end_block

#method_before
@UiHandler("reply")
void onReply(ClickEvent e) {
    checkAndAddReply("", false);
}
#method_after
@UiHandler("reply")
void onReply(ClickEvent e) {
    e.stopPropagation();
    doReply();
}
#end_block

#method_before
@UiHandler("replyDone")
void onReplyDone(ClickEvent e) {
    checkAndAddReply(PatchUtil.C.cannedReplyDone(), true);
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(parent.getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(parent.createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = parent.addDraftBox(result);
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    parent.addFileCommentBox(box, comment.side());
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
        }
    });
    resizeBoxPaddings();
    (cmB != null ? cmB : cmA).focus();
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    handlers.add(UserAgent.addDialogVisibleHandler(new DialogVisibleHandler() {

        @Override
        public void onDialogVisible(DialogVisibleEvent event) {
            diffTable.getElement().getStyle().setVisibility(event.isVisible() ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE);
        }
    }));
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            if (cmA != null) {
                cmA.setOption("viewportMargin", 10);
            }
            if (cmB != null) {
                cmB.setOption("viewportMargin", 10);
            }
            resizeCodeMirror();
        }
    });
    (cmB != null ? cmB : cmA).focus();
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    removeKeyHandlerRegs();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    Gerrit.setHeaderVisible(true);
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(cm));
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    CodeMirror.defineVimEx("up", "u", upToChange());
    CodeMirror.defineVimEx("mark", "m", toggleReviewed());
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    /**
     * TODO: Work on a better way for customizing keybindings and remove
     * temporary navigation hacks.
     */
    for (String s : new String[] { "C", "J", "K", "O", "R", "U", "Ctrl-C", "Enter" }) {
        CodeMirror.disableUnwantedKey("vim", s);
    }
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeEmptyLine(getSideFromCm(cm)));
    // TODO: Prevent right click from updating the cursor.
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'm', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new KeyCommand(0, 'u', PatchUtil.C.upToChange()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange().run();
        }
    });
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingWidgetMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    lineElementMap = new HashMap<LineHandle, Element>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
            resizeBoxPaddings();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    allBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
            resizeBoxPaddings();
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("lineWrapping", true).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents).setInfinity("viewportMargin");
    int h = Gerrit.getHeaderFooterHeight() + 18;
    CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - h);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), mapper.getLineB(), insertCnt, false);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), mapper.getLineA(), deleteCnt, false);
                mapper.appendDelete(deleteCnt);
            }
            insertEmptyLines(cmA, mapper.getLineA(), origLineB, commonCnt, true);
            insertEmptyLines(cmB, mapper.getLineB(), origLineA, commonCnt, true);
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context + 1) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context + 1) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            int commonCnt = Math.min(aLength, bLength);
            mapper.appendCommon(commonCnt);
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                mapper.appendDelete(deleteCnt);
            }
            int chunkEndA = mapper.getLineA() - 1;
            int chunkEndB = mapper.getLineB() - 1;
            if (bLength > 0) {
                addDiffChunkAndPadding(cmA, chunkEndA, chunkEndB, bLength);
            }
            if (aLength > 0) {
                addDiffChunkAndPadding(cmB, chunkEndB, chunkEndA, aLength);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private DraftBox addNewDraft(CodeMirror cm, int line) {
    Side side = getSideFromCm(cm);
    CommentInfo info = CommentInfo.create(path, side, line + 1, null, null);
    return addDraftBox(info, false);
}
#method_after
private DraftBox addNewDraft(CodeMirror cm, int line) {
    return addDraftBox(CommentInfo.createLine(path, getSideFromCm(cm), line + 1, null, null));
}
#end_block

#method_before
DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, revision, info, commentLinkProcessor, true, doSave);
    if (!doSave) {
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#method_after
DraftBox addDraftBox(CommentInfo info) {
    CodeMirror cm = getCmFromSide(info.side());
    DraftBox box = new DraftBox(this, cm, commentLinkProcessor, revision, info);
    if (info.id() == null) {
        box.setOpen(true);
        box.setEdit(true);
    }
    if (!info.has_line()) {
        return box;
    }
    addCommentBox(info, box);
    LineHandle handle = cm.getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 28, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 28, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    allBoxes.add(box);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCm(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 28px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 0, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 0, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidgetWrapper(new PaddingWidgetWrapper(boxWidget, box.getElement()));
    box.setParent(this);
    if (getDiffChunk(getSideFromCm(other), lineToPad) == null) {
        box.setDiffChunkInfo(getDiffChunk(mySide, line));
    }
    allBoxes.add(box);
    return box;
}
#end_block

#method_before
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, revision, info, commentLinkProcessor);
        box.setOpen(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, commentLinkProcessor, revision, info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        Side side = info.side();
        DraftBox box = new DraftBox(this, getCmFromSide(side), commentLinkProcessor, revision, info);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box, side);
            return;
        }
        allBoxes.add(box);
        lineActiveBoxMap.put(getCmFromSide(side).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    if (context == AccountDiffPreference.WHOLE_FILE_CONTEXT) {
        return;
    }
    /**
     * TODO: This is not optimal, but shouldn't bee too costly in most cases.
     * Maybe rewrite after done keeping track of diff chunk positions.
     */
    for (CommentBox box : lineActiveBoxMap.values()) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getCommentInfo();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < -context || deltaAfter < -context) {
                // Size guaranteed to be greater than 1
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, before);
                checkAndAddSkip(temp, skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                checkAndAddSkip(temp, skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                checkAndAddSkip(temp, skip);
            }
        }
        if (temp.isEmpty()) {
            return;
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.isScrollSetByOther()) {
                return;
            }
            other.scrollToY(cm.getScrollInfo().getTop());
            other.setScrollSetByOther(true);
            Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

                @Override
                public boolean execute() {
                    other.setScrollSetByOther(false);
                    return false;
                }
            }, 0);
        }
    };
}
#method_after
private Runnable doScroll(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            // Hack to prevent feedback loop, Chrome seems fine but Firefox chokes.
            if (cm.getScrollSetAt() + 50 > System.currentTimeMillis()) {
                return;
            }
            ScrollInfo si = cm.getScrollInfo();
            if (si.getTop() == 0 && !Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(true);
                diffTable.updateFileCommentVisibility(false);
                resizeCodeMirror();
            } else if (si.getTop() > 0.5 * si.getClientHeight() && Gerrit.isHeaderVisible()) {
                Gerrit.setHeaderVisible(false);
                diffTable.updateFileCommentVisibility(true);
                resizeCodeMirror();
            }
            /**
             * Since CM doesn't always take the height of line widgets into
             * account when calculating scrollInfo when scrolling too fast
             * (e.g. throw-scrolling), simply setting scrollTop to be the same
             * doesn't guarantee alignment, but should work in most cases. See the
             * hack in fixScroll();
             */
            other.scrollToY(si.getTop());
            other.setScrollSetAt(System.currentTimeMillis());
            (cm == cmA ? scrollTimerA : scrollTimerB).schedule(50);
        }
    };
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCm(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                LineHandle activeLine = cm.getActiveLine();
                cm.removeLineClass(activeLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(activeLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                LineHandle otherActiveLine = other.getActiveLine();
                other.removeLineClass(otherActiveLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(otherActiveLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(handle, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(handle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(getSideFromCm(cm), cm.getLineNumber(handle));
            int oLine = info.getLine();
            LineHandle oLineHandle = other.getLineHandle(oLine);
            if (info.isAligned()) {
                other.setActiveLine(oLineHandle);
                other.addLineClass(oLineHandle, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLineHandle, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    if (!Gerrit.isSignedIn()) {
        return new Runnable() {

            @Override
            public void run() {
                Gerrit.doSignIn(getToken());
            }
        };
    }
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box instanceof DraftBox) {
                ((DraftBox) box).setEdit(true);
            } else {
                ((PublishedBox) box).doReply();
            }
        }
    };
}
#end_block

#method_before
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewedTop.setReviewed(!reviewedTop.isReviewed());
        }
    };
}
#method_after
private Runnable toggleReviewed() {
    return new Runnable() {

        public void run() {
            reviewed.setReviewed(!reviewed.isReviewed());
        }
    };
}
#end_block

#method_before
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, final Element element) {
            if (linePaddingWidgetMap.containsKey(handle)) {
                /**
                 * This needs to be deferred because CM fires "renderLine" **before**
                 * the line is actually added to the DOM.
                 */
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        LinePaddingWidgetWrapper otherWrapper = linePaddingWidgetMap.get(handle);
                        int myLineHeight = element.getOffsetHeight();
                        Element otherPadding = otherWrapper.getElement();
                        if (!otherWrapper.isCommon() && myLineHeight > 0) {
                            setHeightInPx(otherPadding, myLineHeight);
                        } else {
                            /**
                             * We have to pay the cost of keeping track of the actual DOM
                             * elements ourselves, because CM doesn't provide an interface
                             * to query for them, and the only place we can ever have legit
                             * access to the line element is in this event handler.
                             */
                            lineElementMap.put(handle, element);
                            if (myLineHeight == 0) {
                                return;
                            }
                            // The lines are always aligned since they are in a common region.
                            int otherLine = mapper.lineOnOther(side, instance.getLineNumber(handle)).getLine();
                            LineHandle other = otherCm(instance).getLineHandle(otherLine);
                            LinePaddingWidgetWrapper myWrapper = linePaddingWidgetMap.get(other);
                            if (lineElementMap.containsKey(other)) {
                                Element otherElement = lineElementMap.get(other);
                                int otherLineHeight = otherElement.getOffsetHeight();
                                if (otherLineHeight == 0) {
                                    return;
                                }
                                Element myPadding = myWrapper.getElement();
                                int delta = myLineHeight - otherLineHeight;
                                if (delta >= 0) {
                                    setHeightInPx(otherPadding, delta);
                                    setHeightInPx(myPadding, 0);
                                } else {
                                    setHeightInPx(otherPadding, 0);
                                    setHeightInPx(myPadding, -delta);
                                }
                                myWrapper.getWidget().changed();
                                otherWrapper.getWidget().changed();
                            }
                        }
                    }
                });
            }
        }
    };
}
#method_after
private RenderLineHandler resizeEmptyLine(final Side side) {
    return new RenderLineHandler() {

        @Override
        public void handle(final CodeMirror instance, final LineHandle handle, Element element) {
            if (linePaddingOnOtherSideMap.containsKey(handle)) {
                Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                    @Override
                    public void execute() {
                        resizePaddingOnOtherSide(side, instance.getLineNumber(handle));
                    }
                });
            }
        }
    };
}
#end_block

#method_before
void resizePaddingWidget() {
    if (fileComment) {
        cm.refresh();
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        public void execute() {
            if (selfWidget == null || widgetManager == null) {
                throw new IllegalStateException("resizePaddingWidget() called before setting up widgets");
            }
            selfWidget.changed();
            widgetManager.resizePaddingWidget();
        }
    });
}
#method_after
void resizePaddingWidget() {
    if (!getCommentInfo().has_line()) {
        return;
    }
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            assert selfWidgetWrapper != null;
            selfWidgetWrapper.getWidget().changed();
            if (diffChunkInfo != null) {
                parent.resizePaddingOnOtherSide(getCommentInfo().side(), diffChunkInfo.getEnd());
            } else {
                assert widgetManager != null;
                widgetManager.resizePaddingWidget();
            }
        }
    });
}
#end_block

#method_before
void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
    resizePaddingWidget();
}
#method_after
void setOpen(boolean open) {
    resizePaddingWidget();
}
#end_block

#method_before
public String getGitSshUrl() {
    if (sshdListenAddressString == null) {
        return "";
    }
    if (downloadSchemes.length != 0) {
        if (!Arrays.asList(downloadSchemes).contains("ssh")) {
            return "";
        }
    }
    String[] urlParts = sshdListenAddressString.split(":");
    if (urlParts.length < 2) {
        log.error("Invalid SSHD listenUrl: " + sshdListenAddressString);
        return "";
    }
    try {
        String hostname = getHost(urlParts[0]);
        int port = getPort(urlParts[1]);
        return "ssh://" + GITBLIT_USER + "@" + hostname + (port == SSH_DEF_PORT ? "" : ":" + port) + "/" + GITBLIT_REPO + "";
    } catch (UnknownHostException e) {
        log.error("Cannot detect localhostname");
        return "";
    }
}
#method_after
public String getGitSshUrl() {
    if (sshdListenAddressString == null) {
        return "";
    }
    if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("ssh")) {
        return "";
    }
    String[] urlParts = sshdListenAddressString.split(":");
    if (urlParts.length < 2) {
        log.error("Invalid SSHD listenUrl: " + sshdListenAddressString);
        return "";
    }
    try {
        String hostname = getHost(urlParts[0]);
        int port = getPort(urlParts[1]);
        return "ssh://" + GITBLIT_USER + "@" + hostname + (port == SSH_DEF_PORT ? "" : ":" + port) + "/" + GITBLIT_REPO + "";
    } catch (UnknownHostException e) {
        log.error("Cannot detect localhostname");
        return "";
    }
}
#end_block

#method_before
public String getGitHttpUrl() throws UnknownHostException {
    String httpListenUrl = getHttpListenUrl();
    if (httpListenUrl == null) {
        return "";
    }
    if (downloadSchemes.length != 0) {
        if (!Arrays.asList(downloadSchemes).contains("http")) {
            return "";
        }
    }
    String httpUrl = Objects.firstNonNull(canonicalWebUrlString, httpListenUrl);
    httpUrl = httpUrl.replace("://", "://" + GITBLIT_USER + "@");
    httpUrl += (httpUrl.endsWith("/") ? "" : "/") + GITBLIT_REPO;
    return httpUrl;
}
#method_after
public String getGitHttpUrl() throws UnknownHostException {
    String httpListenUrl = getHttpListenUrl();
    if (httpListenUrl == null) {
        return "";
    }
    if (!downloadSchemes.isEmpty() && !downloadSchemes.contains("http")) {
        return "";
    }
    String httpUrl = Objects.firstNonNull(canonicalWebUrlString, httpListenUrl);
    httpUrl = httpUrl.replace("://", "://" + GITBLIT_USER + "@");
    httpUrl += (httpUrl.endsWith("/") ? "" : "/") + GITBLIT_REPO;
    return httpUrl;
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, final IdentifiedUser user, final String message, final ReviewDb db, final CommitMessageEditedSender.Factory commitMessageEditedSenderFactory, Repository git, PersonIdent myIdent, PatchSetInserter.Factory patchSetInserterFactory) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet originalPS = db.patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
        if (commit.getFullMessage().equals(message)) {
            throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
        }
        Date now = myIdent.getWhen();
        Change change = db.changes().get(changeId);
        PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setParentIds(commit.getParents());
        commitBuilder.setAuthor(commit.getAuthorIdent());
        commitBuilder.setCommitter(authorIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet newPatchSet = new PatchSet(id);
        newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
        newPatchSet.setUploader(user.getAccountId());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
        change = patchSetInserterFactory.create(git, revWalk, refControl, user, change, newCommit, RECEIVE_COMMITS).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).insert();
        return change.getId();
    } finally {
        revWalk.release();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, final IdentifiedUser user, final String message, final ReviewDb db, final CommitMessageEditedSender.Factory commitMessageEditedSenderFactory, Repository git, PersonIdent myIdent, PatchSetInserter.Factory patchSetInserterFactory) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet originalPS = db.patchSets().get(patchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(originalPS.getRevision().get()));
        if (commit.getFullMessage().equals(message)) {
            throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
        }
        Date now = myIdent.getWhen();
        Change change = db.changes().get(changeId);
        PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setParentIds(commit.getParents());
        commitBuilder.setAuthor(commit.getAuthorIdent());
        commitBuilder.setCommitter(authorIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet newPatchSet = new PatchSet(id);
        newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
        newPatchSet.setUploader(user.getAccountId());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
        change = patchSetInserterFactory.create(git, revWalk, refControl, user, change, newCommit).setPatchSet(newPatchSet).setMessage(msg).setCopyLabels(true).setValidatePolicy(RECEIVE_COMMITS).insert();
        return change.getId();
    } finally {
        revWalk.release();
    }
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetinserter = patchSetInserterFactory.create(git, revWalk, changeControl.getRefControl(), uploader, change, rebasedCommit, validate).setCopyLabels(true).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), patchSetId);
    cmsg.setMessage("Patch Set " + change.currentPatchSetId().get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetinserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#method_after
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks, ValidatePolicy validate) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetinserter = patchSetInserterFactory.create(git, revWalk, changeControl.getRefControl(), uploader, change, rebasedCommit).setCopyLabels(true).setValidatePolicy(validate).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), patchSetId);
    cmsg.setMessage("Patch Set " + change.currentPatchSetId().get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetinserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#end_block

#method_before
@Override
public int run() throws Exception {
    ErrorLogFile.errorOnlyConsole();
    if (listPlugins) {
        ConsoleUI ui = ConsoleUI.getInstance();
        List<PluginData> plugins = InitPlugins.listPlugins();
        ui.message("Available plugins are:\n");
        for (PluginData plugin : plugins) {
            ui.message(" * %s\n", plugin.name);
        }
        if (plugins.isEmpty()) {
            ui.message("No plugins found.\n");
        }
        return 0;
    }
    final SiteInit init = createSiteInit();
    init.flags.autoStart = !noAutoStart && init.site.isNew;
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    run.start();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    ErrorLogFile.errorOnlyConsole();
    final SiteInit init = createSiteInit();
    if (listPlugins) {
        final ConsoleUI ui = ConsoleUI.getInstance();
        final List<PluginData> plugins = InitPlugins.listPlugins(init.site);
        if (!plugins.isEmpty()) {
            ui.message("Available plugins:\n");
            for (PluginData plugin : plugins) {
                ui.message(" * %s version %s\n", plugin.name, plugin.version);
            }
        } else {
            ui.message("No plugins found.\n");
        }
        return 0;
    }
    init.flags.autoStart = !noAutoStart && init.site.isNew;
    final SiteRun run;
    try {
        init.initializer.run();
        init.flags.deleteOnFailure = false;
        run = createSiteRun(init);
        run.upgradeSchema();
    } catch (Exception failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    } catch (Error failure) {
        if (init.flags.deleteOnFailure) {
            recursiveDelete(getSitePath());
        }
        throw failure;
    }
    System.err.println("Initialized " + getSitePath().getCanonicalPath());
    run.start();
    return 0;
}
#end_block

#method_before
public static List<PluginData> listPlugins() throws IOException {
    final File myWar = GerritLauncher.getDistributionArchive();
    final List<PluginData> result = Lists.newArrayList();
    try {
        final ZipFile zf = new ZipFile(myWar);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                    final String pluginJarName = new File(ze.getName()).getName();
                    final String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                    final InputStream in = zf.getInputStream(ze);
                    result.add(new PluginData(pluginName, pluginJarName, copy(in)));
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Failure during plugin installation", e);
    }
    return result;
}
#method_after
public static List<PluginData> listPlugins(SitePaths site) throws IOException {
    final File myWar = GerritLauncher.getDistributionArchive();
    final List<PluginData> result = Lists.newArrayList();
    try {
        final ZipFile zf = new ZipFile(myWar);
        try {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                if (ze.getName().startsWith(PLUGIN_DIR) && ze.getName().endsWith(JAR)) {
                    final String pluginJarName = new File(ze.getName()).getName();
                    final String pluginName = pluginJarName.substring(0, pluginJarName.length() - JAR.length());
                    final InputStream in = zf.getInputStream(ze);
                    final File tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
                    final String pluginVersion = getVersion(tmpPlugin);
                    result.add(new PluginData(pluginName, pluginVersion, tmpPlugin));
                }
            }
        } finally {
            zf.close();
        }
    } catch (IOException e) {
        throw new IOException("Failure during plugin installation", e);
    }
    return result;
}
#end_block

#method_before
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins();
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        String pluginJarName = plugin.jarName;
        InputStream in = new ByteArrayInputStream(plugin.content.toByteArray());
        try {
            final File tmpPlugin = PluginLoader.storeInTemp(pluginName, in, site);
            final String pluginVersion = getVersion(tmpPlugin);
            if (!ui.yesno(false, "Install plugin %s version %s", pluginName, pluginVersion)) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, pluginJarName);
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            in.close();
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#method_after
private void installPlugins() throws IOException {
    List<PluginData> plugins = listPlugins(site);
    for (PluginData plugin : plugins) {
        String pluginName = plugin.name;
        try {
            final File tmpPlugin = plugin.pluginFile;
            if (!ui.yesno(false, "Install plugin %s version %s", pluginName, plugin.version)) {
                tmpPlugin.delete();
                continue;
            }
            final File p = new File(site.plugins_dir, plugin.pluginFile.getName());
            if (p.exists()) {
                final String installedPluginVersion = getVersion(p);
                if (!ui.yesno(false, "version %s is already installed, overwrite it", installedPluginVersion)) {
                    tmpPlugin.delete();
                    continue;
                }
                if (!p.delete()) {
                    throw new IOException("Failed to delete plugin " + pluginName + ": " + p.getAbsolutePath());
                }
            }
            if (!tmpPlugin.renameTo(p)) {
                throw new IOException("Failed to install plugin " + pluginName + ": " + tmpPlugin.getAbsolutePath() + " -> " + p.getAbsolutePath());
            }
        } finally {
            if (plugin.pluginFile.exists()) {
                plugin.pluginFile.delete();
            }
        }
    }
    if (plugins.isEmpty()) {
        ui.message("No plugins found.");
    }
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Set<IdentifiedUser> reviewers) throws OrmException, EmailException {
    if (reviewers.isEmpty()) {
        result.reviewers = ImmutableList.of();
        return;
    }
    ReviewDb db = dbProvider.get();
    PatchSet.Id psid = rsrc.getChange().currentPatchSetId();
    Set<Account.Id> existing = Sets.newHashSet();
    for (PatchSetApproval psa : db.patchSetApprovals().byPatchSet(psid)) {
        existing.add(psa.getAccountId());
    }
    result.reviewers = Lists.newArrayListWithCapacity(reviewers.size());
    List<PatchSetApproval> toInsert = Lists.newArrayListWithCapacity(reviewers.size());
    for (IdentifiedUser user : reviewers) {
        Account.Id id = user.getAccountId();
        if (existing.contains(id)) {
            continue;
        }
        ChangeControl control = rsrc.getControl().forUser(user);
        PatchSetApproval psa = dummyApproval(control, psid, id);
        result.reviewers.add(json.format(new ReviewerInfo(id), control, ImmutableList.of(psa)));
        toInsert.add(psa);
    }
    if (toInsert.isEmpty()) {
        return;
    }
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        // Empty update of Change to bump rowVersion, changing its ETag.
        Change c = db.changes().get(rsrc.getChange().getId());
        if (c != null) {
            db.changes().update(Collections.singleton(c));
        }
        db.patchSetApprovals().insert(toInsert);
        db.commit();
    } finally {
        db.rollback();
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    postAdd(rsrc.getChange(), result);
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Set<IdentifiedUser> reviewers) throws OrmException, EmailException {
    if (reviewers.isEmpty()) {
        result.reviewers = ImmutableList.of();
        return;
    }
    ReviewDb db = dbProvider.get();
    PatchSet.Id psid = rsrc.getChange().currentPatchSetId();
    Set<Account.Id> existing = Sets.newHashSet();
    for (PatchSetApproval psa : db.patchSetApprovals().byPatchSet(psid)) {
        existing.add(psa.getAccountId());
    }
    result.reviewers = Lists.newArrayListWithCapacity(reviewers.size());
    List<PatchSetApproval> toInsert = Lists.newArrayListWithCapacity(reviewers.size());
    for (IdentifiedUser user : reviewers) {
        Account.Id id = user.getAccountId();
        if (existing.contains(id)) {
            continue;
        }
        ChangeControl control = rsrc.getControl().forUser(user);
        PatchSetApproval psa = dummyApproval(control, psid, id);
        result.reviewers.add(json.format(new ReviewerInfo(id), control, ImmutableList.of(psa)));
        toInsert.add(psa);
    }
    if (toInsert.isEmpty()) {
        return;
    }
    db.changes().beginTransaction(rsrc.getChange().getId());
    try {
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().insert(toInsert);
        db.commit();
    } finally {
        db.rollback();
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    postAdd(rsrc.getChange(), result);
}
#end_block

#method_before
@Override
public Object apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        // Empty update of Change to bump rowVersion, changing its ETag.
        Change c = db.changes().get(rsrc.getChange().getId());
        if (c != null) {
            db.changes().update(Collections.singleton(c));
        }
        db.patchSetApprovals().delete(del);
        db.commit();
    } finally {
        db.rollback();
    }
    return Response.none();
}
#method_after
@Override
public Object apply(ReviewerResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException {
    ChangeControl control = rsrc.getControl();
    Change.Id changeId = rsrc.getChange().getId();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(changeId);
    try {
        List<PatchSetApproval> del = Lists.newArrayList();
        for (PatchSetApproval a : approvals(db, rsrc)) {
            if (control.canRemoveReviewer(a)) {
                del.add(a);
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (del.isEmpty()) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(rsrc.getChange().getId(), db);
        db.patchSetApprovals().delete(del);
        db.commit();
    } finally {
        db.rollback();
    }
    return Response.none();
}
#end_block

#method_before
private void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CURRENT_ACTIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
@Override
protected void onUnload() {
    if (availableUpdate != null) {
        availableUpdate.hide(true);
        availableUpdate = null;
    }
    if (poller != null) {
        poller.cancel();
        poller = null;
    }
    for (HandlerRegistration h : keys) {
        h.removeHandler();
    }
    keys.clear();
    super.onUnload();
}
#method_after
@Override
protected void onUnload() {
    if (updateAvailable != null) {
        updateAvailable.hide(true);
        updateAvailable = null;
    }
    if (updateCheck != null) {
        updateCheck.cancel();
        updateCheck = null;
    }
    for (HandlerRegistration h : handlers) {
        h.removeHandler();
    }
    handlers.clear();
    super.onUnload();
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keys.add(GlobalKey.add(this, keysNavigation));
    keys.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    files.registerKeys();
}
#end_block

#method_before
private void loadMergeable(final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(canSubmit);
            }
        });
    } else {
        loadSubmitType(canSubmit);
    }
}
#method_after
private void loadMergeable(final Change.Status status, final boolean canSubmit) {
    if (Gerrit.getConfig().testChangeMerge()) {
        ChangeApi.revision(changeId.get(), revision).view("mergeable").get(new AsyncCallback<MergeableInfo>() {

            @Override
            public void onSuccess(MergeableInfo result) {
                if (canSubmit) {
                    actions.setSubmitEnabled(result.mergeable());
                    if (status == Change.Status.NEW) {
                        statusText.setInnerText(result.mergeable() ? Util.C.readyToSubmit() : Util.C.mergeConflict());
                    }
                }
                setVisible(notMergeable, !result.mergeable());
                renderSubmitType(result.submit_type());
            }

            @Override
            public void onFailure(Throwable caught) {
                loadSubmitType(status, canSubmit);
            }
        });
    } else {
        loadSubmitType(status, canSubmit);
    }
}
#end_block

#method_before
private void loadSubmitType(final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        statusText.setInnerText(Util.C.readyToSubmit());
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#method_after
private void loadSubmitType(final Change.Status status, final boolean canSubmit) {
    if (canSubmit) {
        actions.setSubmitEnabled(true);
        if (status == Change.Status.NEW) {
            statusText.setInnerText(Util.C.readyToSubmit());
        }
    }
    ChangeApi.revision(changeId.get(), revision).view("submit_type").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString result) {
            renderSubmitType(result.asString());
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    statusText.setInnerText(Util.toLongString(info.status()));
    boolean current = info.status().isOpen() && revision.equals(info.current_revision());
    boolean canSubmit = labels.set(info, current);
    renderOwner(info);
    renderReviewers(info);
    renderActionTextDate(info);
    renderRevisions(info);
    renderHistory(info);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    changeIdText.setInnerText(String.valueOf(info.legacy_id()));
    projectText.setInnerText(info.project());
    branchText.setInnerText(info.branch());
    idText.setText("Change-Id: " + info.change_id());
    idText.setPreviewText(info.change_id());
    reload.set(info);
    topic.set(info);
    commit.set(commentLinkProcessor, info, revision);
    quickApprove.set(info, revision);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, reply);
        if (topic.canEdit()) {
            keysAction.add(new KeyCommand(0, 't', Util.C.keyEditTopic()) {

                @Override
                public void onKeyPress(KeyPressEvent event) {
                    topic.onEdit();
                }
            });
        }
    }
    if (current) {
        loadMergeable(info.status(), canSubmit);
    }
    reply.setVisible(replyAction != null);
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
}
#end_block

#method_before
private void showUpdates(ChangeInfo newInfo) {
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (availableUpdate == null) {
        availableUpdate = new UpdatedBar() {

            @Override
            void onShow() {
                // TODO Avoid RPC and use newInfo.
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        availableUpdate.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                availableUpdate = null;
            }
        });
    }
    availableUpdate.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!availableUpdate.isShowing()) {
        availableUpdate.popup();
    }
}
#method_after
void showUpdates(ChangeInfo newInfo) {
    if (!isAttached() || newInfo.updated().equals(lastDisplayedUpdate)) {
        return;
    }
    JsArray<MessageInfo> om = changeInfo.messages();
    JsArray<MessageInfo> nm = newInfo.messages();
    if (om == null) {
        om = JsArray.createArray().cast();
    }
    if (nm == null) {
        nm = JsArray.createArray().cast();
    }
    if (updateAvailable == null) {
        updateAvailable = new UpdateAvailableBar() {

            @Override
            void onShow() {
                reload.reload();
            }

            void onIgnore(Timestamp newTime) {
                lastDisplayedUpdate = newTime;
            }
        };
        updateAvailable.addCloseHandler(new CloseHandler<PopupPanel>() {

            @Override
            public void onClose(CloseEvent<PopupPanel> event) {
                updateAvailable = null;
            }
        });
    }
    updateAvailable.set(Natives.asList(nm).subList(om.length(), nm.length()), newInfo.updated());
    if (!updateAvailable.isShowing()) {
        updateAvailable.popup();
    }
}
#end_block

#method_before
private void startPoller() {
    poller = new Timer() {

        private int delay = REFRESH_POLL_PERIOD;

        @Override
        public void run() {
            if (!isAttached()) {
                // onUnload() should have removed this.
                return;
            } else if (!UserActivityMonitor.isActive()) {
                cancel();
                delay = REFRESH_IDLE_PERIOD;
                scheduleRepeating(delay);
            }
            loadChangeInfo(false, new AsyncCallback<ChangeInfo>() {

                @Override
                public void onSuccess(ChangeInfo info) {
                    if (isAttached() && !info.updated().equals(lastDisplayedUpdate)) {
                        showUpdates(info);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    // but place an upper bound on the delay.
                    if (isAttached()) {
                        cancel();
                        delay = (int) Math.max(delay * (1.5 + Math.random()), REFRESH_MAX_PERIOD);
                        scheduleRepeating(delay);
                    }
                }
            });
        }
    };
    poller.scheduleRepeating(REFRESH_POLL_PERIOD);
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static RootPanel getBottomMenu() {
    return gBottomMenu;
}
#method_after
public static RootPanel getBottomMenu() {
    return bottomMenu;
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(topMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#end_block

#method_before
public static boolean isActive() {
    return impl.recent || impl.active;
}
#method_after
public static boolean isActive() {
    return impl.active || impl.recent;
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    active = true;
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    recent = true;
}
#end_block

#method_before
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    active = true;
}
#method_after
@Override
public void onValueChange(ValueChangeEvent<String> event) {
    recent = true;
}
#end_block

#method_before
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (active) {
        recent = true;
        active = false;
        last = now;
    } else if ((now - last) > TIMEOUT) {
        recent = false;
    }
    return true;
}
#method_after
@Override
public boolean execute() {
    long now = System.currentTimeMillis();
    if (recent) {
        if (!active) {
            ValueChangeEvent.fire(this, active);
        }
        recent = false;
        active = true;
        last = now;
    } else if (active && (now - last) > TIMEOUT) {
        active = false;
        ValueChangeEvent.fire(this, false);
    }
    return true;
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource resource) {
    ConfigInfo result = new ConfigInfo();
    RefControl refConfig = resource.getControl().controlForRef(GitRepositoryManager.REF_CONFIG);
    ProjectState state = resource.getControl().getProjectState();
    Project p = state.getProject();
    if (refConfig.isVisible()) {
        InheritedBooleanInfo useContributorAgreements = new InheritedBooleanInfo();
        InheritedBooleanInfo useSignedOffBy = new InheritedBooleanInfo();
        InheritedBooleanInfo useContentMerge = new InheritedBooleanInfo();
        InheritedBooleanInfo requireChangeId = new InheritedBooleanInfo();
        useContributorAgreements.value = state.isUseContributorAgreements();
        useSignedOffBy.value = state.isUseSignedOffBy();
        useContentMerge.value = state.isUseContentMerge();
        requireChangeId.value = state.isRequireChangeID();
        useContributorAgreements.configuredValue = p.getUseContributorAgreements();
        useSignedOffBy.configuredValue = p.getUseSignedOffBy();
        useContentMerge.configuredValue = p.getUseContentMerge();
        requireChangeId.configuredValue = p.getRequireChangeID();
        ProjectState parentState = Iterables.getFirst(state.parents(), null);
        if (parentState != null) {
            useContributorAgreements.inheritedValue = parentState.isUseContributorAgreements();
            useSignedOffBy.inheritedValue = parentState.isUseSignedOffBy();
            useContentMerge.inheritedValue = parentState.isUseContentMerge();
            requireChangeId.inheritedValue = parentState.isRequireChangeID();
        }
        result.useContributorAgreements = useContributorAgreements;
        result.useSignedOffBy = useSignedOffBy;
        result.useContentMerge = useContentMerge;
        result.requireChangeId = requireChangeId;
    }
    MaxObjectSizeLimitInfo maxObjectSizeLimit = new MaxObjectSizeLimitInfo();
    maxObjectSizeLimit.value = config.getEffectiveMaxObjectSizeLimit(state) == config.getMaxObjectSizeLimit() ? config.getFormattedMaxObjectSizeLimit() : p.getMaxObjectSizeLimit();
    maxObjectSizeLimit.configuredValue = p.getMaxObjectSizeLimit();
    maxObjectSizeLimit.inheritedValue = config.getFormattedMaxObjectSizeLimit();
    result.maxObjectSizeLimit = maxObjectSizeLimit;
    result.submitType = p.getSubmitType();
    result.state = p.getState() != Project.State.ACTIVE ? p.getState() : null;
    // commentlinks are visible to anyone, as they are used for linkification
    // on the client side.
    result.commentlinks = Maps.newLinkedHashMap();
    for (CommentLinkInfo cl : state.getCommentLinks()) {
        result.commentlinks.put(cl.name, cl);
    }
    // Themes are visible to anyone, as they are rendered client-side.
    result.theme = state.getTheme();
    return result;
}
#method_after
@Override
public ConfigInfo apply(ProjectResource resource) {
    ConfigInfo result = new ConfigInfo();
    ProjectState state = resource.getControl().getProjectState();
    Project p = state.getProject();
    InheritedBooleanInfo useContributorAgreements = new InheritedBooleanInfo();
    InheritedBooleanInfo useSignedOffBy = new InheritedBooleanInfo();
    InheritedBooleanInfo useContentMerge = new InheritedBooleanInfo();
    InheritedBooleanInfo requireChangeId = new InheritedBooleanInfo();
    useContributorAgreements.value = state.isUseContributorAgreements();
    useSignedOffBy.value = state.isUseSignedOffBy();
    useContentMerge.value = state.isUseContentMerge();
    requireChangeId.value = state.isRequireChangeID();
    useContributorAgreements.configuredValue = p.getUseContributorAgreements();
    useSignedOffBy.configuredValue = p.getUseSignedOffBy();
    useContentMerge.configuredValue = p.getUseContentMerge();
    requireChangeId.configuredValue = p.getRequireChangeID();
    ProjectState parentState = Iterables.getFirst(state.parents(), null);
    if (parentState != null) {
        useContributorAgreements.inheritedValue = parentState.isUseContributorAgreements();
        useSignedOffBy.inheritedValue = parentState.isUseSignedOffBy();
        useContentMerge.inheritedValue = parentState.isUseContentMerge();
        requireChangeId.inheritedValue = parentState.isRequireChangeID();
    }
    result.useContributorAgreements = useContributorAgreements;
    result.useSignedOffBy = useSignedOffBy;
    result.useContentMerge = useContentMerge;
    result.requireChangeId = requireChangeId;
    MaxObjectSizeLimitInfo maxObjectSizeLimit = new MaxObjectSizeLimitInfo();
    maxObjectSizeLimit.value = config.getEffectiveMaxObjectSizeLimit(state) == config.getMaxObjectSizeLimit() ? config.getFormattedMaxObjectSizeLimit() : p.getMaxObjectSizeLimit();
    maxObjectSizeLimit.configuredValue = p.getMaxObjectSizeLimit();
    maxObjectSizeLimit.inheritedValue = config.getFormattedMaxObjectSizeLimit();
    result.maxObjectSizeLimit = maxObjectSizeLimit;
    result.submitType = p.getSubmitType();
    result.state = p.getState() != Project.State.ACTIVE ? p.getState() : null;
    result.commentlinks = Maps.newLinkedHashMap();
    for (CommentLinkInfo cl : state.getCommentLinks()) {
        result.commentlinks.put(cl.name, cl);
    }
    result.theme = state.getTheme();
    return result;
}
#end_block

#method_before
public static void get(Project.NameKey name, AsyncCallback<Entry> cb) {
    instance.getImpl(name, cb);
}
#method_after
public static void get(Project.NameKey name, AsyncCallback<Entry> cb) {
    instance.getImpl(name.get(), cb);
}
#end_block

#method_before
public static void get(Project.NameKey name, AsyncCallback<Entry> cb) {
    instance.getImpl(name, cb);
}
#method_after
public static void get(Change.Id changeId, AsyncCallback<Entry> cb) {
    instance.getImpl(changeId.get(), cb);
}
#end_block

#method_before
private void getImpl(final Project.NameKey name, final AsyncCallback<Entry> cb) {
    Entry e = cache.get(name.get());
    if (e != null) {
        cb.onSuccess(e);
        return;
    }
    ProjectApi.getConfig(name, new AsyncCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            Entry e = new Entry(result);
            cache.put(name.get(), e);
            cb.onSuccess(e);
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#method_after
private void getImpl(final String name, final AsyncCallback<Entry> cb) {
    Entry e = cache.get(name);
    if (e != null) {
        cb.onSuccess(e);
        return;
    }
    ProjectApi.getConfig(new Project.NameKey(name), new AsyncCallback<ConfigInfo>() {

        @Override
        public void onSuccess(ConfigInfo result) {
            Entry e = new Entry(result);
            cache.put(name, e);
            cb.onSuccess(e);
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public ConfigInfo apply(ProjectResource resource) {
    ConfigInfo result = new ConfigInfo();
    ProjectState state = resource.getControl().getProjectState();
    InheritedBooleanInfo useContributorAgreements = new InheritedBooleanInfo();
    InheritedBooleanInfo useSignedOffBy = new InheritedBooleanInfo();
    InheritedBooleanInfo useContentMerge = new InheritedBooleanInfo();
    InheritedBooleanInfo requireChangeId = new InheritedBooleanInfo();
    useContributorAgreements.value = state.isUseContributorAgreements();
    useSignedOffBy.value = state.isUseSignedOffBy();
    useContentMerge.value = state.isUseContentMerge();
    requireChangeId.value = state.isRequireChangeID();
    Project p = state.getProject();
    useContributorAgreements.configuredValue = p.getUseContributorAgreements();
    useSignedOffBy.configuredValue = p.getUseSignedOffBy();
    useContentMerge.configuredValue = p.getUseContentMerge();
    requireChangeId.configuredValue = p.getRequireChangeID();
    ProjectState parentState = Iterables.getFirst(state.parents(), null);
    if (parentState != null) {
        useContributorAgreements.inheritedValue = parentState.isUseContributorAgreements();
        useSignedOffBy.inheritedValue = parentState.isUseSignedOffBy();
        useContentMerge.inheritedValue = parentState.isUseContentMerge();
        requireChangeId.inheritedValue = parentState.isRequireChangeID();
    }
    result.useContributorAgreements = useContributorAgreements;
    result.useSignedOffBy = useSignedOffBy;
    result.useContentMerge = useContentMerge;
    result.requireChangeId = requireChangeId;
    // commentlinks are visible to anyone, as they are used for linkification
    // on the client side.
    result.commentlinks = Maps.newLinkedHashMap();
    for (CommentLinkInfo cl : state.getCommentLinks()) {
        result.commentlinks.put(cl.name, cl);
    }
    // Themes are visible to anyone, as they are rendered client-side.
    result.theme = state.getTheme();
    return result;
}
#method_after
@Override
public ConfigInfo apply(ProjectResource resource) {
    ConfigInfo result = new ConfigInfo();
    ProjectState state = resource.getControl().getProjectState();
    InheritedBooleanInfo useContributorAgreements = new InheritedBooleanInfo();
    InheritedBooleanInfo useSignedOffBy = new InheritedBooleanInfo();
    InheritedBooleanInfo useContentMerge = new InheritedBooleanInfo();
    InheritedBooleanInfo requireChangeId = new InheritedBooleanInfo();
    useContributorAgreements.value = state.isUseContributorAgreements();
    useSignedOffBy.value = state.isUseSignedOffBy();
    useContentMerge.value = state.isUseContentMerge();
    requireChangeId.value = state.isRequireChangeID();
    Project p = state.getProject();
    useContributorAgreements.configuredValue = p.getUseContributorAgreements();
    useSignedOffBy.configuredValue = p.getUseSignedOffBy();
    useContentMerge.configuredValue = p.getUseContentMerge();
    requireChangeId.configuredValue = p.getRequireChangeID();
    ProjectState parentState = Iterables.getFirst(state.parents(), null);
    if (parentState != null) {
        useContributorAgreements.inheritedValue = parentState.isUseContributorAgreements();
        useSignedOffBy.inheritedValue = parentState.isUseSignedOffBy();
        useContentMerge.inheritedValue = parentState.isUseContentMerge();
        requireChangeId.inheritedValue = parentState.isRequireChangeID();
    }
    result.useContributorAgreements = useContributorAgreements;
    result.useSignedOffBy = useSignedOffBy;
    result.useContentMerge = useContentMerge;
    result.requireChangeId = requireChangeId;
    result.commentlinks = Maps.newLinkedHashMap();
    for (CommentLinkInfo cl : state.getCommentLinks()) {
        result.commentlinks.put(cl.name, cl);
    }
    result.theme = state.getTheme();
    return result;
}
#end_block

#method_before
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    abandon.setVisible(hasUser && actions.containsKey("abandon"));
    restore.setVisible(hasUser && actions.containsKey("restore"));
    revert.setVisible(hasUser && actions.containsKey("revert"));
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(changeId, actions.get(id)));
        }
    }
}
#method_after
private void initChangeActions(ChangeInfo info, boolean hasUser) {
    NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    abandon.setVisible(hasUser && actions.containsKey("abandon"));
    restore.setVisible(hasUser && actions.containsKey("restore"));
    revert.setVisible(hasUser && actions.containsKey("revert"));
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    cherrypick.setVisible(hasUser && actions.containsKey("cherrypick"));
    rebase.setVisible(hasUser && actions.containsKey("rebase"));
    canSubmit = hasUser && actions.containsKey("submit");
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(changeId, revision, actions.get(id)));
        }
    }
}
#method_after
private void initRevisionActions(ChangeInfo info, RevisionInfo revInfo, boolean hasUser) {
    NativeMap<ActionInfo> actions = revInfo.has_actions() ? revInfo.actions() : NativeMap.<ActionInfo>create();
    actions.copyKeysIntoChildren("id");
    cherrypick.setVisible(hasUser && actions.containsKey("cherrypick"));
    rebase.setVisible(hasUser && actions.containsKey("rebase"));
    canSubmit = hasUser && actions.containsKey("submit");
    if (hasUser) {
        for (String id : filterNonCore(actions)) {
            add(new ActionButton(info, revInfo, actions.get(id)));
        }
    }
}
#end_block

#method_before
private void loadDiff(final RevisionInfo rev, CallbackGroup group) {
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadDiff(final RevisionInfo rev, CallbackGroup group) {
    DiffApi.list(changeId.get(), rev.name(), group.add(new AsyncCallback<NativeMap<FileInfo>>() {

        @Override
        public void onSuccess(NativeMap<FileInfo> m) {
            files.setRevisions(null, new PatchSet.Id(changeId, rev._number()));
            files.setValue(m);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.revision(changeId.get(), rev.name()).view("files").addParameterTrue("reviewed").get(group.add(new AsyncCallback<JsArrayString>() {

            @Override
            public void onSuccess(JsArrayString result) {
                files.markReviewed(result);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
}
#end_block

#method_before
private void renderReviewers(ChangeInfo info) {
    // TODO Fix approximation of reviewers and CC list(s).
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    reviewersText.setInnerSafeHtml(labels.formatUserList(r.values()));
    ccText.setInnerSafeHtml(labels.formatUserList(cc.values()));
}
#method_after
private void renderReviewers(ChangeInfo info) {
    // TODO Fix approximation of reviewers and CC list(s).
    Map<Integer, AccountInfo> r = new HashMap<Integer, AccountInfo>();
    Map<Integer, AccountInfo> cc = new HashMap<Integer, AccountInfo>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    r.remove(info.owner()._account_id());
    cc.remove(info.owner()._account_id());
    reviewersText.setInnerSafeHtml(labels.formatUserList(r.values()));
    ccText.setInnerSafeHtml(labels.formatUserList(cc.values()));
}
#end_block

#method_before
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    if (// Ignore merges and initial commit.
    commit.getParentCount() == 1 && (patchList = getPatchList(change, ps)) != null) {
        for (PatchListEntry entry : patchList.getPatches()) {
            BlameResult blameResult;
            if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
                List<Edit> edits = entry.getEdits();
                reviewers.putAll(getReviewersForPatch(edits, blameResult));
            }
        }
        Set<Account.Id> topReviewers = findTopReviewers(Collections.unmodifiableSet(reviewers.entrySet()), maxReviewers);
        addReviewers(topReviewers, change);
    }
}
#method_after
@Override
public void run() {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    PatchList patchList;
    try {
        patchList = patchListCache.get(change, ps);
    } catch (PatchListNotAvailableException ex) {
        log.error("Couldn't load patchlist for change {}", change.getKey(), ex);
        return;
    }
    // Ignore merges and initial commit.
    if (commit.getParentCount() != 1) {
        return;
    }
    for (PatchListEntry entry : patchList.getPatches()) {
        BlameResult blameResult;
        if ((entry.getChangeType() == ChangeType.MODIFIED || entry.getChangeType() == ChangeType.DELETED) && (blameResult = computeBlame(entry, commit.getParent(0))) != null) {
            List<Edit> edits = entry.getEdits();
            reviewers.putAll(getReviewersForPatch(edits, blameResult));
        }
    }
    Set<Account.Id> topReviewers = findTopReviewers(reviewers);
    addReviewers(topReviewers, change);
}
#end_block

#method_before
private Set<Account.Id> findTopReviewers(final Set<Entry<Account, Integer>> reviewers, final int max) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    Queue<Entry<Account, Integer>> pq = new PriorityQueue<Map.Entry<Account, Integer>>(reviewers.size(), new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return second.getValue() - first.getValue();
        }
    });
    pq.addAll(reviewers);
    int curr = 0;
    while (!pq.isEmpty() && curr < max) {
        topReviewers.add(pq.poll().getKey().getId());
        ++curr;
    }
    return topReviewers;
}
#method_after
private Set<Account.Id> findTopReviewers(final Map<Account, Integer> reviewers) {
    Set<Account.Id> topReviewers = Sets.newHashSet();
    List<Entry<Account, Integer>> entries = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        public int compare(Entry<Account, Integer> first, Entry<Account, Integer> second) {
            return first.getValue() - second.getValue();
        }
    }).greatestOf(reviewers.entrySet(), this.maxReviewers);
    for (Entry<Account, Integer> entry : entries) {
        topReviewers.add(entry.getKey().getId());
    }
    return topReviewers;
}
#end_block

#method_before
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i <= edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#method_after
private Map<Account, Integer> getReviewersForPatch(final List<Edit> edits, final BlameResult blameResult) {
    Map<Account, Integer> reviewers = Maps.newHashMap();
    for (Edit edit : edits) {
        for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
            RevCommit commit = blameResult.getSourceCommit(i);
            Set<Account.Id> ids = byEmailCache.get(commit.getAuthorIdent().getEmailAddress());
            for (Account.Id id : ids) {
                Account account = accountCache.get(id).getAccount();
                if (account.isActive() && !change.getOwner().equals(account.getId())) {
                    Integer count = reviewers.get(account);
                    reviewers.put(account, count == null ? 1 : count.intValue() + 1);
                }
            }
        }
    }
    return reviewers;
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                final Change change = reviewDb.changes().get(Change.Id.fromRef(u.getRefName()));
                List<PatchSet> patchSets = reviewDb.patchSets().byChange(change.getId()).toList();
                // only compute for the first patch set
                if (patchSets.size() > 1) {
                    continue;
                }
                final PatchSet ps = patchSets.get(0);
                RevWalk rw = new RevWalk(git);
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(ps.getRevision().get()));
                // FIXME Convert to
                int maxReviewers = 3;
                // project.getMaxReviewersByBlame();
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        git.close();
    }
}
#method_after
@Override
public void onGitReferenceUpdated(final Event e) {
    Project.NameKey projectName = new Project.NameKey(e.getProjectName());
    Repository git;
    try {
        git = repoManager.openRepository(projectName);
    } catch (RepositoryNotFoundException x) {
        log.error(x.getMessage(), x);
        return;
    } catch (IOException x) {
        log.error(x.getMessage(), x);
        return;
    }
    final ReviewDb reviewDb;
    final RevWalk rw = new RevWalk(git);
    try {
        reviewDb = schemaFactory.open();
        try {
            for (Update u : e.getUpdates()) {
                if (!u.getRefName().startsWith("refs/changes/")) {
                    continue;
                }
                PatchSet.Id psId = PatchSet.Id.fromRef(u.getRefName());
                PatchSet ps = reviewDb.patchSets().get(psId);
                final Change change = reviewDb.changes().get(psId.getParentKey());
                final RevCommit commit = rw.parseCommit(ObjectId.fromString(u.getNewObjectId()));
                // TODO Move to config
                int maxReviewers = 3;
                final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git);
                workQueue.getDefaultQueue().submit(new Runnable() {

                    public void run() {
                        RequestContext old = tl.setContext(new RequestContext() {

                            @Override
                            public CurrentUser getCurrentUser() {
                                return identifiedUserFactory.create(change.getOwner());
                            }

                            @Override
                            public Provider<ReviewDb> getReviewDbProvider() {
                                return new Provider<ReviewDb>() {

                                    @Override
                                    public ReviewDb get() {
                                        if (db == null) {
                                            try {
                                                db = schemaFactory.open();
                                            } catch (OrmException e) {
                                                throw new ProvisionException("Cannot open ReviewDb", e);
                                            }
                                        }
                                        return db;
                                    }
                                };
                            }
                        });
                        try {
                            task.run();
                        } finally {
                            tl.setContext(old);
                            if (db != null) {
                                db.close();
                                db = null;
                            }
                        }
                    }
                });
            }
        } catch (OrmException x) {
            log.error(x.getMessage(), x);
        } catch (MissingObjectException x) {
            log.error(x.getMessage(), x);
        } catch (IncorrectObjectTypeException x) {
            log.error(x.getMessage(), x);
        } catch (IOException x) {
            log.error(x.getMessage(), x);
        } finally {
            reviewDb.close();
        }
    } catch (OrmException x) {
        log.error(x.getMessage(), x);
    } finally {
        rw.release();
        git.close();
    }
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? DiffTable.style.diff() : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    String diffColor = diff.meta_a() == null || diff.meta_b() == null ? DiffTable.style.intralineBg() : DiffTable.style.diff();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffColor : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private List<SkippedLine> checkAndAddSkip(List<SkippedLine> list, SkippedLine toAdd) {
    if (toAdd.getSize() > 1) {
        list.add(toAdd);
    }
    return list;
}
#method_after
private void checkAndAddSkip(List<SkippedLine> list, SkippedLine toAdd) {
    if (toAdd.getSize() > 1) {
        list.add(toAdd);
    }
}
#end_block

#method_before
@UiHandler("editArea")
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#method_after
void onEsc(KeyDownEvent e) {
    if (e.getNativeKeyCode() == KeyCodes.KEY_ESCAPE) {
        if (isNew) {
            removeUI();
        } else {
            onCancel(null);
        }
        e.preventDefault();
    }
}
#end_block

#method_before
private void removeKeyHandlerRegs() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    if (regOpenByEnter != null) {
        regOpenByEnter.removeHandler();
        regOpenByEnter = null;
    }
    if (regComment != null) {
        regComment.removeHandler();
        regComment = null;
    }
}
#method_after
private void removeKeyHandlerRegs() {
    for (HandlerRegistration h : keyHandlers) {
        h.removeHandler();
    }
    keyHandlers.clear();
}
#end_block

#method_before
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)));
    cm.addKeyMap(KeyMap.create().on("'k'", moveCursorDown(cm, -1)));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
}
#method_after
private void registerCmEvents(CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("scroll", doScroll(otherCM(cm)));
    /**
     * TODO: Trying to prevent right click from updating the cursor.
     * Doesn't seem to work for now.
     */
    cm.on("mousedown", ignoreRightClick());
    cm.addKeyMap(KeyMap.create().on("'u'", upToChange()));
    cm.addKeyMap(KeyMap.create().on("'o'", toggleOpenBox(cm)));
    cm.addKeyMap(KeyMap.create().on("Enter", toggleOpenBox(cm)));
    if (Gerrit.isSignedIn()) {
        cm.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cm)));
    }
    // TODO: Examine if a better way exists.
    for (String c : new String[] { "A", "C", "D", "I", "O", "P", "R", "S", "U", "X", "Y", "~" }) {
        CodeMirror.disableUnwantedKey("vim", c);
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new UpToChangeCommand(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    regNavigation = GlobalKey.add(this, keysNavigation);
    regAction = GlobalKey.add(this, keysAction);
    regOpenByEnter = GlobalKey.add(this, keysOpenByEnter);
    if (keysComment != null) {
        regComment = GlobalKey.add(this, keysComment);
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysNavigation.add(new NoOpKeyCommand(0, 'u', PatchUtil.C.upToChange()));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    keyHandlers.add(GlobalKey.add(this, keysNavigation));
    keyHandlers.add(GlobalKey.add(this, keysAction));
    keyHandlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        keyHandlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("styleSelectedText", true).set("showTrailingSpace", true).set("keyMap", "vim").set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? DiffTable.style.diff() : DiffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, diffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, DiffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, DiffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#end_block

#method_before
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    /**
     * Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely, and CodeMirror doesn't like manually
     * setting the display of a line to "none". The workaround here uses
     * inline widget for the first line and regular line widgets for others.
     */
    Configuration markerConfig;
    if (markStart == -1) {
        markerConfig = Configuration.create().set("inclusiveLeft", true).set("inclusiveRight", true).set("replacedWith", bar.getElement());
        cm.addLineClass(0, LineClassWhere.WRAP, DiffTable.style.hideNumber());
    } else {
        markerConfig = Configuration.create().set("collapsed", true);
        Configuration config = Configuration.create().set("coverGutter", true);
        bar.setWidget(cm.addLineWidget(markStart, bar.getElement(), config));
    }
    bar.setMarker(cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), markerConfig), size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", DiffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", DiffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, DiffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = getCursorLine(cm);
            LineHandle handle = cm.getLineHandle(line);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
            LineHandle handle = cm.getLineHandleVisualStart(cm.getCursor().getLine());
            int line = cm.getLineNumber(handle);
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, DiffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, DiffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, DiffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
public void setPreviewText(final String text) {
    if (textLabel != null) {
        textLabel.setText(text);
    }
}
#method_after
public void setPreviewText(final String text) {
    if (textLabel != null) {
        textLabel.setText(text);
        visibleLen = text.length();
    }
}
#end_block

#method_before
private void showTextBox() {
    if (textBox == null) {
        textBox = new TextBox();
        textBox.setText(getText());
        textBox.setVisibleLength(visibleLen);
        textBox.setReadOnly(readOnly);
        textBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(final KeyPressEvent event) {
                if (event.isControlKeyDown() || event.isMetaKeyDown()) {
                    switch(event.getCharCode()) {
                        case 'c':
                        case 'x':
                            Scheduler.get().scheduleDeferred(new Command() {

                                public void execute() {
                                    hideTextBox();
                                }
                            });
                            break;
                    }
                }
            }
        });
        textBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(final BlurEvent event) {
                hideTextBox();
            }
        });
        content.insert(textBox, 1);
    }
    textLabel.setVisible(false);
    textBox.setVisible(true);
    Scheduler.get().scheduleDeferred(new Command() {

        @Override
        public void execute() {
            textBox.selectAll();
            textBox.setFocus(true);
        }
    });
}
#method_after
private void showTextBox() {
    if (textBox == null) {
        textBox = new TextBox();
        textBox.setText(getText());
        textBox.setVisibleLength(visibleLen);
        textBox.setReadOnly(true);
        textBox.addKeyPressHandler(new KeyPressHandler() {

            @Override
            public void onKeyPress(final KeyPressEvent event) {
                if (event.isControlKeyDown() || event.isMetaKeyDown()) {
                    switch(event.getCharCode()) {
                        case 'c':
                        case 'x':
                            Scheduler.get().scheduleDeferred(new Command() {

                                public void execute() {
                                    hideTextBox();
                                }
                            });
                            break;
                    }
                }
            }
        });
        textBox.addBlurHandler(new BlurHandler() {

            @Override
            public void onBlur(final BlurEvent event) {
                hideTextBox();
            }
        });
        content.insert(textBox, 1);
    }
    textLabel.setVisible(false);
    textBox.setVisible(true);
    Scheduler.get().scheduleDeferred(new Command() {

        @Override
        public void execute() {
            textBox.selectAll();
            textBox.setFocus(true);
        }
    });
}
#end_block

#method_before
@Override
public Response<CommitInfo> apply(RevisionResource resource) throws OrmException, PatchSetInfoNotAvailableException {
    CommitInfo r = json.toCommit(resource.getPatchSet());
    r.kind = CommitInfo.KIND;
    return Response.ok(r).caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
}
#method_after
@Override
public Response<CommitInfo> apply(RevisionResource resource) throws OrmException, PatchSetInfoNotAvailableException {
    return Response.ok(json.toCommit(resource.getPatchSet())).caching(CacheControl.PRIVATE(7, TimeUnit.DAYS));
}
#end_block

#method_before
static void initLibrary(AsyncCallback<Void> cb) {
    if (isLibLoaded()) {
        cb.onSuccess(null);
    } else {
        CallbackGroup group = new CallbackGroup();
        injectCss(Lib.I.css());
        injectScript(Lib.I.js().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.mark_selection().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.trailingspace().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.foldcode().getSafeUri(), group.addFinal(cb));
    }
}
#method_after
static void initLibrary(AsyncCallback<Void> cb) {
    if (isLibLoaded()) {
        cb.onSuccess(null);
    } else {
        CallbackGroup group = new CallbackGroup();
        injectCss(Lib.I.css());
        injectScript(Lib.I.js().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.mark_selection().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.trailingspace().getSafeUri(), group.addFinal(cb));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
    }
    lineBoxMapA = new HashMap<Integer, CommentBox>();
    lineBoxMapB = new HashMap<Integer, CommentBox>();
    renderPublished();
    renderDrafts();
    published = null;
    drafts = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    if (Gerrit.isSignedIn()) {
        cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
        cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    }
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    if (Gerrit.isSignedIn()) {
        cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
        cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    }
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            // TODO: Handle skips.
            mapper.appendCommon(current.ab().length());
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    DraftBox box = new DraftBox(this, revision, info, commentLinkProcessor, true, doSave);
    addCommentBox(info, box);
    if (!doSave) {
        box.setEdit(true);
    }
    getLineBoxMapFromSide(info.side()).put(info.line() - 1, box);
    return box;
}
#method_after
private DraftBox addDraftBox(CommentInfo info, boolean doSave) {
    DraftBox box = new DraftBox(this, revision, info, commentLinkProcessor, true, doSave);
    addCommentBox(info, box);
    if (!doSave) {
        box.setEdit(true);
    }
    LineHandle handle = getCmFromSide(info.side()).getLineHandle(info.line() - 1);
    lineActiveBoxMap.put(handle, box);
    return box;
}
#end_block

#method_before
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), COMMENT_BOX_CONFIG);
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    // Estimated height at 21px, fixed by deferring after display
    LineWidgetElementPair padding = addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX);
    box.setSelfWidget(boxWidget);
    box.setPadding(padding.widget, padding.element);
    return box;
}
#method_after
CommentBox addCommentBox(CommentInfo info, final CommentBox box) {
    diffTable.add(box);
    Side mySide = info.side();
    CodeMirror cm = mySide == Side.PARENT ? cmA : cmB;
    CodeMirror other = otherCM(cm);
    // CommentInfo is 1-based, but CM is 0-based
    int line = info.line() - 1;
    LineHandle handle = cm.getLineHandle(line);
    PaddingManager manager;
    if (linePaddingManagerMap.containsKey(handle)) {
        manager = linePaddingManagerMap.get(handle);
    } else {
        // Estimated height at 21px, fixed by deferring after display
        manager = new PaddingManager(addPaddingWidget(cm, diffTable.style.padding(), line, 21, Unit.PX, 0));
        linePaddingManagerMap.put(handle, manager);
    }
    int lineToPad = mapper.lineOnOther(mySide, line).getLine();
    LineHandle otherHandle = other.getLineHandle(lineToPad);
    if (linePaddingManagerMap.containsKey(otherHandle)) {
        PaddingManager.link(manager, linePaddingManagerMap.get(otherHandle));
    } else {
        PaddingManager otherManager = new PaddingManager(addPaddingWidget(other, diffTable.style.padding(), lineToPad, 21, Unit.PX, 0));
        linePaddingManagerMap.put(otherHandle, otherManager);
        PaddingManager.link(manager, otherManager);
    }
    int index = manager.getCurrentCount();
    manager.insert(box, index);
    Configuration config = Configuration.create().set("coverGutter", true).set("insertAt", index);
    LineWidget boxWidget = cm.addLineWidget(line, box.getElement(), config);
    box.setPaddingManager(manager);
    box.setSelfWidget(boxWidget);
    return box;
}
#end_block

#method_before
private void renderPublished() {
    for (int i = 0; published != null && i < published.length(); i++) {
        CommentInfo info = published.get(i);
        final PublishedBox box = new PublishedBox(this, revision, info, commentLinkProcessor);
        box.setOpen(false);
        addCommentBox(info, box);
        initialBoxes.add(box);
        publishedMap.put(info.id(), box);
        getLineBoxMapFromSide(info.side()).put(info.line() - 1, box);
    }
}
#method_after
private void renderPublished() {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        final PublishedBox box = new PublishedBox(this, revision, info, commentLinkProcessor);
        box.setOpen(false);
        initialBoxes.add(box);
        publishedMap.put(info.id(), box);
        int line = info.line() - 1;
        LineHandle handle = getCmFromSide(info.side()).getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void renderDrafts() {
    for (int i = 0; drafts != null && i < drafts.length(); i++) {
        CommentInfo info = drafts.get(i);
        final DraftBox box = new DraftBox(this, revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        addCommentBox(info, box);
        initialBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        getLineBoxMapFromSide(info.side()).put(info.line() - 1, box);
    }
}
#method_after
private void renderDrafts() {
    List<CommentInfo> sorted = sortComment(drafts);
    for (CommentInfo info : sorted) {
        final DraftBox box = new DraftBox(this, revision, info, commentLinkProcessor, false, false);
        box.setOpen(false);
        box.setEdit(false);
        initialBoxes.add(box);
        if (published != null) {
            PublishedBox replyToBox = publishedMap.get(info.in_reply_to());
            if (replyToBox != null) {
                replyToBox.registerReplyBox(box);
            }
        }
        lineActiveBoxMap.put(getCmFromSide(info.side()).getLineHandle(info.line() - 1), box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = LineCharacter.create(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(LineCharacter.create(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#method_after
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#end_block

#method_before
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = cm.getCursor("head").getLine();
            cm.setActiveLine(line);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            if (info.isAligned()) {
                int oLine = info.getLine();
                other.setActiveLine(oLine);
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#method_after
private Runnable updateActiveLine(final CodeMirror cm) {
    final CodeMirror other = otherCM(cm);
    return new Runnable() {

        public void run() {
            if (cm.hasActiveLine()) {
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                cm.removeLineClass(cm.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            if (other.hasActiveLine()) {
                other.removeLineClass(other.getActiveLine(), LineClassWhere.WRAP, diffTable.style.activeLine());
                other.removeLineClass(other.getActiveLine(), LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
            int line = cm.getCursor("head").getLine();
            LineHandle handle = cm.getLineHandle(line);
            // Ugly workaround because CodeMirror never hides lines completely.
            if (hiddenSkipMap.containsKey(handle)) {
                line -= hiddenSkipMap.get(handle);
                handle = cm.getLineHandle(line);
            }
            cm.setActiveLine(handle);
            if (cm.somethingSelected()) {
                return;
            }
            cm.addLineClass(line, LineClassWhere.WRAP, diffTable.style.activeLine());
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            LineOnOtherInfo info = mapper.lineOnOther(cm == cmA ? Side.PARENT : Side.REVISION, line);
            int oLine = info.getLine();
            if (info.isAligned()) {
                other.setActiveLine(other.getLineHandle(oLine));
                other.addLineClass(oLine, LineClassWhere.WRAP, diffTable.style.activeLine());
                other.addLineClass(oLine, LineClassWhere.BACKGROUND, diffTable.style.activeLineBg());
            }
        }
    };
}
#end_block

#method_before
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            Map<Integer, CommentBox> lineBoxMap = cm == cmA ? lineBoxMapA : lineBoxMapB;
            int line = cm.getActiveLine();
            CommentBox box = lineBoxMap.get(line);
            if (box == null) {
                lineBoxMap.put(line, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) lineBoxMap.get(line)).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#method_after
private Runnable insertNewDraft(final CodeMirror cm) {
    return new Runnable() {

        public void run() {
            LineHandle handle = cm.getActiveLine();
            int line = cm.getLineNumber(handle);
            CommentBox box = lineActiveBoxMap.get(handle);
            if (box == null) {
                lineActiveBoxMap.put(handle, addNewDraft(cm, line));
            } else if (box.isDraft()) {
                ((DraftBox) lineActiveBoxMap.get(handle)).setEdit(true);
            } else {
                ((PublishedBox) box).onReply(null);
            }
        }
    };
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#end_block

#method_before
public final void removeLineClass(int line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void removeLineClass(LineHandle line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#end_block

#method_before
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (!checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#method_after
void setMarker(TextMarker marker, int length) {
    this.marker = marker;
    numSkipLines = length;
    skipNum.setText(Integer.toString(length));
    if (checkAndUpdateArrows()) {
        upArrow.setHTML(PatchUtil.M.expandBefore(NUM_ROWS_TO_EXPAND));
        downArrow.setHTML(PatchUtil.M.expandAfter(NUM_ROWS_TO_EXPAND));
    }
}
#end_block

#method_before
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(Integer.toString(numSkipLines));
    checkAndUpdateArrows();
}
#method_after
private void updateSkipNum() {
    numSkipLines -= NUM_ROWS_TO_EXPAND;
    skipNum.setText(String.valueOf(numSkipLines));
    checkAndUpdateArrows();
}
#end_block

#method_before
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return true;
    }
    return false;
}
#method_after
private boolean checkAndUpdateArrows() {
    if (numSkipLines <= UP_DOWN_THRESHOLD) {
        upArrow.addStyleName(style.noExpand());
        downArrow.addStyleName(style.noExpand());
        return false;
    }
    return true;
}
#end_block

#method_before
private void expandAll() {
    marker.clear();
    removeFromParent();
}
#method_after
private void expandAll() {
    hiddenSkipMap.remove(cm.getLineHandle(marker.find().getTo().getLine()));
    marker.clear();
    widget.clear();
    removeFromParent();
}
#end_block

#method_before
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine() + NUM_ROWS_TO_EXPAND), CodeMirror.Pos(fromTo.getTo().getLine()), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandBefore() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldStart = fromTo.getFrom().getLine();
    int newStart = oldStart + NUM_ROWS_TO_EXPAND;
    int end = fromTo.getTo().getLine();
    marker = cm.markText(CodeMirror.pos(newStart), CodeMirror.pos(end), COLLAPSED);
    Configuration config = Configuration.create().set("coverGutter", true);
    LineWidget newWidget = cm.addLineWidget(newStart, getElement(), config);
    widget.clear();
    setWidget(newWidget);
    updateSkipNum();
    hiddenSkipMap.put(cm.getLineHandle(end), numSkipLines);
}
#end_block

#method_before
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    marker = cm.markText(CodeMirror.Pos(fromTo.getFrom().getLine()), CodeMirror.Pos(fromTo.getTo().getLine() - NUM_ROWS_TO_EXPAND), Configuration.getReplaceConfig(getElement()));
    updateSkipNum();
}
#method_after
private void expandAfter() {
    FromTo fromTo = marker.find();
    marker.clear();
    int oldEnd = fromTo.getTo().getLine();
    int newEnd = oldEnd - NUM_ROWS_TO_EXPAND;
    marker = cm.markText(CodeMirror.pos(fromTo.getFrom().getLine()), CodeMirror.pos(newEnd), COLLAPSED);
    updateSkipNum();
    hiddenSkipMap.remove(cm.getLineHandle(oldEnd));
    hiddenSkipMap.put(cm.getLineHandle(newEnd), numSkipLines);
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#end_block

#method_before
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(1));
}
#method_after
@Test
public void testSimpleAdvance() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 1), iter.advance(1));
}
#end_block

#method_before
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0), iter.advance(3));
}
#method_after
@Test
public void testEndsBeforeNewline() {
    EditIterator iter = new EditIterator(lines, 0);
    assertLineChsEqual(LineCharacter.create(0, 3), iter.advance(3));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            drafts = m.get(path);
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline().ignoreWhitespace(DiffApi.IgnoreWhitespace.NONE).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    CommentApi.comments(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
            published = m.get(path);
        }
    }));
    if (Gerrit.isSignedIn()) {
        CommentApi.drafts(revision, group.add(new GerritCallback<NativeMap<JsArray<CommentInfo>>>() {

            @Override
            public void onSuccess(NativeMap<JsArray<CommentInfo>> m) {
                drafts = m.get(path);
            }
        }));
    } else {
        drafts = JsArray.createArray().cast();
    }
    ChangeApi.detail(revision.getParentKey().get(), new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            Project.NameKey project = result.project_name_key();
            ConfigInfoCache.get(project, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(CodeMirrorDemo.this) {

                @Override
                protected void preDisplay(ConfigInfoCache.Entry result) {
                    commentLinkProcessor = result.getCommentLinkProcessor();
                    setTheme(result.getTheme());
                    DiffInfo diffInfo = diff;
                    diff = null;
                    display(diffInfo);
                }
            }));
        }
    });
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            for (Runnable r : resizeCallbacks) {
                r.run();
            }
            resizeCallbacks = null;
        }
    });
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    if (cmA != null) {
        cmA.refresh();
    }
    if (cmB != null) {
        cmB.refresh();
    }
    Window.enableScrolling(false);
    for (CommentBox box : initialBoxes) {
        box.resizePaddingWidget();
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    renderSkips();
    skips = null;
    resizeCallbacks = new ArrayList<Runnable>();
    renderComments(published, false);
    renderComments(drafts, true);
    published = null;
    drafts = null;
    mapper = null;
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    skips = new ArrayList<SkippedLine>();
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (published != null) {
        publishedMap = new HashMap<String, PublishedBox>(published.length());
        renderPublished();
    }
    if (drafts != null) {
        renderDrafts();
    }
    renderSkips();
    published = null;
    drafts = null;
    skips = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    if (Gerrit.isSignedIn()) {
        cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
        cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    }
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    int context = pref == null ? DFLT_CONTEXT : pref.getContext();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            colorLines(cmA, origLineA, aLength);
            colorLines(cmB, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    AccountDiffPreference pref = Gerrit.getAccountDiffPreference();
    context = pref != null ? pref.getContext() : AccountDiffPreference.DEFAULT_CONTEXT;
    JsArray<Region> regions = diff.content();
    mapper = new LineMapper();
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        int origLineA = mapper.getLineA();
        int origLineB = mapper.getLineB();
        if (current.ab() != null) {
            // Common
            int length = current.ab().length();
            mapper.appendCommon(length);
            if (i == 0 && length > context) {
                skips.add(new SkippedLine(0, 0, length - context));
            } else if (i == regions.length() - 1 && length > context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - context));
            } else if (length > 2 * context) {
                skips.add(new SkippedLine(origLineA + context, origLineB + context, length - 2 * context));
            }
        } else {
            // Insert, Delete or Edit
            JsArrayString currentA = current.a() == null ? EMPTY : current.a();
            JsArrayString currentB = current.b() == null ? EMPTY : current.b();
            int aLength = currentA.length();
            int bLength = currentB.length();
            String color = currentA == EMPTY || currentB == EMPTY ? diffTable.style.diff() : diffTable.style.intralineBg();
            colorLines(cmA, color, origLineA, aLength);
            colorLines(cmB, color, origLineB, bLength);
            mapper.appendCommon(Math.min(aLength, bLength));
            if (aLength < bLength) {
                // Edit with insertion
                int insertCnt = bLength - aLength;
                insertEmptyLines(cmA, mapper.getLineA(), insertCnt);
                mapper.appendInsert(insertCnt);
            } else if (aLength > bLength) {
                // Edit with deletion
                int deleteCnt = aLength - bLength;
                insertEmptyLines(cmB, mapper.getLineB(), deleteCnt);
                mapper.appendDelete(deleteCnt);
            }
            markEdit(cmA, currentA, current.edit_a(), origLineA);
            markEdit(cmB, currentB, current.edit_b(), origLineB);
        }
    }
}
#end_block

#method_before
private void renderSkips() {
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#method_after
private void renderSkips() {
    hiddenSkipMap = new HashMap<LineHandle, Integer>();
    for (CommentBox box : initialBoxes) {
        List<SkippedLine> temp = new ArrayList<SkippedLine>();
        for (SkippedLine skip : skips) {
            CommentInfo info = box.getOriginal();
            int startLine = info.side() == Side.PARENT ? skip.getStartA() : skip.getStartB();
            int boxLine = info.line();
            int deltaBefore = boxLine - startLine;
            int deltaAfter = startLine + skip.getSize() - boxLine;
            if (deltaBefore < 0 || deltaAfter < 0) {
                temp.add(skip);
            } else if (deltaBefore > context && deltaAfter > context) {
                SkippedLine before = new SkippedLine(skip.getStartA(), skip.getStartB(), skip.getSize() - deltaAfter - context);
                skip.incrementStart(deltaBefore + context);
                temp.add(before);
                temp.add(skip);
            } else if (deltaAfter > context) {
                skip.incrementStart(deltaBefore + context);
                temp.add(skip);
            } else if (deltaBefore > context) {
                skip.reduceSize(deltaAfter + context);
                temp.add(skip);
            }
        }
        skips = temp;
    }
    for (SkippedLine skip : skips) {
        SkipBar barA = renderSkipHelper(cmA, skip);
        SkipBar barB = renderSkipHelper(cmB, skip);
        SkipBar.link(barA, barB);
    }
}
#end_block

#method_before
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int start = cm == cmA ? skip.getStartA() : skip.getStartB();
    SkipBar bar = new SkipBar(cm);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.Pos(start), CodeMirror.Pos(start + size), Configuration.getReplaceConfig(bar.getElement()));
    bar.setMarker(marker, size);
    return bar;
}
#method_after
private SkipBar renderSkipHelper(CodeMirror cm, SkippedLine skip) {
    int size = skip.getSize();
    int markStart = cm == cmA ? skip.getStartA() - 1 : skip.getStartB() - 1;
    int markEnd = markStart + size;
    hiddenSkipMap.put(cm.getLineHandle(markEnd), size);
    SkipBar bar = new SkipBar(cm, hiddenSkipMap);
    diffTable.add(bar);
    TextMarker marker = cm.markText(CodeMirror.pos(markStart), CodeMirror.pos(markEnd), Configuration.create().set("collapsed", true));
    /**
     * TODO: Due to CodeMirror limitation, there's no way to make the first
     * line disappear completely. The current approach leaves an empty line
     * with line number "1" still showing, and CodeMirror doesn't like manually
     * setting the display of a line to "none". A workaround may be to use
     * inline widget for the first line and regular line widgets for others.
     */
    boolean isZero = markStart == -1;
    Configuration config = Configuration.create().set("coverGutter", true).set("above", isZero);
    LineWidget widget = cm.addLineWidget(isZero ? markEnd + 1 : markStart, bar.getElement(), config);
    bar.setWidget(widget);
    bar.setMarker(marker, size);
    return bar;
}
#end_block

#method_before
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    Configuration editOpt = Configuration.create().set("className", diffTable.style.intraline()).set("readOnly", true);
    LineCharacter last = CodeMirror.Pos(0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, diffOpt);
        } else {
            cm.markText(CodeMirror.Pos(fromLine), from, diffOpt);
        }
        cm.markText(from, to, editOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.intraline());
        }
    }
}
#method_after
private void markEdit(CodeMirror cm, JsArrayString lines, JsArray<Span> edits, int startLine) {
    if (edits == null) {
        return;
    }
    EditIterator iter = new EditIterator(lines, startLine);
    Configuration intralineBgOpt = Configuration.create().set("className", diffTable.style.intralineBg()).set("readOnly", true);
    Configuration diffOpt = Configuration.create().set("className", diffTable.style.diff()).set("readOnly", true);
    LineCharacter last = CodeMirror.pos(0, 0);
    for (int i = 0; i < edits.length(); i++) {
        Span span = edits.get(i);
        LineCharacter from = iter.advance(span.skip());
        LineCharacter to = iter.advance(span.mark());
        int fromLine = from.getLine();
        if (last.getLine() == fromLine) {
            cm.markText(last, from, intralineBgOpt);
        } else {
            cm.markText(CodeMirror.pos(fromLine, 0), from, intralineBgOpt);
        }
        cm.markText(from, to, diffOpt);
        last = to;
        for (int line = fromLine; line < to.getLine(); line++) {
            cm.addLineClass(line, LineClassWhere.BACKGROUND, diffTable.style.diff());
        }
    }
}
#end_block

#method_before
private void colorLines(CodeMirror cm, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, diffTable.style.diff());
    }
}
#method_after
private void colorLines(CodeMirror cm, String color, int line, int cnt) {
    for (int i = 0; i < cnt; i++) {
        cm.addLineClass(line + i, LineClassWhere.WRAP, color);
    }
}
#end_block

#method_before
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM);
}
#method_after
private void insertEmptyLines(CodeMirror cm, int nextLine, int cnt) {
    // -1 to compensate for the line we went past when this method is called.
    addPaddingWidget(cm, diffTable.style.padding(), nextLine - 1, cnt, Unit.EM, null);
}
#end_block

#method_before
private Element addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return div;
}
#method_after
private LineWidgetElementPair addPaddingWidget(CodeMirror cm, String style, int line, int height, Unit unit, Integer index) {
    Element div = DOM.createDiv();
    div.setClassName(style);
    div.getStyle().setHeight(height, unit);
    Configuration config = Configuration.create().set("coverGutter", true).set("above", line == -1);
    if (index != null) {
        config = config.set("insertAt", index);
    }
    LineWidget widget = cm.addLineWidget(line == -1 ? 0 : line, div, config);
    return new LineWidgetElementPair(widget, div);
}
#end_block

#method_before
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = CodeMirror.Pos(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#method_after
LineCharacter advance(int numOfChar) {
    while (currLineIndex < lines.length()) {
        int lengthWithNewline = lines.get(currLineIndex).length() - currLineOffset + 1;
        if (numOfChar < lengthWithNewline) {
            LineCharacter at = LineCharacter.create(startLine + currLineIndex, numOfChar + currLineOffset);
            currLineOffset += numOfChar;
            return at;
        }
        numOfChar -= lengthWithNewline;
        advanceLine();
        if (numOfChar == 0) {
            return LineCharacter.create(startLine + currLineIndex, 0);
        }
    }
    throw new IllegalStateException("EditIterator index out of bound");
}
#end_block

#method_before
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db, change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        rebase(git, rw, inserter, patchSetId, change, uploader.getAccountId(), baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, indexer);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#method_after
public void rebase(final PatchSet.Id patchSetId, final IdentifiedUser uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId, uploader);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final String baseRev = findBaseRevision(patchSetId, db, change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        PersonIdent committerIdent = uploader.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true), committerIdent, true, true);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final Account.Id uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, final ChangeIndexer indexer) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader, patchSetId);
    cmsg.setMessage("Patch Set " + patchSetId.get() + " was rebased");
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), identifiedUser);
    Change newChange = patchSetInserterFactory.create(git, revWalk, changeControl.getRefControl(), change, rebasedCommit).setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#method_after
public PatchSet rebase(final Repository git, final RevWalk revWalk, final ObjectInserter inserter, final PatchSet.Id patchSetId, final Change change, final IdentifiedUser uploader, final RevCommit baseCommit, final MergeUtil mergeUtil, PersonIdent committerIdent, boolean sendMail, boolean runHooks) throws NoSuchChangeException, OrmException, IOException, InvalidChangeOperationException, PathConflictException {
    if (!change.currentPatchSetId().equals(patchSetId)) {
        throw new InvalidChangeOperationException("patch set is not current");
    }
    final PatchSet originalPatchSet = db.patchSets().get(patchSetId);
    final RevCommit rebasedCommit;
    ObjectId oldId = ObjectId.fromString(originalPatchSet.getRevision().get());
    ObjectId newId = rebaseCommit(git, inserter, revWalk.parseCommit(oldId), baseCommit, mergeUtil, committerIdent);
    rebasedCommit = revWalk.parseCommit(newId);
    final ChangeControl changeControl = changeControlFactory.validateFor(change.getId(), uploader);
    PatchSetInserter patchSetinserter = patchSetInserterFactory.create(git, revWalk, changeControl.getRefControl(), change, rebasedCommit).setCopyLabels(true).setDraft(originalPatchSet.isDraft()).setSendMail(sendMail).setRunHooks(runHooks);
    final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), uploader.getAccountId(), patchSetId);
    cmsg.setMessage("Patch Set " + change.currentPatchSetId().get() + ": Patch Set " + patchSetId.get() + " was rebased");
    Change newChange = patchSetinserter.setMessage(cmsg).insert();
    return db.patchSets().get(newChange.currentPatchSetId());
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = Objects.firstNonNull(input.submitType, SubmitType.MERGE_IF_NECESSARY);
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    args.maxObjectSizeLimit = input.maxObjectSizeLimit;
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#method_after
@Override
public Object apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ProjectCreationFailedException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        args.newParent = projectsCollection.get().parse(input.parent).getControl();
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = Objects.firstNonNull(input.submitType, SubmitType.MERGE_IF_NECESSARY);
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    try {
        args.maxObjectSizeLimit = ProjectConfig.validLong(input.maxObjectSizeLimit);
    } catch (ConfigInvalidException e) {
        throw new BadRequestException(e.getMessage());
    }
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
}
#method_after
public void copySettingsFrom(final Project update) {
    description = update.description;
    useContributorAgreements = update.useContributorAgreements;
    useSignedOffBy = update.useSignedOffBy;
    useContentMerge = update.useContentMerge;
    requireChangeID = update.requireChangeID;
    submitType = update.submitType;
    state = update.state;
    maxObjectSizeLimit = update.maxObjectSizeLimit;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, Project.InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, Project.InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, Project.InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, Project.InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    maxObjectSizeLimit = rc.getLong(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, 0);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, p.getMaxObjectSizeLimit());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), Project.InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), Project.InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveLabelSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
private void scheduleShow() {
    if (hideTimer != null) {
        hideTimer.cancel();
        hideTimer = null;
    }
    if (popup == null) {
        popup = createPopupPanel(account);
    }
    if ((popup.isShowing() && popup.isVisible()) || showTimer != null) {
        return;
    }
    showTimer = new Timer() {

        @Override
        public void run() {
            if (!popup.isShowing() || !popup.isVisible()) {
                popup.showRelativeTo(target);
            }
        }
    };
    showTimer.schedule(600);
}
#method_after
private void scheduleShow() {
    if (hideTimer != null) {
        hideTimer.cancel();
        hideTimer = null;
    }
    if ((popup != null && popup.isShowing() && popup.isVisible()) || showTimer != null) {
        return;
    }
    showTimer = new Timer() {

        @Override
        public void run() {
            if (popup == null) {
                popup = createPopupPanel(account);
            }
            if (!popup.isShowing() || !popup.isVisible()) {
                popup.showRelativeTo(target);
            }
        }
    };
    showTimer.schedule(600);
}
#end_block

#method_before
public PermissionRange getRange(String permission) {
    if (Permission.isLabel(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#method_after
public PermissionRange getRange(String permission) {
    if (GlobalCapability.hasRange(permission)) {
        return toRange(permission, access(permission));
    }
    return null;
}
#end_block

#method_before
private String comparePattern() {
    if (getRefPattern().startsWith(REGEX_PREFIX)) {
        return getRefPattern().substring(REGEX_PREFIX.length());
    }
    return getRefPattern();
}
#method_after
private String comparePattern() {
    if (getName().startsWith(REGEX_PREFIX)) {
        return getName().substring(REGEX_PREFIX.length());
    }
    return getName();
}
#end_block

#method_before
@Override
public String toString() {
    return "AccessSection[" + getRefPattern() + "]";
}
#method_after
@Override
public String toString() {
    return "AccessSection[" + getName() + "]";
}
#end_block

#method_before
private void initWildCardProject() throws IOException, ConfigInvalidException {
    Repository git;
    try {
        git = mgr.openRepository(DEFAULT_WILD_NAME);
    } catch (RepositoryNotFoundException notFound) {
        // inheritable permissions. For example '-- All Projects --'.
        try {
            git = mgr.createRepository(DEFAULT_WILD_NAME);
        } catch (RepositoryNotFoundException err) {
            final String name = DEFAULT_WILD_NAME.get();
            throw new IOException("Cannot create repository " + name, err);
        }
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), DEFAULT_WILD_NAME, git);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Rights inherited by all other projects");
        p.setUseContributorAgreements(false);
        AccessSection cap = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        cap.getPermission(GlobalCapability.QUERY_LIMIT, true).add(rule(config, registered, 0, 500));
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection meta = config.getAccessSection(GitRepositoryManager.REF_CONFIG, true);
        PermissionRule review = rule(config, registered);
        review.setRange(-1, 1);
        heads.getPermission(Permission.LABEL + "Code-Review", true).add(review);
        // 
        all.getPermission(Permission.READ, true).add(rule(config, admin));
        // 
        all.getPermission(Permission.READ, true).add(rule(config, anonymous));
        // 
        config.getAccessSection("refs/for/" + AccessSection.ALL, true).getPermission(Permission.PUSH, // 
        true).add(rule(config, registered));
        // 
        all.getPermission(Permission.FORGE_AUTHOR, true).add(rule(config, registered));
        // 
        meta.getPermission(Permission.READ, true).add(rule(config, owners));
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + DEFAULT_WILD_NAME.get());
        }
    } finally {
        git.close();
    }
}
#method_after
private void initWildCardProject() throws IOException, ConfigInvalidException {
    Repository git;
    try {
        git = mgr.openRepository(DEFAULT_WILD_NAME);
    } catch (RepositoryNotFoundException notFound) {
        // inheritable permissions. For example 'All-Projects'.
        try {
            git = mgr.createRepository(DEFAULT_WILD_NAME);
        } catch (RepositoryNotFoundException err) {
            final String name = DEFAULT_WILD_NAME.get();
            throw new IOException("Cannot create repository " + name, err);
        }
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), DEFAULT_WILD_NAME, git);
        md.getCommitBuilder().setAuthor(serverUser);
        md.getCommitBuilder().setCommitter(serverUser);
        ProjectConfig config = ProjectConfig.read(md);
        Project p = config.getProject();
        p.setDescription("Rights inherited by all other projects");
        p.setUseContributorAgreements(false);
        AccessSection capabilities = config.getAccessSection(AccessSection.GLOBAL_CAPABILITIES, true);
        PermissionRange.WithDefaults queryLimit = GlobalCapability.getRange(GlobalCapability.QUERY_LIMIT);
        capabilities.getPermission(GlobalCapability.QUERY_LIMIT, true).add(rule(config, anonymous, queryLimit.getDefaultMax(), queryLimit.getDefaultMax()));
        AccessSection all = config.getAccessSection(AccessSection.ALL, true);
        AccessSection heads = config.getAccessSection(AccessSection.HEADS, true);
        AccessSection meta = config.getAccessSection(GitRepositoryManager.REF_CONFIG, true);
        PermissionRule review = rule(config, registered);
        review.setRange(-1, 1);
        heads.getPermission(Permission.LABEL + "Code-Review", true).add(review);
        // 
        all.getPermission(Permission.READ, true).add(rule(config, admin));
        // 
        all.getPermission(Permission.READ, true).add(rule(config, anonymous));
        // 
        config.getAccessSection("refs/for/" + AccessSection.ALL, true).getPermission(Permission.PUSH, // 
        true).add(rule(config, registered));
        // 
        all.getPermission(Permission.FORGE_AUTHOR, true).add(rule(config, registered));
        // 
        meta.getPermission(Permission.READ, true).add(rule(config, owners));
        md.setMessage("Initialized Gerrit Code Review " + Version.getVersion());
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + DEFAULT_WILD_NAME.get());
        }
    } finally {
        git.close();
    }
}
#end_block

#method_before
public void remove(AccessSection section) {
    if (section != null) {
        accessSections.remove(section.getRefPattern());
    }
}
#method_after
public void remove(AccessSection section) {
    if (section != null) {
        accessSections.remove(section.getName());
    }
}
#end_block

#method_before
public void replace(AccessSection section) {
    for (Permission permission : section.getPermissions()) {
        for (PermissionRule rule : permission.getRules()) {
            rule.setGroup(resolve(rule.getGroup()));
        }
    }
    accessSections.put(section.getRefPattern(), section);
}
#method_after
public void replace(AccessSection section) {
    for (Permission permission : section.getPermissions()) {
        for (PermissionRule rule : permission.getRules()) {
            rule.setGroup(resolve(rule.getGroup()));
        }
    }
    accessSections.put(section.getName(), section);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(rc.getBoolean(RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(rc.getBoolean(RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(rc.getBoolean(RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(rc.getEnum(SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(rc.getBoolean(SUBMIT, null, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    prologRules = readUTF8("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (isAccessSection(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#end_block

#method_before
private void loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, Permission perm, boolean useRange) throws ConfigInvalidException {
    for (String ruleString : rc.getStringList(section, subsection, varName)) {
        PermissionRule rule;
        try {
            rule = PermissionRule.fromString(ruleString, useRange);
        } catch (IllegalArgumentException notRule) {
            throw new ConfigInvalidException("Invalid rule in " + section + (subsection != null ? "." + subsection : "") + "." + varName + ": " + notRule.getMessage(), notRule);
        }
        GroupReference ref = groupsByName.get(rule.getGroup().getName());
        if (ref == null) {
            // The group wasn't mentioned in the groups table, so there is
            // no valid UUID for it. Pool the reference anyway so at least
            // all rules in the same file share the same GroupReference.
            // 
            ref = rule.getGroup();
            groupsByName.put(ref.getName(), ref);
        }
        rule.setGroup(ref);
        perm.add(rule);
    }
}
#method_after
private void loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, Permission perm, boolean useRange) {
    for (String ruleString : rc.getStringList(section, subsection, varName)) {
        PermissionRule rule;
        try {
            rule = PermissionRule.fromString(ruleString, useRange);
        } catch (IllegalArgumentException notRule) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + section + (subsection != null ? "." + subsection : "") + "." + varName + ": " + notRule.getMessage()));
            continue;
        }
        GroupReference ref = groupsByName.get(rule.getGroup().getName());
        if (ref == null) {
            // The group wasn't mentioned in the groups table, so there is
            // no valid UUID for it. Pool the reference anyway so at least
            // all rules in the same file share the same GroupReference.
            // 
            ref = rule.getGroup();
            groupsByName.put(ref.getName(), ref);
            error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GROUP_LIST));
        }
        rule.setGroup(ref);
        perm.add(rule);
    }
}
#end_block

#method_before
private Map<String, GroupReference> readGroupList() throws IOException, ConfigInvalidException {
    groupsByUUID = new HashMap<AccountGroup.UUID, GroupReference>();
    Map<String, GroupReference> groupsByName = new HashMap<String, GroupReference>();
    BufferedReader br = new BufferedReader(new StringReader(readUTF8(GROUP_LIST)));
    String s;
    while ((s = br.readLine()) != null) {
        if (s.isEmpty() || s.startsWith("#")) {
            continue;
        }
        int tab = s.indexOf('\t');
        if (tab < 0) {
            throw new ConfigInvalidException("Invalid group line: " + s);
        }
        AccountGroup.UUID uuid = new AccountGroup.UUID(s.substring(0, tab).trim());
        String name = s.substring(tab + 1).trim();
        GroupReference ref = new GroupReference(uuid, name);
        groupsByUUID.put(uuid, ref);
        groupsByName.put(name, ref);
    }
    return groupsByName;
}
#method_after
private Map<String, GroupReference> readGroupList() throws IOException {
    groupsByUUID = new HashMap<AccountGroup.UUID, GroupReference>();
    Map<String, GroupReference> groupsByName = new HashMap<String, GroupReference>();
    BufferedReader br = new BufferedReader(new StringReader(readUTF8(GROUP_LIST)));
    String s;
    for (int lineNumber = 1; (s = br.readLine()) != null; lineNumber++) {
        if (s.isEmpty() || s.startsWith("#")) {
            continue;
        }
        int tab = s.indexOf('\t');
        if (tab < 0) {
            error(new ValidationError(GROUP_LIST, lineNumber, "missing tab delimiter"));
            continue;
        }
        AccountGroup.UUID uuid = new AccountGroup.UUID(s.substring(0, tab).trim());
        String name = s.substring(tab + 1).trim();
        GroupReference ref = new GroupReference(uuid, name);
        groupsByUUID.put(uuid, ref);
        groupsByName.put(name, ref);
    }
    return groupsByName;
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getRefPattern();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (isAccessSection(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(CapabilityControl.Factory.class).in(SINGLETON);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(ReviewDb.class).toProvider(RequestScopedReviewDbProvider.class).in(RequestScoped.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(MetaDataUpdate.User.class).in(RequestScoped.class);
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    bind(CapabilityControl.Factory.class).in(SINGLETON);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(ChangeQueryBuilder.Factory.class);
    factory(ReceiveCommits.Factory.class);
    factory(MergeOp.Factory.class);
    factory(CreateCodeReviewNotes.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(PublishComments.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(AbandonedSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
}
#end_block

#method_before
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#method_after
public void query(String queryString) throws IOException {
    out = new // 
    PrintWriter(new // 
    BufferedWriter(new OutputStreamWriter(outputStream, "UTF-8")));
    try {
        if (defaultLimit == 0) {
            ErrorMessage m = new ErrorMessage();
            m.message = "query disabled";
            show(m);
            return;
        }
        try {
            final QueryStats stats = new QueryStats();
            stats.runTimeMilliseconds = System.currentTimeMillis();
            final Predicate<ChangeData> visibleToMe = queryBuilder.is_visible();
            Predicate<ChangeData> s = compileQuery(queryString, visibleToMe);
            List<ChangeData> results = new ArrayList<ChangeData>();
            HashSet<Change.Id> want = new HashSet<Change.Id>();
            for (ChangeData d : ((ChangeDataSource) s).read()) {
                if (d.hasChange()) {
                    // 
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                } else {
                    want.add(d.getId());
                }
            }
            if (!want.isEmpty()) {
                for (Change c : db.get().changes().get(want)) {
                    ChangeData d = new ChangeData(c);
                    if (visibleToMe.match(d)) {
                        results.add(d);
                    }
                }
            }
            Collections.sort(results, new Comparator<ChangeData>() {

                @Override
                public int compare(ChangeData a, ChangeData b) {
                    return b.getChange().getSortKey().compareTo(a.getChange().getSortKey());
                }
            });
            int limit = limit(s);
            if (limit < results.size()) {
                results = results.subList(0, limit);
            }
            for (ChangeData d : results) {
                ChangeAttribute c = eventFactory.asChangeAttribute(d.getChange());
                eventFactory.extend(c, d.getChange());
                eventFactory.addTrackingIds(c, d.trackingIds(db));
                if (includePatchSets) {
                    eventFactory.addPatchSets(c, d.patches(db), includeApprovals ? d.approvalsMap(db) : null);
                }
                if (includeCurrentPatchSet) {
                    PatchSet current = d.currentPatchSet(db);
                    if (current != null) {
                        c.currentPatchSet = eventFactory.asPatchSetAttribute(current);
                        // 
                        eventFactory.addApprovals(// 
                        c.currentPatchSet, d.approvalsFor(db, current.getId()));
                    }
                }
                show(c);
            }
            stats.rowCount = results.size();
            stats.runTimeMilliseconds = System.currentTimeMillis() - stats.runTimeMilliseconds;
            show(stats);
        } catch (OrmException err) {
            log.error("Cannot execute query: " + queryString, err);
            ErrorMessage m = new ErrorMessage();
            m.message = "cannot query database";
            show(m);
        } catch (QueryParseException e) {
            ErrorMessage m = new ErrorMessage();
            m.message = e.getMessage();
            show(m);
        }
    } finally {
        try {
            out.flush();
        } finally {
            out = null;
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    for (final String projectMatch : projects) {
        String projectName = project.get();
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (isRE(projectMatch) || isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Eventhough they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#method_after
boolean isSingleProjectMatch() {
    boolean ret = (projects.length == 1);
    if (ret) {
        String projectMatch = projects[0];
        if (isRE(projectMatch) || isWildcard(projectMatch)) {
            // projectMatch is either regular expression, or wild-card.
            // 
            // Even though they might refer to a single project now, they need not
            // after new projects have been created. Hence, we do not treat them as
            // matching a single project.
            ret = false;
        }
    }
    return ret;
}
#end_block

#method_before
@Override
protected void onUnload() {
    super.onUnload();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
    mapper = null;
    initialBoxes = null;
    publishedMap = null;
    lineBoxMapA = null;
    lineBoxMapB = null;
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (resizeHandler != null) {
        resizeHandler.removeHandler();
        resizeHandler = null;
    }
    if (cmA != null) {
        cmA.getWrapperElement().removeFromParent();
        cmA = null;
    }
    if (cmB != null) {
        cmB.getWrapperElement().removeFromParent();
        cmB = null;
    }
    Window.enableScrolling(true);
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    render(diffInfo);
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    initialBoxes = new ArrayList<CommentBox>();
    publishedMap = new HashMap<String, PublishedBox>(published.length());
    lineBoxMapA = new HashMap<Integer, CommentBox>();
    lineBoxMapB = new HashMap<Integer, CommentBox>();
    renderPublished();
    renderDrafts();
    published = null;
    drafts = null;
    cmA.addKeyMap(KeyMap.create("'c'", insertNewDraft(cmA)));
    cmB.addKeyMap(KeyMap.create("'c'", insertNewDraft(cmB)));
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.getCmA());
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.getCmB());
    render(diffInfo);
    initialBoxes = new ArrayList<CommentBox>();
    publishedMap = new HashMap<String, PublishedBox>(published.length());
    lineBoxMapA = new HashMap<Integer, CommentBox>();
    lineBoxMapB = new HashMap<Integer, CommentBox>();
    renderPublished();
    renderDrafts();
    published = null;
    drafts = null;
    cmA.on("cursorActivity", updateActiveLine(cmA));
    cmB.on("cursorActivity", updateActiveLine(cmB));
    cmA.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmA)));
    cmB.addKeyMap(KeyMap.create().on("'c'", insertNewDraft(cmB)));
    // TODO: Probably need horizontal resize
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
    cmA.on("scroll", doScroll(cmB));
    cmB.on("scroll", doScroll(cmA));
}
#end_block

#method_before
public static KeyMap create(String key, Runnable thunk) {
    KeyMap map = createObject().cast();
    map.setHandler(key, thunk);
    return map;
}
#method_after
public static KeyMap create() {
    return createObject().cast();
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDateText(FormatUtil.shortFormatDayTime(result.updated()));
            setEdit(false);
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setMessageText(message);
            setDate(result.updated());
            setEdit(false);
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null || !(obj instanceof LineOnOtherInfo)) {
        return false;
    }
    LineOnOtherInfo other = (LineOnOtherInfo) obj;
    return (aligned == other.aligned && line == other.line);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (obj instanceof LineOnOtherInfo) {
        LineOnOtherInfo other = (LineOnOtherInfo) obj;
        return aligned == other.aligned && line == other.line;
    }
    return false;
}
#end_block

#method_before
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDateText(FormatUtil.shortFormatDayTime(result.updated()));
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#method_after
@UiHandler("save")
void onSave(ClickEvent e) {
    final String message = editArea.getText();
    if (message.equals("")) {
        return;
    }
    CommentInfo original = getOriginal();
    CommentInput input = CommentInput.create(original);
    input.setMessage(message);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            updateOriginal(result);
            setEdit(false);
            setMessageText(message);
            setDate(result.updated());
            resizePaddingWidget();
            if (isNew) {
                removeStyleName(draftStyle.newDraft());
                isNew = false;
            }
        }
    };
    if (isNew) {
        CommentApi.createDraft(getPatchSetId(), input, cb);
    } else {
        CommentApi.updateDraft(getPatchSetId(), original.id(), input, cb);
    }
}
#end_block

#method_before
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    input.setLine(original.line());
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#method_after
public static CommentInput create(CommentInfo original) {
    CommentInput input = createObject().cast();
    input.setId(original.id());
    input.setPath(original.path());
    input.setSide(original.side());
    if (original.has_line()) {
        input.setLine(original.line());
    }
    input.setInReplyTo(original.in_reply_to());
    input.setMessage(original.message());
    return input;
}
#end_block

#method_before
@Override
public void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#method_after
@Override
protected void onUnload() {
    super.onUnload();
    if (messageClick != null) {
        messageClick.removeHandler();
        messageClick = null;
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    headerClick = header.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            setOpen(!isOpen());
            if (clickCallback != null) {
                clickCallback.run();
            }
        }
    }, ClickEvent.getType());
    res.style().ensureInjected();
}
#end_block

#method_before
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(style.close());
        addStyleName(style.open());
    } else {
        removeStyleName(style.open());
        addStyleName(style.close());
    }
}
#method_after
private void setOpen(boolean open) {
    if (open) {
        removeStyleName(res.style().close());
        addStyleName(res.style().open());
    } else {
        removeStyleName(res.style().open());
        addStyleName(res.style().close());
    }
}
#end_block

#method_before
private boolean isOpen() {
    return getStyleName().contains(style.open());
}
#method_after
private boolean isOpen() {
    return getStyleName().contains(res.style().open());
}
#end_block

#method_before
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(id())));
}
#method_after
public final AccountGroup.UUID getGroupUUID() {
    return new AccountGroup.UUID(URL.decodeQueryString(id()));
}
#end_block

#method_before
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodePathSegment(URL.decodeQueryString(owner)));
    }
    return null;
}
#method_after
public final AccountGroup.UUID getOwnerUUID() {
    String owner = owner_id();
    if (owner != null) {
        return new AccountGroup.UUID(URL.decodeQueryString(owner));
    }
    return null;
}
#end_block

#method_before
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodePathSegment(URL.encodeQueryString(uuid.get())));
}
#method_after
public final void setOwnerUUID(AccountGroup.UUID uuid) {
    owner_id(URL.encodeQueryString(uuid.get()));
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    SolrInputDocument doc = toDocument(cd);
    try {
        if (cd.getChange().getStatus().isOpen()) {
            closedIndex.deleteById(id);
            openIndex.add(doc);
        } else {
            openIndex.deleteById(id);
            closedIndex.add(doc);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    String id = cd.getId().toString();
    try {
        if (cd.getChange().getStatus().isOpen()) {
            openIndex.deleteById(id);
            commit(openIndex);
        } else {
            closedIndex.deleteById(id);
            commit(closedIndex);
        }
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    commit(openIndex);
    commit(closedIndex);
}
#method_after
@Override
public void deleteAll() throws IOException {
    try {
        openIndex.deleteByQuery("*:*");
        closedIndex.deleteByQuery("*:*");
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
    commit(openIndex);
    commit(closedIndex);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SolrServer> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
#method_after
private void commit(SolrServer server) throws IOException {
    try {
        server.commit();
    } catch (SolrServerException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = null;
        SolrDocumentList docs = new SolrDocumentList();
        query.setParam("shards.tolerant", true);
        for (SolrServer index : indexes) {
            QueryResponse rsp = index.query(query);
            docs.addAll(rsp.getResults());
        }
        result = Lists.newArrayListWithCapacity(docs.size());
        for (SolrDocument doc : docs) {
            Integer v = (Integer) doc.getFieldValue(FIELD_CHANGE);
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (SolrServerException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
public static IndexImplementation getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String implementation = config.getString("index", null, "implementation");
        if ("solr".equals(implementation)) {
            return IndexImplementation.SOLR;
        } else {
            return IndexImplementation.LUCENE;
        }
    }
    return IndexImplementation.NONE;
}
#method_after
public static IndexType getChangeIndexImpl(Injector injector) {
    if (isEnabled(injector)) {
        Config config = injector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        return config.getEnum("index", null, "type", IndexType.LUCENE);
    }
    return IndexType.NONE;
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(Names.named("url")).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(SolrIndexVersionCheck.class);
    }
}
#method_after
@Override
protected void configure() {
    install(new IndexModule(threads));
    bind(String.class).annotatedWith(SolrIndexUrl.class).toInstance(url);
    bind(ChangeIndex.class).to(SolrChangeIndex.class);
    listener().to(SolrChangeIndex.class);
    if (checkVersion) {
        listener().to(IndexVersionCheck.class);
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    cfgInjector = createCfgInjector();
    sysInjector = createSysInjector();
    // Delete before any LuceneChangeIndex may be created.
    deleteAll();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(dbInjector), false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule(false, threads, dryRun);
            break;
        case SOLR:
            Config config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
            changeIndexModule = new SolrIndexModule(config, false, threads);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    modules.add(new ReviewDbModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    switch(IndexModule.getChangeIndexImpl(dbInjector)) {
        case LUCENE:
            LuceneIndexVersionCheck.writeVersion(sitePaths);
            break;
        case SOLR:
            SolrIndexVersionCheck.writeVersion(sitePaths);
            break;
        default:
            return;
    }
}
#method_after
private void writeVersion() throws IOException, ConfigInvalidException {
    if (dryRun) {
        return;
    }
    ChangeIndex index = sysInjector.getInstance(ChangeIndex.class);
    index.finishIndex();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = new SolrIndexModule(IndexModule.getSolrUrl(cfgInjector));
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    AbstractModule changeIndexModule;
    switch(IndexModule.getChangeIndexImpl(cfgInjector)) {
        case LUCENE:
            changeIndexModule = new LuceneIndexModule();
            break;
        case SOLR:
            changeIndexModule = cfgInjector.getInstance(SolrIndexModule.class);
            break;
        default:
            changeIndexModule = new NoIndexModule();
    }
    modules.add(changeIndexModule);
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, toQuery(p));
}
#method_after
@Override
public ChangeDataSource getSource(Predicate<ChangeData> p) throws QueryParseException {
    Set<Change.Status> statuses = IndexRewriteImpl.getPossibleStatus(p);
    List<SubIndex> indexes = Lists.newArrayListWithCapacity(2);
    if (!Sets.intersection(statuses, OPEN_STATUSES).isEmpty()) {
        indexes.add(openIndex);
    }
    if (!Sets.intersection(statuses, CLOSED_STATUSES).isEmpty()) {
        indexes.add(closedIndex);
    }
    return new QuerySource(indexes, QueryBuilder.toQuery(p));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return QueryBuilder.intTerm(FIELD_CHANGE, cd.getId().get());
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw QueryBuilder.badFieldType(f.getType());
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                    } catch (Exception e) {
                        log.warn("Failed to index change " + cd.getId(), e);
                        failed.update(1);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    List<ChangeData> cds = byId.get(bCommit);
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                Iterator<ChangeData> cdit = cds.iterator();
                for (ChangeData cd; cdit.hasNext(); cdit.remove()) {
                    cd = cdit.next();
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        fail("Failed to index change " + cd.getId(), true, e);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        fail("Failed to index commit " + bCommit.name(), false, e);
        for (ChangeData cd : cds) {
            fail("Failed to index change " + cd.getId(), true, null);
        }
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    try {
                        cd.setCurrentFilePaths(paths);
                        indexer.indexTask(cd).call();
                        done.update(1);
                        if (verbose) {
                            System.out.println("Reindexed change " + cd.getId());
                        }
                    } catch (Exception e) {
                        log.warn("Failed to index change " + cd.getId(), e);
                        if (verbose) {
                            System.out.println("Failed to index change " + cd.getId());
                        }
                        failed.update(1);
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        if (verbose) {
            System.out.println("Failed to index changes for commit " + bCommit.name());
        }
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                    if (verbose) {
                        System.out.println("Reindexed change " + cd.getId());
                    }
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        fail("Failed to index commit " + bCommit.name(), e);
    }
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        return object.commitMessage(repoManager, db).contains(value);
    } catch (IOException e) {
        return false;
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public boolean match(ChangeData object) throws OrmException {
    try {
        for (ChangeData cData : index.getSource(Predicate.and(new LegacyChangeIdPredicate(db, object.getId()), this)).read()) {
            if (cData.getId().equals(object.getId())) {
                return true;
            }
        }
    } catch (QueryParseException e) {
        throw new OrmException(e);
    }
    return false;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.insert(doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.insert(doc));
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    if (cd.getChange().getStatus().isOpen()) {
        return allOf(closedIndex.delete(id), openIndex.replace(id, doc));
    } else {
        return allOf(openIndex.delete(id), closedIndex.replace(id, doc));
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public ListenableFuture<Void> delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return Futures.immediateFuture(null);
    }
    return allOf(openIndex.delete(id), closedIndex.delete(id));
}
#end_block

#method_before
private Term idTerm(ChangeData cd) {
    return intTerm(FIELD_CHANGE, cd.getId().get());
}
#method_after
private Term idTerm(ChangeData cd) {
    return intTerm(ID_FIELD, cd.getId().get());
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else if (p.getType() == FieldType.PREFIX) {
        return prefixQuery(p);
    } else if (p.getType() == FieldType.FULL_TEXT) {
        return fullTextQuery(p);
    } else if (p instanceof SortKeyPredicate) {
        return sortKeyQuery((SortKeyPredicate) p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getOperator(), value));
}
#method_after
private Query intQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    int value;
    try {
        // Can't use IntPredicate because it and IndexPredicate are different
        // subclasses of OperatorPredicate.
        value = Integer.valueOf(p.getValue());
    } catch (IllegalArgumentException e) {
        throw new QueryParseException("not an integer: " + p.getValue());
    }
    return new TermQuery(intTerm(p.getField().getName(), value));
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getField().getName(), p.getValue()));
    }
}
#end_block

#method_before
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query fullTextQuery(IndexPredicate<ChangeData> p) {
    return new FuzzyQuery(new Term(p.getField().getName(), p.getValue()));
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc, FIELDS);
            Number v = doc.getField(ID_FIELD).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                Object val = f.get(cd, fillArgs);
                if (val != null) {
                    add(result, f, Collections.singleton(val));
                }
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.LONG) {
        for (Object value : values) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT || f.getType() == FieldType.PREFIX) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (f.getType() == FieldType.FULL_TEXT) {
        for (Object value : values) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        for (URIish uri : cfg.getURIs(project, urlMatch)) {
            cfg.schedule(project, PushOne.ALL_REFS, uri);
        }
    }
}
#method_after
void scheduleFullSync(final Project.NameKey project, final String urlMatch) {
    if (!running) {
        log.warn("Replication plugin did not finish startup before event");
        return;
    }
    for (Destination cfg : configs) {
        if (cfg.wouldPushProject(project)) {
            for (URIish uri : cfg.getURIs(project, urlMatch)) {
                cfg.schedule(project, PushOne.ALL_REFS, uri);
            }
        }
    }
}
#end_block

#method_before
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, internalUserFactory, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> allDestinations(File cfgPath) throws ConfigInvalidException, IOException {
    FileBasedConfig cfg = new FileBasedConfig(cfgPath, FS.DETECTED);
    if (!cfg.getFile().exists()) {
        log.warn("No " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    if (cfg.getFile().length() == 0) {
        log.info("Empty " + cfg.getFile() + "; not replicating");
        return Collections.emptyList();
    }
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    replicateAllOnPluginStart = cfg.getBoolean("gerrit", "replicateOnStartup", true);
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#method_after
@Override
public void onNewProjectCreated(NewProjectCreatedListener.Event event) {
    if (configs.isEmpty()) {
        return;
    }
    if (!running) {
        log.error("Replication plugin did not finish startup before event");
        return;
    }
    Project.NameKey projectName = new Project.NameKey(event.getProjectName());
    for (Destination config : configs) {
        if (!config.wouldPushProject(projectName)) {
            continue;
        }
        List<URIish> uriList = config.getURIs(projectName, "*");
        String[] adminUrls = config.getAdminUrls();
        boolean adminURLUsed = false;
        for (String url : adminUrls) {
            if (Strings.isNullOrEmpty(url)) {
                continue;
            }
            URIish uri;
            try {
                uri = new URIish(url);
            } catch (URISyntaxException e) {
                log.warn(String.format("adminURL '%s' is invalid: %s", url, e.getMessage()));
                continue;
            }
            String path = replaceName(uri.getPath(), projectName.get());
            if (path == null) {
                log.warn(String.format("adminURL %s does not contain ${name}", uri));
                continue;
            }
            uri = uri.setPath(path);
            if (!isSSH(uri)) {
                log.warn(String.format("adminURL '%s' is invalid: only SSH is supported", uri));
                continue;
            }
            createProject(uri, event.getHeadName());
            adminURLUsed = true;
        }
        if (!adminURLUsed) {
            for (URIish uri : uriList) {
                createProject(uri, event.getHeadName());
            }
        }
    }
}
#end_block

#method_before
boolean wouldPushProject(Project.NameKey project) {
    if (projectMatch != null) {
        if (projectMatch.endsWith("/*")) {
            // special case
            return project.get().startsWith(projectMatch.substring(0, projectMatch.length() - 1));
        } else {
            String projectPattern;
            if (isRE(projectMatch)) {
                projectPattern = projectMatch.substring(1);
            } else {
                projectPattern = projectMatch;
            }
            return (new RegExp(projectPattern)).toAutomaton().run(project.get());
        }
    }
    return true;
}
#method_after
boolean wouldPushProject(Project.NameKey project) {
    // by default push all projects
    if (projects.length < 1) {
        return true;
    }
    String projectName = project.get();
    for (final String projectMatch : projects) {
        if (isRE(projectMatch)) {
            // projectMatch is a regular expression
            if (projectName.matches(projectMatch)) {
                return true;
            }
        } else if (isWildcard(projectMatch)) {
            // projectMatch is a wildcard
            if (projectName.startsWith(projectMatch.substring(0, projectMatch.length() - 1))) {
                return true;
            }
        } else {
            // No special case, so we try to match directly
            if (projectName.equals(projectMatch)) {
                return true;
            }
        }
    }
    // Nothing matched, so don't push the project
    return false;
}
#end_block

#method_before
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#method_after
List<URIish> getURIs(Project.NameKey project, String urlMatch) {
    List<URIish> r = Lists.newArrayListWithCapacity(remote.getURIs().size());
    for (URIish uri : remote.getURIs()) {
        if (matches(uri, urlMatch)) {
            String name = project.get();
            if (needsUrlEncoding(uri)) {
                name = encode(name);
            }
            if (remoteNameStyle.equals("dash")) {
                name = name.replace("/", "-");
            } else if (remoteNameStyle.equals("underscore")) {
                name = name.replace("/", "_");
            } else if (!remoteNameStyle.equals("slash")) {
                ReplicationQueue.log.debug(String.format("Unknown remoteNameStyle: %s, falling back to slash", remoteNameStyle));
            }
            String replacedPath = ReplicationQueue.replaceName(uri.getPath(), name);
            if (replacedPath != null) {
                uri = uri.setPath(replacedPath);
                r.add(uri);
            }
        }
    }
    return r;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    ProjectCapabilities.all(getProjectKey(), new GerritCallback<ProjectCapabilities>() {

        @Override
        public void onSuccess(ProjectCapabilities result) {
            addPanel.setVisible(result.canPerform(ProjectCapabilities.CREATE_REF));
        }
    }, ProjectCapabilities.CREATE_REF);
    refreshBranches();
    savedPanel = BRANCH;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    AccessMap.get(getProjectKey(), new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            addPanel.setVisible(result.canAddRefs());
        }
    });
    refreshBranches();
    savedPanel = BRANCH;
}
#end_block

#method_before
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            enableForm();
        }
    });
}
#method_after
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            updateForm();
        }
    });
}
#end_block

#method_before
void insert(BranchInfo info) {
    Comparator<BranchInfo> c = new Comparator<BranchInfo>() {

        @Override
        public int compare(BranchInfo a, BranchInfo b) {
            return a.ref().compareTo(b.ref());
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        BranchInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // branch is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#method_after
void insert(BranchInfo info) {
    Comparator<BranchInfo> c = new Comparator<BranchInfo>() {

        @Override
        public int compare(BranchInfo a, BranchInfo b) {
            return a.ref().compareTo(b.ref());
        }
    };
    int insertPos = getInsertRow(c, info);
    if (insertPos >= 0) {
        table.insertRow(insertPos);
        applyDataRowStyle(insertPos);
        populate(insertPos, info);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    AccountApi.canCreateRefs("self", getProjectKey(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            addPanel.setVisible(true);
        }
    });
    refreshBranches();
    savedPanel = BRANCH;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    addPanel.setVisible(false);
    AccessMap.get(getProjectKey(), new GerritCallback<ProjectAccessInfo>() {

        @Override
        public void onSuccess(ProjectAccessInfo result) {
            addPanel.setVisible(result.canAddRefs());
        }
    });
    refreshBranches();
    savedPanel = BRANCH;
}
#end_block

#method_before
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            enableForm();
        }
    });
}
#method_after
private void refreshBranches() {
    ProjectApi.getBranches(getProjectKey(), new ScreenLoadCallback<JsArray<BranchInfo>>(this) {

        @Override
        public void preDisplay(final JsArray<BranchInfo> result) {
            display(Natives.asList(result));
            updateForm();
        }
    });
}
#end_block

#method_before
public static void deleteBranches(Project.NameKey projectName, Set<String> refs, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (String ref : refs) {
        new RestApi("/projects/").id(projectName.get()).view("branches").id(ref).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
}
#method_after
public static void deleteBranches(Project.NameKey projectName, Set<String> refs, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (String ref : refs) {
        new RestApi("/projects/").id(projectName.get()).view("branches").id(ref).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
    group.done();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args.dbProvider, currentUser);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, currentUser, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return new IsReviewedPredicate(args.dbProvider);
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(args.dbProvider, self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(args.dbProvider, self());
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return new RegexBranchPredicate(args.dbProvider, name);
    return new BranchPredicate(args.dbProvider, name);
}
#method_after
@Operator
public Predicate<ChangeData> branch(String name) {
    if (name.startsWith("^"))
        return ref("^" + branchToRef(name.substring(1)));
    return ref(branchToRef(name));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (!allowsFile) {
        throw error("operator not permitted here: file:" + file);
    }
    if (file.startsWith("^")) {
        return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (file.startsWith("^")) {
        if (allowFileRegex || args.index != ChangeIndex.DISABLED) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw error("secondary index must be enabled for file:" + file);
        }
    } else {
        if (args.index == ChangeIndex.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    String[] splitReviewer = name.split("~");
    name = splitReviewer[0];
    if (splitReviewer.length > 2) {
        throw new QueryParseException("more than one user specified");
    } else if (splitReviewer.length == 2) {
        accounts = parseAccount(splitReviewer[1]);
    }
    return new LabelPredicate(args.changeControlGenericFactory, args.userFactory, args.dbProvider, args.approvalTypes, name, accounts);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.dbProvider, name, accounts, group);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id)));
        }
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> watchedby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<IsWatchedByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        if (currentUser instanceof IdentifiedUser && id.equals(((IdentifiedUser) currentUser).getAccountId())) {
            p.add(new IsWatchedByPredicate(args, currentUser, false));
        } else {
            p.add(new IsWatchedByPredicate(args, args.userFactory.create(args.dbProvider, id), true));
        }
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#method_after
@Operator
public Predicate<ChangeData> visibleto(String who) throws QueryParseException, OrmException {
    if ("self".equals(who)) {
        return is_visible();
    }
    Set<Account.Id> m = args.accountResolver.findAll(who);
    if (!m.isEmpty()) {
        List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
        for (Account.Id id : m) {
            return visibleto(args.userFactory.create(args.dbProvider, id));
        }
        return Predicate.or(p);
    }
    // If its not an account, maybe its a group?
    // 
    Collection<GroupReference> suggestions = args.groupBackend.suggest(who, null);
    if (!suggestions.isEmpty()) {
        HashSet<AccountGroup.UUID> ids = new HashSet<AccountGroup.UUID>();
        for (GroupReference ref : suggestions) {
            ids.add(ref.getUUID());
        }
        return visibleto(new SingleGroupUser(args.capabilityControlFactory, ids));
    }
    throw error("No user or group matches \"" + who + "\".");
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case TAR:
        case ZIP:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    // Don't copy params.
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
            path = other.path;
        // Fallthrough.
        case REVISION:
        case ARCHIVE:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (type == Type.ARCHIVE) {
        extension = other.extension;
    }
    // Don't copy params.
    return this;
}
#end_block

#method_before
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = checkNotNull(revision);
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#method_after
public Builder setOldRevision(Revision revision) {
    switch(type) {
        case DIFF:
        case LOG:
            this.oldRevision = revision;
            return this;
        default:
            throw new IllegalStateException(String.format("cannot set old revision on %s view", type));
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case TAR:
        case ZIP:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case TAR:
            url.append(repositoryName).append("/+tar/").append(revision.getName());
            break;
        case ZIP:
            url.append(repositoryName).append("/+zip/").append(revision.getName());
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName()).append(Objects.firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url.toString();
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    String filename = getFilename(view, rev);
    setRawHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    GitilesView view = ViewFilter.getView(req);
    Revision rev = view.getRevision();
    Repository repo = ServletUtils.getRepository(req);
    // Check object type before starting the archive. If we just caught the
    // exception from cmd.call() below, we wouldn't know whether it was because
    // the input object is not a tree or something broke later.
    RevWalk walk = new RevWalk(repo);
    try {
        walk.parseTree(rev.getId());
    } catch (IncorrectObjectTypeException e) {
        res.sendError(SC_NOT_FOUND);
        return;
    } finally {
        walk.release();
    }
    Format format = FORMATS_BY_EXTENSION.get(view.getExtension());
    String filename = getFilename(view, rev, view.getExtension());
    setDownloadHeaders(req, res, filename, format.mimeType);
    res.setStatus(SC_OK);
    try {
        new ArchiveCommand(repo).setFormat(format.name()).setTree(rev.getId()).setOutputStream(res.getOutputStream()).call();
    } catch (GitAPIException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private String getFilename(GitilesView view, Revision rev) {
    return new StringBuilder().append(view.getRepositoryName().replace('/', '-')).append('-').append(rev.getName()).append(format.format.suffixes().iterator().next()).toString();
}
#method_after
private String getFilename(GitilesView view, Revision rev, String ext) {
    return new StringBuilder().append(Paths.basename(view.getRepositoryName())).append('-').append(rev.getName()).append(ext).toString();
}
#end_block

#method_before
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
}
#method_after
public void testPath() throws Exception {
    RevCommit master = repo.branch("refs/heads/master").commit().create();
    repo.branch("refs/heads/stable").commit().create();
    GitilesView view;
    view = getView("/repo/+show/master/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("", view.getPathPart());
    view = getView("/repo/+show/master/foo");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo", view.getPathPart());
    view = getView("/repo/+show/master/foo/bar");
    assertEquals(Type.PATH, view.getType());
    assertEquals(master, view.getRevision().getId());
    assertEquals("foo/bar", view.getPathPart());
    assertNull(getView("/repo/+show/stable..master/foo"));
}
#end_block

#method_before
static String trimLeadingSlash(String str) {
    checkArgument(str.startsWith("/"), "expected string starting with a slash: %s", str);
    return str.substring(1);
}
#method_after
static String trimLeadingSlash(String str) {
    return checkLeadingSlash(str).substring(1);
}
#end_block

#method_before
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    boolean emptyPath = (path.isEmpty() || path.equals("/"));
    // Non-path cases.
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    } else if (command.equals(CMD_REFS)) {
        return GitilesView.refs().setRepositoryName(repoName).setPathPart(path);
    } else if (command.equals(CMD_LOG) && emptyPath) {
        return GitilesView.log().setRepositoryName(repoName);
    } else if (command.equals(CMD_DESCRIBE) && !emptyPath) {
        return GitilesView.describe().setRepositoryName(repoName).setPathPart(path);
    } else if (command.isEmpty()) {
        return GitilesView.repositoryIndex().setRepositoryName(repoName);
    } else if (path.isEmpty()) {
        // Command that requires a path, but no path.
        return null;
    }
    path = trimLeadingSlash(path);
    RevisionParser revParser = new RevisionParser(ServletUtils.getRepository(req), accessFactory.forRequest(req), visibilityCache);
    RevisionParser.Result result = revParser.parse(path);
    if (result == null) {
        return null;
    }
    path = path.substring(result.getPathStart());
    command = getCommand(command, result, path);
    GitilesView.Builder view;
    if (CMD_LOG.equals(command)) {
        view = GitilesView.log().setPathPart(path);
    } else if (CMD_SHOW.equals(command)) {
        if (path.isEmpty()) {
            view = GitilesView.revision();
        } else {
            view = GitilesView.path().setPathPart(path);
        }
    } else if (CMD_DIFF.equals(command)) {
        view = GitilesView.diff().setPathPart(path);
    } else if (CMD_REFS.equals(command)) {
        view = GitilesView.repositoryIndex();
    } else if (command.equals(CMD_TAR)) {
        view = GitilesView.tar();
    } else if (command.equals(CMD_ZIP)) {
        view = GitilesView.zip();
    } else {
        // Bad command.
        return null;
    }
    if (result.getOldRevision() != null) {
        // May be NULL.
        view.setOldRevision(result.getOldRevision());
    }
    view.setRepositoryName(repoName).setRevision(result.getRevision());
    return view;
}
#method_after
private GitilesView.Builder parse(HttpServletRequest req) throws IOException {
    String repoName = trimLeadingSlash(getRegexGroup(req, 1));
    if (repoName.isEmpty()) {
        return GitilesView.hostIndex();
    }
    String command = getRegexGroup(req, 2);
    String path = getRegexGroup(req, 3);
    if (command.isEmpty()) {
        return parseNoCommand(req, repoName, path);
    } else if (command.equals(CMD_ARCHIVE)) {
        return parseArchiveCommand(req, repoName, path);
    } else if (command.equals(CMD_AUTO)) {
        return parseAutoCommand(req, repoName, path);
    } else if (command.equals(CMD_DESCRIBE)) {
        return parseDescribeCommand(req, repoName, path);
    } else if (command.equals(CMD_DIFF)) {
        return parseDiffCommand(req, repoName, path);
    } else if (command.equals(CMD_LOG)) {
        return parseLogCommand(req, repoName, path);
    } else if (command.equals(CMD_REFS)) {
        return parseRefsCommand(req, repoName, path);
    } else if (command.equals(CMD_SHOW)) {
        return parseShowCommand(req, repoName, path);
    } else {
        return null;
    }
}
#end_block

#method_before
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case TAR:
            return new ArchiveServlet(ArchiveServlet.Format.TGZ);
        case ZIP:
            return new ArchiveServlet(ArchiveServlet.Format.ZIP);
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#method_after
public synchronized BaseServlet getDefaultHandler(GitilesView.Type view) {
    checkNotInitialized();
    switch(view) {
        case HOST_INDEX:
            return new HostIndexServlet(renderer, urls, accessFactory);
        case REPOSITORY_INDEX:
            return new RepositoryIndexServlet(renderer, accessFactory, timeCache);
        case REFS:
            return new RefServlet(renderer, timeCache);
        case REVISION:
            return new RevisionServlet(renderer, linkifier());
        case PATH:
            return new PathServlet(renderer, urls);
        case DIFF:
            return new DiffServlet(renderer, linkifier());
        case LOG:
            return new LogServlet(renderer, linkifier());
        case DESCRIBE:
            return new DescribeServlet();
        case ARCHIVE:
            return new ArchiveServlet();
        default:
            throw new IllegalArgumentException("Invalid view type: " + view);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final ReviewDb db = schemaFactory.open();
        try {
            context.setContext(new RequestContext() {

                @Override
                public Provider<ReviewDb> getReviewDbProvider() {
                    return Providers.of(db);
                }

                @Override
                public CurrentUser getCurrentUser() {
                    throw new OutOfScopeException("No user during ChangeIndexer");
                }
            });
            index.replace(cd);
            return null;
        } finally {
            context.setContext(null);
            db.close();
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d in %s", cd.getId().get(), cd.getChange().getProject().get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    if (!IndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sitePaths = dbInjector.getInstance(SitePaths.class);
    // Delete before any index may be created depending on this data.
    deleteAll();
    sysInjector = createSysInjector();
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    int result = indexAll();
    writeVersion();
    sysManager.stop();
    dbManager.stop();
    return result;
}
#end_block

#method_before
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects;
    try {
        projects = Sets.newTreeSet();
        for (Change change : db.changes().all()) {
            int n = projects.size();
            projects.add(change.getProject());
            int d = projects.size() - n;
            if (d > 0) {
                pm.update(d);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final CountDownLatch latch = new CountDownLatch(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                    latch.countDown();
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(sysInjector.getInstance(WorkQueue.class).getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            mpm.end();
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#method_after
private int indexAll() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    ListeningScheduledExecutorService executor = sysInjector.getInstance(Key.get(ListeningScheduledExecutorService.class, IndexExecutor.class));
    ProgressMonitor pm = new TextProgressMonitor(new PrintWriter(System.out));
    pm.start(1);
    pm.beginTask("Collecting projects", ProgressMonitor.UNKNOWN);
    Set<Project.NameKey> projects = Sets.newTreeSet();
    try {
        for (Change change : db.changes().all()) {
            if (projects.add(change.getProject())) {
                pm.update(1);
            }
        }
    } finally {
        db.close();
    }
    pm.endTask();
    final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, "Reindexing changes");
    final Task projTask = mpm.beginSubTask("projects", projects.size());
    final Task doneTask = mpm.beginSubTask(null, MultiProgressMonitor.UNKNOWN);
    final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
    Stopwatch sw = new Stopwatch().start();
    final List<ListenableFuture<?>> futures = Lists.newArrayListWithCapacity(projects.size());
    final AtomicBoolean ok = new AtomicBoolean(true);
    for (final Project.NameKey project : projects) {
        final ListenableFuture<?> future = executor.submit(new ReindexProject(project, doneTask, failedTask));
        futures.add(future);
        future.addListener(new Runnable() {

            @Override
            public void run() {
                try {
                    future.get();
                } catch (InterruptedException e) {
                    fail(project, e);
                } catch (ExecutionException e) {
                    // Logged by indexer.
                    ok.set(false);
                } catch (RuntimeException e) {
                    failAndThrow(project, e);
                } catch (Error e) {
                    failAndThrow(project, e);
                } finally {
                    projTask.update(1);
                }
            }

            private void fail(Project.NameKey project, Throwable t) {
                log.error("Failed to index project " + project, t);
                ok.set(false);
            }

            private void failAndThrow(Project.NameKey project, RuntimeException e) {
                fail(project, e);
                throw e;
            }

            private void failAndThrow(Project.NameKey project, Error e) {
                fail(project, e);
                throw e;
            }
        }, MoreExecutors.sameThreadExecutor());
    }
    mpm.waitFor(Futures.transform(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

        @Override
        public ListenableFuture<Void> apply(List<?> input) throws Exception {
            mpm.end();
            return Futures.immediateFuture(null);
        }
    }));
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    int n = doneTask.getCount() + failedTask.getCount();
    System.out.format("Reindexed %d changes in %.01fs (%.01f/s)\n", n, elapsed, n / elapsed);
    return ok.get() ? 0 : 1;
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().all()) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#method_after
@Override
public Void call() throws Exception {
    ReviewDb db = sysInjector.getInstance(ReviewDb.class);
    GitRepositoryManager mgr = sysInjector.getInstance(GitRepositoryManager.class);
    repo = mgr.openRepository(project);
    try {
        Map<String, Ref> refs = repo.getAllRefs();
        for (Change c : db.changes().byProject(project)) {
            Ref r = refs.get(c.currentPatchSetId().toRefName());
            if (r != null) {
                byId.put(r.getObjectId(), new ChangeData(c));
            }
        }
        walk();
    } finally {
        repo.close();
        // Only used once per Reindex call.
        RepositoryCache.close(repo);
    }
    return null;
}
#end_block

#method_before
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (!(o instanceof RevCommit)) {
                continue;
            }
            walk.markStart((RevCommit) o);
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null) {
            if (!byId.containsKey(bCommit)) {
                // Not a change, skip diff.
                continue;
            }
            getPathsAndIndex(bCommit, true);
            if (byId.isEmpty()) {
                break;
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id), false);
        }
    } finally {
        walk.release();
    }
}
#method_after
private void walk() throws Exception {
    walk = new RevWalk(repo);
    try {
        // to mark every single change.
        for (Ref ref : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            RevObject o = walk.parseAny(ref.getObjectId());
            if (o instanceof RevCommit) {
                walk.markStart((RevCommit) o);
            }
        }
        RevCommit bCommit;
        while ((bCommit = walk.next()) != null && !byId.isEmpty()) {
            if (byId.containsKey(bCommit)) {
                getPathsAndIndex(bCommit);
                byId.removeAll(bCommit);
            }
        }
        for (ObjectId id : byId.keySet()) {
            getPathsAndIndex(walk.parseCommit(id));
        }
    } finally {
        walk.release();
    }
}
#end_block

#method_before
private void getPathsAndIndex(RevCommit bCommit, boolean remove) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = remove ? byId.removeAll(bCommit) : byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#method_after
private void getPathsAndIndex(RevCommit bCommit) throws Exception {
    RevTree bTree = bCommit.getTree();
    try {
        RevTree aTree = aFor(bCommit, walk);
        if (aTree == null) {
            return;
        }
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE);
        try {
            df.setRepository(repo);
            List<ChangeData> cds = byId.get(bCommit);
            if (!cds.isEmpty()) {
                List<String> paths = getPaths(df.scan(aTree, bTree));
                for (ChangeData cd : cds) {
                    cd.setCurrentFilePaths(paths);
                    indexer.indexTask(cd).call();
                    done.update(1);
                }
            }
        } finally {
            df.release();
        }
    } catch (Exception e) {
        log.warn("Failed to index changes for commit " + bCommit.name(), e);
        failed.update(1);
    }
}
#end_block

#method_before
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        Project.NameKey projectName = new Project.NameKey(p);
        ProjectControl pc = open(projectName);
        ProjectConfig config;
        try {
            // Load the current configuration from the repository, ensuring its the most
            // recent version available. If it differs from what was in the project
            // state, force a cache flush now.
            // 
            MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
            try {
                config = ProjectConfig.read(md);
                if (config.updateGroupNames(groupBackend)) {
                    md.setMessage("Update group names\n");
                    config.commit(md);
                    projectCache.evict(config.getProject());
                    pc = open(projectName);
                } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
                    projectCache.evict(config.getProject());
                    pc = open(projectName);
                }
            } catch (ConfigInvalidException e) {
                throw new ResourceConflictException(e.getMessage());
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException e) {
            throw new ResourceNotFoundException(p);
        }
        access.put(p, new ProjectAccessInfo(pc, config));
    }
    return access;
}
#method_after
@Override
public Map<String, ProjectAccessInfo> apply(TopLevelResource resource) throws ResourceNotFoundException, ResourceConflictException, IOException {
    Map<String, ProjectAccessInfo> access = Maps.newTreeMap();
    for (String p : projects) {
        Project.NameKey projectName = new Project.NameKey(p);
        ProjectControl pc = open(projectName);
        ProjectConfig config;
        try {
            // Load the current configuration from the repository, ensuring it's the most
            // recent version available. If it differs from what was in the project
            // state, force a cache flush now.
            // 
            MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
            try {
                config = ProjectConfig.read(md);
                if (config.updateGroupNames(groupBackend)) {
                    md.setMessage("Update group names\n");
                    config.commit(md);
                    projectCache.evict(config.getProject());
                    pc = open(projectName);
                } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
                    projectCache.evict(config.getProject());
                    pc = open(projectName);
                }
            } catch (ConfigInvalidException e) {
                throw new ResourceConflictException(e.getMessage());
            } finally {
                md.close();
            }
        } catch (RepositoryNotFoundException e) {
            throw new ResourceNotFoundException(p);
        }
        access.put(p, new ProjectAccessInfo(pc, config));
    }
    return access;
}
#end_block

#method_before
private Query exactQuery(IndexPredicate<ChangeData> p) {
    return new TermQuery(new Term(p.getOperator(), p.getValue()));
}
#method_after
private Query exactQuery(IndexPredicate<ChangeData> p) {
    if (p instanceof RegexPredicate<?>) {
        return regexQuery(p);
    } else {
        return new TermQuery(new Term(p.getOperator(), p.getValue()));
    }
}
#end_block

#method_before
public static Timestamp timeFromSortKey(String sortKey) {
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#method_after
public static Timestamp timeFromSortKey(String sortKey) {
    if ("z".equals(sortKey)) {
        return new Timestamp(Long.MAX_VALUE);
    }
    String ts = sortKey.substring(0, 8);
    int i = 0;
    while (i < 8 && ts.charAt(i) == '0') i++;
    long v = Long.parseLong(ts.substring(i), 16) * 60;
    return new Timestamp((v + SORT_KEY_EPOCH) * 1000);
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
    refreshThread.start();
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#end_block

#method_before
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#method_after
private Query toQuery(Predicate<ChangeData> p) throws QueryParseException {
    if (p.getClass() == AndPredicate.class) {
        return booleanQuery(p, MUST);
    } else if (p.getClass() == OrPredicate.class) {
        return booleanQuery(p, SHOULD);
    } else if (p.getClass() == NotPredicate.class) {
        if (p.getChild(0) instanceof TimestampRangePredicate) {
            return notTimestampQuery((TimestampRangePredicate<ChangeData>) p.getChild(0));
        }
        return booleanQuery(p, MUST_NOT);
    } else if (p instanceof IndexPredicate) {
        return fieldQuery((IndexPredicate<ChangeData>) p);
    } else {
        throw new QueryParseException("Cannot convert to index predicate: " + p);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p instanceof AgePredicate) {
        int t = ChangeField.toIndexTime(((AgePredicate) p).getCutTimestamp());
        return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
    } else if (p instanceof SortKeyPredicate) {
        int t = ChangeField.toIndexTime(((SortKeyPredicate) p).getCutTimestamp());
        if (p instanceof SortKeyPredicate.Before) {
            return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
        } else {
            return NumericRangeQuery.newIntRange(p.getField().getName(), t, Integer.MAX_VALUE, true, true);
        }
    } else if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.TIMESTAMP) {
        return timestampQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(f.getName(), (Integer) value, store(f)));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(f.getName(), (String) value, store(f)));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#method_after
private void add(Document doc, FieldDef<ChangeData, ?> f, Iterable<?> values) throws OrmException {
    String name = f.getName();
    Store store = store(f);
    if (f.getType() == FieldType.INTEGER) {
        for (Object value : values) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (f.getType() == FieldType.TIMESTAMP) {
        for (Object v : values) {
            doc.add(new IntField(name, toIndexTime((Timestamp) v), store));
        }
    } else if (f.getType() == FieldType.EXACT) {
        for (Object value : values) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else {
        throw badFieldType(f.getType());
    }
}
#end_block

#method_before
long getCut() {
    return cut;
}
#method_after
long getCut() {
    return cut + 1;
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() < cut;
}
#method_after
@Override
public boolean match(final ChangeData object) throws OrmException {
    Change change = object.change(dbProvider);
    return change != null && change.getLastUpdatedOn().getTime() <= cut;
}
#end_block

#method_before
@Override
public void start() {
// Do nothing.
}
#method_after
@Override
public void start() {
    refreshThread.start();
}
#end_block

#method_before
@Override
public void stop() {
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    List<Future<?>> closeFutures = Lists.newArrayListWithCapacity(2);
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            openIndex.close();
        }
    }));
    closeFutures.add(executor.submit(new Runnable() {

        @Override
        public void run() {
            closedIndex.close();
        }
    }));
    for (Future<?> future : closeFutures) {
        Futures.getUnchecked(future);
    }
}
#end_block

#method_before
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#method_after
@Override
public void insert(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.insert(doc);
    } else {
        openIndex.delete(id);
        closedIndex.insert(doc);
    }
}
#end_block

#method_before
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    Document doc = toDocument(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        closedIndex.delete(id);
        openIndex.replace(id, doc);
    } else {
        openIndex.delete(id);
        closedIndex.replace(id, doc);
    }
}
#end_block

#method_before
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#method_after
@Override
public void delete(ChangeData cd) throws IOException {
    Term id = idTerm(cd);
    if (readOnly) {
        return;
    }
    if (cd.getChange().getStatus().isOpen()) {
        openIndex.delete(id);
    } else {
        closedIndex.delete(id);
    }
}
#end_block

#method_before
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p instanceof AgePredicate) {
        int t = ChangeField.toIndexTime(((AgePredicate) p).getCutTimestamp());
        return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
    } else if (p instanceof SortKeyPredicate) {
        int t = ChangeField.toIndexTime(((SortKeyPredicate) p).getCutTimestamp());
        if (p instanceof SortKeyPredicate.Before) {
            return NumericRangeQuery.newIntRange(p.getField().getName(), 0, t, true, true);
        } else {
            return NumericRangeQuery.newIntRange(p.getField().getName(), t, Integer.MAX_VALUE, true, true);
        }
    } else if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#method_after
private Query fieldQuery(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    Sort sort = new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.INT, true));
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT, sort);
        }
        TopDocs docs = TopDocs.merge(sort, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
public <T> Callback<T> addFinal(final AsyncCallback<T> cb) {
    checkFinalAdded();
    done();
    return handleAdd(cb);
}
#method_after
public <T> Callback<T> addFinal(final AsyncCallback<T> cb) {
    checkFinalAdded();
    finalAdded = true;
    return handleAdd(cb);
}
#end_block

#method_before
public void done() {
    finalAdded = true;
}
#method_after
public void done() {
    finalAdded = true;
    applyAllSuccess();
}
#end_block

#method_before
@Override
public void onSuccess(T value) {
    if (!failed) {
        this.result = value;
        remaining.remove(this);
        if (finalAdded && remaining.isEmpty()) {
            CallbackGroup.this.onSuccess();
        }
    }
}
#method_after
@Override
public void onSuccess(T value) {
    if (failed) {
        return;
    }
    this.result = value;
    remaining.remove(this);
    CallbackGroup.this.applyAllSuccess();
}
#end_block

#method_before
@Override
public void onFailure(Throwable caught) {
    if (!failed) {
        CallbackGroup.this.onFailure(caught);
    }
}
#method_after
@Override
public void onFailure(Throwable caught) {
    if (failed) {
        return;
    }
    failed = true;
    failedThrowable = caught;
    for (CallbackImpl<?> cb : callbacks) {
        cb.delegate.onFailure(failedThrowable);
        cb.delegate = null;
        cb.result = null;
    }
    callbacks.clear();
    remaining.clear();
}
#end_block

#method_before
static void initLibrary(AsyncCallback<Void> cb) {
    if (isLibLoaded()) {
        cb.onSuccess(null);
    } else {
        CallbackGroup group = new CallbackGroup();
        injectCss(Lib.I.css());
        injectScript(Lib.I.js().getSafeUri(), group.add(new AsyncCallback<Void>() {

            public void onFailure(Throwable caught) {
            }

            public void onSuccess(Void result) {
            }
        }));
        injectScript(Addons.I.mark_selection().getSafeUri(), group.addFinal(cb));
    }
}
#method_after
static void initLibrary(AsyncCallback<Void> cb) {
    if (isLibLoaded()) {
        cb.onSuccess(null);
    } else {
        CallbackGroup group = new CallbackGroup();
        injectCss(Lib.I.css());
        injectScript(Lib.I.js().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.mark_selection().getSafeUri(), group.add(CallbackGroup.<Void>emptyCallback()));
        injectScript(Addons.I.foldcode().getSafeUri(), group.addFinal(cb));
    }
}
#end_block

#method_before
@Override
public void stop() {
    refreshThread.stop = true;
    try {
        refreshThread.join();
    } catch (InterruptedException e) {
        log.warn("error stopping refresh thread", e);
    }
    openIndex.close();
    closedIndex.close();
}
#method_after
@Override
public void stop() {
    refreshThread.halt();
    openIndex.close();
    closedIndex.close();
}
#end_block

#method_before
@Override
public ResultSet<ChangeData> read() throws OrmException {
    try {
        List<ChangeData> result = Lists.newArrayListWithExpectedSize(2 * getCardinality());
        for (SubIndex index : indexes) {
            result.addAll(index.search(query, LIMIT));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    }
}
#method_after
@Override
public ResultSet<ChangeData> read() throws OrmException {
    IndexSearcher[] searchers = new IndexSearcher[indexes.size()];
    try {
        TopDocs[] hits = new TopDocs[indexes.size()];
        for (int i = 0; i < indexes.size(); i++) {
            searchers[i] = indexes.get(i).acquire();
            hits[i] = searchers[i].search(query, LIMIT);
        }
        TopDocs docs = TopDocs.merge(null, LIMIT, hits);
        List<ChangeData> result = Lists.newArrayListWithCapacity(docs.scoreDocs.length);
        for (ScoreDoc sd : docs.scoreDocs) {
            Document doc = searchers[sd.shardIndex].doc(sd.doc);
            Number v = doc.getField(FIELD_CHANGE).numericValue();
            result.add(new ChangeData(new Change.Id(v.intValue())));
        }
        final List<ChangeData> r = Collections.unmodifiableList(result);
        return new ResultSet<ChangeData>() {

            @Override
            public Iterator<ChangeData> iterator() {
                return r.iterator();
            }

            @Override
            public List<ChangeData> toList() {
                return r;
            }

            @Override
            public void close() {
            // Do nothing.
            }
        };
    } catch (IOException e) {
        throw new OrmException(e);
    } finally {
        for (int i = 0; i < indexes.size(); i++) {
            if (searchers[i] != null) {
                try {
                    indexes.get(i).release(searchers[i]);
                } catch (IOException e) {
                    log.warn("cannot release Lucene searcher", e);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        if (stop) {
            break;
        }
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            log.warn("error refreshing index searchers", e);
        }
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
    }
}
#method_after
@Override
public void run() {
    while (!stop) {
        openIndex.maybeRefresh();
        closedIndex.maybeRefresh();
        synchronized (this) {
            try {
                wait(100);
            } catch (InterruptedException e) {
                log.warn("error refreshing index searchers", e);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.Id groupId : groups) {
        GroupResource resource = toResource(groupId);
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.apply(resource, fromMembers(accountsToRemove));
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.apply(resource, fromGroups(groupsToRemove));
        }
        if (!accountsToAdd.isEmpty()) {
            reportMembersAdded(resource.getName(), addMembers.apply(resource, fromMembers(accountsToAdd)));
        }
        if (!groupsToInclude.isEmpty()) {
            reportGroupsAdded(resource.getName(), addIncludedGroups.apply(resource, fromGroups(groupsToInclude)));
        }
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure, Failure, Exception {
    for (AccountGroup.UUID groupUuid : groups) {
        GroupResource resource = groupsCollection.parse(TopLevelResource.INSTANCE, IdString.fromUrl(groupUuid.get()));
        if (!accountsToRemove.isEmpty()) {
            deleteMembers.get().apply(resource, fromMembers(accountsToRemove));
            reportMembersAction("removed from", resource, accountsToRemove);
        }
        if (!groupsToRemove.isEmpty()) {
            deleteIncludedGroups.get().apply(resource, fromGroups(groupsToRemove));
            reportGroupsAction("excluded from", resource, groupsToRemove);
        }
        if (!accountsToAdd.isEmpty()) {
            addMembers.get().apply(resource, fromMembers(accountsToAdd));
            reportMembersAction("added to", resource, accountsToAdd);
        }
        if (!groupsToInclude.isEmpty()) {
            addIncludedGroups.get().apply(resource, fromGroups(groupsToInclude));
            reportGroupsAction("included to", resource, groupsToInclude);
        }
    }
}
#end_block

#method_before
private AddIncludedGroups.Input fromGroups(List<AccountGroup.Id> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.Id, String>() {

        @Override
        public String apply(AccountGroup.Id id) {
            return id.toString();
        }
    })));
}
#method_after
private AddIncludedGroups.Input fromGroups(List<AccountGroup.UUID> accounts) {
    return AddIncludedGroups.Input.fromGroups(Lists.newArrayList(Iterables.transform(accounts, new Function<AccountGroup.UUID, String>() {

        @Override
        public String apply(AccountGroup.UUID uuid) {
            return uuid.toString();
        }
    })));
}
#end_block

#method_before
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        RowItem i = getRowItem(middle);
        int cmp = comparator.compare(i, item);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return -1;
        }
    }
    return left;
}
#method_after
protected int getInsertRow(Comparator<RowItem> comparator, RowItem item) {
    int row = lookupRowItem(comparator, item);
    if (row >= table.getRowCount() || comparator.compare(item, getRowItem(row)) != 0) {
        return row;
    }
    return -1;
}
#end_block

#method_before
@Override
public Address from(final Account.Id fromId) {
    if (fromId != null) {
        final Account a = accountCache.get(fromId).getAccount();
        final String userEmail = a.getPreferredEmail();
        return new Address(a.getFullName(), userEmail ? userEmail : srvAddr.getEmail());
    }
    return srvAddr;
}
#method_after
@Override
public Address from(final Account.Id fromId) {
    if (fromId != null) {
        Account a = accountCache.get(fromId).getAccount();
        String userEmail = a.getPreferredEmail();
        return new Address(a.getFullName(), userEmail != null ? userEmail : srvAddr.getEmail());
    }
    return srvAddr;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new BecomeAnyAccountModule());
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    install(new CmdLineParserModule());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null);
    saveCookie();
}
#method_after
@Override
public void login(final AuthResult res, final boolean rememberMe) {
    final Account.Id id = res.getAccountId();
    final AccountExternalId.Key identity = res.getExternalId();
    if (val != null) {
        manager.destroy(key);
    }
    key = manager.createKey(id);
    val = manager.createVal(key, id, rememberMe, identity, null, null);
    saveCookie();
}
#end_block

#method_before
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null);
    user = null;
}
#method_after
@Override
public void setUserAccountId(Account.Id id) {
    key = new Key("id:" + id);
    val = new Val(id, 0, false, null, 0, null, null);
    user = null;
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    try {
        int status = SC_OK;
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        Multimap<String, String> params = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        Object result;
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        handleException(e, req, res);
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req, rsrc);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, r);
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (UnprocessableEntityException e) {
        replyError(res, status = 422, Objects.firstNonNull(e.getMessage(), "Unprocessable Entity"));
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (MalformedJsonException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            json.setLenient(true);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if (("PUT".equals(req.getMethod()) || "POST".equals(req.getMethod())) && acceptsRawInput(type)) {
        return parseRawInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, asBinaryResult(buf).setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder();
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, Splitter.on(',').omitEmptyStrings().trimResults().split(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = NAMING.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#method_after
private static void enablePartialGetFields(GsonBuilder gb, Multimap<String, String> config) {
    final Set<String> want = Sets.newHashSet();
    for (String p : config.get("fields")) {
        Iterables.addAll(want, OptionUtil.splitOptionValue(p));
    }
    if (!want.isEmpty()) {
        gb.addSerializationExclusionStrategy(new ExclusionStrategy() {

            private final Map<String, String> names = Maps.newHashMap();

            @Override
            public boolean shouldSkipField(FieldAttributes field) {
                String name = names.get(field.getName());
                if (name == null) {
                    // Translate and cache the JSON lower_case_style used.
                    try {
                        name = // 
                        FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES.translateName(field.getDeclaringClass().getDeclaredField(field.getName()));
                        names.put(field.getName(), name);
                    } catch (SecurityException e) {
                        return true;
                    } catch (NoSuchFieldException e) {
                        return true;
                    }
                }
                return !want.contains(name);
            }

            @Override
            public boolean shouldSkipClass(Class<?> clazz) {
                return false;
            }
        });
    }
}
#end_block

#method_before
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    final BinaryResult appResult = bin;
    try {
        if (bin.isBase64()) {
            bin = stackBase64(res, bin);
        }
        if (bin.canGzip() && acceptsGzip(req)) {
            bin = stackGzip(res, bin);
        }
        res.setContentType(bin.getContentType());
        long len = bin.getContentLength();
        if (0 <= len && len < Integer.MAX_VALUE) {
            res.setContentLength((int) len);
        } else if (0 <= len) {
            res.setHeader("Content-Length", Long.toString(len));
        }
        OutputStream dst = res.getOutputStream();
        try {
            bin.writeTo(dst);
        } finally {
            dst.close();
        }
    } finally {
        appResult.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#method_after
private void checkUserSession(HttpServletRequest req) throws AuthException {
    CurrentUser user = globals.currentUser.get();
    if (isStateChange(req)) {
        if (user instanceof AnonymousUser) {
            throw new AuthException("Authentication required");
        } else if (!globals.webSession.get().isAccessPathOk(AccessPath.REST_API)) {
            throw new AuthException("Invalid authentication method. In order to authenticate, prefix the REST endpoint URL with /a/ (e.g. http://example.com/a/projects/).");
        }
    }
    user.setAccessPath(AccessPath.REST_API);
}
#end_block

#method_before
static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    replyText(null, res, msg);
}
#method_after
public static void replyError(HttpServletResponse res, int statusCode, String msg) throws IOException {
    res.setStatus(statusCode);
    CacheHeaders.setNotCacheable(res);
    replyText(null, res, msg);
}
#end_block

#method_before
public static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static TemporaryBuffer.Heap compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.finish();
    gz.flush();
    return buf;
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser user = session.get().getCurrentUser();
        if (!user.getCapabilities().canAdministrateServer()) {
            error(req, res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            error(req, res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            error(req, res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    String runas = req.getHeader(RUN_AS);
    if (runas != null) {
        CurrentUser self = session.get().getCurrentUser();
        if (!self.getCapabilities().canRunAs()) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "not permitted to use " + RUN_AS);
            return;
        }
        Account target;
        try {
            target = accountResolver.find(runas);
        } catch (OrmException e) {
            log.warn("cannot resolve account for " + RUN_AS, e);
            RestApiServlet.replyError((HttpServletResponse) res, SC_INTERNAL_SERVER_ERROR, "cannot resolve " + RUN_AS);
            return;
        }
        if (target == null) {
            RestApiServlet.replyError((HttpServletResponse) res, SC_FORBIDDEN, "no account matches " + RUN_AS);
            return;
        }
        session.get().setUserAccountId(target.getId());
    }
    chain.doFilter(req, res);
}
#end_block

#method_before
public static RestApi capabilities() {
    return new RestApi("/config/server/capabilities/");
}
#method_after
public static void capabilities(AsyncCallback<NativeMap<CapabilityInfo>> cb) {
    new RestApi("/config/server/capabilities/").get(cb);
}
#end_block

#method_before
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        /*
      for (String varName : Util.C.capabilityNames().keySet()) {
        addPermission(varName, perms);
      }
      */
        for (String varName : projectAccess.getCapabilities().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (LabelType t : projectAccess.getLabelTypes().getLabelTypes()) {
            addPermission(Permission.LABEL + t.getName(), perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#method_after
private void rebuildPermissionSelector() {
    List<String> perms = new ArrayList<String>();
    if (AccessSection.GLOBAL_CAPABILITIES.equals(value.getName())) {
        for (String varName : projectAccess.getCapabilities().keySet()) {
            addPermission(varName, perms);
        }
    } else if (RefConfigSection.isValid(value.getName())) {
        for (LabelType t : projectAccess.getLabelTypes().getLabelTypes()) {
            addPermission(Permission.LABEL + t.getName(), perms);
        }
        for (String varName : Util.C.permissionNames().keySet()) {
            addPermission(varName, perms);
        }
    }
    if (perms.isEmpty()) {
        addContainer.getStyle().setDisplay(Display.NONE);
    } else {
        addContainer.getStyle().setDisplay(Display.BLOCK);
        perms.add(0, Util.C.addPermission());
        permissionSelector.setValue(Util.C.addPermission());
        permissionSelector.setAcceptableValues(perms);
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities().get(cbs.add(new AsyncCallback<CapabilityMap>() {

        @Override
        public void onSuccess(CapabilityMap result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addGwtjsonrpc(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ConfigServerApi.capabilities(cbs.add(new AsyncCallback<NativeMap<CapabilityInfo>>() {

        @Override
        public void onSuccess(NativeMap<CapabilityInfo> result) {
            capabilityMap = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.PROJECT_SVC.projectAccess(getProjectKey(), cbs.addGwtjsonrpc(new ScreenLoadCallback<ProjectAccess>(this) {

        @Override
        public void preDisplay(ProjectAccess access) {
            displayReadOnly(access);
        }
    }));
    savedPanel = ACCESS;
}
#end_block

#method_before
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (final CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#method_after
private void displayReadOnly(ProjectAccess access) {
    this.access = access;
    Map<String, String> allCapabilities = new HashMap<String, String>();
    for (CapabilityInfo c : Natives.asList(capabilityMap.values())) {
        allCapabilities.put(c.id(), c.name());
    }
    this.access.setCapabilities(allCapabilities);
    accessEditor.setEditing(false);
    UIObject.setVisible(editTools, !access.getOwnerOf().isEmpty() || access.canUpload());
    edit.setEnabled(!access.getOwnerOf().isEmpty() || access.canUpload());
    cancel1.setVisible(false);
    UIObject.setVisible(commitTools, false);
    driver.edit(access);
}
#end_block

#method_before
@Override
public CapabilityResource parse(ConfigResource parent, IdString id) throws ResourceNotFoundException, Exception {
    return null;
}
#method_after
@Override
public CapabilityResource parse(ConfigResource parent, IdString id) throws ResourceNotFoundException {
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public Object apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<String, CapabilityInfo> output = Maps.newTreeMap();
    Class<? extends CapabilityConstants> bundleClass = CapabilityConstants.get().getClass();
    CapabilityConstants c = CapabilityConstants.get();
    for (String s : Splitter.on(", ").split(CapabilityConstants.get().capabilityNames)) {
        String v = (String) bundleClass.getField(s).get(c);
        CapabilityInfo info = new CapabilityInfo(s, v);
        output.put(s, info);
    }
    return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
    }.getType());
}
#method_after
@Override
public Map<String, CapabilityInfo> apply(ConfigResource resource) throws AuthException, BadRequestException, ResourceConflictException, IllegalArgumentException, SecurityException, IllegalAccessException, NoSuchFieldException {
    Map<String, CapabilityInfo> output = Maps.newTreeMap();
    Class<? extends CapabilityConstants> bundleClass = CapabilityConstants.get().getClass();
    CapabilityConstants c = CapabilityConstants.get();
    for (String id : GlobalCapability.getAllNames()) {
        String name = (String) bundleClass.getField(id).get(c);
        output.put(id, new CapabilityInfo(id, name));
    }
    return output;
}
#end_block

#method_before
@Override
public String render(String varName) {
    if (Permission.isLabel(varName)) {
        return Util.M.label(new Permission(varName).getLabel());
    }
    String desc = all.get(varName);
    if (desc == null) {
        desc = all.get(varName.toLowerCase());
    }
    return desc != null ? desc : varName;
}
#method_after
@Override
public String render(String varName) {
    if (Permission.isLabel(varName)) {
        return Util.M.label(new Permission(varName).getLabel());
    }
    String desc = permissions.get(varName);
    if (desc != null) {
        return desc;
    }
    desc = fromServer.get(varName);
    if (desc != null) {
        return desc;
    }
    desc = permissions.get(varName.toLowerCase());
    if (desc != null) {
        return desc;
    }
    desc = fromServer.get(varName.toLowerCase());
    if (desc != null) {
        return desc;
    }
    return varName;
}
#end_block

#method_before
@Override
public RestView<TopLevelResource> list() {
    return null;
}
#method_after
@Override
public RestView<TopLevelResource> list() throws ResourceNotFoundException {
    throw new ResourceNotFoundException();
}
#end_block

#method_before
@Override
public ConfigResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException {
    if (!"server".equals(id.get())) {
        throw new ResourceNotFoundException(id);
    }
    return new ConfigResource();
}
#method_after
@Override
public ConfigResource parse(TopLevelResource root, IdString id) throws ResourceNotFoundException {
    if (id.equals("server")) {
        return new ConfigResource();
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
protected void onUnload() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    detailCache.removeValueChangeHandler(this);
    super.onUnload();
}
#method_after
@Override
protected void onUnload() {
    if (regNavigation != null) {
        regNavigation.removeHandler();
        regNavigation = null;
    }
    if (regAction != null) {
        regAction.removeHandler();
        regAction = null;
    }
    if (regDetailCache != null) {
        regDetailCache.removeHandler();
        regDetailCache = null;
    }
    super.onUnload();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    ChangeCache cache = ChangeCache.get(changeId);
    detailCache = cache.getChangeDetailCache();
    detailCache.addValueChangeHandler(this);
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    addStyleName(Gerrit.RESOURCES.css().screenNoHeader());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
    }
    descriptionBlock = new ChangeDescriptionBlock(keysAction);
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    dependsOn.setChangeRowFormatter(new ChangeTable.ChangeRowFormatter() {

        @Override
        public String getRowStyle(ChangeInfo c) {
            if (!c.isLatest() || Change.Status.ABANDONED.equals(c.getStatus())) {
                return Gerrit.RESOURCES.css().outdated();
            }
            return null;
        }

        @Override
        public String getDisplayText(final ChangeInfo c, final String displayText) {
            if (!c.isLatest()) {
                return displayText + " [OUTDATED]";
            }
            return displayText;
        }
    });
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new ComplexDisclosurePanel(Util.C.changeScreenDependencies(), false);
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (index == 0) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.referenceVersion());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    patchSetsBlock = new PatchSetsBlock();
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    ChangeCache cache = ChangeCache.get(changeId);
    detailCache = cache.getChangeDetailCache();
    regDetailCache = detailCache.addValueChangeHandler(this);
    addStyleName(Gerrit.RESOURCES.css().changeScreen());
    addStyleName(Gerrit.RESOURCES.css().screenNoHeader());
    keysNavigation = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysNavigation.add(new UpToListKeyCommand(0, 'u', Util.C.upToChangeList()));
    keysNavigation.add(new ExpandCollapseDependencySectionKeyCommand(0, 'd', Util.C.expandCollapseDependencies()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new PublishCommentsKeyCommand(0, 'r', Util.C.keyPublishComments()));
    }
    descriptionBlock = new ChangeDescriptionBlock(keysAction);
    add(descriptionBlock);
    approvals = new ApprovalTable();
    add(approvals);
    includedInPanel = new DisclosurePanel(Util.C.changeScreenIncludedIn());
    includedInTable = new IncludedInTable(changeId);
    includedInPanel.setContent(includedInTable);
    add(includedInPanel);
    dependencies = new ChangeTable() {

        {
            table.setWidth("auto");
        }
    };
    dependsOn = new ChangeTable.Section(Util.C.changeScreenDependsOn());
    dependsOn.setChangeRowFormatter(new ChangeTable.ChangeRowFormatter() {

        @Override
        public String getRowStyle(ChangeInfo c) {
            if (!c.isLatest() || Change.Status.ABANDONED.equals(c.getStatus())) {
                return Gerrit.RESOURCES.css().outdated();
            }
            return null;
        }

        @Override
        public String getDisplayText(final ChangeInfo c, final String displayText) {
            if (!c.isLatest()) {
                return displayText + " [OUTDATED]";
            }
            return displayText;
        }
    });
    neededBy = new ChangeTable.Section(Util.C.changeScreenNeededBy());
    dependencies.addSection(dependsOn);
    dependencies.addSection(neededBy);
    dependenciesPanel = new ComplexDisclosurePanel(Util.C.changeScreenDependencies(), false);
    dependenciesPanel.setContent(dependencies);
    add(dependenciesPanel);
    patchesList = new ListBox();
    patchesList.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            final int index = patchesList.getSelectedIndex();
            final String selectedPatchSet = patchesList.getValue(index);
            if (index == 0) {
                diffBaseId = null;
            } else {
                diffBaseId = PatchSet.Id.parse(selectedPatchSet);
            }
            if (patchSetsBlock != null) {
                patchSetsBlock.refresh(diffBaseId);
            }
        }
    });
    patchesGrid = new Grid(1, 2);
    patchesGrid.setStyleName(Gerrit.RESOURCES.css().selectPatchSetOldVersion());
    patchesGrid.setText(0, 0, Util.C.referenceVersion());
    patchesGrid.setWidget(0, 1, patchesList);
    add(patchesGrid);
    patchSetsBlock = new PatchSetsBlock();
    add(patchSetsBlock);
    comments = new FlowPanel();
    comments.setStyleName(Gerrit.RESOURCES.css().changeComments());
    add(comments);
}
#end_block

#method_before
// Find the last attached screen.
// When DialogBox is used (i. e. CommentedActionDialog) then the original
// ChangeScreen is still in attached state.
private boolean isLastValueChangeHandler() {
    int count = detailCache.getHandlerCount();
    int last = count - 1;
    for (int i = 0; i < count; i++) {
        if (this == detailCache.getHandler(i)) {
            return i == last;
        }
    }
    return false;
}
#method_after
// Find the last attached screen.
// When DialogBox is used (i. e. CommentedActionDialog) then the original
// ChangeScreen is still in attached state.
private boolean isLastValueChangeHandler() {
    int count = detailCache.getHandlerCount();
    return count > 0 && detailCache.getHandler(count - 1) == this;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    final String ref = receiveEvent.command.getRefName();
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(ref).matches() || ReceiveCommits.NEW_PATCHSET.matcher(ref).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForGerritCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || ReceiveCommits.NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, labelTypes, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final SetMultimap<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Set<Ref> refs = byCommit.get(c.copy());
            for (Ref ref : refs) {
                if (ref != null) {
                    rw.parseBody(c);
                    Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                    closeProgress.update(1);
                    if (closedChange != null) {
                        byKey.remove(closedChange);
                    }
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    final ReplaceRequest req = new ReplaceRequest(onto, c, cmd, false);
                    req.change = db.changes().get(onto);
                    req.patchSets = db.patchSets().byChange(onto).toList();
                    toClose.add(req);
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private Map<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = new HashMap<ObjectId, Ref>();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#method_after
private SetMultimap<ObjectId, Ref> changeRefsById() throws IOException {
    if (refsById == null) {
        refsById = HashMultimap.create();
        for (Ref r : repo.getRefDatabase().getRefs("refs/changes/").values()) {
            if (PatchSet.isRef(r.getName())) {
                refsById.put(r.getObjectId(), r);
            }
        }
    }
    return refsById;
}
#end_block

#method_before
public static void deleteSshKeys(String account, Set<Integer> sequenceNumbers, AsyncCallback<VoidResult> cb) {
    CountingCallback ccb = new CountingCallback(sequenceNumbers.size(), cb);
    for (int seq : sequenceNumbers) {
        new RestApi("/accounts/").id(account).view("sshkeys").id(seq).delete(ccb);
    }
}
#method_after
public static void deleteSshKeys(String account, Set<Integer> sequenceNumbers, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (int seq : sequenceNumbers) {
        new RestApi("/accounts/").id(account).view("sshkeys").id(seq).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
}
#end_block

#method_before
void deleteChecked() {
    final HashSet<Integer> sequenceNumbers = new HashSet<Integer>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            sequenceNumbers.add(k.seq());
        }
    }
    if (sequenceNumbers.isEmpty()) {
        updateDeleteButton();
    } else {
        AccountApi.deleteSshKeys("self", sequenceNumbers, new GerritCallback<VoidResult>() {

            public void onSuccess(VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && sequenceNumbers.contains(k.seq())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                refreshSshKeys();
                super.onFailure(caught);
            }
        });
    }
}
#method_after
void deleteChecked() {
    final HashSet<Integer> sequenceNumbers = new HashSet<Integer>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            sequenceNumbers.add(k.seq());
        }
    }
    if (sequenceNumbers.isEmpty()) {
        updateDeleteButton();
    } else {
        AccountApi.deleteSshKeys("self", sequenceNumbers, new GerritCallback<VoidResult>() {

            public void onSuccess(VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && sequenceNumbers.contains(k.seq())) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                refreshSshKeys();
                updateDeleteButton();
                super.onFailure(caught);
            }
        });
    }
}
#end_block

#method_before
static HttpPasswordInput create() {
    return (HttpPasswordInput) createObject();
}
#method_after
static HttpPasswordInput create() {
    return createObject().cast();
}
#end_block

#method_before
void deleteChecked() {
    final HashSet<AccountSshKey.Id> ids = new HashSet<AccountSshKey.Id>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            ids.add(new AccountSshKey.Id(Gerrit.getUserAccount().getId(), k.id()));
        }
    }
    if (ids.isEmpty()) {
        updateDeleteButton();
    } else {
        Util.ACCOUNT_SEC.deleteSshKeys(ids, new GerritCallback<VoidResult>() {

            public void onSuccess(final VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && ids.contains(new AccountSshKey.Id(Gerrit.getUserAccount().getId(), k.id()))) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }
        });
    }
}
#method_after
void deleteChecked() {
    final HashSet<AccountSshKey.Id> ids = new HashSet<AccountSshKey.Id>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final SshKeyInfo k = getRowItem(row);
        if (k != null && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            ids.add(new AccountSshKey.Id(Gerrit.getUserAccount().getId(), k.seq()));
        }
    }
    if (ids.isEmpty()) {
        updateDeleteButton();
    } else {
        Util.ACCOUNT_SEC.deleteSshKeys(ids, new GerritCallback<VoidResult>() {

            public void onSuccess(final VoidResult result) {
                for (int row = 1; row < table.getRowCount(); ) {
                    final SshKeyInfo k = getRowItem(row);
                    if (k != null && ids.contains(new AccountSshKey.Id(Gerrit.getUserAccount().getId(), k.seq()))) {
                        table.removeRow(row);
                    } else {
                        row++;
                    }
                }
                if (table.getRowCount() == 1) {
                    display(Collections.<SshKeyInfo>emptyList());
                } else {
                    updateDeleteButton();
                }
            }
        });
    }
}
#end_block

#method_before
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws OrmException {
    List<SshKeyInfo> sshKeys = Lists.newArrayList();
    for (AccountSshKey sshKey : dbProvider.get().accountSshKeys().byAccount(rsrc.getUser().getAccountId()).toList()) {
        SshKeyInfo info = new SshKeyInfo();
        info.id = sshKey.getKey().get();
        info.sshPublicKey = sshKey.getSshPublicKey();
        info.encodedKey = sshKey.getEncodedKey();
        info.algorithm = sshKey.getAlgorithm();
        info.comment = Strings.emptyToNull(sshKey.getComment());
        info.valid = sshKey.isValid();
        sshKeys.add(info);
    }
    return sshKeys;
}
#method_after
@Override
public List<SshKeyInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to get SSH keys");
    }
    List<SshKeyInfo> sshKeys = Lists.newArrayList();
    for (AccountSshKey sshKey : dbProvider.get().accountSshKeys().byAccount(rsrc.getUser().getAccountId()).toList()) {
        SshKeyInfo info = new SshKeyInfo();
        info.seq = sshKey.getKey().get();
        info.sshPublicKey = sshKey.getSshPublicKey();
        info.encodedKey = sshKey.getEncodedKey();
        info.algorithm = sshKey.getAlgorithm();
        info.comment = Strings.emptyToNull(sshKey.getComment());
        info.valid = sshKey.isValid();
        sshKeys.add(info);
    }
    return sshKeys;
}
#end_block

#method_before
static HttpPasswordInput create() {
    return (HttpPasswordInput) createObject();
}
#method_after
static HttpPasswordInput create() {
    return createObject().cast();
}
#end_block

#method_before
@Override
public String apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to get http password");
    }
    AccountExternalId id = dbProvider.get().accountExternalIds().get(new AccountExternalId.Key(SCHEME_USERNAME, rsrc.getUser().getUserName()));
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    return Strings.nullToEmpty(id.getPassword());
}
#method_after
@Override
public String apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to get http password");
    }
    AccountState s = rsrc.getUser().state();
    if (s.getUserName() == null) {
        throw new ResourceNotFoundException();
    }
    String p = s.getPassword(s.getUserName());
    if (p == null) {
        throw new ResourceNotFoundException();
    }
    return p;
}
#end_block

#method_before
private void doGeneratePassword() {
    if (id != null) {
        enableUI(false);
        AccountApi.generateHttpPassword(id.getAccountId().toString(), new GerritCallback<NativeString>() {

            @Override
            public void onSuccess(NativeString newPassword) {
                id.setPassword(newPassword.asString());
                display(id);
            }

            @Override
            public void onFailure(final Throwable caught) {
                enableUI(true);
            }
        });
    }
}
#method_after
private void doGeneratePassword() {
    if (id != null) {
        enableUI(false);
        AccountApi.generateHttpPassword("self", new GerritCallback<NativeString>() {

            @Override
            public void onSuccess(NativeString newPassword) {
                id.setPassword(newPassword.asString());
                display(id);
            }

            @Override
            public void onFailure(final Throwable caught) {
                enableUI(true);
            }
        });
    }
}
#end_block

#method_before
private void doClearPassword() {
    if (id != null) {
        enableUI(false);
        AccountApi.clearHttpPassword(id.getAccountId().toString(), new GerritCallback<VoidResult>() {

            @Override
            public void onSuccess(VoidResult result) {
                id.setPassword(null);
                display(id);
            }

            @Override
            public void onFailure(final Throwable caught) {
                enableUI(true);
            }
        });
    }
}
#method_after
private void doClearPassword() {
    if (id != null) {
        enableUI(false);
        AccountApi.clearHttpPassword("self", new GerritCallback<VoidResult>() {

            @Override
            public void onSuccess(VoidResult result) {
                id.setPassword(null);
                display(id);
            }

            @Override
            public void onFailure(final Throwable caught) {
                enableUI(true);
            }
        });
    }
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to set HTTP password");
    }
    if (input == null) {
        input = new Input();
    }
    AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, rsrc.getUser().getUserName());
    AccountExternalId id = dbProvider.get().accountExternalIds().get(key);
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    String newPassword;
    if (input.generate) {
        newPassword = generate();
    } else {
        if (!Strings.isNullOrEmpty(input.httpPassword) && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to set HTTP password directly, " + "need to be Gerrit administrator");
        }
        newPassword = Strings.emptyToNull(input.httpPassword);
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(rsrc.getUser().getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.none() : newPassword;
}
#method_after
@Override
public Response<String> apply(AccountResource rsrc, Input input) throws AuthException, ResourceNotFoundException, ResourceConflictException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to set HTTP password");
    }
    if (input == null) {
        input = new Input();
    }
    if (rsrc.getUser().getUserName() == null) {
        throw new ResourceConflictException("username must be set");
    }
    AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, rsrc.getUser().getUserName());
    AccountExternalId id = dbProvider.get().accountExternalIds().get(key);
    if (id == null) {
        throw new ResourceNotFoundException();
    }
    String newPassword;
    if (input.generate) {
        newPassword = generate();
    } else {
        if (!Strings.isNullOrEmpty(input.httpPassword) && !self.get().getCapabilities().canAdministrateServer()) {
            throw new AuthException("not allowed to set HTTP password directly, " + "need to be Gerrit administrator");
        }
        newPassword = Strings.emptyToNull(input.httpPassword);
    }
    id.setPassword(newPassword);
    dbProvider.get().accountExternalIds().update(Collections.singleton(id));
    accountCache.evict(rsrc.getUser().getAccountId());
    return Strings.isNullOrEmpty(newPassword) ? Response.<String>none() : Response.ok(newPassword);
}
#end_block

#method_before
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    List<String> sorted_labels = new ArrayList<String>();
    sorted_labels.addAll(labels);
    Collections.sort(sorted_labels);
    for (String name : sorted_labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayHeader(Collection<String> labels) {
    table.resizeColumns(2 + labels.size());
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setText(0, col, Util.C.approvalTableReviewer());
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    table.clearCell(0, col);
    fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
    col++;
    for (String name : labels) {
        table.setText(0, col, name);
        fmt.setStyleName(0, col, Gerrit.RESOURCES.css().header());
        col++;
    }
    fmt.addStyleName(0, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        displayHeader(change.labels());
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, change, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#method_after
void display(ChangeInfo change) {
    lastChange = change;
    reviewerSuggestOracle.setChange(change.legacy_id());
    Map<Integer, ApprovalDetail> byUser = new LinkedHashMap<Integer, ApprovalDetail>();
    Map<Integer, AccountInfo> accounts = new LinkedHashMap<Integer, AccountInfo>();
    List<String> missingLabels = initLabels(change, accounts, byUser);
    removeAllChildren(missing.getElement());
    for (String label : missingLabels) {
        addMissingLabel(Util.M.needApproval(label));
    }
    if (byUser.isEmpty()) {
        table.setVisible(false);
    } else {
        List<String> labels = new ArrayList<String>(change.labels());
        Collections.sort(labels);
        displayHeader(labels);
        table.resizeRows(1 + byUser.size());
        int i = 1;
        for (ApprovalDetail ad : ApprovalDetail.sort(byUser.values(), change.owner()._account_id())) {
            displayRow(i++, ad, labels, accounts.get(ad.getAccount().get()));
        }
        table.setVisible(true);
    }
    if (Gerrit.getConfig().testChangeMerge() && change.status() != Change.Status.MERGED && !change.mergeable()) {
        addMissingLabel(Util.C.messageNeedsRebaseOrHasDependency());
    }
    missing.setVisible(DOM.getChildCount(missing.getElement()) > 0);
    addReviewer.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
private void displayRow(int row, final ApprovalDetail ad, ChangeInfo change, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLink(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : change.labels()) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#method_after
private void displayRow(int row, final ApprovalDetail ad, List<String> labels, AccountInfo account) {
    final CellFormatter fmt = table.getCellFormatter();
    int col = 0;
    table.setWidget(row, col++, new AccountLinkPanel(account));
    rows.put(account._account_id(), row);
    if (ad.canRemove()) {
        final PushButton remove = new // 
        PushButton(// 
        new Image(Util.R.removeReviewerNormal()), new Image(Util.R.removeReviewerPressed()));
        remove.setTitle(Util.M.removeReviewer(account.name()));
        remove.setStyleName(Gerrit.RESOURCES.css().removeReviewer());
        remove.addStyleName(Gerrit.RESOURCES.css().link());
        remove.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                doRemove(ad, remove);
            }
        });
        table.setWidget(row, col, remove);
    } else {
        table.clearCell(row, col);
    }
    fmt.setStyleName(row, col++, Gerrit.RESOURCES.css().removeReviewerCell());
    for (String labelName : labels) {
        fmt.setStyleName(row, col, Gerrit.RESOURCES.css().approvalscore());
        if (!ad.canVote(labelName)) {
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().notVotable());
            fmt.getElement(row, col).setTitle(Gerrit.C.userCannotVoteToolTip());
        }
        if (ad.isRejected(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
        } else if (ad.isApproved(labelName)) {
            table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
        } else {
            int v = ad.getValue(labelName);
            if (v == 0) {
                table.clearCell(row, col);
                col++;
                continue;
            }
            String vstr = String.valueOf(ad.getValue(labelName));
            if (v > 0) {
                vstr = "+" + vstr;
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            } else {
                fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            }
            table.setText(row, col, vstr);
        }
        col++;
    }
    fmt.addStyleName(row, col - 1, Gerrit.RESOURCES.css().rightmost());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (file.startsWith("^")) {
            throw error("regular expression not permitted here: file:" + file);
        }
        if (args.indexManager == ChangeIndex.Manager.DISABLED) {
            throw error("secondary index support is disabled, please enable it first");
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (file.startsWith("^")) {
            throw error("regular expression not permitted here: file:" + file);
        }
        if (args.indexManager == ChangeIndex.Manager.DISABLED) {
            throw error("secondary index must be enabled for file:" + file);
        }
        return new EqualsFilePredicate(args.dbProvider, args.patchListCache, file);
    }
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        // TODO: Handle empty contents
        return null;
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        contents = "";
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents).setInfinity("viewportMargin");
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            padLines(cmA, delta, lineA - 1);
            lineB = colorLine(delta, lineA, lineB, true);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            padLines(cmB, delta, lineB - 1);
            lineA = colorLine(delta, lineA, lineB, false);
        } else {
            lineA = colorLine(current.a().length(), lineA, lineB, false);
            lineB = colorLine(current.b().length(), lineA, lineB, true);
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            insertEmptyLines(cmA, lineA, delta);
            lineB = colorLines(cmB, lineB, delta);
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            insertEmptyLines(cmB, lineB, delta);
            lineA = colorLines(cmA, lineA, delta);
        } else {
            // TODO: Implement intraline
            int aLength = current.a().length();
            int bLength = current.b().length();
            lineA = colorLines(cmA, lineA, aLength);
            lineB = colorLines(cmB, lineB, bLength);
            if (aLength < bLength) {
                insertEmptyLines(cmA, lineA, bLength - aLength);
            } else if (aLength > bLength) {
                insertEmptyLines(cmB, lineB, aLength - bLength);
            }
        }
    }
}
#end_block

#method_before
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(new IndexRewrite(index).rewrite(in));
}
#method_after
@Override
public Predicate<ChangeData> rewrite(Predicate<ChangeData> in) {
    return super.rewrite(indexRewrite.rewrite(in));
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                addRepeatableField(result, f, cd);
            } else {
                addSingleField(result, f, cd);
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    rewrite = new IndexRewrite(index);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    index = new DummyIndex();
    queryBuilder = new ChangeQueryBuilder(new ChangeQueryBuilder.Arguments(null, null, null, null, null, null, null, null, null, null, null, null), null);
    rewrite = new IndexRewriteImpl(index);
}
#end_block

#method_before
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = new FieldPredicate("in");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("file:a");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(f1, f2);
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a file:b");
    assertEquals(wrap(in), rewrite(in));
}
#end_block

#method_before
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> in = Predicate.and(o1, o2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, o2), out.getChildren());
}
#method_after
public void testNonIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("branch:a OR branch:b");
    assertSame(in, rewrite(in));
}
#end_block

#method_before
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> o1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f2 = new FieldPredicate("f2");
    Predicate<ChangeData> in = Predicate.and(o1, f2);
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o1, wrap(f2)), out.getChildren());
}
#method_after
public void testOneIndexPredicate() throws Exception {
    Predicate<ChangeData> in = parse("branch:a file:b");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(f1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#method_after
public void testThreeLevelTreeWithAllIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-status:abandoned (status:open OR status:merged)");
    assertEquals(wrap(in), rewrite.rewrite(in));
}
#end_block

#method_before
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> op1 = new OpPredicate("o1", "o1");
    Predicate<ChangeData> f21 = new FieldPredicate("f21");
    Predicate<ChangeData> f22 = new FieldPredicate("f22");
    Predicate<ChangeData> n1 = Predicate.not(op1);
    Predicate<ChangeData> o2 = Predicate.or(f21, f22);
    Predicate<ChangeData> in = Predicate.and(n1, o2);
    assertEquals(2, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(n1, wrap(o2)), out.getChildren());
}
#method_after
public void testThreeLevelTreeWithSomeIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("-branch:a (file:b OR file:c)");
    Predicate<ChangeData> out = rewrite(in);
    assertEquals(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(0), wrap(in.getChild(1))), out.getChildren());
}
#end_block

#method_before
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> f1 = new FieldPredicate("f1");
    Predicate<ChangeData> o2 = new OpPredicate("o2", "o2");
    Predicate<ChangeData> f3 = new FieldPredicate("f3");
    Predicate<ChangeData> o4 = new OpPredicate("o4", "o4");
    Predicate<ChangeData> in = Predicate.and(f1, o2, f3, o4);
    assertEquals(4, in.getChildCount());
    Predicate<ChangeData> out = rewrite.rewrite(in);
    assertSame(AndPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(o2, o4, wrap(Predicate.and(f1, f3))), out.getChildren());
}
#method_after
public void testMultipleIndexPredicates() throws Exception {
    Predicate<ChangeData> in = parse("file:a OR branch:b OR file:c OR branch:d");
    Predicate<ChangeData> out = rewrite(in);
    assertSame(OrPredicate.class, out.getClass());
    assertEquals(ImmutableList.of(in.getChild(1), in.getChild(3), wrap(Predicate.or(in.getChild(0), in.getChild(2)))), out.getChildren());
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^")) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#method_after
@Operator
public Predicate<ChangeData> file(String file) throws QueryParseException {
    if (allowFileRegex) {
        if (file.startsWith("^")) {
            return new RegexFilePredicate(args.dbProvider, args.patchListCache, file);
        } else {
            throw new IllegalArgumentException();
        }
    } else {
        if (!file.startsWith("^") && args.index != ChangeIndex.DISABLED) {
            // TODO(dborowitz): Wrap predicates in query rewriter, not here.
            return new PredicateWrapper(args.index, new EqualsFilePredicate(args.dbProvider, args.patchListCache, file));
        } else {
            throw error("regular expression not permitted here: file:" + file);
        }
    }
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    Provider<ReviewDb> dbProvider = Providers.of(db);
    PatchListCache plc = sysInjector.getInstance(PatchListCache.class);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    index.getWriter().deleteAll();
    int i = 0;
    for (Change change : db.changes().all()) {
        ChangeData cd = new ChangeData(change);
        cd.fillIndexFields(dbProvider, plc);
        index.insert(cd);
        i++;
    }
    index.getWriter().commit();
    System.out.println("Reindexed " + i + " changes");
    manager.stop();
    return 0;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(SINGLE_USER);
    if (!LuceneIndexModule.isEnabled(dbInjector)) {
        throw die("Secondary index not enabled");
    }
    sitePaths = dbInjector.getInstance(SitePaths.class);
    deleteAll();
    sysInjector = createSysInjector();
    manager.add(dbInjector);
    manager.add(sysInjector);
    manager.start();
    SchemaFactory<ReviewDb> schema = dbInjector.getInstance(Key.get(new TypeLiteral<SchemaFactory<ReviewDb>>() {
    }));
    ReviewDb db = schema.open();
    dbRef.set(db);
    LuceneChangeIndex index = sysInjector.getInstance(LuceneChangeIndex.class);
    Stopwatch sw = new Stopwatch().start();
    int i = 0;
    for (Change change : db.changes().all()) {
        index.insert(new ChangeData(change));
        i++;
    }
    index.getWriter().commit();
    double elapsed = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Reindexed %d changes in %.02fms", i, elapsed);
    manager.stop();
    return 0;
}
#end_block

#method_before
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new LifecycleModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    List<Module> modules = Lists.newArrayList();
    modules.add(PatchListCacheImpl.module());
    modules.add(new LuceneIndexModule());
    modules.add(new AbstractModule() {

        @SuppressWarnings("rawtypes")
        @Override
        protected void configure() {
            bind(ReviewDb.class).toProvider(new Provider<ReviewDb>() {

                @Override
                public ReviewDb get() {
                    return dbRef.get();
                }
            });
            // Plugins are not loaded and we're just running through each change
            // once, so don't worry about cache removal.
            bind(new TypeLiteral<DynamicSet<CacheRemovalListener>>() {
            }).toInstance(DynamicSet.<CacheRemovalListener>emptySet());
            install(new DefaultCacheFactory.Module());
        }
    });
    return dbInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    switch(p.getType()) {
        case INTEGER:
            return intQuery(p);
        case EXACT_REPEATABLE:
            return exactQuery(p);
        default:
            throw badFieldType(p.getType());
    }
}
#method_after
@Override
public ChangeDataSource getSource(IndexPredicate<ChangeData> p) throws QueryParseException {
    if (p.getType() == FieldType.INTEGER) {
        return intQuery(p);
    } else if (p.getType() == FieldType.EXACT) {
        return exactQuery(p);
    } else {
        throw badFieldType(p.getType());
    }
}
#end_block

#method_before
private Document toDocument(ChangeData cd) throws IOException {
    cd.checkIndexFields();
    org.apache.lucene.document.Document result = new Document();
    for (ChangeField f : ChangeField.values()) {
        switch(f.getType()) {
            case INTEGER:
                result.add(new IntField(f.getName(), (Integer) f.get(cd), store(f)));
                break;
            case EXACT_REPEATABLE:
                // Type checked in ChangeField.
                @SuppressWarnings("unchecked")
                Iterable<String> values = (Iterable<String>) f.get(cd);
                for (String value : values) {
                    result.add(new StringField(f.getName(), value, store(f)));
                }
                break;
        }
    }
    return result;
}
#method_after
private Document toDocument(ChangeData cd) throws IOException {
    try {
        Document result = new Document();
        for (FieldDef<ChangeData, ?> f : ChangeField.ALL.values()) {
            if (f.isRepeatable()) {
                add(result, f, (Iterable<?>) f.get(cd, fillArgs));
            } else {
                add(result, f, Collections.singleton(f.get(cd, fillArgs)));
            }
        }
        return result;
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Field.Store store(ChangeField f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#method_after
private static Field.Store store(FieldDef<?, ?> f) {
    return f.isStored() ? Field.Store.YES : Field.Store.NO;
}
#end_block

#method_before
private static IllegalArgumentException badFieldType(FieldType t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#method_after
private static IllegalArgumentException badFieldType(FieldType<?> t) {
    return new IllegalArgumentException("unknown index field type " + t);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new com.google.gerrit.server.index.Module());
    modules.add(LuceneChangeIndex.module());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new IntraLineWorkerPool.Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (LuceneIndexModule.isEnabled(cfgInjector)) {
        modules.add(new LuceneIndexModule());
    } else {
        modules.add(new NoIndexModule());
    }
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
public FieldType getType() {
    return type;
}
#method_after
public FieldType<?> getType() {
    return def.getType();
}
#end_block

#method_before
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        workQueue.getDefaultQueue().submit(indexerFactory.create(change));
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#method_after
public Change insert() throws InvalidChangeOperationException, OrmException, IOException {
    init();
    validate();
    Change updatedChange;
    RefUpdate ru = git.updateRef(patchSet.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(commit);
    ru.disableRefLog();
    if (ru.update(revWalk) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", patchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(change.getProject(), ru);
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange == null) {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        db.commit();
        if (changeMessage != null) {
            db.changeMessages().insert(Collections.singleton(changeMessage));
        }
        indexer.index(change);
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return updatedChange;
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            walk.markUninteresting(magicBranch.baseCommit);
        } else {
            markHeadsAsUninteresting(walk, existing, magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // 
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(changeIndexerFactory.create(change)));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final PatchSet ps = ins.getPatchSet();
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    ins.setReviewers(recipients.getReviewers()).insert();
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, ins.getPatchSetInfo());
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void addPadding(int line, CodeMirror cm) {
    Element div = DOM.createDiv();
    div.setAttribute("style", "background-color: #E6E6E6");
    div.appendChild(DOM.createElement("br"));
    cm.addLineWidget(line, div, null);
}
#method_after
private void addPadding(CodeMirror cm, int line) {
    Element div = DOM.createDiv();
    div.setClassName(diffTable.style.padding());
    cm.addLineWidget(line, div, null);
}
#end_block

#method_before
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", "insert").set("readOnly", "true");
    Configuration deleteOpt = Configuration.create().set("className", "delete").set("readOnly", "true");
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineA - 1, cmA);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, "wrap", "insert");
                LineCharacter from = LineCharacter.create(lineB, 0).setLine(lineB).setCh(0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(lineB - 1, cmB);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, "wrap", "delete");
                LineCharacter from = LineCharacter.create(lineA, 0).setLine(lineA).setCh(0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#method_after
private void render(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    Configuration insertOpt = Configuration.create().set("className", diffTable.style.insert()).set("readOnly", true);
    Configuration deleteOpt = Configuration.create().set("className", diffTable.style.delete()).set("readOnly", true);
    int lineA = 0, lineB = 0;
    for (int i = 0; i < regions.length(); i++) {
        Region current = regions.get(i);
        if (current.ab() != null) {
            lineA += current.ab().length();
            lineB += current.ab().length();
        } else if (current.a() == null && current.b() != null) {
            int delta = current.b().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmA, lineA - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmB.addLineClass(lineB, LineClassWhere.WRAP, diffTable.style.insert());
                LineCharacter from = LineCharacter.create(lineB, 0);
                cmB.markText(from, from, insertOpt);
                lineB++;
            }
        } else if (current.a() != null && current.b() == null) {
            int delta = current.a().length();
            for (int j = 0; j < delta; j++) {
                addPadding(cmB, lineB - 1);
            }
            for (int j = 0; j < delta; j++) {
                cmA.addLineClass(lineA, LineClassWhere.WRAP, diffTable.style.delete());
                LineCharacter from = LineCharacter.create(lineA, 0);
                cmA.markText(from, from, deleteOpt);
                lineA++;
            }
        } else {
            // TODO: Handle intraline edit.
            lineA += current.a().length();
            lineB += current.a().length();
        }
    }
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException {
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("No such account: " + rsrc.getUser().getAccountId());
    }
    if (a.isActive()) {
        return Response.ok("");
    }
    a.setActive(true);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws ResourceNotFoundException, OrmException {
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("account not found");
    }
    if (a.isActive()) {
        return Response.ok("");
    }
    a.setActive(true);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Response.created("");
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "state").to(GetState.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    put(ACCOUNT_KIND, "inactive").to(PutInactive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#end_block

#method_before
public DivElement getCmA() {
    return cmA;
}
#method_after
DivElement getCmA() {
    return cmA;
}
#end_block

#method_before
public DivElement getCmB() {
    return cmB;
}
#method_after
DivElement getCmB() {
    return cmB;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    add(editorContainer = new FlowPanel());
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    add(diffTable = new DiffTable());
}
#end_block

#method_before
private void display(DiffInfo diff) {
    diffTable = new DiffTable();
    cmA = displaySide(diff.meta_a(), diff.text_a(), diffTable.getCmA());
    cmB = displaySide(diff.meta_b(), diff.text_b(), diffTable.getCmB());
    editorContainer.getElement().appendChild(diffTable.getElement());
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
}
#method_after
private void display(DiffInfo diff) {
    cmA = displaySide(diff.meta_a(), diff.text_a(), diffTable.getCmA());
    cmB = displaySide(diff.meta_b(), diff.text_b(), diffTable.getCmB());
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            if (cmA != null) {
                cmA.setHeight(event.getHeight() - HEADER_FOOTER);
                cmA.refresh();
            }
            if (cmB != null) {
                cmB.setHeight(event.getHeight() - HEADER_FOOTER);
                cmB.refresh();
            }
        }
    });
}
#end_block

#method_before
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, DivElement ele) {
    if (meta == null) {
        // TODO: Handle empty contents
        return null;
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#method_after
private CodeMirror displaySide(DiffInfo.FileMeta meta, String contents, Element ele) {
    if (meta == null) {
        // TODO: Handle empty contents
        return null;
    }
    Configuration cfg = Configuration.create().set("readOnly", true).set("lineNumbers", true).set("tabSize", 2).set("mode", getContentType(meta)).set("value", contents);
    final CodeMirror cm = CodeMirror.create(ele, cfg);
    cm.setWidth("100%");
    cm.setHeight(Window.getClientHeight() - HEADER_FOOTER);
    return cm;
}
#end_block

#method_before
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.getPatchSetsWithDraftComments().contains(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#method_after
public void display(final ChangeDetail detail, final PatchSet.Id diffBaseId) {
    clear();
    final PatchSet currps = detail.getCurrentPatchSet();
    currentPatchSetId = currps.getId();
    patchSets = detail.getPatchSets();
    if (Gerrit.isSignedIn()) {
        final AccountGeneralPreferences p = Gerrit.getUserAccount().getGeneralPreferences();
        if (p.isReversePatchSetOrder()) {
            Collections.reverse(patchSets);
        }
    }
    patchSetPanelsList = new ArrayList<PatchSetComplexDisclosurePanel>();
    for (final PatchSet ps : patchSets) {
        final PatchSetComplexDisclosurePanel p = new PatchSetComplexDisclosurePanel(ps, ps == currps, detail.hasDraftComments(ps.getId()));
        if (diffBaseId != null) {
            p.setDiffBaseId(diffBaseId);
            if (ps == currps) {
                p.refresh();
            }
        }
        add(p);
        patchSetPanelsList.add(p);
    }
}
#end_block

#method_before
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id id = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(id, me).iterator().hasNext()) {
                patchesWithDraftComments.add(id);
            }
        }
        patchsetsById.put(id, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#method_after
private void loadPatchSets() throws OrmException {
    ResultSet<PatchSet> source = db.patchSets().byChange(changeId);
    List<PatchSet> patches = new ArrayList<PatchSet>();
    Set<PatchSet.Id> patchesWithDraftComments = new HashSet<PatchSet.Id>();
    final CurrentUser user = control.getCurrentUser();
    final Account.Id me = user instanceof IdentifiedUser ? ((IdentifiedUser) user).getAccountId() : null;
    for (PatchSet ps : source) {
        final PatchSet.Id psId = ps.getId();
        if (control.isPatchVisible(ps, db)) {
            patches.add(ps);
            if (me != null && db.patchComments().draftByPatchSetAuthor(psId, me).iterator().hasNext()) {
                patchesWithDraftComments.add(psId);
            }
        }
        patchsetsById.put(psId, ps);
    }
    detail.setPatchSets(patches);
    detail.setPatchSetsWithDraftComments(patchesWithDraftComments);
}
#end_block

#method_before
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#method_after
public void loadActionPanel(final PatchSetDetail detail) {
    if (!patchSet.getId().equals(diffBaseId)) {
        actionsPanel = new FlowPanel();
        actionsPanel.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
        actionsPanel.setVisible(true);
        if (Gerrit.isSignedIn()) {
            if (changeDetail.canEdit()) {
                populateReviewAction();
                if (changeDetail.isCurrentPatchSet(detail)) {
                    populateActions(detail);
                }
                populateCommands(detail);
            }
            if (detail.getPatchSet().isDraft()) {
                if (changeDetail.canPublish()) {
                    populatePublishAction();
                }
                if (changeDetail.canDeleteDraft() && changeDetail.getPatchSets().size() > 1) {
                    populateDeleteDraftPatchSetAction();
                }
            }
        }
        body.add(actionsPanel);
    }
}
#end_block

#method_before
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> patchSetsWithDraftComments) {
    this.patchSetsWithDraftComments = patchSetsWithDraftComments;
}
#method_after
public void setPatchSetsWithDraftComments(Set<PatchSet.Id> pwdc) {
    this.patchSetsWithDraftComments = pwdc;
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws BadRequestException, ResourceConflictException, ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input == null) {
        input = new Input();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (input.noConfirmation && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address without confirmation, " + "need to be Gerrit administrator");
    }
    if (input.noConfirmation || authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(rsrc.getUser().getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    EmailInfo e = new EmailInfo();
    e.email = email;
    if (input.preferred) {
        putPreferredProvider.get().apply(new AccountResource.Email(rsrc.getUser(), email), null);
        e.setPreferred(true);
    }
    return Response.created(e);
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws AuthException, BadRequestException, ResourceConflictException, ResourceNotFoundException, OrmException, EmailException {
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address");
    }
    if (input == null) {
        input = new Input();
    }
    if (input.email != null && !email.equals(input.email)) {
        throw new BadRequestException("email address must match URL");
    }
    if (input.noConfirmation && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to add email address without confirmation, " + "need to be Gerrit administrator");
    }
    if (input.noConfirmation || authConfig.getAuthType() == AuthType.DEVELOPMENT_BECOME_ANY_ACCOUNT) {
        try {
            accountManager.link(rsrc.getUser().getAccountId(), AuthRequest.forEmail(email));
        } catch (AccountException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    } else {
        try {
            RegisterNewEmailSender sender = registerNewEmailFactory.create(email);
            sender.send();
        } catch (EmailException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        } catch (RuntimeException e) {
            log.error("Cannot send email verification message to " + email, e);
            throw e;
        }
    }
    EmailInfo e = new EmailInfo();
    e.email = email;
    if (input.preferred) {
        putPreferredProvider.get().apply(new AccountResource.Email(rsrc.getUser(), email), null);
        e.setPreferred(true);
    }
    return Response.created(e);
}
#end_block

#method_before
@Override
public AccountResource.Email parse(AccountResource parent, IdString id) throws ResourceNotFoundException {
    if ("preferred".equals(id.get())) {
        String preferredEmail = parent.getUser().getAccount().getPreferredEmail();
        if (!Strings.isNullOrEmpty(preferredEmail)) {
            return new AccountResource.Email(parent.getUser(), preferredEmail);
        }
        throw new ResourceNotFoundException();
    }
    for (Account.Id a : byEmailCache.get(id.get())) {
        if (parent.getUser().getAccountId().equals(a)) {
            return new AccountResource.Email(parent.getUser(), id.get());
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
@Override
public AccountResource.Email parse(AccountResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    if ("preferred".equals(id.get())) {
        String preferredEmail = parent.getUser().getAccount().getPreferredEmail();
        if (!Strings.isNullOrEmpty(preferredEmail)) {
            return new AccountResource.Email(parent.getUser(), preferredEmail);
        }
        throw new ResourceNotFoundException();
    }
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() == parent.getUser().getAccountId().get() || s.getCapabilities().canAdministrateServer()) {
        for (Account.Id a : byEmailCache.get(id.get())) {
            if (parent.getUser().getAccountId().equals(a)) {
                return new AccountResource.Email(parent.getUser(), id.get());
            }
        }
    }
    throw new ResourceNotFoundException();
}
#end_block

#method_before
@Override
public AccountResource.Email parse(AccountResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() == parent.getUser().getAccountId().get() || s.getCapabilities().canAdministrateServer()) {
        for (Account.Id a : byEmailCache.get(id.get())) {
            if (s.getAccountId().equals(a)) {
                return new AccountResource.Email(parent.getUser(), id.get());
            }
        }
    }
    throw new ResourceNotFoundException();
}
#method_after
@Override
public AccountResource.Email parse(AccountResource parent, IdString id) throws AuthException, ResourceNotFoundException {
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() == parent.getUser().getAccountId().get() || s.getCapabilities().canAdministrateServer()) {
        for (Account.Id a : byEmailCache.get(id.get())) {
            if (parent.getUser().getAccountId().equals(a)) {
                return new AccountResource.Email(parent.getUser(), id.get());
            }
        }
    }
    throw new ResourceNotFoundException();
}
#end_block

#method_before
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
            }
        });
    } catch (ResourceException e) {
    }
}
#method_after
private static void asyncInjectCss(ExternalTextResource css) {
    try {
        css.getText(new ResourceCallback<TextResource>() {

            @Override
            public void onSuccess(TextResource resource) {
                StyleInjector.inject(resource.getText());
            }

            @Override
            public void onError(ResourceException e) {
                error(e);
            }
        });
    } catch (ResourceException e) {
        error(e);
    }
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws OrmException {
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        if (extId.isScheme(AccountExternalId.SCHEME_MAILTO)) {
            EmailInfo e = new EmailInfo();
            e.email = extId.getEmailAddress();
            e.setPreferred(extId.getEmailAddress().equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (!(self.get() instanceof IdentifiedUser)) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !s.getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    ResultSet<AccountExternalId> ids = dbProvider.get().accountExternalIds().byAccount(rsrc.getUser().getAccountId());
    for (AccountExternalId extId : ids) {
        String email = extId.getEmailAddress();
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.setPreferred(email.equals(rsrc.getUser().getAccount().getPreferredEmail()));
            emails.add(e);
        }
    }
    return emails;
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc) {
    return Strings.nullToEmpty(rsrc.getUser().getAccount().getFullName());
}
#method_after
@Override
public String apply(AccountResource rsrc) {
    return Strings.nullToEmpty(rsrc.getUser().getAccount().getFullName());
}
#end_block

#method_before
@Override
public Object apply(AccountResource rsrc, Input input) throws OrmException, MethodNotAllowedException {
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("The realm doesn't allow editing names");
    }
    if (input == null) {
        input = new Input();
    }
    Account a = rsrc.getUser().getAccount();
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a.getFullName();
}
#method_after
@Override
public Object apply(AccountResource rsrc, Input input) throws AuthException, MethodNotAllowedException, ResourceNotFoundException, OrmException {
    IdentifiedUser s = (IdentifiedUser) self.get();
    if (s.getAccountId().get() != rsrc.getUser().getAccountId().get() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("not allowed to change name");
    }
    if (!realm.allowsEdit(FieldName.FULL_NAME)) {
        throw new MethodNotAllowedException("The realm doesn't allow editing names");
    }
    if (input == null) {
        input = new Input();
    }
    Account a = dbProvider.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException("No such account: " + rsrc.getUser().getAccountId());
    }
    a.setFullName(input.name);
    dbProvider.get().accounts().update(Collections.singleton(a));
    byIdCache.evict(a.getId());
    return Strings.isNullOrEmpty(a.getFullName()) ? Response.none() : a.getFullName();
}
#end_block

#method_before
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = HtmlDomUtil.parseFile(LdapLoginServlet.class, "LoginForm.html");
    injectCssFile(doc, "gerrit_sitecss", sitePaths.site_css);
    injectXmlFile(doc, "gerrit_header", sitePaths.site_header);
    injectXmlFile(doc, "gerrit_footer", sitePaths.site_footer);
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#method_after
private void sendForm(HttpServletRequest req, HttpServletResponse res, @Nullable String errorMessage) throws IOException {
    String self = req.getRequestURI();
    String cancel = Objects.firstNonNull(urlProvider.get(req), "/");
    String token = getToken(req);
    if (!token.equals("/")) {
        cancel += "#" + token;
    }
    Document doc = headers.parse(LdapLoginServlet.class, "LoginForm.html");
    HtmlDomUtil.find(doc, "hostName").setTextContent(req.getServerName());
    HtmlDomUtil.find(doc, "login_form").setAttribute("action", self);
    HtmlDomUtil.find(doc, "cancel_link").setAttribute("href", cancel);
    Element emsg = HtmlDomUtil.find(doc, "error_message");
    if (Strings.isNullOrEmpty(errorMessage)) {
        emsg.getParentNode().removeChild(emsg);
    } else {
        emsg.setTextContent(errorMessage);
    }
    byte[] bin = HtmlDomUtil.toUTF8(doc);
    res.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    res.setContentType("text/html");
    res.setCharacterEncoding("UTF-8");
    res.setContentLength(bin.length);
    ServletOutputStream out = res.getOutputStream();
    try {
        out.write(bin);
    } finally {
        out.close();
    }
}
#end_block

#method_before
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    String token = getToken(req);
    StringBuilder dest = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    dest.append(url);
    dest.append('#');
    dest.append(token);
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#method_after
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    String username = Strings.nullToEmpty(req.getParameter("username")).trim();
    String password = Strings.nullToEmpty(req.getParameter("password"));
    String remember = Strings.nullToEmpty(req.getParameter("rememberme"));
    if (username.isEmpty() || password.isEmpty()) {
        sendForm(req, res, "Invalid username or password.");
        return;
    }
    AuthRequest areq = AuthRequest.forUser(username);
    areq.setPassword(password);
    AuthResult ares;
    try {
        ares = accountManager.authenticate(areq);
    } catch (AccountUserNameException e) {
        sendForm(req, res, e.getMessage());
        return;
    } catch (AuthenticationUnavailableException e) {
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    } catch (AccountException e) {
        log.info(String.format("'%s' failed to sign in: %s", username, e.getMessage()));
        sendForm(req, res, "Invalid username or password.");
        return;
    } catch (RuntimeException e) {
        log.error("LDAP authentication failed", e);
        sendForm(req, res, "Authentication unavailable at this time.");
        return;
    }
    StringBuilder dest = new StringBuilder();
    dest.append(urlProvider.get(req));
    dest.append('#');
    dest.append(getToken(req));
    CacheHeaders.setNotCacheable(res);
    webSession.get().login(ares, "1".equals(remember));
    res.sendRedirect(dest.toString());
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    String url = urlProvider == null ? null : urlProvider.get();
    if (url == null) {
        url = guessCanonicalUrl(req);
    }
    rdr.append(url);
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#method_after
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws ServletException, IOException {
    final String token = getToken(req);
    if ("/logout".equals(token) || "/signout".equals(token)) {
        req.getRequestDispatcher("/logout").forward(req, rsp);
        return;
    }
    CacheHeaders.setNotCacheable(rsp);
    final String user = authFilter.getRemoteUser(req);
    if (user == null || "".equals(user)) {
        log.error("Unable to authenticate user by " + authFilter.getLoginHeader() + " request header.  Check container or server configuration.");
        final Document doc = // 
        HtmlDomUtil.parseFile(HttpLoginServlet.class, "ConfigurationError.html");
        replace(doc, "loginHeader", authFilter.getLoginHeader());
        replace(doc, "ServerName", req.getServerName());
        replace(doc, "ServerPort", ":" + req.getServerPort());
        replace(doc, "ContextPath", req.getContextPath());
        final byte[] bin = HtmlDomUtil.toUTF8(doc);
        rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding("UTF-8");
        rsp.setContentLength(bin.length);
        final ServletOutputStream out = rsp.getOutputStream();
        try {
            out.write(bin);
        } finally {
            out.flush();
            out.close();
        }
        return;
    }
    final AuthRequest areq = AuthRequest.forUser(user);
    final AuthResult arsp;
    try {
        arsp = accountManager.authenticate(areq);
    } catch (AccountException e) {
        log.error("Unable to authenticate user \"" + user + "\"", e);
        rsp.sendError(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    final StringBuilder rdr = new StringBuilder();
    rdr.append(urlProvider.get(req));
    rdr.append('#');
    if (arsp.isNew() && !token.startsWith(PageLinks.REGISTER + "/")) {
        rdr.append(PageLinks.REGISTER);
    }
    rdr.append(token);
    webSession.get().login(arsp, true);
    rsp.sendRedirect(rdr.toString());
}
#end_block

#method_before
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo result) {
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            Util.PROJECT_SVC.listBranches(getProjectKey(), new GerritCallback<ListBranchesResult>() {

                @Override
                public void onSuccess(ListBranchesResult result) {
                    display(result.getBranches());
                }
            });
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseStartingRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    final Repository repo = repoManager.openRepository(rsrc.getNameKey());
    try {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        if (!refControl.canCreate(rw, object)) {
            throw new IllegalStateException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo b = new BranchInfo();
            b.ref = ref;
            b.revision = revid.getName();
            b.setCanDelete(refControl.canDelete());
            return b;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    } finally {
        repo.close();
    }
}
#end_block

#method_before
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return trimTrailingSlashes(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#method_after
private static String getGerritUrl(String canonicalWebUrl) {
    if (canonicalWebUrl != null) {
        return CharMatcher.is('/').trimTrailingFrom(canonicalWebUrl);
    } else {
        return "http://" + getGerritHost(canonicalWebUrl);
    }
}
#end_block

#method_before
private static String getGerritHost(String canonicalWebUrl) {
    String host = null;
    if (canonicalWebUrl != null) {
        try {
            host = new URL(canonicalWebUrl).getHost();
        } catch (MalformedURLException e) {
        // Ignore
        }
    }
    if (host == null) {
        host = SystemReader.getInstance().getHostname();
    }
    return trimTrailingSlashes(host);
}
#method_after
private static String getGerritHost(String canonicalWebUrl) {
    String host;
    if (canonicalWebUrl != null) {
        try {
            host = new URL(canonicalWebUrl).getHost();
        } catch (MalformedURLException e) {
            host = SystemReader.getInstance().getHostname();
        }
    } else {
        host = SystemReader.getInstance().getHostname();
    }
    return host;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), CHILD_PROJECT_KIND);
    DynamicMap.mapOf(binder(), BRANCH_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    child(PROJECT_KIND, "children").to(ChildProjectsCollection.class);
    get(CHILD_PROJECT_KIND).to(GetChildProject.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    get(PROJECT_KIND, "statistics.git").to(GetStatistics.class);
    post(PROJECT_KIND, "gc").to(GarbageCollect.class);
    child(PROJECT_KIND, "branches").to(BranchesCollection.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
    get(PROJECT_KIND, "config").to(GetConfig.class);
}
#end_block

#method_before
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = new HashSet<String>();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#method_after
@Override
public List<BranchInfo> apply(ProjectResource rsrc) throws ResourceNotFoundException, IOException {
    List<BranchInfo> branches = Lists.newArrayList();
    BranchInfo headBranch = null;
    BranchInfo configBranch = null;
    final Set<String> targets = Sets.newHashSet();
    final Repository db;
    try {
        db = repoManager.openRepository(rsrc.getNameKey());
    } catch (RepositoryNotFoundException noGitRepository) {
        throw new ResourceNotFoundException();
    }
    try {
        final Map<String, Ref> all = db.getAllRefs();
        if (!all.containsKey(Constants.HEAD)) {
            // 
            try {
                Ref head = db.getRef(Constants.HEAD);
                if (head != null) {
                    all.put(Constants.HEAD, head);
                }
            } catch (IOException e) {
            // Ignore the failure reading HEAD.
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                targets.add(ref.getTarget().getName());
            }
        }
        for (final Ref ref : all.values()) {
            if (ref.isSymbolic()) {
                // A symbolic reference to another branch, instead of
                // showing the resolved value, show the name it references.
                // 
                String target = ref.getTarget().getName();
                RefControl targetRefControl = rsrc.getControl().controlForRef(target);
                if (!targetRefControl.isVisible()) {
                    continue;
                }
                if (target.startsWith(Constants.R_HEADS)) {
                    target = target.substring(Constants.R_HEADS.length());
                }
                BranchInfo b = new BranchInfo();
                b.ref = ref.getName();
                b.revision = target;
                if (Constants.HEAD.equals(ref.getName())) {
                    b.setCanDelete(false);
                    headBranch = b;
                } else {
                    b.setCanDelete(targetRefControl.canDelete());
                    branches.add(b);
                }
                continue;
            }
            final RefControl refControl = rsrc.getControl().controlForRef(ref.getName());
            if (refControl.isVisible()) {
                if (ref.getName().startsWith(Constants.R_HEADS)) {
                    branches.add(createBranchInfo(ref, refControl, targets));
                } else if (GitRepositoryManager.REF_CONFIG.equals(ref.getName())) {
                    configBranch = createBranchInfo(ref, refControl, targets);
                }
            }
        }
    } finally {
        db.close();
    }
    Collections.sort(branches, new Comparator<BranchInfo>() {

        @Override
        public int compare(final BranchInfo a, final BranchInfo b) {
            return a.ref.compareTo(b.ref);
        }
    });
    if (configBranch != null) {
        branches.add(0, configBranch);
    }
    if (headBranch != null) {
        branches.add(0, headBranch);
    }
    return branches;
}
#end_block

#method_before
private BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#method_after
private static BranchInfo createBranchInfo(Ref ref, RefControl refControl, Set<String> targets) {
    BranchInfo b = new BranchInfo();
    b.ref = ref.getName();
    if (ref.getObjectId() != null) {
        b.revision = ref.getObjectId().name();
    }
    b.setCanDelete(!targets.contains(ref.getName()) && refControl.canDelete());
    return b;
}
#end_block

#method_before
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(info.canDelete != null ? true : false);
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#method_after
@Override
public ListBranchesResult call() throws NoSuchProjectException, IOException {
    ProjectControl pctl = projectControlFactory.validateFor(projectName, ProjectControl.OWNER | ProjectControl.VISIBLE);
    try {
        List<Branch> branches = Lists.newArrayList();
        List<BranchInfo> branchInfos = listBranchesProvider.get().apply(new ProjectResource(pctl));
        for (BranchInfo info : branchInfos) {
            Branch b = new Branch(new Branch.NameKey(projectName, info.ref));
            b.setRevision(new RevId(info.revision));
            b.setCanDelete(Objects.firstNonNull(info.canDelete, false));
            branches.add(b);
        }
        return new ListBranchesResult(branches, pctl.canAddRefs(), false);
    } catch (ResourceNotFoundException e) {
        throw new NoSuchProjectException(projectName);
    }
}
#end_block

#method_before
@Override
public ProjectState get(final Project.NameKey projectName) {
    try {
        return getChecked(projectName);
    } catch (IOException e) {
        return null;
    }
}
#method_after
@Override
public ProjectState get(final Project.NameKey projectName) {
    try {
        return checkedGet(projectName);
    } catch (IOException e) {
        return null;
    }
}
#end_block

#method_before
public static File createTempDirectory() throws IOException {
    String dt = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File tmp = File.createTempFile("gerrit_test_" + dt + "_", "_site");
    if (!tmp.delete() || !tmp.mkdir()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#method_after
public static File createTempDirectory() throws IOException {
    File tmp = File.createTempFile("gerrit_test_", "");
    if (!tmp.delete() || !tmp.mkdir()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#end_block

#method_before
public static void recursivelyDelete(File dir) throws IOException {
    if (!dir.getPath().equals(dir.getCanonicalPath())) {
        // Directory symlink reaching outside of temporary space.
        throw new IOException("Refusing to clear symlink " + dir.getPath());
    }
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                d.delete();
            }
        }
        dir.delete();
    }
}
#method_after
public static void recursivelyDelete(File dir) throws IOException {
    if (!dir.getPath().equals(dir.getCanonicalPath())) {
        // Directory symlink reaching outside of temporary space.
        throw new IOException("Refusing to clear symlink " + dir.getPath());
    }
    File[] contents = dir.listFiles();
    if (contents != null) {
        for (File d : contents) {
            if (d.isDirectory()) {
                recursivelyDelete(d);
            } else {
                deleteNowOrOnExit(d);
            }
        }
    }
    deleteNowOrOnExit(dir);
}
#end_block

#method_before
private File random() throws IOException {
    String dt = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
    File tmp = File.createTempFile("gerrit_test_" + dt + "_", "_site");
    if (!tmp.delete()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#method_after
private static File random() throws IOException {
    File tmp = File.createTempFile("gerrit_test_", "_site");
    if (!tmp.delete()) {
        throw new IOException("Cannot create " + tmp.getPath());
    }
    return tmp;
}
#end_block

#method_before
public Change insertPatchSet(Change change, final PatchSet patchSet, final RevCommit commit, RefControl refControl, ChangeMessage cMessage, boolean copyLabels) throws OrmException, InvalidChangeOperationException, NoSuchChangeException {
    final Change.Id changeId = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    final PatchSet originalPS = db.patchSets().get(currentPatchSetId);
    if (originalPS == null) {
        throw new NoSuchChangeException(changeId);
    }
    db.changes().beginTransaction(change.getId());
    try {
        Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    return change;
                } else {
                    return null;
                }
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), originalPS.getId(), change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        if (cMessage != null) {
            db.changeMessages().insert(Collections.singleton(cMessage));
        }
        db.commit();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return change;
}
#method_after
public Change insertPatchSet(Change change, final PatchSet patchSet, final RevCommit commit, RefControl refControl, String message, boolean copyLabels) throws OrmException, InvalidChangeOperationException, NoSuchChangeException {
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (patchSet.getId().get() <= currentPatchSetId.get()) {
        throw new InvalidChangeOperationException("New Patch Set ID [" + patchSet.getId().get() + "] is not greater than the current Patch Set ID [" + currentPatchSetId.get() + "]");
    }
    db.changes().beginTransaction(change.getId());
    try {
        if (!db.changes().get(change.getId()).getStatus().isOpen()) {
            throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
        }
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isClosed()) {
                    return null;
                }
                if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                    return null;
                }
                if (change.getStatus() != Change.Status.DRAFT) {
                    change.setStatus(Change.Status.NEW);
                }
                change.setLastSha1MergeTested(null);
                change.setCurrentPatchSet(patchSetInfoFactory.get(commit, patchSet.getId()));
                ChangeUtil.updated(change);
                return change;
            }
        });
        if (updatedChange != null) {
            change = updatedChange;
        } else {
            throw new ChangeModifiedException(String.format("Change %s was modified", change.getId()));
        }
        if (copyLabels) {
            ApprovalsUtil.copyLabels(db, refControl.getProjectControl().getLabelTypes(), currentPatchSetId, change.currentPatchSetId());
        }
        final List<FooterLine> footerLines = commit.getFooterLines();
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        if (message != null) {
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getId());
            cmsg.setMessage(message);
            db.changeMessages().insert(Collections.singleton(cmsg));
        }
        db.commit();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
    } finally {
        db.rollback();
    }
    return change;
}
#end_block

#method_before
public Collection<PatchSet> patches(Provider<ReviewDb> db) throws OrmException {
    if (patches == null) {
        if (limitedIds != null) {
            patches = Lists.newArrayList();
            for (PatchSet ps : db.get().patchSets().byChange(legacyId)) {
                if (limitedIds.contains(ps.getId())) {
                    patches.add(ps);
                }
            }
        } else {
            patches = db.get().patchSets().byChange(legacyId).toList();
        }
    }
    return patches;
}
#method_after
public Collection<PatchSet> patches(Provider<ReviewDb> db) throws OrmException {
    if (patches == null || !patchesLoaded) {
        if (limitedIds != null) {
            patches = Lists.newArrayList();
            for (PatchSet ps : db.get().patchSets().byChange(legacyId)) {
                if (limitedIds.contains(ps.getId())) {
                    patches.add(ps);
                }
            }
        } else {
            patches = db.get().patchSets().byChange(legacyId).toList();
        }
        patchesLoaded = true;
    }
    return patches;
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListGroupMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    // The following commands can be ran on a server in either Master or Slave
    // mode. If a command should only be used on a server in one mode, but not
    // both, it should be bound in both MasterCommandModule and
    // SlaveCommandModule.
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, BanCommitCommand.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    // 
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command("git-receive-pack").to(Commands.key(git, "receive-pack"));
    command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
    command("suexec").to(SuExec.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().to(ShowCaches.StartupListener.class);
        }
    });
}
#end_block

#method_before
@Override
public Object apply(RevisionResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.get().parse(resource.getChangeResource(), IdString.fromUrl(base));
        basePatchSet = baseResource.getPatchSet();
    }
    return fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet(), basePatchSet);
}
#method_after
@Override
public Object apply(RevisionResource resource) throws ResourceNotFoundException, OrmException, PatchListNotAvailableException {
    PatchSet basePatchSet = null;
    if (base != null) {
        RevisionResource baseResource = revisions.get().parse(resource.getChangeResource(), IdString.fromDecoded(base));
        basePatchSet = baseResource.getPatchSet();
    }
    return fileInfoJson.toFileInfoMap(resource.getChange(), resource.getPatchSet(), basePatchSet);
}
#end_block

#method_before
private void displayUserIdentity(final int row, final UserIdentity who) {
    if (who == null) {
        infoTable.clearCell(row, 1);
        return;
    }
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().patchSetUserIdentity());
    if (who.getName() != null) {
        if (who.getAccount() != null) {
            fp.add(new InlineHyperlink(who.getName(), PageLinks.toAccountQuery(who.getName())));
        } else {
            final InlineLabel lbl = new InlineLabel(who.getName());
            lbl.setStyleName(Gerrit.RESOURCES.css().accountName());
            fp.add(lbl);
        }
    }
    if (who.getEmail() != null) {
        fp.add(new InlineLabel("<" + who.getEmail() + ">"));
    }
    if (who.getDate() != null) {
        fp.add(new InlineLabel(FormatUtil.mediumFormat(who.getDate())));
    }
    infoTable.setWidget(row, 1, fp);
}
#method_after
private void displayUserIdentity(final int row, final UserIdentity who) {
    if (who == null) {
        infoTable.clearCell(row, 1);
        return;
    }
    final FlowPanel fp = new FlowPanel();
    fp.setStyleName(Gerrit.RESOURCES.css().patchSetUserIdentity());
    if (who.getName() != null) {
        if (who.getAccount() != null) {
            fp.add(new AccountLinkPanel(who));
        } else {
            final InlineLabel lbl = new InlineLabel(who.getName());
            lbl.setStyleName(Gerrit.RESOURCES.css().accountName());
            fp.add(lbl);
        }
    }
    if (who.getEmail() != null) {
        fp.add(new InlineLabel("<" + who.getEmail() + ">"));
    }
    if (who.getDate() != null) {
        fp.add(new InlineLabel(FormatUtil.mediumFormat(who.getDate())));
    }
    infoTable.setWidget(row, 1, fp);
}
#end_block

#method_before
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        CherryPickInput cherryPickInput = CherryPickInput.create();
                        cherryPickInput.setMessage(getMessageText());
                        cherryPickInput.setDestination(getDestinationBranch());
                        new RestApi("/changes/" + changeDetail.getChange().getId() + "/revisions/" + patchSet.getRevision().get() + "/cherrypick").data(cherryPickInput).post(new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new AsyncCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                new ErrorDialog(caught.getMessage()).center();
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#method_after
private void populateActions(final PatchSetDetail detail) {
    final boolean isOpen = changeDetail.getChange().getStatus().isOpen();
    if (isOpen && changeDetail.canSubmit()) {
        final Button b = new Button(Util.M.submitPatchSet(detail.getPatchSet().getPatchSetId()));
        if (Gerrit.getConfig().testChangeMerge()) {
            b.setEnabled(changeDetail.getChange().isMergeable());
        }
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                ChangeApi.submit(patchSet.getId().getParentKey().get(), patchSet.getRevision().get(), new GerritCallback<SubmitInfo>() {

                    public void onSuccess(SubmitInfo result) {
                        redisplay();
                    }

                    public void onFailure(Throwable err) {
                        if (SubmitFailureDialog.isConflict(err)) {
                            new SubmitFailureDialog(err.getMessage()).center();
                            redisplay();
                        } else {
                            b.setEnabled(true);
                            super.onFailure(err);
                        }
                    }

                    private void redisplay() {
                        Gerrit.display(PageLinks.toChange(patchSet.getId().getParentKey()), new ChangeScreen(patchSet.getId().getParentKey()));
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRevert()) {
        final Button b = new Button(Util.C.buttonRevertChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, true, Util.C.revertChangeTitle(), Util.C.headingRevertMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRevertChangeSend());
                        message.setText(Util.M.revertChangeDefaultMessage(detail.getInfo().getSubject(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.revert(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canCherryPick()) {
        final Button b = new Button(Util.C.buttonCherryPickChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new CherryPickDialog(b, changeDetail.getChange().getProject()) {

                    {
                        sendButton.setText(Util.C.buttonCherryPickChangeSend());
                        message.setText(Util.M.cherryPickedChangeDefaultMessage(detail.getInfo().getMessage().trim(), detail.getPatchSet().getRevision().get()));
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.cherrypick(changeDetail.getChange().getChangeId(), patchSet.getRevision().get(), getDestinationBranch(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canAbandon()) {
        final Button b = new Button(Util.C.buttonAbandonChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.abandonChangeTitle(), Util.C.headingAbandonMessage()) {

                    {
                        sendButton.setText(Util.C.buttonAbandonChangeSend());
                    }

                    @Override
                    public void onSend() {
                        // TODO: once the other users of ActionDialog have converted to
                        // REST APIs, we can use createCallback() rather than providing
                        // them directly.
                        ChangeApi.abandon(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.getChange().getStatus() == Change.Status.DRAFT && changeDetail.canDeleteDraft()) {
        final Button b = new Button(Util.C.buttonDeleteDraftChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.deleteDraftChange(patchSet.getId(), new GerritCallback<VoidResult>() {

                    public void onSuccess(VoidResult result) {
                        Gerrit.display(PageLinks.MINE);
                    }

                    @Override
                    public void onFailure(Throwable caught) {
                        b.setEnabled(true);
                        super.onFailure(caught);
                    }
                });
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRestore()) {
        final Button b = new Button(Util.C.buttonRestoreChangeBegin());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                new ActionDialog(b, false, Util.C.restoreChangeTitle(), Util.C.headingRestoreMessage()) {

                    {
                        sendButton.setText(Util.C.buttonRestoreChangeSend());
                    }

                    @Override
                    public void onSend() {
                        ChangeApi.restore(changeDetail.getChange().getChangeId(), getMessageText(), new GerritCallback<ChangeInfo>() {

                            @Override
                            public void onSuccess(ChangeInfo result) {
                                sent = true;
                                Gerrit.display(PageLinks.toChange(new Change.Id(result._number())));
                                hide();
                            }

                            @Override
                            public void onFailure(Throwable caught) {
                                enableButtons(true);
                                super.onFailure(caught);
                            }
                        });
                    }
                }.center();
            }
        });
        actionsPanel.add(b);
    }
    if (changeDetail.canRebase()) {
        final Button b = new Button(Util.C.buttonRebaseChange());
        b.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(final ClickEvent event) {
                b.setEnabled(false);
                Util.MANAGE_SVC.rebaseChange(patchSet.getId(), new ChangeDetailCache.GerritWidgetCallback(b));
            }
        });
        actionsPanel.add(b);
    }
}
#end_block

#method_before
@Override
public boolean match(Repository repo, RevWalk rw, AnyObjectId objectId) {
    try {
        return rFilter.include(rw, rw.parseCommit(objectId));
    } catch (MissingObjectException e) {
        log.error(objectId.getName() + " commit does not exist.", e);
    } catch (IncorrectObjectTypeException e) {
        log.error(objectId.getName() + " revision is not a commit.", e);
    } catch (IOException e) {
        log.error("Could not search for commit message in " + objectId.getName(), e);
    }
    return false;
}
#method_after
@Override
public boolean match(Repository repo, RevWalk rw, Arguments args) {
    try {
        return rFilter.include(rw, rw.parseCommit(args.objectId));
    } catch (MissingObjectException e) {
        log.error(args.projectName.get() + "\" commit does not exist.", e);
    } catch (IncorrectObjectTypeException e) {
        log.error(args.projectName.get() + "\" revision is not a commit.", e);
    } catch (IOException e) {
        log.error("Could not search for commit message in \"" + args.projectName.get() + "\" repository.", e);
    }
    return false;
}
#end_block

#method_before
@Override
public boolean match(ChangeData object) throws OrmException {
    final PatchSet patchSet = object.currentPatchSet(db);
    if (patchSet == null) {
        throw new OrmException("Unable to read patchset for " + object.getId());
    }
    final RevId revision = patchSet.getRevision();
    if (revision == null) {
        throw new OrmException("Unable to read revision for " + object.getId());
    }
    final AnyObjectId objectId = ObjectId.fromString(revision.get());
    if (objectId == null) {
        throw new OrmException("Unable to read objectId(SHA-1) for " + object.getId());
    }
    Change change = object.change(db);
    if (change == null) {
        throw new OrmException("Unable to get change for " + object.getId());
    }
    final Project.NameKey projectName = change.getProject();
    if (projectName == null) {
        throw new OrmException("Unable to get projectName for " + object.getId());
    }
    try {
        final Repository repo = repoManager.openRepository(projectName);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                return match(repo, rw, objectId);
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryNotFoundException e) {
        log.error(projectName.get() + " does not denote an existing repository", e);
    } catch (IOException e) {
        log.error(projectName.get() + " cannot be read as a repository", e);
    }
    return false;
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    final PatchSet patchSet = object.currentPatchSet(db);
    if (patchSet == null) {
        return false;
    }
    final RevId revision = patchSet.getRevision();
    if (revision == null) {
        return false;
    }
    final AnyObjectId objectId = ObjectId.fromString(revision.get());
    if (objectId == null) {
        return false;
    }
    Change change = object.change(db);
    if (change == null) {
        return false;
    }
    final Project.NameKey projectName = change.getProject();
    if (projectName == null) {
        return false;
    }
    Arguments args = new Arguments(patchSet, revision, objectId, change, projectName);
    try {
        final Repository repo = repoManager.openRepository(projectName);
        try {
            final RevWalk rw = new RevWalk(repo);
            try {
                return match(repo, rw, args);
            } finally {
                rw.release();
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Repository \"" + projectName.get() + "\" unknown.", e);
    } catch (IOException e) {
        log.error(projectName.get() + " cannot be read as a repository", e);
    }
    return false;
}
#end_block

#method_before
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(script, nc);
    lines.add(null);
    if (!isDisplayBinary) {
        if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
            openLine(nc);
            appendModeLine(nc, script.getFileModeA());
            appendModeLine(nc, script.getFileModeB());
            closeLine(nc);
            lines.add(null);
        }
        if (hasDifferences(script)) {
            int lastA = 0;
            int lastB = 0;
            final boolean ignoreWS = script.isIgnoreWhitespace();
            a = getSparseHtmlFileA(script);
            b = getSparseHtmlFileB(script);
            final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
            for (final EditList.Hunk hunk : script.getHunks()) {
                if (!hunk.isStartOfFile()) {
                    appendSkipLine(nc, hunk.getCurB() - lastB);
                    lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
                }
                while (hunk.next()) {
                    if (hunk.isContextLine()) {
                        openLine(nc);
                        final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                        appendLineNumber(nc, hunk.getCurA(), false);
                        appendLineText(nc, CONTEXT, ctx, false, false);
                        if (ignoreWS && b.contains(hunk.getCurB())) {
                            appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                        } else {
                            appendLineText(nc, CONTEXT, ctx, false, false);
                        }
                        appendLineNumber(nc, hunk.getCurB(), true);
                        closeLine(nc);
                        hunk.incBoth();
                        lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
                    } else if (hunk.isModifiedLine()) {
                        final boolean del = hunk.isDeletedA();
                        final boolean ins = hunk.isInsertedB();
                        final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                        openLine(nc);
                        if (del) {
                            appendLineNumber(nc, hunk.getCurA(), false);
                            appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                            hunk.incA();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, DELETE);
                        } else {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, CONTEXT);
                        }
                        if (ins) {
                            appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                            appendLineNumber(nc, hunk.getCurB(), true);
                            hunk.incB();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNone(nc, INSERT);
                            appendLineNumber(nc, true);
                        } else {
                            appendLineNone(nc, CONTEXT);
                            appendLineNumber(nc, true);
                        }
                        closeLine(nc);
                        if (del && ins) {
                            lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                        } else if (del) {
                            lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                        } else if (ins) {
                            lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                        }
                    }
                }
                lastA = hunk.getCurA();
                lastB = hunk.getCurB();
            }
            if (lastB != b.size()) {
                appendSkipLine(nc, b.size() - lastB);
                lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
            }
        }
    } else {
        // Display the patch header for binary
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
        // If there is a picture involved, we show it
        if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImageLine(script, nc);
        }
    }
    if (!hasDifferences(script)) {
        appendNoDifferences(nc);
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    if (hasDifferences(script)) {
        initScript(script);
        if (!isDisplayBinary) {
            for (int row = 0; row < lines.size(); row++) {
                setRowItem(row, lines.get(row));
                if (lines.get(row) instanceof SkippedLine) {
                    createSkipLine(row, (SkippedLine) lines.get(row));
                }
            }
        }
    }
}
#method_after
@Override
protected void render(final PatchScript script, final PatchSetDetail detail) {
    final ArrayList<Object> lines = new ArrayList<Object>();
    final SafeHtmlBuilder nc = new SafeHtmlBuilder();
    allocateTableHeader(script, nc);
    lines.add(null);
    if (!isDisplayBinary) {
        if (script.getFileModeA() != FileMode.FILE || script.getFileModeB() != FileMode.FILE) {
            openLine(nc);
            appendModeLine(nc, script.getFileModeA());
            appendModeLine(nc, script.getFileModeB());
            closeLine(nc);
            lines.add(null);
        }
        if (hasDifferences(script)) {
            int lastA = 0;
            int lastB = 0;
            final boolean ignoreWS = script.isIgnoreWhitespace();
            a = getSparseHtmlFileA(script);
            b = getSparseHtmlFileB(script);
            final boolean intraline = script.getDiffPrefs().isIntralineDifference() && script.hasIntralineDifference();
            for (final EditList.Hunk hunk : script.getHunks()) {
                if (!hunk.isStartOfFile()) {
                    appendSkipLine(nc, hunk.getCurB() - lastB);
                    lines.add(new SkippedLine(lastA, lastB, hunk.getCurB() - lastB));
                }
                while (hunk.next()) {
                    if (hunk.isContextLine()) {
                        openLine(nc);
                        final SafeHtml ctx = a.getSafeHtmlLine(hunk.getCurA());
                        appendLineNumber(nc, hunk.getCurA(), false);
                        appendLineText(nc, CONTEXT, ctx, false, false);
                        if (ignoreWS && b.contains(hunk.getCurB())) {
                            appendLineText(nc, CONTEXT, b, hunk.getCurB(), false);
                        } else {
                            appendLineText(nc, CONTEXT, ctx, false, false);
                        }
                        appendLineNumber(nc, hunk.getCurB(), true);
                        closeLine(nc);
                        hunk.incBoth();
                        lines.add(new PatchLine(CONTEXT, hunk.getCurA(), hunk.getCurB()));
                    } else if (hunk.isModifiedLine()) {
                        final boolean del = hunk.isDeletedA();
                        final boolean ins = hunk.isInsertedB();
                        final boolean full = intraline && hunk.getCurEdit().getType() != Edit.Type.REPLACE;
                        openLine(nc);
                        if (del) {
                            appendLineNumber(nc, hunk.getCurA(), false);
                            appendLineText(nc, DELETE, a, hunk.getCurA(), full);
                            hunk.incA();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, DELETE);
                        } else {
                            appendLineNumber(nc, false);
                            appendLineNone(nc, CONTEXT);
                        }
                        if (ins) {
                            appendLineText(nc, INSERT, b, hunk.getCurB(), full);
                            appendLineNumber(nc, hunk.getCurB(), true);
                            hunk.incB();
                        } else if (hunk.getCurEdit().getType() == Edit.Type.REPLACE) {
                            appendLineNone(nc, INSERT);
                            appendLineNumber(nc, true);
                        } else {
                            appendLineNone(nc, CONTEXT);
                            appendLineNumber(nc, true);
                        }
                        closeLine(nc);
                        if (del && ins) {
                            lines.add(new PatchLine(REPLACE, hunk.getCurA(), hunk.getCurB()));
                        } else if (del) {
                            lines.add(new PatchLine(DELETE, hunk.getCurA(), -1));
                        } else if (ins) {
                            lines.add(new PatchLine(INSERT, -1, hunk.getCurB()));
                        }
                    }
                }
                lastA = hunk.getCurA();
                lastB = hunk.getCurB();
            }
            if (lastB != b.size()) {
                appendSkipLine(nc, b.size() - lastB);
                lines.add(new SkippedLine(lastA, lastB, b.size() - lastB));
            }
        }
    } else {
        // Display the patch header for binary
        for (final String line : script.getPatchHeader()) {
            appendFileHeader(nc, line);
        }
        // If there is a safe picture involved, we show it
        if (script.getDisplayMethodA() == DisplayMethod.IMG || script.getDisplayMethodB() == DisplayMethod.IMG) {
            appendImageLine(script, nc);
        }
    }
    if (!hasDifferences(script)) {
        appendNoDifferences(nc);
    }
    resetHtml(nc);
    populateTableHeader(script, detail);
    if (hasDifferences(script)) {
        initScript(script);
        if (!isDisplayBinary) {
            for (int row = 0; row < lines.size(); row++) {
                setRowItem(row, lines.get(row));
                if (lines.get(row) instanceof SkippedLine) {
                    createSkipLine(row, (SkippedLine) lines.get(row));
                }
            }
        }
    }
}
#end_block

#method_before
private void appendImageLine(final PatchScript script, final SafeHtmlBuilder m) {
    final String rawBase = GWT.getHostPageBaseURL() + "cat/";
    m.openTr();
    m.setAttribute("valign", "center");
    m.setAttribute("align", "center");
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconCell());
    m.closeTd();
    appendLineNumber(m, false);
    if (script.getDisplayMethodA() == DisplayMethod.IMG) {
        final String url;
        if (idSideA == null) {
            url = rawBase + KeyUtil.encode(patchKey.toString()) + "^1";
        } else {
            Patch.Key k = new Patch.Key(idSideA, patchKey.get());
            url = rawBase + KeyUtil.encode(k.toString()) + "^0";
        }
        appendLineText(m, DELETE, createImage(url), false, true);
    } else {
        appendLineNone(m, DELETE);
    }
    if (script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String url = rawBase + KeyUtil.encode(patchKey.toString()) + "^0";
        appendLineText(m, INSERT, createImage(url), false, true);
    } else {
        appendLineNone(m, INSERT);
    }
    appendLineNumber(m, true);
    m.closeTr();
}
#method_after
private void appendImageLine(final PatchScript script, final SafeHtmlBuilder m) {
    m.openTr();
    m.setAttribute("valign", "center");
    m.setAttribute("align", "center");
    m.openTd();
    m.setStyleName(Gerrit.RESOURCES.css().iconCell());
    m.closeTd();
    appendLineNumber(m, false);
    if (script.getDisplayMethodA() == DisplayMethod.IMG) {
        final String url = getUrlA();
        appendLineText(m, DELETE, createImage(url), false, true);
    } else {
        appendLineNone(m, DELETE);
    }
    if (script.getDisplayMethodB() == DisplayMethod.IMG) {
        final String url = getUrlB();
        appendLineText(m, INSERT, createImage(url), false, true);
    } else {
        appendLineNone(m, INSERT);
    }
    appendLineNumber(m, true);
    m.closeTr();
}
#end_block

#method_before
/**
 * Get specificity of mime types with generic types forced to low values
 *
 * "application/octet-stream" is forced to -1.
 * "text/plain" is forced to 0.
 * All other mime types return the specificity reported by mimeType itself.
 *
 * @param mimeType The mimeType to get the corrected specificity for.
 * @return The corrected specificity.
 */
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    final int ret;
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        ret = -1;
    } else if (mimeTypeStr.equals("text/plain")) {
        ret = 0;
    } else {
        ret = mimeType.getSpecificity();
    }
    return ret;
}
#method_after
private int getCorrectedMimeSpecificity(MimeType mimeType) {
    // Although the documentation of MimeType's getSpecificity claims that for
    // example "application/octet-stream" always has a specificity of 0, it
    // effectively returns 1 for us. This causes problems when trying to get
    // the correct mime type via sorting. For example in
    // [application/octet-stream, image/x-icon] both mime types come with
    // specificity 1 for us. Hence, getMimeType below may end up using
    // application/octet-stream instead of the more specific image/x-icon.
    // Therefore, we have to force the specificity of generic types below the
    // default of 1.
    // 
    final String mimeTypeStr = mimeType.toString();
    if (mimeTypeStr.equals("application/octet-stream")) {
        return -1;
    }
    if (mimeTypeStr.equals("text/plain")) {
        return 0;
    }
    return mimeType.getSpecificity();
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.isDraft() && magicBranch.isSubmit()) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.isSubmit() && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(magicBranch.cmd.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, ps);
    }
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    changeInserter.insertChange(db, change, ps, commit, labelTypes, footerLines, info, recipients.getReviewers());
    created = true;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(projectControl.controlFor(change), ps);
    }
}
#end_block

#method_before
private void submit(Change change, PatchSet ps) throws OrmException {
    if (!projectControl.controlForRef(MagicBranch.NEW_CHANGE + change.getDest().get()).canSubmit()) {
        addError("Submitting of change " + change.getChangeId() + " not allowed.");
    } else {
        Change c = SubmitChange.submit(db, change, ps, currentUser);
        if (c == null) {
            addError("Submitting change " + change.getChangeId() + " failed.");
        } else {
            addMessage("");
            mergeQueue.merge(c.getDest());
            c = db.changes().get(c.getId());
            switch(c.getStatus()) {
                case SUBMITTED:
                    addMessage("Change " + c.getChangeId() + " submitted.");
                    break;
                case MERGED:
                    addMessage("Change " + c.getChangeId() + " merged.");
                    break;
                case NEW:
                    // If the merge was attempted and it failed the system usually
                    // writes a comment as a ChangeMessage and sets status to NEW.
                    // Find the relevant message and report that as the conflict.
                    final Timestamp before = change.getLastUpdatedOn();
                    ChangeMessage msg = Iterables.getFirst(Iterables.filter(Lists.reverse(db.changeMessages().byChange(c.getId()).toList()), new Predicate<ChangeMessage>() {

                        @Override
                        public boolean apply(ChangeMessage input) {
                            return input.getAuthor() == null && input.getWrittenOn().getTime() >= before.getTime();
                        }
                    }), null);
                    if (msg != null) {
                        addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                        break;
                    }
                default:
                    addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
            }
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(new ChangeResource(changeCtl), ps);
    Change c = submit.submit(rsrc, currentUser);
    if (c == null) {
        addError("Submitting change " + changeCtl.getChange().getChangeId() + " failed.");
    } else {
        addMessage("");
        mergeQueue.merge(c.getDest());
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(change, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        ChangeUtil.insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        final MailRecipients oldRecipients = getRecipientsFromApprovals(ApprovalsUtil.copyLabels(db, labelTypes, priorPatchSet, newPatchSet.getId()));
        approvalsUtil.addReviewers(db, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    if (magicBranch != null && magicBranch.isSubmit()) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
protected SparseHtmlFile getSparseHtmlFileB(PatchScript s) {
    AccountDiffPreference dp = new AccountDiffPreference(s.getDiffPrefs());
    PrettyFormatter f = ClientSideFormatter.FACTORY.get();
    f.setDiffPrefs(dp);
    f.setFileName(s.getB().getPath());
    f.setEditFilter(PrettyFormatter.B);
    f.setEditList(s.getEdits());
    if ((dp.isSyntaxHighlighting() || dp.getContext() != AccountDiffPreference.WHOLE_FILE_CONTEXT) && s.getA().isWholeFile() && !s.getB().isWholeFile()) {
        f.format(s.getB().apply(s.getA(), s.getEdits()));
    } else {
        f.format(s.getB());
    }
    return f;
}
#method_after
protected SparseHtmlFile getSparseHtmlFileB(PatchScript s) {
    AccountDiffPreference dp = new AccountDiffPreference(s.getDiffPrefs());
    SparseFileContent b = s.getB();
    PrettyFormatter f = ClientSideFormatter.FACTORY.get();
    f.setDiffPrefs(dp);
    f.setFileName(b.getPath());
    f.setEditFilter(PrettyFormatter.B);
    f.setEditList(s.getEdits());
    if (s.getA().isWholeFile() && !b.isWholeFile()) {
        b = b.apply(s.getA(), s.getEdits());
    }
    f.format(b);
    return f;
}
#end_block

#method_before
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<Edit>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<Edit>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    ensureCommentsVisible(comments);
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<Edit>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            diffPrefs.setContext((short) Math.min(25, context));
            diffPrefs.setSyntaxHighlighting(false);
            context = diffPrefs.getContext();
            hugeFile = true;
        } else if (diffPrefs.isSyntaxHighlighting() || diffPrefs.getContext() != AccountDiffPreference.WHOLE_FILE_CONTEXT) {
            // In order to expand the skipped common lines or syntax highlight the
            // file properly we need to give the client the complete file contents.
            // So force our context temporarily to the complete file size.
            // 
            context = MAX_CONTEXT;
        }
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure);
}
#method_after
private PatchScript build(final PatchListEntry content, final CommentDetail comments, final List<Patch> history) throws IOException {
    boolean intralineDifferenceIsPossible = true;
    boolean intralineFailure = false;
    a.path = oldName(content);
    b.path = newName(content);
    a.resolve(null, aId);
    b.resolve(a, bId);
    edits = new ArrayList<Edit>(content.getEdits());
    if (!isModify(content)) {
        intralineDifferenceIsPossible = false;
    } else if (diffPrefs.isIntralineDifference()) {
        IntraLineDiff d = patchListCache.getIntraLineDiff(new IntraLineDiffKey(a.id, a.src, b.id, b.src, edits, projectKey, bId, b.path, diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE));
        if (d != null) {
            switch(d.getStatus()) {
                case EDIT_LIST:
                    edits = new ArrayList<Edit>(d.getEdits());
                    break;
                case DISABLED:
                    intralineDifferenceIsPossible = false;
                    break;
                case ERROR:
                case TIMEOUT:
                    intralineDifferenceIsPossible = false;
                    intralineFailure = true;
                    break;
            }
        } else {
            intralineDifferenceIsPossible = false;
            intralineFailure = true;
        }
    }
    ensureCommentsVisible(comments);
    boolean hugeFile = false;
    if (a.mode == FileMode.GITLINK || b.mode == FileMode.GITLINK) {
    } else if (a.src == b.src && a.size() <= context && content.getEdits().isEmpty()) {
        // 
        for (int i = 0; i < a.size(); i++) {
            a.addLine(i);
        }
        edits = new ArrayList<Edit>(1);
        edits.add(new Edit(a.size(), a.size()));
    } else {
        if (BIG_FILE < Math.max(a.size(), b.size())) {
            // IF the file is really large, we disable things to avoid choking
            // the browser client.
            // 
            diffPrefs.setContext((short) Math.min(25, context));
            diffPrefs.setSyntaxHighlighting(false);
            context = diffPrefs.getContext();
            hugeFile = true;
        } else {
            // In order to expand the skipped common lines or syntax highlight the
            // file properly we need to give the client the complete file contents.
            // So force our context temporarily to the complete file size.
            // 
            context = MAX_CONTEXT;
        }
        packContent(diffPrefs.getIgnoreWhitespace() != Whitespace.IGNORE_NONE);
    }
    return new PatchScript(change.getKey(), content.getChangeType(), content.getOldName(), content.getNewName(), a.fileMode, b.fileMode, content.getHeaderLines(), diffPrefs, a.dst, b.dst, edits, a.displayMethod, b.displayMethod, comments, history, hugeFile, intralineDifferenceIsPossible, intralineFailure);
}
#end_block

#method_before
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS);
}
#method_after
public boolean canStreamEvents() {
    return canPerform(GlobalCapability.STREAM_EVENTS) || canAdministrateServer();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    defaultCommentVisibilityStrategy = new ListBox();
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    defaultCommentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.defaultCommentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, defaultCommentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(defaultCommentVisibilityStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    final Grid formGrid = new Grid(9, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(commentVisibilityStrategy);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    defaultCommentVisibilityStrategy.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(defaultCommentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getDefaultCommentVisibilityStrategy());
}
#method_after
private void display(final AccountGeneralPreferences p) {
    showSiteHeader.setValue(p.isShowSiteHeader());
    useFlashClipboard.setValue(p.isUseFlashClipboard());
    copySelfOnEmails.setValue(p.isCopySelfOnEmails());
    reversePatchSetOrder.setValue(p.isReversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.isShowUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.getMaximumPageSize());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.getDateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.getTimeFormat());
    relativeDateInChangeTable.setValue(p.isRelativeDateInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT, p.getCommentVisibilityStrategy());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setDefaultCommentVisibilityStrategy(getListBox(defaultCommentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_MOST_RECENT, CommentVisibilityStrategy.values()));
    enable(false);
    save.setEnabled(false);
    Util.ACCOUNT_SVC.changePreferences(p, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(final VoidResult result) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
        }

        @Override
        public void onFailure(final Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    final CommentVisibilityStrategy commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getDefaultCommentVisibilityStrategy();
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#method_after
private void addComments(final ChangeDetail detail) {
    comments.clear();
    final AccountInfoCache accts = detail.getAccounts();
    final List<ChangeMessage> msgList = detail.getMessages();
    HorizontalPanel title = new HorizontalPanel();
    title.setWidth("100%");
    title.add(new Label(Util.C.changeScreenComments()));
    if (msgList.size() > 1) {
        title.add(messagesMenuBar());
    }
    title.setStyleName(Gerrit.RESOURCES.css().blockHeader());
    comments.add(title);
    final long AGE = 7 * 24 * 60 * 60 * 1000L;
    final Timestamp aged = new Timestamp(System.currentTimeMillis() - AGE);
    CommentVisibilityStrategy commentVisibilityStrategy = CommentVisibilityStrategy.EXPAND_MOST_RECENT;
    if (Gerrit.isSignedIn()) {
        commentVisibilityStrategy = Gerrit.getUserAccount().getGeneralPreferences().getCommentVisibilityStrategy();
    }
    for (int i = 0; i < msgList.size(); i++) {
        final ChangeMessage msg = msgList.get(i);
        AccountInfo author;
        if (msg.getAuthor() != null) {
            author = FormatUtil.asInfo(accts.get(msg.getAuthor()));
        } else {
            author = AccountInfo.create(0, Util.C.messageNoAuthor(), null);
        }
        boolean isRecent;
        if (i == msgList.size() - 1) {
            isRecent = true;
        } else {
            // TODO Instead of opening messages by strict age, do it by "unread"?
            isRecent = msg.getWrittenOn().after(aged);
        }
        final CommentPanel cp = new CommentPanel(author, msg.getWrittenOn(), msg.getMessage());
        cp.setRecent(isRecent);
        cp.addStyleName(Gerrit.RESOURCES.css().commentPanelBorder());
        if (i == msgList.size() - 1) {
            cp.addStyleName(Gerrit.RESOURCES.css().commentPanelLast());
        }
        boolean isOpen = false;
        switch(commentVisibilityStrategy) {
            case COLLAPSE_ALL:
                break;
            case EXPAND_RECENT:
                isOpen = isRecent;
                break;
            case EXPAND_ALL:
                isOpen = true;
                break;
            case EXPAND_MOST_RECENT:
            default:
                isOpen = i == msgList.size() - 1;
                break;
        }
        cp.setOpen(isOpen);
        comments.add(cp);
    }
    final Button b = new Button(Util.C.changeScreenAddComment());
    b.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            PatchSet.Id currentPatchSetId = patchSetsBlock.getCurrentPatchSet().getId();
            Gerrit.display(Dispatcher.toPublish(currentPatchSetId));
        }
    });
    comments.add(b);
    comments.setVisible(msgList.size() > 0);
}
#end_block

#method_before
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = new ArrayList<NamedFactory<UserAuth>>();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; furhter errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#method_after
private void initUserAuth(final PublickeyAuthenticator pubkey, final GSSAuthenticator kerberosAuthenticator, String kerberosKeytab, String kerberosPrincipal) {
    List<NamedFactory<UserAuth>> authFactories = Lists.newArrayList();
    if (kerberosKeytab != null) {
        authFactories.add(new UserAuthGSS.Factory());
        log.info("Enabling kerberos with keytab " + kerberosKeytab);
        if (!new File(kerberosKeytab).canRead()) {
            log.error("Keytab " + kerberosKeytab + " does not exist or is not readable; further errors are possible");
        }
        kerberosAuthenticator.setKeytabFile(kerberosKeytab);
        if (kerberosPrincipal == null) {
            try {
                kerberosPrincipal = "host/" + InetAddress.getLocalHost().getCanonicalHostName();
            } catch (UnknownHostException e) {
                kerberosPrincipal = "host/localhost";
            }
        }
        log.info("Using kerberos principal " + kerberosPrincipal);
        if (!kerberosPrincipal.startsWith("host/")) {
            log.warn("Host principal does not start with host/ " + "which most SSH clients will supply automatically");
        }
        kerberosAuthenticator.setServicePrincipalName(kerberosPrincipal);
        setGSSAuthenticator(kerberosAuthenticator);
    }
    authFactories.add(new UserAuthPublicKey.Factory());
    setUserAuthFactories(authFactories);
    setPublickeyAuthenticator(pubkey);
}
#end_block

#method_before
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sd, SshUtil.createUser(sd, account, userFactory), sshScope, sshLog);
    } else {
        return false;
    }
}
#method_after
@Override
public boolean validateIdentity(final ServerSession session, final String identity) {
    final SshSession sd = session.getAttribute(SshSession.KEY);
    int at = identity.indexOf('@');
    String username;
    if (at == -1) {
        username = identity;
    } else {
        username = identity.substring(0, at);
    }
    AccountState state = accounts.getByUsername(username);
    Account account = state == null ? null : state.getAccount();
    boolean active = account != null && account.isActive();
    if (active) {
        return SshUtil.success(username, session, sshScope, sshLog, sd, SshUtil.createUser(sd, userFactory, account.getId()));
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc, Input input) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (input == null) {
        input = new Input();
    }
    AccountDiffPreference p = rsrc.getUser().getAccountDiffPreference();
    p.setContext(input.context);
    p.setExpandAllComments(input.expandAllComments);
    p.setIgnoreWhitespace(Objects.firstNonNull(input.ignoreWhitespace, AccountDiffPreference.DEFAULT_IGNORE_WHITESPACE));
    p.setIntralineDifference(input.intralineDifference);
    p.setLineLength(input.lineLength);
    p.setManualReview(input.manualReview);
    p.setRetainHeader(input.retainHeader);
    p.setShowLineEndings(input.showLineEndings);
    p.setShowTabs(input.showTabs);
    p.setShowWhitespaceErrors(input.showWhitespaceErrors);
    p.setSkipDeleted(input.skipDeleted);
    p.setSkipUncommented(input.skipUncommented);
    p.setSyntaxHighlighting(input.syntaxHighlighting);
    p.setTabSize(input.tabSize);
    db.accountDiffPreferences().upsert(Collections.singleton(p));
    return DiffPreferencesInfo.parse(p);
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc, Input input) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (input == null) {
        input = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountDiffPreference p;
    db.accounts().beginTransaction(accountId);
    try {
        p = db.accountDiffPreferences().get(accountId);
        if (p == null) {
            p = new AccountDiffPreference(accountId);
        }
        if (input.context != null) {
            p.setContext(input.context);
        }
        if (input.ignoreWhitespace != null) {
            p.setIgnoreWhitespace(input.ignoreWhitespace);
        }
        if (input.expandAllComments != null) {
            p.setExpandAllComments(input.expandAllComments);
        }
        if (input.intralineDifference != null) {
            p.setIntralineDifference(input.intralineDifference);
        }
        if (input.lineLength != null) {
            p.setLineLength(input.lineLength);
        }
        if (input.manualReview != null) {
            p.setManualReview(input.manualReview);
        }
        if (input.retainHeader != null) {
            p.setRetainHeader(input.retainHeader);
        }
        if (input.showLineEndings != null) {
            p.setShowLineEndings(input.showLineEndings);
        }
        if (input.showTabs != null) {
            p.setShowTabs(input.showTabs);
        }
        if (input.showWhitespaceErrors != null) {
            p.setShowWhitespaceErrors(input.showWhitespaceErrors);
        }
        if (input.skipDeleted != null) {
            p.setSkipDeleted(input.skipDeleted);
        }
        if (input.skipUncommented != null) {
            p.setSkipUncommented(input.skipUncommented);
        }
        if (input.syntaxHighlighting != null) {
            p.setSyntaxHighlighting(input.syntaxHighlighting);
        }
        if (input.tabSize != null) {
            p.setTabSize(input.tabSize);
        }
        db.accountDiffPreferences().upsert(Collections.singleton(p));
        db.commit();
    } finally {
        db.rollback();
    }
    return DiffPreferencesInfo.parse(p);
}
#end_block

#method_before
@Override
public Object apply(CommentResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#method_after
@Override
public Object apply(CommentResource rsrc) throws OrmException {
    AccountInfo.Loader accountLoader = accountLoaderFactory.create(true);
    CommentInfo ci = new CommentInfo(rsrc.getComment(), accountLoader);
    accountLoader.fill();
    return ci;
}
#end_block

#method_before
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = useAccountLoader() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#method_after
@Override
public Object apply(RevisionResource rsrc) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    Map<String, List<CommentInfo>> out = Maps.newTreeMap();
    AccountInfo.Loader accountLoader = includeAuthorInfo() ? accountLoaderFactory.create(true) : null;
    for (PatchLineComment c : listComments(rsrc)) {
        CommentInfo o = new CommentInfo(c, accountLoader);
        List<CommentInfo> list = out.get(o.path);
        if (list == null) {
            list = Lists.newArrayList();
            out.put(o.path, list);
        }
        o.path = null;
        list.add(o);
    }
    for (List<CommentInfo> list : out.values()) {
        Collections.sort(list, new Comparator<CommentInfo>() {

            @Override
            public int compare(CommentInfo a, CommentInfo b) {
                int c = firstNonNull(a.side, Side.REVISION).ordinal() - firstNonNull(b.side, Side.REVISION).ordinal();
                if (c == 0) {
                    c = firstNonNull(a.line, 0) - firstNonNull(b.line, 0);
                }
                if (c == 0) {
                    c = a.id.compareTo(b.id);
                }
                return c;
            }
        });
    }
    if (accountLoader != null) {
        accountLoader.fill();
    }
    return out;
}
#end_block

#method_before
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final GarbageCollectionProgressMonitor pm) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        pm.startGarbageCollection(projectName);
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(pm, (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            pm.endGarbageCollection();
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(final List<Project.NameKey> projectNames, final PrintWriter writer) {
    final GarbageCollectionResult result = new GarbageCollectionResult();
    if (!currentUser.getCapabilities().canRunGC()) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_PERMITTED, currentUser.getUserName()));
        return result;
    }
    for (final Project.NameKey projectName : projectNames) {
        writer.print("collecting garbage for \"" + projectName + "\":\n");
        try {
            final Repository repo = repoManager.openRepository(projectName);
            try {
                if (!(repo instanceof FileRepository)) {
                    result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_NOT_SUPPORTED, projectName));
                    continue;
                }
                GC.gc(new TextProgressMonitor(writer), (FileRepository) repo);
            } catch (IOException e) {
                log.error("garbage collection for project \"" + projectName + "\" failed", e);
                result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, projectName));
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException e) {
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, projectName));
        } finally {
            writer.print("done.\n\n");
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                collectGarbage();
            } finally {
                stdout.flush();
            }
        }
    });
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    startThread(new CommandRunnable() {

        @Override
        public void run() throws Exception {
            stdout = toPrintWriter(out);
            try {
                parseCommandLine();
                verifyCommandLine();
                runGC();
            } finally {
                stdout.flush();
            }
        }
    });
}
#end_block

#method_before
@Override
public void assertCanDelete(Project project) throws Exception {
    if (db.submoduleSubscriptions().bySuperProjectProject(project.getNameKey()).iterator().hasNext()) {
        throw new Exception("Cannot delete project " + project.getName() + ", it has subscribed submodules.");
    }
}
#method_after
@Override
public void assertCanDelete(Project project) throws Exception {
    if (db.submoduleSubscriptions().bySuperProjectProject(project.getNameKey()).iterator().hasNext()) {
        throw new Exception("Project has subscribed submodules.");
    }
}
#end_block

#method_before
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    // Don't let people delete All-Projects, that's stupid
    final String projectName = project.getProject().getName();
    if (project.getProject().getName().endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project.getProject());
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        stdout.print("Really delete " + project.getProject().getName() + "?\n");
        stdout.print("This is an operation which permanently deletes data. " + "This cannot be undone!\n");
        stdout.print("If you are sure you wish to delete this project, re-run\n" + "with the --yes-really-delete flag.\n");
        return;
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project.getProject());
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(" nonetheless, re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project.getProject());
    deleteFromDisk(project.getProject());
    // Clean up the cache
    projectCache.remove(project.getProject());
}
#method_after
@Override
public void run() throws UnloggedFailure, Failure, Exception {
    // Don't let people delete All-Projects, that's stupid
    final String projectName = project.getProject().getName();
    if (project.getProject().getName().endsWith(AllProjectsNameProvider.DEFAULT)) {
        throw new UnloggedFailure("Perhaps you meant to rm -fR " + site.site_path);
    }
    try {
        databaseDeleteHandler.assertCanDelete(project.getProject());
    } catch (Exception e) {
        throw new UnloggedFailure("Cannot delete project " + projectName + ": " + e.getMessage());
    }
    if (!yesReallyDelete) {
        stdout.print("Really delete " + project.getProject().getName() + "?\n");
        stdout.print("This is an operation which permanently deletes data. " + "This cannot be undone!\n");
        stdout.print("If you are sure you wish to delete this project, re-run\n" + "with the --yes-really-delete flag.\n");
        return;
    }
    if (!force) {
        Collection<String> warnings = databaseDeleteHandler.getWarnings(project.getProject());
        if (warnings != null && !warnings.isEmpty()) {
            StringBuilder msgBuilder = new StringBuilder();
            msgBuilder.append("There are warnings against deleting ");
            msgBuilder.append(projectName);
            msgBuilder.append(":\n");
            for (String warning : warnings) {
                msgBuilder.append(" * ");
                msgBuilder.append(warning);
                msgBuilder.append("\n");
            }
            msgBuilder.append("To really delete ");
            msgBuilder.append(projectName);
            msgBuilder.append(", re-run with the --force flag.");
            throw new UnloggedFailure(msgBuilder.toString());
        }
    }
    databaseDeleteHandler.delete(project.getProject());
    deleteFromDisk(project.getProject());
    // Clean up the cache
    projectCache.remove(project.getProject());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "head").to(GetHead.class);
    put(PROJECT_KIND, "head").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(ProjectsCollection.class);
    bind(DashboardsCollection.class);
    DynamicMap.mapOf(binder(), PROJECT_KIND);
    DynamicMap.mapOf(binder(), DASHBOARD_KIND);
    put(PROJECT_KIND).to(PutProject.class);
    get(PROJECT_KIND).to(GetProject.class);
    get(PROJECT_KIND, "description").to(GetDescription.class);
    put(PROJECT_KIND, "description").to(PutDescription.class);
    delete(PROJECT_KIND, "description").to(PutDescription.class);
    get(PROJECT_KIND, "parent").to(GetParent.class);
    put(PROJECT_KIND, "parent").to(SetParent.class);
    get(PROJECT_KIND, "HEAD").to(GetHead.class);
    put(PROJECT_KIND, "HEAD").to(SetHead.class);
    child(PROJECT_KIND, "dashboards").to(DashboardsCollection.class);
    get(DASHBOARD_KIND).to(GetDashboard.class);
    put(DASHBOARD_KIND).to(SetDashboard.class);
    delete(DASHBOARD_KIND).to(DeleteDashboard.class);
    install(new FactoryModuleBuilder().build(CreateProject.Factory.class));
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", input.ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.disableRefLog();
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc, Input input) throws AuthException, ResourceNotFoundException, BadRequestException, UnprocessableEntityException, IOException {
    if (!rsrc.getControl().isOwner()) {
        throw new AuthException("restricted to project owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.ref)) {
        throw new BadRequestException("ref required");
    }
    String ref = input.ref;
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        if (repo.getRef(ref) == null) {
            throw new UnprocessableEntityException(String.format("Ref Not Found: %s", ref));
        }
        if (!repo.getRef(Constants.HEAD).getTarget().getName().equals(ref)) {
            final RefUpdate u = repo.updateRef(Constants.HEAD, true);
            u.setRefLogIdent(identifiedUser.newRefLogIdent());
            RefUpdate.Result res = u.link(ref);
            switch(res) {
                case NO_CHANGE:
                case RENAMED:
                case FORCED:
                case NEW:
                    break;
                default:
                    throw new IOException("Setting HEAD failed with " + res);
            }
        }
        return ref;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        String headRef = repo.getRef(Constants.HEAD).getTarget().getName();
        if (!rsrc.getControl().controlForRef(headRef).isVisible()) {
            throw new AuthException();
        }
        return headRef;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#method_after
@Override
public String apply(ProjectResource rsrc) throws AuthException, ResourceNotFoundException, IOException {
    Repository repo = null;
    try {
        repo = repoManager.openRepository(rsrc.getNameKey());
        Ref head = repo.getRef(Constants.HEAD);
        if (head == null) {
            throw new ResourceNotFoundException(Constants.HEAD);
        } else if (head.isSymbolic()) {
            String n = head.getTarget().getName();
            if (rsrc.getControl().controlForRef(n).isVisible()) {
                return n;
            }
            throw new AuthException();
        } else if (head.getObjectId() != null) {
            if (rsrc.getControl().isOwner()) {
                return head.getObjectId().name();
            }
            throw new AuthException();
        }
        throw new ResourceNotFoundException(Constants.HEAD);
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent = null;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n, labelTypes);
    final CodeReviewCommit newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    insertAncestors(args.db, ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.patchSetApprovals().insert(approvals);
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent = null;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    insertAncestors(args.db, ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.patchSetApprovals().insert(approvals);
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
public SubmitStrategy create(final SubmitType submitType, final ReviewDb db, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Set<RevCommit> alreadyAccepted, final Branch.NameKey destBranch) throws MergeException, NoSuchProjectException {
    ProjectState project = getProject(destBranch);
    final SubmitStrategy.Arguments args = new SubmitStrategy.Arguments(identifiedUserFactory, myIdent, db, repo, rw, inserter, canMergeFlag, alreadyAccepted, destBranch, mergeUtilFactory.create(project));
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args, patchSetInfoFactory, project.getLabelTypes(), gitRefUpdated);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args, rebaseChange);
        default:
            final String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new MergeException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(final SubmitType submitType, final ReviewDb db, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Set<RevCommit> alreadyAccepted, final Branch.NameKey destBranch) throws MergeException, NoSuchProjectException {
    ProjectState project = getProject(destBranch);
    final SubmitStrategy.Arguments args = new SubmitStrategy.Arguments(identifiedUserFactory, myIdent, db, repo, rw, inserter, canMergeFlag, alreadyAccepted, destBranch, mergeUtilFactory.create(project));
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args, patchSetInfoFactory, gitRefUpdated);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args, rebaseChange);
        default:
            final String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new MergeException(errorMsg);
    }
}
#end_block

#method_before
public void rebase(final PatchSet.Id patchSetId, final Account.Id uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final String baseRev = findBaseRevision(patchSetId, db, change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        final PatchSet newPatchSet = rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState()));
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        final ReplacePatchSetSender cm = rebasedPatchSetSenderFactory.create(change);
        cm.setFrom(uploader);
        cm.setPatchSet(newPatchSet);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#method_after
public void rebase(final PatchSet.Id patchSetId, final Account.Id uploader) throws NoSuchChangeException, EmailException, OrmException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl changeControl = changeControlFactory.validateFor(changeId);
    if (!changeControl.canRebase()) {
        throw new InvalidChangeOperationException("Cannot rebase: New patch sets are not allowed to be added to change: " + changeId.toString());
    }
    final Change change = changeControl.getChange();
    Repository git = null;
    RevWalk rw = null;
    ObjectInserter inserter = null;
    try {
        git = gitManager.openRepository(change.getProject());
        rw = new RevWalk(git);
        inserter = git.newObjectInserter();
        final List<PatchSetApproval> oldPatchSetApprovals = db.patchSetApprovals().byChange(change.getId()).toList();
        final String baseRev = findBaseRevision(patchSetId, db, change.getDest(), git, null, null, null);
        final RevCommit baseCommit = rw.parseCommit(ObjectId.fromString(baseRev));
        final PatchSet newPatchSet = rebase(git, rw, inserter, patchSetId, change, uploader, baseCommit, mergeUtilFactory.create(changeControl.getProjectControl().getProjectState(), true));
        final Set<Account.Id> oldReviewers = Sets.newHashSet();
        final Set<Account.Id> oldCC = Sets.newHashSet();
        for (PatchSetApproval a : oldPatchSetApprovals) {
            if (a.getValue() != 0) {
                oldReviewers.add(a.getAccountId());
            } else {
                oldCC.add(a.getAccountId());
            }
        }
        final ReplacePatchSetSender cm = rebasedPatchSetSenderFactory.create(change);
        cm.setFrom(uploader);
        cm.setPatchSet(newPatchSet);
        cm.addReviewers(oldReviewers);
        cm.addExtraCC(oldCC);
        cm.send();
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    } catch (PathConflictException e) {
        throw new IOException(e.getMessage());
    } finally {
        if (inserter != null) {
            inserter.release();
        }
        if (rw != null) {
            rw.release();
        }
        if (git != null) {
            git.close();
        }
    }
}
#end_block

#method_before
public String createCherryPickCommitMessage(final CodeReviewCommit n, // TODO(dborowitz): get from ProjectState.
final LabelTypes labelTypes) {
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (final PatchSetApproval a : getApprovalsForCommit(n)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (CRVW.equals(a.getCategoryId())) {
            tag = "Reviewed-by";
        } else if (VRIF.equals(a.getCategoryId())) {
            tag = "Tested-by";
        } else {
            final LabelType lt = labelTypes.byId(a.getCategoryId().get());
            if (lt == null) {
                // TODO: Support arbitrary labels.
                continue;
            }
            tag = lt.getName();
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#method_after
public String createCherryPickCommitMessage(final CodeReviewCommit n) {
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (final PatchSetApproval a : getApprovalsForCommit(n)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (CRVW.equals(a.getCategoryId())) {
            tag = "Reviewed-by";
        } else if (VRIF.equals(a.getCategoryId())) {
            tag = "Tested-by";
        } else {
            final LabelType lt = project.getLabelTypes().byId(a.getCategoryId().get());
            if (lt == null) {
                // TODO: Support arbitrary labels.
                continue;
            }
            tag = lt.getName();
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#end_block

#method_before
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        return findById(m.group(1));
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        return findById(nameOrEmail);
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#method_after
public Set<Account.Id> findAll(String nameOrEmail) throws OrmException {
    Matcher m = Pattern.compile("^.* \\(([1-9][0-9]*)\\)$").matcher(nameOrEmail);
    if (m.matches()) {
        Account.Id id = Account.Id.parse(m.group(1));
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches("^[1-9][0-9]*$")) {
        Account.Id id = Account.Id.parse(nameOrEmail);
        if (exists(id)) {
            return Collections.singleton(id);
        } else {
            return Collections.emptySet();
        }
    }
    if (nameOrEmail.matches(Account.USER_NAME_PATTERN)) {
        AccountState who = byId.getByUsername(nameOrEmail);
        if (who != null) {
            return Collections.singleton(who.getAccount().getId());
        }
    }
    return findAllByNameOrEmail(nameOrEmail);
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd, out.labels.values());
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (out.labels != null && options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd, out.labels.values());
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        if (out.revisions != null) {
            for (String commit : out.revisions.keySet()) {
                if (out.revisions.get(commit).isCurrent) {
                    out.current_revision = commit;
                    break;
                }
            }
        }
    }
    lastControl = null;
    return out;
}
#end_block

#method_before
private ChangeControl control(ChangeData cd) throws OrmException {
    ChangeControl ctrl = cd.changeControl();
    if (ctrl != null && ctrl.getCurrentUser() == user) {
        return ctrl;
    }
    ctrl = controls.get(cd.getId());
    if (ctrl != null) {
        return ctrl;
    }
    try {
        if (changeControlUserFactory != null) {
            ctrl = changeControlUserFactory.controlFor(cd.change(db));
        } else {
            ctrl = changeControlGenericFactory.controlFor(cd.change(db), user);
        }
    } catch (NoSuchChangeException e) {
        return null;
    }
    controls.put(cd.getId(), ctrl);
    return ctrl;
}
#method_after
private ChangeControl control(ChangeData cd) throws OrmException {
    ChangeControl ctrl = cd.changeControl();
    if (ctrl != null && ctrl.getCurrentUser() == user) {
        return ctrl;
    } else if (lastControl != null && cd.getId().equals(lastControl.getChange().getId())) {
        return lastControl;
    }
    try {
        if (changeControlUserFactory != null) {
            ctrl = changeControlUserFactory.controlFor(cd.change(db));
        } else {
            ctrl = changeControlGenericFactory.controlFor(cd.change(db), user);
        }
    } catch (NoSuchChangeException e) {
        return null;
    }
    lastControl = ctrl;
    return ctrl;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, standard, detailed);
    } else {
        return labelsForClosedChange(cd, standard, detailed);
    }
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    if (!standard && !detailed) {
        return null;
    }
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return null;
    }
    if (cd.getChange().getStatus().isOpen()) {
        return labelsForOpenChange(cd, standard, detailed);
    } else {
        return labelsForClosedChange(cd, standard, detailed);
    }
}
#end_block

#method_before
private void setAllApprovals(ChangeData cd, Map<String, LabelInfo> labels) throws OrmException {
    Set<Account.Id> allUsers = Sets.newHashSet();
    for (PatchSetApproval psa : cd.allApprovals(db)) {
        allUsers.add(psa.getAccountId());
    }
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals(db)) {
        current.put(a.getAccountId(), a);
    }
    allUsers.addAll(current.keySet());
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = control(cd).forUser(user);
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        for (String name : labels.keySet()) {
            ApprovalInfo ai = new ApprovalInfo(accountId);
            accountLoader.put(ai);
            byLabel.put(name, ai);
            labels.get(name).addApproval(ai);
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            // TODO Support arbitrary labels placed by a reviewer.
            LabelType lt = labelTypes.byId(psa.getCategoryId().get());
            if (lt == null) {
                continue;
            }
            ApprovalInfo info = byLabel.get(lt.getName());
            if (info == null) {
                continue;
            }
            PermissionRange range = ctl.getRange(lt.getName());
            info.value = range != null ? range.squash(psa.getValue()) : 0;
        }
    }
}
#method_after
private void setAllApprovals(ChangeData cd, Map<String, LabelInfo> labels) throws OrmException {
    ChangeControl baseCtrl = control(cd);
    if (baseCtrl == null) {
        return;
    }
    Set<Account.Id> allUsers = Sets.newHashSet();
    for (PatchSetApproval psa : cd.allApprovals(db)) {
        allUsers.add(psa.getAccountId());
    }
    Multimap<Account.Id, PatchSetApproval> current = HashMultimap.create();
    for (PatchSetApproval a : cd.currentApprovals(db)) {
        current.put(a.getAccountId(), a);
    }
    for (Account.Id accountId : allUsers) {
        IdentifiedUser user = userFactory.create(accountId);
        ChangeControl ctl = baseCtrl.forUser(user);
        Map<String, ApprovalInfo> byLabel = Maps.newHashMapWithExpectedSize(labels.size());
        for (String name : labels.keySet()) {
            ApprovalInfo ai = approvalInfo(accountId, 0);
            byLabel.put(name, ai);
            labels.get(name).addApproval(ai);
        }
        for (PatchSetApproval psa : current.get(accountId)) {
            // TODO Support arbitrary labels placed by a reviewer.
            LabelType lt = labelTypes.byId(psa.getCategoryId().get());
            if (lt == null) {
                continue;
            }
            ApprovalInfo info = byLabel.get(lt.getName());
            if (info == null) {
                continue;
            }
            PermissionRange r = ctl.getRange(Permission.forLabel(lt.getName()));
            info.value = r != null ? r.squash(psa.getValue()) : 0;
        }
    }
}
#end_block

#method_before
private Map<String, Collection<String>> permittedLabels(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    ListMultimap<String, String> permitted = LinkedListMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                // TODO: Support arbitrary labels.
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#method_after
private Map<String, Collection<String>> permittedLabels(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    ListMultimap<String, String> permitted = LinkedListMultimap.create();
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelType type = labelTypes.byLabel(r.label);
            if (type == null) {
                // TODO: Support arbitrary labels.
                continue;
            }
            PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
            for (LabelValue v : type.getValues()) {
                if (range.contains(v.getValue())) {
                    permitted.put(r.label, v.formatValue());
                }
            }
        }
    }
    List<String> toClear = Lists.newArrayListWithCapacity(permitted.keySet().size());
    for (Map.Entry<String, Collection<String>> e : permitted.asMap().entrySet()) {
        if (isOnlyZero(e.getValue())) {
            toClear.add(e.getKey());
        }
    }
    for (String label : toClear) {
        permitted.removeAll(label);
    }
    return permitted.asMap();
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeData cd, Collection<LabelInfo> labels) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            if (ctl.canRemoveReviewer(ai._id, ai.value)) {
                removable.add(ai._id);
            } else {
                fixed.add(ai._id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, Collection<LabelInfo> labels) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            if (ctl.canRemoveReviewer(ai._id, ai.value)) {
                removable.add(ai._id);
            } else {
                fixed.add(ai._id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    Collection<PatchSet> src;
    if (cd.getLimitedPatchSets() != null || options.contains(ALL_REVISIONS)) {
        src = cd.patches(db);
    } else {
        src = Collections.singletonList(cd.currentPatchSet(db));
    }
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : src) {
        if (ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(cd, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return null;
    }
    Collection<PatchSet> src;
    if (cd.getLimitedPatchSets() != null || options.contains(ALL_REVISIONS)) {
        src = cd.patches(db);
    } else {
        src = Collections.singletonList(cd.currentPatchSet(db));
    }
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : src) {
        if (ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(cd, in));
        }
    }
    return res;
}
#end_block

#method_before
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(RAW_QUERY, cc.canPerformRawQuery());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#method_after
@Override
public Object apply(AccountResource resource) throws BadRequestException, Exception {
    if (self.get() != resource.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    CapabilityControl cc = resource.getUser().getCapabilities();
    Map<String, Object> have = Maps.newLinkedHashMap();
    for (String name : GlobalCapability.getAllNames()) {
        if (!name.equals(PRIORITY) && want(name) && cc.canPerform(name)) {
            if (GlobalCapability.hasRange(name)) {
                have.put(name, new Range(cc.getRange(name)));
            } else {
                have.put(name, true);
            }
        }
    }
    have.put(CREATE_ACCOUNT, cc.canCreateAccount());
    have.put(CREATE_GROUP, cc.canCreateGroup());
    have.put(CREATE_PROJECT, cc.canCreateProject());
    have.put(EMAIL_REVIEWERS, cc.canEmailReviewers());
    have.put(KILL_TASK, cc.canKillTask());
    have.put(VIEW_CACHES, cc.canViewCaches());
    have.put(FLUSH_CACHES, cc.canFlushCaches());
    have.put(VIEW_CONNECTIONS, cc.canViewConnections());
    have.put(VIEW_QUEUE, cc.canViewQueue());
    have.put(START_REPLICATION, cc.canStartReplication());
    have.put(ACCESS_DATABASE, cc.canAccessDatabase());
    QueueProvider.QueueType queue = cc.getQueueType();
    if (queue != QueueProvider.QueueType.INTERACTIVE || (query != null && query.contains(PRIORITY))) {
        have.put(PRIORITY, queue);
    }
    Iterator<Map.Entry<String, Object>> itr = have.entrySet().iterator();
    while (itr.hasNext()) {
        Map.Entry<String, Object> e = itr.next();
        if (!want(e.getKey())) {
            itr.remove();
        } else if (e.getValue() instanceof Boolean && !((Boolean) e.getValue())) {
            itr.remove();
        }
    }
    if (format == OutputFormat.TEXT) {
        StringBuilder sb = new StringBuilder();
        for (Map.Entry<String, Object> e : have.entrySet()) {
            sb.append(e.getKey());
            if (!(e.getValue() instanceof Boolean)) {
                sb.append(": ");
                sb.append(e.getValue().toString());
            }
            sb.append('\n');
        }
        return BinaryResult.create(sb.toString());
    } else {
        return OutputFormat.JSON.newGson().toJsonTree(have, new TypeToken<Map<String, Object>>() {
        }.getType());
    }
}
#end_block

#method_before
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#method_after
List<SectionMatcher> getLocalAccessSections() {
    List<SectionMatcher> sm = localAccessSections;
    if (sm == null) {
        Collection<AccessSection> fromConfig = config.getAccessSections();
        sm = new ArrayList<SectionMatcher>(fromConfig.size());
        for (AccessSection section : fromConfig) {
            if (isAllProjects) {
                List<Permission> copy = Lists.newArrayListWithCapacity(section.getPermissions().size());
                for (Permission p : section.getPermissions()) {
                    if (Permission.canBeOnAllProjects(section.getName(), p.getName())) {
                        copy.add(p);
                    }
                }
                section = new AccessSection(section.getName());
                section.setPermissions(copy);
            }
            SectionMatcher matcher = SectionMatcher.wrap(getProject().getNameKey(), section);
            if (matcher != null) {
                sm.add(matcher);
            }
        }
        localAccessSections = sm;
    }
    return sm;
}
#end_block

#method_before
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = new ArrayList<SectionMatcher>();
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    ProjectState allProjects = projectCache.getAllProjects();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        all.addAll(s.getLocalAccessSections());
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    if (seen.add(allProjects.getProject().getNameKey())) {
        all.addAll(allProjects.getLocalAccessSections());
    }
    return all;
}
#method_after
List<SectionMatcher> getAllSections() {
    if (isAllProjects) {
        return getLocalAccessSections();
    }
    List<SectionMatcher> all = Lists.newArrayList();
    for (ProjectState s : tree()) {
        all.addAll(s.getLocalAccessSections());
    }
    return all;
}
#end_block

#method_before
public Set<AccountGroup.UUID> getOwners() {
    Project.NameKey parentName = getProject().getParent();
    if (!localOwners.isEmpty() || parentName == null || isAllProjects) {
        return localOwners;
    }
    ProjectState parent = projectCache.get(parentName);
    if (parent != null) {
        return parent.getOwners();
    }
    return Collections.emptySet();
}
#method_after
public Set<AccountGroup.UUID> getOwners() {
    for (ProjectState p : tree()) {
        if (!p.localOwners.isEmpty()) {
            return p.localOwners;
        }
    }
    return Collections.emptySet();
}
#end_block

#method_before
boolean isOwner(GroupMembership groups) {
    Set<Project.NameKey> seen = new HashSet<Project.NameKey>();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        if (groups.containsAnyOf(s.localOwners)) {
            return true;
        }
        Project.NameKey parent = s.getProject().getParent();
        if (parent == null || !seen.add(parent)) {
            break;
        }
        s = projectCache.get(parent);
    } while (s != null);
    return false;
}
#method_after
boolean isOwner(final GroupMembership groups) {
    return Iterables.any(tree(), new Predicate<ProjectState>() {

        @Override
        public boolean apply(ProjectState in) {
            return groups.containsAnyOf(in.localOwners);
        }
    });
}
#end_block

#method_before
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    Set<Project.NameKey> seen = Sets.newHashSet();
    seen.add(getProject().getNameKey());
    ProjectState s = this;
    do {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                Project.NameKey parent = s.getProject().getParent(allProjectsName);
                if (parent != null && seen.add(parent)) {
                    s = projectCache.get(parent);
                } else {
                    s = null;
                }
        }
    } while (s != null);
    return false;
}
#method_after
private boolean getInheritableBoolean(Function<Project, InheritableBoolean> func) {
    for (ProjectState s : tree()) {
        switch(func.apply(s.getProject())) {
            case TRUE:
                return true;
            case FALSE:
                return false;
            case INHERIT:
            default:
                continue;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new ResourceNotFoundException();
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, Input input) throws BadRequestException, ResourceNotFoundException, AuthException, OrmException, EmailException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    Account.Id accountId = parser.parse(rsrc, input.reviewer);
    try {
        if (accountId != null) {
            return putAccount(reviewerFactory.create(rsrc, accountId));
        } else {
            return putGroup(rsrc, input);
        }
    } catch (NoSuchChangeException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchGroupException e) {
        throw new ResourceNotFoundException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, TestSubmitRuleCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, Receive.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, ReviewCommand.class);
    // deprecated alias to review command
    alias(gerrit, "approve", ReviewCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
}
#end_block

#method_before
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps == null) {
            throw new ResourceNotFoundException(id);
        }
        return new RevisionResource(change, ps);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && change.getControl().isPatchVisible(ps, dbProvider.get())) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#method_after
@Override
public RevisionResource parse(ChangeResource change, IdString id) throws ResourceNotFoundException, OrmException {
    if (id.equals("current")) {
        PatchSet.Id p = change.getChange().currentPatchSetId();
        PatchSet ps = p != null ? dbProvider.get().patchSets().get(p) : null;
        if (ps != null && visible(change, ps)) {
            return new RevisionResource(change, ps);
        }
        throw new ResourceNotFoundException(id);
    }
    List<PatchSet> match = Lists.newArrayListWithExpectedSize(2);
    for (PatchSet ps : find(change, id.get())) {
        Change.Id changeId = ps.getId().getParentKey();
        if (changeId.equals(change.getChange().getId()) && visible(change, ps)) {
            match.add(ps);
        }
    }
    if (match.size() != 1) {
        throw new ResourceNotFoundException(id);
    }
    return new RevisionResource(change, match.get(0));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.mergeable = in.getStatus() != Change.Status.MERGED ? in.isMergeable() : null;
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
        out.removable_reviewers = removableReviewers(cd, out.labels.values());
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> initLabels(ChangeData cd, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            break;
                        default:
                            break;
                    }
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    // 
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsForClosedChange(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    // We can only approximately reconstruct what the submit rule evaluator
    // would have done. These should really come from a stored submit record.
    // 
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelInfo> labels = new TreeMap<String, LabelInfo>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval psa : cd.currentApprovals(db)) {
        ApprovalType type = approvalTypes.byId(psa.getCategoryId());
        if (type == null) {
            continue;
        }
        String label = type.getCategory().getLabelName();
        LabelInfo li = labels.get(label);
        if (li == null) {
            li = new LabelInfo();
            labels.put(label, li);
            if (detailed) {
                setLabelValues(type, li);
            }
        }
        short val = psa.getValue();
        if (detailed) {
            li.addApproval(approvalInfo(psa.getAccountId(), val));
        }
        if (!standard || li.approved != null || li.rejected != null) {
            continue;
        }
        if (val == type.getMax().getValue()) {
            li.approved = accountInfo(psa);
        } else if (val == type.getMin().getValue() && // A merged change can't have been rejected.
        cd.getChange().getStatus() != Status.MERGED) {
            li.rejected = accountInfo(psa);
        } else if (val > 0) {
            li.recommended = accountInfo(psa);
            li.value = val;
        } else if (val < 0) {
            li.disliked = accountInfo(psa);
            li.value = val;
        }
    }
    return labels;
}
#end_block

#method_before
private Collection<AccountInfo> removableReviewers(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Change change = ctl.getChange();
    if (!change.getStatus().isOpen() || !(ctl.getCurrentUser() instanceof IdentifiedUser)) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSet();
    Set<Account.Id> removable = Sets.newHashSet();
    for (PatchSetApproval app : cd.currentApprovals(db)) {
        if (ctl.canRemoveReviewer(app)) {
            removable.add(app.getAccountId());
        } else {
            fixed.add(app.getAccountId());
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#method_after
private Collection<AccountInfo> removableReviewers(ChangeData cd, Collection<LabelInfo> labels) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return ImmutableList.of();
    }
    Set<Account.Id> fixed = Sets.newHashSetWithExpectedSize(labels.size());
    Set<Account.Id> removable = Sets.newHashSetWithExpectedSize(labels.size());
    for (LabelInfo label : labels) {
        if (label.all == null) {
            continue;
        }
        for (ApprovalInfo ai : label.all) {
            if (ctl.canRemoveReviewer(ai._id, ai.value)) {
                removable.add(ai._id);
            } else {
                fixed.add(ai._id);
            }
        }
    }
    removable.removeAll(fixed);
    List<AccountInfo> result = Lists.newArrayListWithCapacity(removable.size());
    for (Account.Id id : removable) {
        result.add(accountLoader.get(id));
    }
    return result;
}
#end_block

#method_before
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // For the following TreeMap, we'd rather use
    // [...] = Maps.newTreeMap(LabelOrdering.create(approvalTypes));
    // but this fails on OpenJDK 6. See:
    // http://bugs.openjdk.java.net/show_bug.cgi?id=100167#c1
    // To still be able to compile on OpenJDK 6, we instantiate the following
    // TreeMap directly.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#method_after
public ReviewerInfo format(ReviewerInfo out, ChangeControl ctl, List<PatchSetApproval> approvals) throws OrmException {
    PatchSet.Id psId = ctl.getChange().currentPatchSetId();
    if (approvals == null) {
        approvals = ChangeData.sortApprovals(db.get().patchSetApprovals().byPatchSetUser(psId, out._id));
    }
    FunctionState fs = functionState.create(ctl, psId, approvals);
    for (ApprovalType at : approvalTypes.getApprovalTypes()) {
        CategoryFunction.forCategory(at.getCategory()).run(at, fs);
    }
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    out.approvals = new TreeMap<String, String>(LabelOrdering.create(approvalTypes));
    for (PatchSetApproval ca : approvals) {
        for (PermissionRange pr : ctl.getLabelRanges()) {
            if (!pr.isEmpty()) {
                // TODO: Support arbitrary labels.
                ApprovalType at = approvalTypes.byId(ca.getCategoryId());
                if (at != null) {
                    out.approvals.put(at.getCategory().getLabelName(), formatValue(ca.getValue()));
                }
            }
        }
    }
    // Add dummy approvals for all permitted labels for the user even if they
    // do not exist in the DB.
    ChangeData cd = new ChangeData(ctl);
    PatchSet ps = cd.currentPatchSet(db);
    if (ps != null) {
        for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
            for (SubmitRecord.Label label : rec.labels) {
                String name = label.label;
                if (!out.approvals.containsKey(name) && !ctl.getRange(Permission.forLabel(name)).isEmpty()) {
                    out.approvals.put(name, formatValue((short) 0));
                }
            }
        }
    }
    if (out.approvals.isEmpty()) {
        out.approvals = null;
    }
    return out;
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case DELETE:
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (ReplaceRequest replace : replaceByChange.values()) {
        if (replace.inputCommand == newChange) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            } catch (OrmException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", replace.newPatchSet.getId(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
        }
    }
    if (newChange == null || newChange.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(newChange, "internal server error");
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, OrmException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == newChange) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (CheckedFuture<?, OrmException> f : futures) {
            f.checkedGet();
        }
        newChange.setResult(OK);
    } catch (OrmException err) {
        log.error("Can't insert changes for " + project.getName(), err);
        reject(newChange, "internal server error");
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(newChange, "internal server error");
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        reject(cmd);
    }
}
#end_block

#method_before
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(db, ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(db, change, ps, info, recipients.getReviewers(), Collections.<Account.Id>emptySet());
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    replication.fire(project.getNameKey(), ps.getRefName());
    hooks.doPatchsetCreatedHook(change, ps, db);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#method_after
private void insertChange(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        insertAncestors(db, ps.getId(), commit);
        db.patchSets().insert(Collections.singleton(ps));
        db.changes().insert(Collections.singleton(change));
        ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        approvalsUtil.addReviewers(db, change, ps, info, recipients.getReviewers(), Collections.<Account.Id>emptySet());
        db.commit();
    } finally {
        db.rollback();
    }
    created = true;
    gitRefUpdated.fire(project.getNameKey(), ps.getRefName(), ObjectId.zeroId(), commit);
    hooks.doPatchsetCreatedHook(change, ps, db);
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                CreateChangeSender cm = createChangeSenderFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(ps, info);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new change " + change.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email newchange";
        }
    }));
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, OrmException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException {
            try {
                if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    ReviewDb db = schemaFactory.open();
                    try {
                        return insertPatchSet(db);
                    } finally {
                        db.close();
                    }
                }
            } finally {
                synchronized (replaceProgress) {
                    replaceProgress.update(1);
                }
            }
        }
    }));
    return Futures.makeChecked(future, ORM_EXCEPTION);
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    final RefUpdate ru = repo.updateRef(newPatchSet.getRefName());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(rp.getRevWalk()) != RefUpdate.Result.NEW) {
        throw new IOException("Failed to create ref " + newPatchSet.getRefName() + " in " + repo.getDirectory() + ": " + ru.getResult());
    }
    replication.fire(project.getNameKey(), ru.getName());
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException {
    final Account.Id me = currentUser.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients(reviewerId, ccId);
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        insertAncestors(db, newPatchSet.getId(), newCommit);
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        List<PatchSetApproval> patchSetApprovals = approvalsUtil.copyVetosToPatchSet(db, newPatchSet.getId());
        final MailRecipients oldRecipients = getRecipientsFromApprovals(patchSetApprovals);
        approvalsUtil.addReviewers(db, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        recipients.add(oldRecipients);
        msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), me, newPatchSet.getCreatedOn(), newPatchSet.getId());
        msg.setMessage("Uploaded patch set " + newPatchSet.getPatchSetId() + ".");
        db.changeMessages().insert(Collections.singleton(msg));
        if (change.currentPatchSetId().equals(priorPatchSet)) {
            ChangeUtil.updateTrackingIds(db, change, trackingFooters, footerLines);
        }
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (destTopicName != null) {
                        change.setTopic(destTopicName);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, currentUser.getAccount(), newPatchSet, db);
    }
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                ReplacePatchSetSender cm = replacePatchSetFactory.create(change);
                cm.setFrom(me);
                cm.setPatchSet(newPatchSet, info);
                cm.setChangeMessage(msg);
                cm.addReviewers(recipients.getReviewers());
                cm.addExtraCC(recipients.getCcOnly());
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
            }
            if (mergedIntoRef != null) {
                sendMergedEmail(ReplaceRequest.this);
            }
        }

        @Override
        public String toString() {
            return "send-email newpatchset";
        }
    }));
    return newPatchSet.getId();
}
#end_block

#method_before
Map<String, Provider<Command>> getMap() {
    return commands;
}
#method_after
Map<String, CommandProvider> getMap() {
    return commands;
}
#end_block

#method_before
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final Provider<Command> p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#method_after
@Override
public void start(final Environment env) throws IOException {
    try {
        parseCommandLine();
        if (Strings.isNullOrEmpty(commandName)) {
            StringWriter msg = new StringWriter();
            msg.write(usage());
            throw new UnloggedFailure(1, msg.toString());
        }
        final CommandProvider p = commands.get(commandName);
        if (p == null) {
            String msg = (getName().isEmpty() ? "Gerrit Code Review" : getName()) + ": " + commandName + ": not found";
            throw new UnloggedFailure(1, msg);
        }
        final Command cmd = p.getProvider().get();
        checkRequiresCapability(cmd);
        if (cmd instanceof BaseCommand) {
            final BaseCommand bc = (BaseCommand) cmd;
            if (getName().isEmpty())
                bc.setName(commandName);
            else
                bc.setName(getName() + " " + commandName);
            bc.setArguments(args.toArray(new String[args.size()]));
        } else if (!args.isEmpty()) {
            throw new UnloggedFailure(1, commandName + " does not take arguments");
        }
        provideStateTo(cmd);
        atomicCmd.set(cmd);
        cmd.start(env);
    } catch (UnloggedFailure e) {
        String msg = e.getMessage();
        if (!msg.endsWith("\n")) {
            msg += "\n";
        }
        err.write(msg.getBytes(ENC));
        err.flush();
        onExit(e.exitCode);
    }
}
#end_block

#method_before
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final Command cmd = commands.get(name).get();
        usage.append("   ");
        if (cmd instanceof BaseCommand) {
            BaseCommand bc = (BaseCommand) cmd;
            String descr = bc.getDescription();
            if (name.equals("plugin")) {
                descr = "Install, reload, remove and list plugins";
            }
            usage.append(String.format(format, name, descr));
        } else {
            usage.append(name);
        }
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#method_after
@Override
protected String usage() {
    final StringBuilder usage = new StringBuilder();
    usage.append("Available commands");
    if (!getName().isEmpty()) {
        usage.append(" of ");
        usage.append(getName());
    }
    usage.append(" are:\n");
    usage.append("\n");
    int maxLength = -1;
    for (String name : commands.keySet()) {
        maxLength = Math.max(maxLength, name.length());
    }
    String format = "%-" + maxLength + "s   %s";
    for (String name : Sets.newTreeSet(commands.keySet())) {
        final CommandProvider p = commands.get(name);
        usage.append("   ");
        usage.append(String.format(format, name, Strings.nullToEmpty(p.getDescription())));
        usage.append("\n");
    }
    usage.append("\n");
    usage.append("See '");
    if (getName().indexOf(' ') < 0) {
        usage.append(getName());
        usage.append(' ');
    }
    usage.append("COMMAND --help' for more information.\n");
    usage.append("\n");
    return usage.toString();
}
#end_block

#method_before
private boolean isDuplicate(ChangeMessage msg) {
    try {
        ChangeMessage last = Iterables.getLast(db.changeMessages().byChange(msg.getPatchSetId().getParentKey()), null);
        if (last != null) {
            long lastMs = last.getWrittenOn().getTime();
            long msgMs = msg.getWrittenOn().getTime();
            if (last.getAuthor() == null && Objects.equal(last.getMessage(), msg.getMessage()) && msgMs - lastMs > DUPLICATE_MESSAGE_INTERVAL) {
                return true;
            }
        }
    } catch (OrmException err) {
        log.warn("Cannot check previous merge failure message", err);
    }
    return false;
}
#method_after
private boolean isDuplicate(ChangeMessage msg) {
    try {
        ChangeMessage last = Iterables.getLast(db.changeMessages().byChange(msg.getPatchSetId().getParentKey()), null);
        if (last != null) {
            long lastMs = last.getWrittenOn().getTime();
            long msgMs = msg.getWrittenOn().getTime();
            if (Objects.equal(last.getAuthor(), msg.getAuthor()) && Objects.equal(last.getMessage(), msg.getMessage()) && msgMs - lastMs < DUPLICATE_MESSAGE_INTERVAL) {
                return true;
            }
        }
    } catch (OrmException err) {
        log.warn("Cannot check previous merge failure message", err);
    }
    return false;
}
#end_block

#method_before
public Repository openRepository(Project.NameKey name) throws RepositoryNotFoundException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    if (!names.contains(name)) {
        // The this.names list does not hold the project-name but it can still exists
        // on disk; for instance when the project has been created directly on the
        // file-system through replication.
        // 
        File f = new File(basePath, name.get().endsWith(Constants.DOT_GIT_EXT) ? name.get() : name.get() + Constants.DOT_GIT_EXT);
        if (FileKey.isGitRepository(f, FS.DETECTED)) {
            onCreateProject(name);
        } else {
            throw new RepositoryNotFoundException(gitDirOf(name));
        }
    }
    final FileKey loc = FileKey.lenient(gitDirOf(name), FS.DETECTED);
    try {
        return RepositoryCache.open(loc);
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot open repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#method_after
public Repository openRepository(Project.NameKey name) throws RepositoryNotFoundException {
    if (isUnreasonableName(name)) {
        throw new RepositoryNotFoundException("Invalid name: " + name);
    }
    if (!names.contains(name)) {
        // 
        if (FileKey.resolve(gitDirOf(name), FS.DETECTED) != null) {
            onCreateProject(name);
        } else {
            throw new RepositoryNotFoundException(gitDirOf(name));
        }
    }
    final FileKey loc = FileKey.lenient(gitDirOf(name), FS.DETECTED);
    try {
        return RepositoryCache.open(loc);
    } catch (IOException e1) {
        final RepositoryNotFoundException e2;
        e2 = new RepositoryNotFoundException("Cannot open repository " + name);
        e2.initCause(e1);
        throw e2;
    }
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    final int exitValue = result.getExitValue();
    if (exitValue != 0) {
        log.debug("hook[" + getName() + "] exitValue:" + exitValue);
    } else {
        log.info("hook[" + getName() + "] exitValue:" + exitValue);
    }
    BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
    try {
        String line;
        while ((line = br.readLine()) != null) {
            log.info("hook[" + getName() + "] output: " + line);
        }
    } catch (IOException iox) {
        log.error("Error writing hook output", iox);
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<String>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    final int exitValue = result.getExitValue();
    if (exitValue == 0) {
        log.debug("hook[" + getName() + "] exitValue:" + exitValue);
    } else {
        log.info("hook[" + getName() + "] exitValue:" + exitValue);
    }
    BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
    try {
        String line;
        while ((line = br.readLine()) != null) {
            log.info("hook[" + getName() + "] output: " + line);
        }
    } catch (IOException iox) {
        log.error("Error writing hook output", iox);
    }
    return result;
}
#end_block

#method_before
@Override
protected void display(final GroupDetail groupDetail) {
    switch(groupDetail.group.getType()) {
        case INTERNAL:
            accounts = groupDetail.accounts;
            MemberList.all(getGroupUUID(), new GerritCallback<MemberList>() {

                @Override
                public void onSuccess(MemberList result) {
                    members.display(result.asList());
                }
            });
            GroupList.included(getGroupUUID(), new GerritCallback<GroupList>() {

                @Override
                public void onSuccess(GroupList result) {
                    includes.display(result.asList());
                }
            });
            break;
        default:
            memberPanel.setVisible(false);
            includePanel.setVisible(false);
            noMembersInfo.setVisible(true);
            break;
    }
    enableForm(groupDetail.canModify);
    delMember.setVisible(groupDetail.canModify);
    delInclude.setVisible(groupDetail.canModify);
}
#method_after
@Override
protected void display(final GroupInfo group, final boolean canModify) {
    if (AccountGroup.isInternalGroup(group.getGroupUUID()) && !AccountGroup.isSystemGroup(group.getGroupUUID())) {
        MemberList.all(getGroupUUID(), new GerritCallback<MemberList>() {

            @Override
            public void onSuccess(MemberList result) {
                members.display(Natives.asList(result));
            }
        });
        GroupList.included(getGroupUUID(), new GerritCallback<GroupList>() {

            @Override
            public void onSuccess(GroupList result) {
                includes.display(Natives.asList(result));
            }
        });
    } else {
        memberPanel.setVisible(false);
        includePanel.setVisible(false);
        noMembersInfo.setVisible(true);
    }
    enableForm(canModify);
    delMember.setVisible(canModify);
    delInclude.setVisible(canModify);
}
#end_block

#method_before
void insert(MemberInfo info) {
    Comparator<MemberInfo> c = new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            int cmp = nullToEmpty(a.fullName()).compareTo(nullToEmpty(b.fullName()));
            if (cmp != 0) {
                return cmp;
            }
            cmp = nullToEmpty(a.preferredEmail()).compareTo(nullToEmpty(b.preferredEmail()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getAccountId().get() - b.getAccountId().get();
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    for (int row = 1; row < table.getRowCount(); row++) {
        final MemberInfo i = getRowItem(row);
        if (i != null) {
            if (c.compare(info, i) < 0) {
                table.insertRow(row);
                applyDataRowStyle(row);
                populate(row, info);
                return;
            }
        }
    }
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    populate(row, info);
}
#method_after
void insert(MemberInfo info) {
    Comparator<MemberInfo> c = new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            int cmp = nullToEmpty(a.fullName()).compareTo(nullToEmpty(b.fullName()));
            if (cmp != 0) {
                return cmp;
            }
            cmp = nullToEmpty(a.preferredEmail()).compareTo(nullToEmpty(b.preferredEmail()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getAccountId().get() - b.getAccountId().get();
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        MemberInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
void populate(final int row, final MemberInfo i) {
    final Account.Id accountId = i.getAccountId();
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, AccountLink.link(accounts, accountId));
    table.setText(row, 3, accounts.get(accountId).getPreferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, i);
}
#method_after
void populate(final int row, final MemberInfo i) {
    CheckBox checkBox = new CheckBox();
    table.setWidget(row, 1, checkBox);
    checkBox.setEnabled(enabled);
    table.setWidget(row, 2, new AccountLink(i));
    table.setText(row, 3, i.preferredEmail());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, 1, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, 2, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, 3, Gerrit.RESOURCES.css().dataCell());
    setRowItem(row, i);
}
#end_block

#method_before
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        public String nullToEmpty(String str) {
            return str == null ? "" : str;
        }
    };
    for (int row = 1; row < table.getRowCount(); row++) {
        final GroupInfo i = getRowItem(row);
        if (i != null) {
            if (c.compare(info, i) < 0) {
                table.insertRow(row);
                applyDataRowStyle(row);
                populate(row, info);
                return;
            }
        }
    }
    final int row = table.getRowCount();
    table.insertRow(row);
    applyDataRowStyle(row);
    populate(row, info);
}
#method_after
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        private String nullToEmpty(@Nullable String str) {
            return (str == null) ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
public static void isGroupOwner(String groupName, final AsyncCallback<Boolean> cb) {
    GroupList.myOwned(groupName, new AsyncCallback<GroupList>() {

        @Override
        public void onSuccess(GroupList result) {
            cb.onSuccess(!result.asList().isEmpty());
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#method_after
public static void isGroupOwner(String groupName, final AsyncCallback<Boolean> cb) {
    GroupMap.myOwned(groupName, new AsyncCallback<GroupMap>() {

        @Override
        public void onSuccess(GroupMap result) {
            cb.onSuccess(!result.isEmpty());
        }

        @Override
        public void onFailure(Throwable caught) {
            cb.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static void setGroupOptions(AccountGroup.UUID group, boolean isVisibleToAll, AsyncCallback<VoidResult> cb) {
    GroupOptionsInput in = GroupOptionsInput.create();
    in.isVisibleToAll(isVisibleToAll);
    group(group).view("options").put(in, cb);
}
#method_after
public static void setGroupOptions(AccountGroup.UUID group, boolean isVisibleToAll, AsyncCallback<VoidResult> cb) {
    GroupOptionsInput in = GroupOptionsInput.create();
    in.visibleToAll(isVisibleToAll);
    group(group).view("options").put(in, cb);
}
#end_block

#method_before
public static void addMembers(AccountGroup.UUID group, Set<String> members, final AsyncCallback<NativeList<MemberInfo>> cb) {
    if (members.size() == 1) {
        addMember(group, members.iterator().next(), new AsyncCallback<MemberInfo>() {

            @Override
            public void onSuccess(MemberInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        MemberInput input = MemberInput.create();
        for (String member : members) {
            input.add_member(member);
        }
        members(group).post(input, cb);
    }
}
#method_after
public static void addMembers(AccountGroup.UUID group, Set<String> members, final AsyncCallback<JsArray<MemberInfo>> cb) {
    if (members.size() == 1) {
        addMember(group, members.iterator().next(), new AsyncCallback<MemberInfo>() {

            @Override
            public void onSuccess(MemberInfo result) {
                cb.onSuccess(Natives.arrayOf(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        MemberInput input = MemberInput.create();
        for (String member : members) {
            input.add_member(member);
        }
        members(group).post(input, cb);
    }
}
#end_block

#method_before
public static void addIncludedGroups(AccountGroup.UUID group, Set<String> includedGroups, final AsyncCallback<NativeList<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(group, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_group(includedGroup);
        }
        groups(group).post(input, cb);
    }
}
#method_after
public static void addIncludedGroups(AccountGroup.UUID group, Set<String> includedGroups, final AsyncCallback<JsArray<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(group, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(Natives.arrayOf(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_group(includedGroup);
        }
        groups(group).post(input, cb);
    }
}
#end_block

#method_before
public static <T extends JavaScriptObject> List<T> asList(final JsArray<T> arr) {
    return new AbstractList<T>() {

        @Override
        public T set(int index, T element) {
            T old = arr.get(index);
            arr.set(0, element);
            return old;
        }

        @Override
        public T get(int index) {
            return arr.get(index);
        }

        @Override
        public int size() {
            return arr.length();
        }
    };
}
#method_after
public static <T extends JavaScriptObject> List<T> asList(final JsArray<T> arr) {
    return new AbstractList<T>() {

        @Override
        public T set(int index, T element) {
            T old = arr.get(index);
            arr.set(index, element);
            return old;
        }

        @Override
        public T get(int index) {
            return arr.get(index);
        }

        @Override
        public int size() {
            return arr.length();
        }
    };
}
#end_block

#method_before
public static RestApi revision(PatchSet.Id id) {
    return call(id);
}
#method_after
public static RestApi revision(PatchSet.Id id) {
    return change(id.getParentKey().get()).view("revisions").id(id.get());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ChangeApi.revision(patchSetId).view("review").get(cbs.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            change = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    ChangeApi.revision(patchSetId).view("review").get(cbs.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo result) {
            result.init();
            change = result;
        }

        @Override
        public void onFailure(Throwable caught) {
        // Handled by ScreenLoadCallback.onFailure().
        }
    }));
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#end_block

#method_before
private void initLabel(PatchSetPublishDetail r, String labelName, Panel body) {
    LabelInfo label = change.label(labelName);
    List<String> values = new ArrayList<String>(label.values());
    if (values.isEmpty()) {
        return;
    }
    Collections.reverse(values);
    body.add(new SmallHeading(label.category() + ":"));
    VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    ApprovalCategory.Id catId = new ApprovalCategory.Id(label.id());
    // TODO(dborowitz): Move to LabelInfo.
    PatchSetApproval prior = r.getChangeApproval(catId);
    for (String value : values) {
        ValueRadioButton b = new ValueRadioButton(labelName, label, value);
        SafeHtml buf = new SafeHtmlBuilder().append(b.value.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(label.id())) {
            short numValue = parseLabelValue(value);
            b.setValue(lastState.approvals.get(label.id()) == numValue);
        } else {
            short v = b.value.getValue();
            b.setValue(prior != null ? v == prior.getValue() : v == 0);
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#method_after
private void initLabel(PatchSetPublishDetail r, String labelName, Panel body) {
    JsArrayString nativeValues = change.permitted_values(labelName);
    if (nativeValues == null || nativeValues.length() == 0) {
        return;
    }
    List<String> values = new ArrayList<String>(nativeValues.length());
    for (int i = 0; i < nativeValues.length(); i++) {
        values.add(nativeValues.get(i));
    }
    Collections.reverse(values);
    LabelInfo label = change.label(labelName);
    body.add(new SmallHeading(label.name() + ":"));
    VerticalPanel vp = new VerticalPanel();
    vp.setStyleName(Gerrit.RESOURCES.css().approvalCategoryList());
    Short prior = null;
    for (ApprovalInfo app : Natives.asList(label.all())) {
        if (app._account_id() == Gerrit.getUserAccount().getId().get()) {
            prior = app.value();
            break;
        }
    }
    for (String value : values) {
        ValueRadioButton b = new ValueRadioButton(label, value);
        SafeHtml buf = new SafeHtmlBuilder().append(b.format());
        buf = CommentLinkProcessor.apply(buf);
        SafeHtml.set(b, buf);
        if (lastState != null && patchSetId.equals(lastState.patchSetId) && lastState.approvals.containsKey(label.name())) {
            b.setValue(lastState.approvals.get(label.name()) == value);
        } else {
            b.setValue(b.parseValue() == (prior != null ? prior : 0));
        }
        approvalButtons.add(b);
        vp.add(b);
    }
    body.add(vp);
}
#end_block

#method_before
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.labelName, b.value.getValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/").id(String.valueOf(patchSetId.getParentKey().get())).view("revisions").id(revision).view("review").post(data, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#method_after
private void onSend2(final boolean submit) {
    ReviewInput data = ReviewInput.create();
    data.message(ChangeApi.emptyToNull(message.getText().trim()));
    data.init();
    for (final ValueRadioButton b : approvalButtons) {
        if (b.getValue()) {
            data.label(b.label.name(), b.parseValue());
        }
    }
    enableForm(false);
    new RestApi("/changes/").id(String.valueOf(patchSetId.getParentKey().get())).view("revisions").id(revision).view("review").post(data, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            if (submit) {
                submit();
            } else {
                saveStateOnUnload = false;
                goChange();
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            super.onFailure(caught);
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(AccountInfo.Loader.Factory.class);
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = new ChangeData(rsrc.getControl());
    cd.setPatchSets(ImmutableList.of(rsrc.getPatchSet().getId()));
    return format(cd);
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = new ChangeData(rsrc.getControl());
    cd.limitToPatchSets(ImmutableList.of(rsrc.getPatchSet().getId()));
    return format(cd);
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(DETAILED_LABELS)) {
        out.detailed_labels = detailedLabelsFor(cd);
    } else if (options.contains(LABELS)) {
        out.labels = labelsFor(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getSpecifiedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION) || cd.getLimitedPatchSets() != null) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
private Map<String, RevisionInfo> revisions(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    Collection<PatchSet> src;
    if (cd.getSpecifiedPatchSets() != null || options.contains(ALL_REVISIONS)) {
        src = cd.patches(db);
    } else {
        src = Collections.singletonList(cd.currentPatchSet(db));
    }
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : src) {
        if (ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(cd, in));
        }
    }
    return res;
}
#method_after
private Map<String, RevisionInfo> revisions(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    Collection<PatchSet> src;
    if (cd.getLimitedPatchSets() != null || options.contains(ALL_REVISIONS)) {
        src = cd.patches(db);
    } else {
        src = Collections.singletonList(cd.currentPatchSet(db));
    }
    Map<String, RevisionInfo> res = Maps.newLinkedHashMap();
    for (PatchSet in : src) {
        if (ctl.isPatchVisible(in, db.get())) {
            res.put(in.getRevision().get(), toRevisionInfo(cd, in));
        }
    }
    return res;
}
#end_block

#method_before
public static void ensureCurrentPatchSetLoaded(Provider<ReviewDb> db, List<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patches == null) {
            missing.put(cd.change(db).currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        for (PatchSet ps : db.get().patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
            if (cd.patchSetIds == null) {
                cd.patches = Lists.newArrayList(ps);
            }
        }
    }
}
#method_after
public static void ensureCurrentPatchSetLoaded(Provider<ReviewDb> db, List<ChangeData> changes) throws OrmException {
    Map<PatchSet.Id, ChangeData> missing = Maps.newHashMap();
    for (ChangeData cd : changes) {
        if (cd.currentPatchSet == null && cd.patches == null) {
            missing.put(cd.change(db).currentPatchSetId(), cd);
        }
    }
    if (!missing.isEmpty()) {
        for (PatchSet ps : db.get().patchSets().get(missing.keySet())) {
            ChangeData cd = missing.get(ps.getId());
            cd.currentPatchSet = ps;
            if (cd.limitedIds == null) {
                cd.patches = Lists.newArrayList(ps);
            }
        }
    }
}
#end_block

#method_before
public Collection<PatchSetApproval> currentApprovals(Provider<ReviewDb> db) throws OrmException {
    if (currentApprovals == null) {
        Change c = change(db);
        if (c == null) {
            currentApprovals = Collections.emptyList();
        } else if (approvalsMap != null) {
            return approvalsMap.get(c.currentPatchSetId());
        } else {
            currentApprovals = db.get().patchSetApprovals().byPatchSet(c.currentPatchSetId()).toList();
        }
    }
    return currentApprovals;
}
#method_after
public Collection<PatchSetApproval> currentApprovals(Provider<ReviewDb> db) throws OrmException {
    if (currentApprovals == null) {
        Change c = change(db);
        if (c == null) {
            currentApprovals = Collections.emptyList();
        } else if (approvals != null && (limitedIds == null || limitedIds.contains(c.currentPatchSetId()))) {
            return approvals.get(c.currentPatchSetId());
        } else {
            currentApprovals = db.get().patchSetApprovals().byPatchSet(c.currentPatchSetId()).toList();
        }
    }
    return currentApprovals;
}
#end_block

#method_before
public Collection<PatchSet> patches(Provider<ReviewDb> db) throws OrmException {
    if (patches == null) {
        if (patchSetIds != null) {
            patches = Lists.newArrayList();
            for (PatchSet ps : db.get().patchSets().byChange(legacyId)) {
                if (patchSetIds.contains(ps.getId())) {
                    patches.add(ps);
                }
            }
        } else {
            patches = db.get().patchSets().byChange(legacyId).toList();
        }
    }
    return patches;
}
#method_after
public Collection<PatchSet> patches(Provider<ReviewDb> db) throws OrmException {
    if (patches == null) {
        if (limitedIds != null) {
            patches = Lists.newArrayList();
            for (PatchSet ps : db.get().patchSets().byChange(legacyId)) {
                if (limitedIds.contains(ps.getId())) {
                    patches.add(ps);
                }
            }
        } else {
            patches = db.get().patchSets().byChange(legacyId).toList();
        }
    }
    return patches;
}
#end_block

#method_before
public Multimap<PatchSet.Id, PatchSetApproval> approvalsMap(Provider<ReviewDb> db) throws OrmException {
    if (approvalsMap == null) {
        approvalsMap = ArrayListMultimap.create();
        for (PatchSetApproval psa : db.get().patchSetApprovals().byChange(legacyId)) {
            if (patchSetIds == null || patchSetIds.contains(legacyId)) {
                approvalsMap.put(psa.getPatchSetId(), psa);
            }
        }
    }
    return approvalsMap;
}
#method_after
public Multimap<PatchSet.Id, PatchSetApproval> approvalsMap(Provider<ReviewDb> db) throws OrmException {
    if (approvals == null) {
        approvals = ArrayListMultimap.create();
        for (PatchSetApproval psa : db.get().patchSetApprovals().byChange(legacyId)) {
            if (limitedIds == null || limitedIds.contains(legacyId)) {
                approvals.put(psa.getPatchSetId(), psa);
            }
        }
    }
    return approvals;
}
#end_block

#method_before
public final Set<String> values() {
    return Natives.keys(values0());
}
#method_after
public final Set<String> values() {
    return Natives.keys(_values());
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    if (!accounts.isEmpty()) {
        for (Account account : db.get().accounts().get(accounts.keySet())) {
            AccountAttribute a = accounts.get(account.getId());
            a.name = Strings.emptyToNull(account.getFullName());
        }
    }
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = asAccountAttribute(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    if (options.contains(LABELS) || options.contains(DETAILED_LABELS)) {
        out.labels = labelsFor(cd, options.contains(DETAILED_LABELS));
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = labelsFor(cd, options.contains(LABELS), options.contains(DETAILED_LABELS));
    if (options.contains(DETAILED_LABELS)) {
        out.permitted_labels = permittedLabels(cd);
    }
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = asAccountAttribute(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = asAccountAttribute(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                if (detailed) {
                    ApprovalType at = approvalTypes.byLabel(r.label);
                    if (at != null) {
                        PermissionRange range = ctl.getRange(Permission.forLabel(r.label));
                        n.category = at.getCategory().getName();
                        n.id = at.getCategory().getId().get();
                        n.values = Maps.newLinkedHashMap();
                        for (ApprovalCategoryValue acv : at.getValues()) {
                            if (range.contains(acv.getValue())) {
                                n.values.put(acv.formatValue(), acv.getName());
                            }
                        }
                        if (n.values.size() == 1 && " 0".equals(Iterables.getOnlyElement(n.values.keySet()))) {
                            n.values = ImmutableMap.of();
                        }
                    }
                }
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = asAccountAttribute(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd, boolean standard, boolean detailed) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    initLabels(cd, labels, standard);
    Collection<PatchSetApproval> approvals = null;
    if (detailed) {
        approvals = cd.currentApprovals(db);
        setAllApprovals(labels, approvals);
    }
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null) {
            // TODO: Support arbitrary labels.
            continue;
        }
        if (standard) {
            approvals = setRecommendedAndDisliked(cd, approvals, type, e.getValue());
        }
        if (detailed) {
            setLabelValues(type, e.getValue());
        }
    }
    return labels;
}
#end_block

#method_before
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountInfoCache = new AccountInfo.Cache(db, !options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountInfoCache.fill();
    return res;
}
#method_after
public List<List<ChangeInfo>> formatList2(List<List<ChangeData>> in) throws OrmException {
    accountLoader = accountLoaderFactory.create(options.contains(DETAILED_ACCOUNTS));
    List<List<ChangeInfo>> res = Lists.newArrayListWithCapacity(in.size());
    for (List<ChangeData> changes : in) {
        ChangeData.ensureChangeLoaded(db, changes);
        ChangeData.ensureCurrentPatchSetLoaded(db, changes);
        ChangeData.ensureCurrentApprovalsLoaded(db, changes);
        res.add(toChangeInfo(changes));
    }
    accountLoader.fill();
    return res;
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountInfoCache.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd) throws OrmException {
    ChangeInfo out = new ChangeInfo();
    Change in = cd.change(db);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.changeId = in.getKey().get();
    out.subject = in.getSubject();
    out.status = in.getStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out._sortkey = in.getSortKey();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    out.reviewed = in.getStatus().isOpen() && isChangeReviewed(cd) ? true : null;
    out.labels = options.contains(LABELS) ? labelsFor(cd) : null;
    out.finish();
    if (options.contains(ALL_REVISIONS) || options.contains(CURRENT_REVISION)) {
        out.revisions = revisions(cd);
        for (String commit : out.revisions.keySet()) {
            if (out.revisions.get(commit).isCurrent) {
                out.current_revision = commit;
                break;
            }
        }
    }
    return out;
}
#end_block

#method_before
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountInfoCache.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountInfoCache.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountInfoCache.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelInfo> labelsFor(ChangeData cd) throws OrmException {
    ChangeControl ctl = control(cd);
    if (ctl == null) {
        return Collections.emptyMap();
    }
    PatchSet ps = cd.currentPatchSet(db);
    if (ps == null) {
        return Collections.emptyMap();
    }
    Map<String, LabelInfo> labels = Maps.newLinkedHashMap();
    for (SubmitRecord rec : ctl.canSubmit(db.get(), ps, cd, true, false)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelInfo p = labels.get(r.label);
            if (p == null || p._status.compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                n._status = r.status;
                switch(r.status) {
                    case OK:
                        n.approved = accountLoader.get(r.appliedBy);
                        break;
                    case REJECT:
                        n.rejected = accountLoader.get(r.appliedBy);
                        break;
                    default:
                        break;
                }
                n.optional = n._status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, n);
            }
        }
    }
    Collection<PatchSetApproval> approvals = null;
    for (Map.Entry<String, LabelInfo> e : labels.entrySet()) {
        if (e.getValue().approved != null || e.getValue().rejected != null) {
            continue;
        }
        ApprovalType type = approvalTypes.byLabel(e.getKey());
        if (type == null || type.getMin() == null || type.getMax() == null) {
            // Unknown or misconfigured type can't have intermediate scores.
            continue;
        }
        short min = type.getMin().getValue();
        short max = type.getMax().getValue();
        if (-1 <= min && max <= 1) {
            // Types with a range of -1..+1 can't have intermediate scores.
            continue;
        }
        if (approvals == null) {
            approvals = cd.currentApprovals(db);
        }
        for (PatchSetApproval psa : approvals) {
            short val = psa.getValue();
            if (val != 0 && min < val && val < max && psa.getCategoryId().equals(type.getCategory().getId())) {
                if (0 < val) {
                    e.getValue().recommended = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != 1 ? val : null;
                } else {
                    e.getValue().disliked = accountLoader.get(psa.getAccountId());
                    e.getValue().value = val != -1 ? val : null;
                }
            }
        }
    }
    return labels;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForReceiveCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new CommitterUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
public List<CommitValidationMessage> validateForRevertCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#method_after
public List<CommitValidationMessage> validateForRevertCommits(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    List<CommitValidationListener> validators = new LinkedList<CommitValidationListener>();
    validators.add(new UploadMergesPermissionValidator(refControl));
    validators.add(new AmendedGerritMergeCommitValidationListener(refControl, gerritIdent));
    validators.add(new AuthorUploaderValidator(refControl, canonicalWebUrl));
    validators.add(new SignedOffByValidator(refControl, canonicalWebUrl));
    if (MagicBranch.isMagicBranch(receiveEvent.command.getRefName()) || NEW_PATCHSET.matcher(receiveEvent.command.getRefName()).matches()) {
        validators.add(new ChangeIdValidator(refControl, canonicalWebUrl, sshInfo));
    }
    validators.add(new ConfigValidator(refControl, repo));
    validators.add(new PluginCommitValidationListener(commitValidationListeners));
    List<CommitValidationMessage> messages = new LinkedList<CommitValidationMessage>();
    try {
        for (CommitValidationListener commitValidator : validators) {
            messages.addAll(commitValidator.onCommitReceived(receiveEvent));
        }
    } catch (CommitValidationException e) {
        // Keep the old messages (and their order) in case of an exception
        messages.addAll(e.getMessages());
        throw new CommitValidationException(e.getMessage(), messages);
    }
    return messages;
}
#end_block

#method_before
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = Strings.nullToEmpty(a.name()).compareTo(Strings.nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#method_after
void insert(GroupInfo info) {
    Comparator<GroupInfo> c = new Comparator<GroupInfo>() {

        @Override
        public int compare(GroupInfo a, GroupInfo b) {
            int cmp = nullToEmpty(a.name()).compareTo(nullToEmpty(b.name()));
            if (cmp != 0) {
                return cmp;
            }
            return a.getGroupUUID().compareTo(b.getGroupUUID());
        }

        private String nullToEmpty(@Nullable String str) {
            return (str == null) ? "" : str;
        }
    };
    int insertPosition = table.getRowCount();
    int left = 1;
    int right = table.getRowCount() - 1;
    while (left <= right) {
        // (left+right)/2
        int middle = (left + right) >>> 1;
        GroupInfo i = getRowItem(middle);
        int cmp = c.compare(i, info);
        if (cmp < 0) {
            left = middle + 1;
        } else if (cmp > 0) {
            right = middle - 1;
        } else {
            // group is already contained in the table
            return;
        }
    }
    insertPosition = left;
    table.insertRow(insertPosition);
    applyDataRowStyle(insertPosition);
    populate(insertPosition, info);
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    // Add icons to lineNumber column header
    if (headerSideA.isFileOrCommitMessae()) {
        table.setWidget(R_HEAD, 1, iconA);
    }
    if (headerSideB.isFileOrCommitMessae()) {
        table.setWidget(rowOfTableHeaderB, 2, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, PC, headerSideA);
    table.setWidget(rowOfTableHeaderB, PC, headerSideB);
    table.getFlexCellFormatter().addStyleName(R_HEAD, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    table.getFlexCellFormatter().addStyleName(rowOfTableHeaderB, PC, Gerrit.RESOURCES.css().unifiedTableHeader());
    // Add icons to lineNumber column header
    if (headerSideA.isFileOrCommitMessage()) {
        table.setWidget(R_HEAD, 1, iconA);
    }
    if (headerSideB.isFileOrCommitMessage()) {
        table.setWidget(rowOfTableHeaderB, 2, iconB);
    }
}
#end_block

#method_before
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFileOrCommitMessae()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFileOrCommitMessae()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#method_after
private void populateTableHeader(final PatchScript script, final PatchSetDetail detail) {
    initHeaders(script, detail);
    table.setWidget(R_HEAD, A, headerSideA);
    table.setWidget(R_HEAD, B, headerSideB);
    // Populate icons to lineNumber column header.
    if (headerSideA.isFileOrCommitMessage()) {
        table.setWidget(R_HEAD, A - 1, iconA);
    }
    if (headerSideB.isFileOrCommitMessage()) {
        table.setWidget(R_HEAD, B + 1, iconB);
    }
}
#end_block

#method_before
protected void initHeaders(PatchScript script, PatchSetDetail detail) {
    PatchScreen.Type type = getPatchScreenType();
    headerSideA = new PatchSetSelectBox(PatchSetSelectBox.Side.A, type);
    headerSideA.display(detail, script, patchKey, idSideA, idSideB);
    headerSideA.addDoubleClickHandler(new DoubleClickHandler() {

        @Override
        public void onDoubleClick(DoubleClickEvent event) {
            if (headerSideA.isFileOrCommitMessae()) {
                createFileCommentEditorOnSideA();
            }
        }
    });
    headerSideB = new PatchSetSelectBox(PatchSetSelectBox.Side.B, type);
    headerSideB.display(detail, script, patchKey, idSideA, idSideB);
    headerSideB.addDoubleClickHandler(new DoubleClickHandler() {

        @Override
        public void onDoubleClick(DoubleClickEvent event) {
            if (headerSideB.isFileOrCommitMessae()) {
                createFileCommentEditorOnSideB();
            }
        }
    });
    // Prepare icons.
    iconA = new Image(Gerrit.RESOURCES.addFileComment());
    iconA.setTitle(PatchUtil.C.addFileCommentToolTip());
    iconA.addStyleName(Gerrit.RESOURCES.css().link());
    iconA.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            createFileCommentEditorOnSideA();
        }
    });
    iconB = new Image(Gerrit.RESOURCES.addFileComment());
    iconB.setTitle(PatchUtil.C.addFileCommentToolTip());
    iconB.addStyleName(Gerrit.RESOURCES.css().link());
    iconB.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            createFileCommentEditorOnSideB();
        }
    });
}
#method_after
protected void initHeaders(PatchScript script, PatchSetDetail detail) {
    PatchScreen.Type type = getPatchScreenType();
    headerSideA = new PatchSetSelectBox(PatchSetSelectBox.Side.A, type);
    headerSideA.display(detail, script, patchKey, idSideA, idSideB);
    headerSideA.addDoubleClickHandler(new DoubleClickHandler() {

        @Override
        public void onDoubleClick(DoubleClickEvent event) {
            if (headerSideA.isFileOrCommitMessage()) {
                createFileCommentEditorOnSideA();
            }
        }
    });
    headerSideB = new PatchSetSelectBox(PatchSetSelectBox.Side.B, type);
    headerSideB.display(detail, script, patchKey, idSideA, idSideB);
    headerSideB.addDoubleClickHandler(new DoubleClickHandler() {

        @Override
        public void onDoubleClick(DoubleClickEvent event) {
            if (headerSideB.isFileOrCommitMessage()) {
                createFileCommentEditorOnSideB();
            }
        }
    });
    // Prepare icons.
    iconA = new Image(Gerrit.RESOURCES.addFileComment());
    iconA.setTitle(PatchUtil.C.addFileCommentToolTip());
    iconA.addStyleName(Gerrit.RESOURCES.css().link());
    iconA.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            createFileCommentEditorOnSideA();
        }
    });
    iconB = new Image(Gerrit.RESOURCES.addFileComment());
    iconB.setTitle(PatchUtil.C.addFileCommentToolTip());
    iconB.addStyleName(Gerrit.RESOURCES.css().link());
    iconB.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            createFileCommentEditorOnSideB();
        }
    });
}
#end_block

#method_before
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    if (isFileOrCommitMessae()) {
        linkPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#method_after
public void display(final PatchSetDetail detail, final PatchScript script, Patch.Key key, PatchSet.Id idSideA, PatchSet.Id idSideB) {
    this.script = script;
    this.patchKey = key;
    this.idSideA = idSideA;
    this.idSideB = idSideB;
    this.idActive = (side == Side.A) ? idSideA : idSideB;
    this.links = new HashMap<Integer, Anchor>();
    linkPanel.clear();
    if (isFileOrCommitMessage()) {
        linkPanel.setTitle(PatchUtil.C.addFileCommentByDoubleClick());
    }
    patchSet = new Label(PatchUtil.C.patchSet());
    patchSet.addStyleName(style.patchSetLabel());
    linkPanel.add(patchSet);
    if (screenType == PatchScreen.Type.UNIFIED) {
        Label sideMarker = new Label((side == Side.A) ? "(-)" : "(+)");
        sideMarker.addStyleName(style.sideMarker());
        linkPanel.add(sideMarker);
    }
    Anchor baseLink = null;
    if (detail.getInfo().getParents().size() > 1) {
        baseLink = createLink(PatchUtil.C.patchBaseAutoMerge(), null);
    } else {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
    }
    links.put(0, baseLink);
    if (screenType == PatchScreen.Type.UNIFIED || side == Side.A) {
        linkPanel.add(baseLink);
    }
    if (side == Side.B) {
        links.get(0).setStyleName(style.hidden());
    }
    for (Patch patch : script.getHistory()) {
        PatchSet.Id psId = patch.getKey().getParentKey();
        Anchor anchor = createLink(Integer.toString(psId.get()), psId);
        links.put(psId.get(), anchor);
        linkPanel.add(anchor);
    }
    if (idActive == null && side == Side.A) {
        links.get(0).setStyleName(style.selected());
    } else {
        links.get(idActive.get()).setStyleName(style.selected());
    }
    Anchor downloadLink = createDownloadLink();
    if (downloadLink != null) {
        linkPanel.add(downloadLink);
    }
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.emptyToNull(input.owner) == null) {
        throw new BadRequestException("new owner is missing");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        if (!internalGroup.getOwnerGroupUUID().equals(owner.getUUID())) {
            internalGroup.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(internalGroup));
            groupCache.evict(internalGroup);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, ResourceNotFoundException, OrmException {
    AccountGroup group = resource.toAccountGroup();
    if (group == null) {
        throw new MethodNotAllowedException();
    } else if (!resource.getControl().isOwner()) {
        throw new AuthException("Not group owner");
    }
    if (input == null || Strings.isNullOrEmpty(input.owner)) {
        throw new BadRequestException("owner is required");
    }
    GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, input.owner);
    if (owner == null) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
    try {
        GroupControl c = controlFactory.validateFor(owner.getUUID());
        group = db.accountGroups().get(group.getId());
        if (group == null) {
            throw new ResourceNotFoundException();
        }
        if (!group.getOwnerGroupUUID().equals(owner.getUUID())) {
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
        }
        return new GroupInfo(c.getGroup());
    } catch (NoSuchGroupException e) {
        throw new BadRequestException(String.format("No such group: %s", input.owner));
    }
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    com.google.gwtjsonrpc.common.AsyncCallback<PatchSetPublishDetail> load = new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    };
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.add(load));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cbs = new CallbackGroup();
    Util.DETAIL_SVC.patchSetPublishDetail(patchSetId, cbs.addGwtjsonrpc(new ScreenLoadCallback<PatchSetPublishDetail>(this) {

        @Override
        protected void preDisplay(final PatchSetPublishDetail result) {
            send.setEnabled(true);
            display(result);
        }

        @Override
        protected void postDisplay() {
            message.setFocus(true);
        }
    }));
}
#end_block

#method_before
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    Throwable caught = null;
    for (Object o : callbacks) {
        try {
            Object result = results.get(o);
            if (o instanceof AsyncCallback) {
                @SuppressWarnings("unchecked")
                AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
                cb.onSuccess(result);
            } else {
                @SuppressWarnings("unchecked")
                com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
                cb.onSuccess(result);
            }
        } catch (Throwable t) {
            if (caught != null) {
                caught = t;
            }
        }
    }
    if (caught != null) {
        if (caught instanceof RuntimeException) {
            throw (RuntimeException) caught;
        } else if (caught instanceof Error) {
            throw (Error) caught;
        } else {
            throw new RuntimeException(caught);
        }
    }
}
#method_after
private void onSuccess() {
    if (results.size() < callbacks.size()) {
        return;
    }
    for (Object o : callbacks) {
        Object result = results.get(o);
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onSuccess(result);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onSuccess(result);
        }
    }
}
#end_block

#method_before
private void onFailure(Throwable caught) {
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#method_after
private void onFailure(Throwable caught) {
    if (failed) {
        return;
    }
    failed = true;
    for (Object o : callbacks) {
        if (o instanceof AsyncCallback) {
            @SuppressWarnings("unchecked")
            AsyncCallback<Object> cb = (AsyncCallback<Object>) o;
            cb.onFailure(caught);
        } else {
            @SuppressWarnings("unchecked")
            com.google.gwtjsonrpc.common.AsyncCallback<Object> cb = (com.google.gwtjsonrpc.common.AsyncCallback<Object>) o;
            cb.onFailure(caught);
        }
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (!headless) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    if (uiOptions.enableDefaultUi()) {
        serve("/").with(HostPageServlet.class);
        serve("/Gerrit").with(LegacyGerritServlet.class);
        serve("/Gerrit/*").with(legacyGerritScreen());
    }
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bindConstant().annotatedWith(Names.named("Headless")).to(false);
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new MasterNodeStartup());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(false));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(SshKeyCacheImpl.module());
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bindConstant().annotatedWith(Names.named("HEADLESS")).to(headless);
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<Module>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (httpd) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(SshKeyCacheImpl.module());
    if (!slave) {
        modules.add(new MasterNodeStartup());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritUiOptions.class).toInstance(new GerritUiOptions(headless));
        }
    });
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, headless));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    switch(authConfig.getAuthType()) {
        case HTTP:
        case HTTP_LDAP:
            install(new HttpAuthModule());
            break;
        case CLIENT_SSL_CERT_LDAP:
            install(new HttpsClientSslCertModule());
            break;
        case LDAP:
        case LDAP_BIND:
            install(new LdapAuthModule());
            break;
        case DEVELOPMENT_BECOME_ANY_ACCOUNT:
            install(new ServletModule() {

                @Override
                protected void configureServlets() {
                    serve("/become").with(BecomeAnyAccountLoginServlet.class);
                }
            });
            break;
        case OPENID:
        case OPENID_SSO:
        // OpenID support is bound in WebAppInitializer and Daemon.
        case CUSTOM_EXTENSION:
            break;
        default:
            throw new ProvisionException("Unsupported loginType: " + authConfig.getAuthType());
    }
    install(new UrlModule(urlConfig, uiOptions));
    install(new UiRpcModule());
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module());
    bind(GitWebConfig.class).toInstance(gitWebConfig);
    if (gitWebConfig.getGitwebCGI() != null) {
        install(new GitWebModule());
    }
    bind(ContactStore.class).toProvider(ContactStoreProvider.class).in(SINGLETON);
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    factory(ClearPassword.Factory.class);
    install(new CmdLineParserModule());
    factory(GeneratePassword.Factory.class);
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    install(new LifecycleModule() {

        @Override
        protected void configure() {
            listener().toInstance(registerInParentInjectors());
        }
    });
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append(uuid.toString());
    sb.append("|");
    sb.append(sessionId);
    sb.append('|');
    sb.append(who);
    sb.append('|');
    sb.append(when);
    sb.append('|');
    sb.append(what);
    sb.append('|');
    sb.append(elapsed);
    sb.append('|');
    if (params != null) {
        sb.append('[');
        for (int i = 0; i < params.size(); i++) {
            if (i > 0)
                sb.append(',');
            if (params != null) {
                Set<String> paramNames = params.keySet();
                for (String paramName : paramNames) {
                    sb.append("name=");
                    sb.append(paramName);
                    int numValues = 0;
                    Collection<?> paramValues = params.get(paramName);
                    for (Object paramValue : paramValues) {
                        sb.append(Objects.firstNonNull(paramValue, "null"));
                        if (numValues++ > 0) {
                            sb.append(",");
                        }
                    }
                }
            }
        }
        sb.append(']');
    }
    sb.append('|');
    if (result != null) {
        sb.append(result);
    }
    return sb.toString();
}
#method_after
@Override
public String toString() {
    return String.format("AuditEvent UUID:%s, SID:%s, TS:%d, who:%s, what:%s", uuid.get(), sessionId, when, who, what);
}
#end_block

#method_before
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
        } else {
            if (paramName == null) {
                parms.put("$" + argPos++, arg);
            } else {
                parms.put(paramName, arg);
                paramName = null;
            }
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#method_after
private Multimap<String, ?> extractParameters(DispatchCommand dcmd) {
    String[] cmdArgs = dcmd.getArguments();
    String paramName = null;
    int argPos = 0;
    Multimap<String, String> parms = ArrayListMultimap.create();
    for (int i = 2; i < cmdArgs.length; i++) {
        String arg = cmdArgs[i];
        // -- stop parameters parsing
        if (arg.equals("--")) {
            for (i++; i < cmdArgs.length; i++) {
                parms.put("$" + argPos++, cmdArgs[i]);
            }
            break;
        }
        // --param=value
        int eqPos = arg.indexOf('=');
        if (arg.startsWith("--") && eqPos > 0) {
            parms.put(arg.substring(0, eqPos), arg.substring(eqPos + 1));
            continue;
        }
        // -p value or --param value
        if (arg.startsWith("-")) {
            if (paramName != null) {
                parms.put(paramName, null);
            }
            paramName = arg;
            continue;
        }
        // value
        if (paramName == null) {
            parms.put("$" + argPos++, arg);
        } else {
            parms.put(paramName, arg);
            paramName = null;
        }
    }
    if (paramName != null) {
        parms.put(paramName, null);
    }
    return parms;
}
#end_block

#method_before
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + cmd, created, null, result));
}
#method_after
void audit(Context ctx, Object result, String cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), cmd, created, null, result));
}
#end_block

#method_before
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new AuditEvent(sid, extractCurrentUser(ctx), "ssh:" + extractWhat(cmd), created, extractParameters(cmd), result));
}
#method_after
void audit(Context ctx, Object result, DispatchCommand cmd) {
    final String sid = extractSessionId(ctx);
    final long created = extractCreated(ctx);
    auditService.dispatch(new SshAuditEvent(sid, extractCurrentUser(ctx), extractWhat(cmd), created, extractParameters(cmd), result));
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    int status = SC_OK;
    Object result = "";
    Multimap<String, String> params = LinkedHashMultimap.create();
    res.setHeader("Expires", "Fri, 01 Jan 1980 00:00:00 GMT");
    res.setHeader("Pragma", "no-cache");
    res.setHeader("Cache-Control", "no-cache, must-revalidate");
    res.setHeader("Content-Disposition", "attachment");
    try {
        checkUserSession(req);
        List<String> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            view = rc.list();
        } else {
            String id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                view = c.list();
                break;
            } else {
                rsrc = c.parse(rsrc, path.remove(0));
                view = view(c, req.getMethod(), path);
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            result = m.apply(rsrc, parseRequest(req, m.inputType()));
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        res.setStatus(status);
        if (result instanceof BinaryResult) {
            replyBinaryResult(req, res, (BinaryResult) result);
        } else {
            replyJson(req, res, config, result);
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (InvalidMethodException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new AuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getMethod() + " " + req.getRequestURI(), auditStartTs, params, status + " " + result));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = System.currentTimeMillis();
    CacheHeaders.setNotCacheable(res);
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        checkAccessAnnotations(rc.getClass());
        RestResource rsrc = TopLevelResource.INSTANCE;
        RestView<RestResource> view = null;
        if (path.isEmpty()) {
            if ("GET".equals(req.getMethod())) {
                view = rc.list();
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                view = ac.post(rsrc);
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                checkPreconditions(req, rsrc);
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    view = ac.create(rsrc, id);
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (view == null) {
                view = view(rc, req.getMethod(), path);
            }
        }
        checkAccessAnnotations(view.getClass());
        while (view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) view;
            if (path.isEmpty()) {
                if ("GET".equals(req.getMethod())) {
                    view = c.list();
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    view = ac.post(rsrc);
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req, rsrc);
                    view = null;
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        view = ac.create(rsrc, id);
                        status = SC_CREATED;
                    } else {
                        throw e;
                    }
                }
                if (view == null) {
                    view = view(c, req.getMethod(), path);
                }
            }
            checkAccessAnnotations(view.getClass());
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(view, params, req, res)) {
            return;
        }
        if (view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response r = (Response) result;
            status = r.statusCode();
        } else if (result instanceof Response.Redirect) {
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (AuthException e) {
        replyError(res, status = SC_FORBIDDEN, e.getMessage());
    } catch (BadRequestException e) {
        replyError(res, status = SC_BAD_REQUEST, e.getMessage());
    } catch (MethodNotAllowedException e) {
        replyError(res, status = SC_METHOD_NOT_ALLOWED, "Method not allowed");
    } catch (ResourceConflictException e) {
        replyError(res, status = SC_CONFLICT, e.getMessage());
    } catch (PreconditionFailedException e) {
        replyError(res, status = SC_PRECONDITION_FAILED, Objects.firstNonNull(e.getMessage(), "Precondition failed"));
    } catch (ResourceNotFoundException e) {
        replyError(res, status = SC_NOT_FOUND, "Not found");
    } catch (AmbiguousViewException e) {
        replyError(res, status = SC_NOT_FOUND, e.getMessage());
    } catch (JsonParseException e) {
        replyError(res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request");
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new HttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req.getRequestURI(), auditStartTs, params, req.getMethod(), inputRequestBody, status, result));
    }
}
#end_block

#method_before
private Object parseRequest(HttpServletRequest req, Class<Object> type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, InvalidMethodException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (type.getDeclaredFields().length == 0 && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#method_after
private Object parseRequest(HttpServletRequest req, Type type) throws IOException, BadRequestException, SecurityException, IllegalArgumentException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, MethodNotAllowedException {
    if (isType(JSON_TYPE, req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            JsonReader json = new JsonReader(br);
            JsonToken first;
            try {
                first = json.peek();
            } catch (EOFException e) {
                throw new BadRequestException("Expected JSON object");
            }
            if (first == JsonToken.STRING) {
                return parseString(json.nextString(), type);
            }
            return OutputFormat.JSON.newGson().fromJson(json, type);
        } finally {
            br.close();
        }
    } else if ("PUT".equals(req.getMethod()) && acceptsPutInput(type)) {
        return parsePutInput(req, type);
    } else if ("DELETE".equals(req.getMethod()) && hasNoBody(req)) {
        return null;
    } else if (isEmptyType(type) && hasNoBody(req)) {
        return createInstance(type);
    } else if (isType("text/plain", req.getContentType())) {
        BufferedReader br = req.getReader();
        try {
            char[] tmp = new char[256];
            StringBuilder sb = new StringBuilder();
            int n;
            while (0 < (n = br.read(tmp))) {
                sb.append(tmp, 0, n);
            }
            return parseString(sb.toString(), type);
        } finally {
            br.close();
        }
    } else if ("POST".equals(req.getMethod()) && isType(FORM_TYPE, req.getContentType())) {
        return OutputFormat.JSON.newGson().fromJson(ParameterParser.formToJson(req), type);
    } else {
        throw new BadRequestException("Expected Content-Type: " + JSON_TYPE);
    }
}
#end_block

#method_before
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType("application/x-www-form-urlencoded", type));
}
#method_after
private static boolean hasNoBody(HttpServletRequest req) {
    int len = req.getContentLength();
    String type = req.getContentType();
    return (len <= 0 && type == null) || (len == 0 && isType(FORM_TYPE, type));
}
#end_block

#method_before
private static boolean acceptsPutInput(Class<Object> type) {
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            return true;
        }
    }
    return false;
}
#method_after
@SuppressWarnings("rawtypes")
private static boolean acceptsPutInput(Type type) {
    if (type instanceof Class) {
        for (Field f : ((Class) type).getDeclaredFields()) {
            if (f.getType() == PutInput.class) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
private Object parsePutInput(final HttpServletRequest req, Class<Object> type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, InvalidMethodException {
    Object obj = createInstance(type);
    for (Field f : type.getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new InvalidMethodException();
}
#method_after
private Object parsePutInput(final HttpServletRequest req, Type type) throws SecurityException, NoSuchMethodException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException, MethodNotAllowedException {
    Object obj = createInstance(type);
    for (Field f : obj.getClass().getDeclaredFields()) {
        if (f.getType() == PutInput.class) {
            f.setAccessible(true);
            f.set(obj, new PutInput() {

                @Override
                public String getContentType() {
                    return req.getContentType();
                }

                @Override
                public long getContentLength() {
                    return req.getContentLength();
                }

                @Override
                public InputStream getInputStream() throws IOException {
                    return req.getInputStream();
                }
            });
            return obj;
        }
    }
    throw new MethodNotAllowedException();
}
#end_block

#method_before
private Object parseString(String value, Class<Object> type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    Object obj = createInstance(type);
    Field[] fields = type.getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#method_after
private Object parseString(String value, Type type) throws BadRequestException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InstantiationException, InvocationTargetException {
    if (type == String.class) {
        return value;
    }
    Object obj = createInstance(type);
    Field[] fields = obj.getClass().getDeclaredFields();
    if (fields.length == 0 && Strings.isNullOrEmpty(value)) {
        return obj;
    }
    for (Field f : fields) {
        if (f.getAnnotation(DefaultInput.class) != null && f.getType() == String.class) {
            f.setAccessible(true);
            f.set(obj, value);
            return obj;
        }
    }
    throw new BadRequestException("Expected JSON object");
}
#end_block

#method_before
private static Object createInstance(Class<Object> type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<Object> c = type.getDeclaredConstructor();
    c.setAccessible(true);
    return c.newInstance();
}
#method_after
private static Object createInstance(Type type) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    if (type instanceof Class) {
        @SuppressWarnings("unchecked")
        Class<Object> clazz = (Class<Object>) type;
        Constructor<Object> c = clazz.getDeclaredConstructor();
        c.setAccessible(true);
        return c.newInstance();
    }
    throw new InstantiationException("Cannot make " + type);
}
#end_block

#method_before
private static void replyJson(HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8));
}
#method_after
private static void replyJson(@Nullable HttpServletRequest req, HttpServletResponse res, Multimap<String, String> config, Object result) throws IOException {
    final TemporaryBuffer.Heap buf = heap(Integer.MAX_VALUE);
    buf.write(JSON_MAGIC);
    Writer w = new BufferedWriter(new OutputStreamWriter(buf, UTF_8));
    Gson gson = newGson(config, req);
    if (result instanceof JsonElement) {
        gson.toJson((JsonElement) result, w);
    } else {
        gson.toJson(result, w);
    }
    w.write('\n');
    w.flush();
    replyBinaryResult(req, res, new BinaryResult() {

        @Override
        public long getContentLength() {
            return buf.length();
        }

        @Override
        public void writeTo(OutputStream os) throws IOException {
            buf.writeTo(os, null);
        }
    }.setContentType(JSON_TYPE).setCharacterEncoding(UTF_8.name()));
}
#end_block

#method_before
private static Gson newGson(Multimap<String, String> config, HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#method_after
private static Gson newGson(Multimap<String, String> config, @Nullable HttpServletRequest req) {
    GsonBuilder gb = OutputFormat.JSON_COMPACT.newGsonBuilder().setFieldNamingPolicy(NAMING);
    enablePrettyPrint(gb, config, req);
    enablePartialGetFields(gb, config);
    return gb.create();
}
#end_block

#method_before
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#method_after
private static void enablePrettyPrint(GsonBuilder gb, Multimap<String, String> config, @Nullable HttpServletRequest req) {
    String pp = Iterables.getFirst(config.get("pp"), null);
    if (pp == null) {
        pp = Iterables.getFirst(config.get("prettyPrint"), null);
        if (pp == null && req != null) {
            pp = acceptsJson(req) ? "0" : "1";
        }
    }
    if ("1".equals(pp) || "true".equals(pp)) {
        gb.setPrettyPrinting();
    }
}
#end_block

#method_before
private static void replyBinaryResult(HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                res.setContentLength((int) buf.length());
                res.setHeader("Content-Encoding", "gzip");
                buf.writeTo(dst, null);
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                if (0 <= len && len < Integer.MAX_VALUE) {
                    res.setContentLength((int) len);
                } else if (0 <= len) {
                    res.setHeader("Content-Length", Long.toString(len));
                }
                bin.writeTo(dst);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#method_after
static void replyBinaryResult(@Nullable HttpServletRequest req, HttpServletResponse res, BinaryResult bin) throws IOException {
    try {
        res.setContentType(bin.getContentType());
        OutputStream dst = res.getOutputStream();
        try {
            long len = bin.getContentLength();
            boolean gzip = bin.canGzip() && acceptsGzip(req);
            if (gzip && 256 <= len && len <= (10 << 20)) {
                TemporaryBuffer.Heap buf = compress(bin);
                if (buf.length() < len) {
                    res.setContentLength((int) buf.length());
                    res.setHeader("Content-Encoding", "gzip");
                    buf.writeTo(dst, null);
                } else {
                    replyUncompressed(res, dst, bin, len);
                }
            } else if (gzip) {
                res.setHeader("Content-Encoding", "gzip");
                dst = new GZIPOutputStream(dst);
                bin.writeTo(dst);
            } else {
                replyUncompressed(res, dst, bin, len);
            }
        } finally {
            dst.close();
        }
    } finally {
        bin.close();
    }
}
#end_block

#method_before
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<String> path) throws ResourceNotFoundException, InvalidMethodException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final String projection = path.isEmpty() ? "/" : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#method_after
private RestView<RestResource> view(RestCollection<RestResource, RestResource> rc, String method, List<IdString> path) throws ResourceNotFoundException, MethodNotAllowedException, AmbiguousViewException {
    DynamicMap<RestView<RestResource>> views = rc.views();
    final IdString projection = path.isEmpty() ? IdString.fromUrl("/") : path.remove(0);
    if (!path.isEmpty()) {
        // If there are path components still remaining after this projection
        // is chosen, look for the projection based upon GET as the method as
        // the client thinks it is a nested collection.
        method = "GET";
    }
    List<String> p = splitProjection(projection);
    if (p.size() == 2) {
        RestView<RestResource> view = views.get(p.get(0), method + "." + p.get(1));
        if (view != null) {
            return view;
        }
        throw new ResourceNotFoundException(projection);
    }
    String name = method + "." + p.get(0);
    RestView<RestResource> core = views.get("gerrit", name);
    if (core != null) {
        return core;
    }
    Map<String, RestView<RestResource>> r = Maps.newTreeMap();
    for (String plugin : views.plugins()) {
        RestView<RestResource> action = views.get(plugin, name);
        if (action != null) {
            r.put(plugin, action);
        }
    }
    if (r.size() == 1) {
        return Iterables.getFirst(r.values(), null);
    } else if (r.isEmpty()) {
        throw new ResourceNotFoundException(projection);
    } else {
        throw new AmbiguousViewException(String.format("Projection %s is ambiguous: ", name, Joiner.on(", ").join(Iterables.transform(r.keySet(), new Function<String, String>() {

            @Override
            public String apply(String in) {
                return in + "~" + projection;
            }
        }))));
    }
}
#end_block

#method_before
private static List<String> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<String> out = Lists.newArrayList(Splitter.on('/').split(path));
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#method_after
private static List<IdString> splitPath(HttpServletRequest req) {
    String path = req.getPathInfo();
    if (Strings.isNullOrEmpty(path)) {
        return Collections.emptyList();
    }
    List<IdString> out = Lists.newArrayList();
    for (String p : Splitter.on('/').split(path)) {
        out.add(IdString.fromUrl(p));
    }
    if (out.size() > 0 && out.get(out.size() - 1).isEmpty()) {
        out.remove(out.size() - 1);
    }
    return out;
}
#end_block

#method_before
private static List<String> splitProjection(String projection) {
    return Lists.newArrayList(Splitter.on('~').limit(2).split(projection));
}
#method_after
private static List<String> splitProjection(IdString projection) {
    List<String> p = Lists.newArrayListWithCapacity(2);
    Iterables.addAll(p, Splitter.on('~').limit(2).split(projection.get()));
    return p;
}
#end_block

#method_before
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if (!text.endsWith("\n")) {
        text += "\n";
    }
    replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
}
#method_after
static void replyText(@Nullable HttpServletRequest req, HttpServletResponse res, String text) throws IOException {
    if ((req == null || "GET".equals(req.getMethod())) && isMaybeHTML(text)) {
        replyJson(req, res, ImmutableMultimap.of("pp", "0"), new JsonPrimitive(text));
    } else {
        if (!text.endsWith("\n")) {
            text += "\n";
        }
        replyBinaryResult(req, res, BinaryResult.create(text).setContentType("text/plain"));
    }
}
#end_block

#method_before
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader("Accept"));
}
#method_after
private static boolean acceptsJson(HttpServletRequest req) {
    return req != null && isType(JSON_TYPE, req.getHeader(HttpHeaders.ACCEPT));
}
#end_block

#method_before
private static boolean acceptsGzip(HttpServletRequest req) {
    return req != null && RPCServletUtils.acceptsGzipEncoding(req);
}
#method_after
private static boolean acceptsGzip(HttpServletRequest req) {
    if (req != null) {
        String accepts = req.getHeader(HttpHeaders.ACCEPT_ENCODING);
        return accepts != null && accepts.indexOf("gzip") != -1;
    }
    return false;
}
#end_block

#method_before
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, rsp);
    currentCall.set(call);
    return call;
}
#method_after
@Override
protected GerritCall createActiveCall(final HttpServletRequest req, final HttpServletResponse rsp) {
    final GerritCall call = new GerritCall(session.get(), req, new AuditedHttpServletResponse(rsp));
    currentCall.set(call);
    return call;
}
#end_block

#method_before
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, method.getName());
            final Object result = call.getResult();
            audit.dispatch(new AuditEvent(sid, username, what, call.getWhen(), args, result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#method_after
private void audit() {
    try {
        GerritCall call = currentCall.get();
        MethodHandle method = call.getMethod();
        if (method == null) {
            return;
        }
        Audit note = (Audit) method.getAnnotation(Audit.class);
        if (note != null) {
            final String sid = call.getWebSession().getSessionId();
            final CurrentUser username = call.getWebSession().getCurrentUser();
            final Multimap<String, ?> args = extractParams(note, call);
            final String what = extractWhat(note, call);
            final Object result = call.getResult();
            audit.dispatch(new RpcAuditEvent(sid, username, what, call.getWhen(), args, call.getHttpServletRequest().getMethod(), call.getHttpServletRequest().getMethod(), ((AuditedHttpServletResponse) (call.getHttpServletResponse())).getStatus(), result));
        }
    } catch (Throwable all) {
        log.error("Unable to log the call", all);
    }
}
#end_block

#method_before
private String extractWhat(final Audit note, final String methodName) {
    String what = note.action();
    if (what.length() == 0) {
        boolean ccase = Character.isLowerCase(methodName.charAt(0));
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < methodName.length(); i++) {
            char c = methodName.charAt(i);
            if (ccase && !Character.isLowerCase(c)) {
                sb.append(' ');
            }
            sb.append(Character.toLowerCase(c));
        }
        what = sb.toString();
    }
    return what;
}
#method_after
private String extractWhat(final Audit note, final GerritCall call) {
    String methodClass = call.getMethodClass().getName();
    methodClass = methodClass.substring(methodClass.lastIndexOf(".") + 1);
    String what = note.action();
    if (what.length() == 0) {
        what = call.getMethod().getName();
    }
    return methodClass + "." + what;
}
#end_block

#method_before
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else {
        // 
        return session.isSignedIn() && session.isValidAuthorization(keyIn);
    }
}
#method_after
@Override
public boolean xsrfValidate() {
    final String keyIn = getXsrfKeyIn();
    if (keyIn == null || "".equals(keyIn)) {
        // 
        return !session.isSignedIn();
    } else if (session.isSignedIn() && session.isValidAuthorization(keyIn)) {
        // The session must exist, and must be using this token.
        // 
        session.getCurrentUser().setAccessPath(AccessPath.JSON_RPC);
        return true;
    }
    return false;
}
#end_block

#method_before
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    MarkReviewedInput in = MarkReviewedInput.create();
    in.reviewed(reviewed);
    PatchSet.Id ps = patchKey.getParentKey();
    new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed").post(in, new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    });
}
#method_after
public void setReviewedByCurrentUser(boolean reviewed) {
    if (fileList != null) {
        fileList.updateReviewedStatus(patchKey, reviewed);
    }
    PatchSet.Id ps = patchKey.getParentKey();
    RestApi api = new RestApi("/changes/").id(ps.getParentKey().get()).view("revisions").id(ps.get()).view("files").id(patchKey.getFileName()).view("reviewed");
    AsyncCallback<VoidResult> cb = new AsyncCallback<VoidResult>() {

        @Override
        public void onFailure(Throwable arg0) {
        // nop
        }

        @Override
        public void onSuccess(VoidResult result) {
        // nop
        }
    };
    if (reviewed) {
        api.put(cb);
    } else {
        api.delete(cb);
    }
}
#end_block

#method_before
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#method_after
public RestApi addParameter(String name, String value) {
    return addParameterRaw(name, URL.encodeQueryString(value));
}
#end_block

#method_before
public RestApi addParameter(String name, Enum<?> value) {
    return addParameterRaw(name, value.name());
}
#method_after
public RestApi addParameter(String name, String... value) {
    for (String val : value) {
        addParameter(name, val);
    }
    return this;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    post(PATCH_KIND, "reviewed").to(MarkReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Patches.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), PATCH_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "files").to(Patches.class);
    put(PATCH_KIND, "reviewed").to(PutReviewed.class);
    delete(PATCH_KIND, "reviewed").to(DeleteReviewed.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(EmailReviewComments.Factory.class);
        }
    });
}
#end_block

#method_before
static Input init(Input in) {
    if (in == null) {
        in = new Input();
    }
    if (in.includedGroups == null) {
        in.includedGroups = Lists.newArrayListWithCapacity(1);
    }
    if (!Strings.isNullOrEmpty(in._oneIncludedGroup)) {
        in.includedGroups.add(in._oneIncludedGroup);
    }
    return in;
}
#method_after
static Input init(Input in) {
    if (in == null) {
        in = new Input();
    }
    if (in.groups == null) {
        in.groups = Lists.newArrayListWithCapacity(1);
    }
    if (!Strings.isNullOrEmpty(in._oneGroup)) {
        in.groups.add(in._oneGroup);
    }
    return in;
}
#end_block

#method_before
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    final GroupDescription.Basic group = resource.getGroup();
    if (!(group instanceof GroupDescription.Internal)) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final AccountGroup internalGroup = ((GroupDescription.Internal) group).getAccountGroup();
    final GroupControl control = groupControlFactory.controlFor(internalGroup);
    final Map<AccountGroup.UUID, AccountGroupIncludeByUuid> newIncludedGroups = Maps.newHashMap();
    final List<AccountGroupIncludeByUuidAudit> newIncludedGroupsAudits = Lists.newLinkedList();
    final BadRequestHandler badRequest = new BadRequestHandler("adding new included groups");
    final List<GroupInfo> result = Lists.newLinkedList();
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    for (final String includedGroup : input.includedGroups) {
        try {
            final GroupResource includedGroupResource = groupsCollection.get().parse(includedGroup);
            if (!control.canAddGroup(includedGroupResource.getGroupUUID())) {
                throw new AuthException("Cannot add included group: " + Objects.firstNonNull(includedGroupResource.getName(), includedGroupResource.getGroupUUID()));
            }
            if (!newIncludedGroups.containsKey(includedGroupResource.getGroupUUID())) {
                final AccountGroupIncludeByUuid.Key agiKey = new AccountGroupIncludeByUuid.Key(internalGroup.getId(), includedGroupResource.getGroupUUID());
                AccountGroupIncludeByUuid agi = db.accountGroupIncludesByUuid().get(agiKey);
                if (agi == null) {
                    agi = new AccountGroupIncludeByUuid(agiKey);
                    newIncludedGroups.put(includedGroupResource.getGroupUUID(), agi);
                    newIncludedGroupsAudits.add(new AccountGroupIncludeByUuidAudit(agi, me));
                }
            }
            result.add(new GroupInfo(includedGroupResource.getGroup()));
        } catch (ResourceNotFoundException e) {
            badRequest.addError(new NoSuchGroupException(includedGroup));
        }
    }
    badRequest.failOnError();
    if (!newIncludedGroups.isEmpty()) {
        db.accountGroupIncludesByUuidAudit().insert(newIncludedGroupsAudits);
        db.accountGroupIncludesByUuid().insert(newIncludedGroups.values());
        for (final AccountGroupIncludeByUuid agi : newIncludedGroups.values()) {
            groupIncludeCache.evictMemberIn(agi.getIncludeUUID());
        }
        groupIncludeCache.evictMembersOf(group.getGroupUUID());
    }
    return result;
}
#method_after
@Override
public List<GroupInfo> apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    final GroupDescription.Basic group = resource.getGroup();
    if (!(group instanceof GroupDescription.Internal)) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    final AccountGroup internalGroup = ((GroupDescription.Internal) group).getAccountGroup();
    final GroupControl control = groupControlFactory.controlFor(internalGroup);
    final Map<AccountGroup.UUID, AccountGroupIncludeByUuid> newIncludedGroups = Maps.newHashMap();
    final List<AccountGroupIncludeByUuidAudit> newIncludedGroupsAudits = Lists.newLinkedList();
    final BadRequestHandler badRequest = new BadRequestHandler("adding groups");
    final List<GroupInfo> result = Lists.newLinkedList();
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    for (final String includedGroup : input.groups) {
        try {
            final GroupResource includedGroupResource = groupsCollection.get().parse(includedGroup);
            if (!control.canAddGroup(includedGroupResource.getGroupUUID())) {
                throw new AuthException(String.format("Cannot add group: %s", includedGroupResource.getName()));
            }
            if (!newIncludedGroups.containsKey(includedGroupResource.getGroupUUID())) {
                final AccountGroupIncludeByUuid.Key agiKey = new AccountGroupIncludeByUuid.Key(internalGroup.getId(), includedGroupResource.getGroupUUID());
                AccountGroupIncludeByUuid agi = db.accountGroupIncludesByUuid().get(agiKey);
                if (agi == null) {
                    agi = new AccountGroupIncludeByUuid(agiKey);
                    newIncludedGroups.put(includedGroupResource.getGroupUUID(), agi);
                    newIncludedGroupsAudits.add(new AccountGroupIncludeByUuidAudit(agi, me));
                }
            }
            result.add(new GroupInfo(includedGroupResource.getGroup()));
        } catch (ResourceNotFoundException e) {
            badRequest.addError(new NoSuchGroupException(includedGroup));
        }
    }
    badRequest.failOnError();
    if (!newIncludedGroups.isEmpty()) {
        db.accountGroupIncludesByUuidAudit().insert(newIncludedGroupsAudits);
        db.accountGroupIncludesByUuid().insert(newIncludedGroups.values());
        for (final AccountGroupIncludeByUuid agi : newIncludedGroups.values()) {
            groupIncludeCache.evictMemberIn(agi.getIncludeUUID());
        }
        groupIncludeCache.evictMembersOf(group.getGroupUUID());
    }
    return result;
}
#end_block

#method_before
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    AddIncludedGroups.Input in = new AddIncludedGroups.Input();
    in._oneIncludedGroup = id;
    List<GroupInfo> list = put.get().apply(resource, in);
    if (list.size() == 1) {
        return list.get(0);
    } else {
        throw new IllegalStateException();
    }
}
#method_after
@Override
public GroupInfo apply(GroupResource resource, Input input) throws MethodNotAllowedException, AuthException, BadRequestException, OrmException {
    AddIncludedGroups.Input in = new AddIncludedGroups.Input();
    in.groups = ImmutableList.of(id);
    List<GroupInfo> list = put.get().apply(resource, in);
    if (list.size() == 1) {
        return list.get(0);
    } else {
        throw new IllegalStateException();
    }
}
#end_block

#method_before
public static void addIncludedGroups(AccountGroup.UUID groupUUID, Set<String> includedGroups, final AsyncCallback<NativeList<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(groupUUID, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_included_group(includedGroup);
        }
        new RestApi(includedGroupsBase(groupUUID) + ".add").data(input).post(cb);
    }
}
#method_after
public static void addIncludedGroups(AccountGroup.UUID groupUUID, Set<String> includedGroups, final AsyncCallback<NativeList<GroupInfo>> cb) {
    if (includedGroups.size() == 1) {
        addIncludedGroup(groupUUID, includedGroups.iterator().next(), new AsyncCallback<GroupInfo>() {

            @Override
            public void onSuccess(GroupInfo result) {
                cb.onSuccess(NativeList.of(result));
            }

            @Override
            public void onFailure(Throwable caught) {
                cb.onFailure(caught);
            }
        });
    } else {
        IncludedGroupInput input = IncludedGroupInput.create();
        for (String includedGroup : includedGroups) {
            input.add_group(includedGroup);
        }
        new RestApi(includedGroupsBase(groupUUID) + ".add").data(input).post(cb);
    }
}
#end_block

#method_before
public List<CommitValidationMessage> validCommit(ReceiveCommand cmd, RevCommit commit) throws CommitValidationException {
    HashMap<Pattern, ItsAssociationPolicy> regexes = getCommentRegexMap();
    if (regexes.size() == 0) {
        return Collections.emptyList();
    }
    String comment = commit.getFullMessage();
    log.debug("Searching comment " + comment.trim() + " for patterns " + regexes);
    String issueId = null;
    ItsAssociationPolicy associationPolicy = ItsAssociationPolicy.OPTIONAL;
    Pattern pattern = null;
    for (Entry<Pattern, ItsAssociationPolicy> entry : regexes.entrySet()) {
        pattern = entry.getKey();
        Matcher matcher = pattern.matcher(comment);
        associationPolicy = entry.getValue();
        if (matcher.find()) {
            issueId = extractMatchedWorkItems(matcher);
            log.debug("Pattern matched on comment '{}' with issue id '{}'", comment.trim(), issueId);
            break;
        }
    }
    String validationMessage = null;
    if (pattern != null && issueId == null) {
        validationMessage = "Missing issue-id in commit message\n" + "Commit " + commit.getId().getName() + " not associated to any issue\n" + "\n" + "Hint: insert one ore more issue-id anywhere in the commit message.\n" + "      Issue-ids are strings matching " + pattern.pattern() + "\n" + "      and are pointing to existing tickets on " + client.name() + " Issue-Tracker";
    } else if (pattern != null && !isWorkitemPresent(issueId, comment)) {
        validationMessage = "Issue " + issueId + " not found or visible in " + client.name() + " Issue-Tracker";
    } else {
        return Collections.emptyList();
    }
    switch(associationPolicy) {
        case MANDATORY:
            throw new CommitValidationException(validationMessage.split("\n")[0], Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false)));
        case SUGGESTED:
            return Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false));
        default:
            return Collections.emptyList();
    }
}
#method_after
public List<CommitValidationMessage> validCommit(ReceiveCommand cmd, RevCommit commit) throws CommitValidationException {
    HashMap<Pattern, ItsAssociationPolicy> regexes = getCommentRegexMap();
    if (regexes.size() == 0) {
        return Collections.emptyList();
    }
    String message = commit.getFullMessage();
    log.debug("Searching comment " + message.trim() + " for patterns " + regexes);
    String issueId = null;
    ItsAssociationPolicy associationPolicy = ItsAssociationPolicy.OPTIONAL;
    Pattern pattern = null;
    for (Entry<Pattern, ItsAssociationPolicy> entry : regexes.entrySet()) {
        pattern = entry.getKey();
        Matcher matcher = pattern.matcher(message);
        associationPolicy = entry.getValue();
        if (matcher.find()) {
            issueId = extractMatchedWorkItems(matcher);
            log.debug("Pattern matched on comment '{}' with issue id '{}'", message.trim(), issueId);
            break;
        }
    }
    String validationMessage = null;
    if (pattern != null && issueId == null) {
        validationMessage = "Missing issue-id in commit message\n" + "Commit " + commit.getId().getName() + " not associated to any issue\n" + "\n" + "Hint: insert one or more issue-id anywhere in the commit message.\n" + "      Issue-ids are strings matching " + pattern.pattern() + "\n" + "      and are pointing to existing tickets on " + client.name() + " Issue-Tracker";
    } else if (pattern != null && !isWorkitemPresent(issueId, message)) {
        validationMessage = "Issue " + issueId + " not found or visible in " + client.name() + " Issue-Tracker";
    } else {
        return Collections.emptyList();
    }
    switch(associationPolicy) {
        case MANDATORY:
            throw new CommitValidationException(validationMessage.split("\n")[0], Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false)));
        case SUGGESTED:
            return Collections.singletonList(new CommitValidationMessage("\n" + validationMessage + "\n", false));
        default:
            return Collections.emptyList();
    }
}
#end_block

#method_before
private boolean isWorkitemPresent(String issueId, String comment) {
    boolean exist = false;
    if (issueId != null) {
        try {
            ItsIssue issue = client.getIssue(issueId);
            if (issue == null) {
                log.warn("Workitem " + issueId + " declared in the comment " + comment + " but not found on ITS");
            } else {
                exist = true;
                log.warn("Workitem found: " + issue);
            }
        } catch (IOException ex) {
            log.warn("Unexpected error accessint ITS", ex);
        }
    } else {
        log.debug("Rejecting commit: no pattern matched on comment " + comment);
    }
    return exist;
}
#method_after
private boolean isWorkitemPresent(String issueId, String comment) {
    boolean exist = false;
    if (issueId != null) {
        try {
            if (!client.exists(issueId)) {
                log.warn("Workitem " + issueId + " declared in the comment " + comment + " but not found on ITS");
            } else {
                exist = true;
                log.warn("Workitem " + issueId + " found");
            }
        } catch (IOException ex) {
            log.warn("Unexpected error accessint ITS", ex);
        }
    } else {
        log.debug("Rejecting commit: no pattern matched on comment " + comment);
    }
    return exist;
}
#end_block

#method_before
@Override
public void addComment(String issueId, String comment) throws IOException {
    if (log.isDebugEnabled())
        log.debug("addComment({},{})", issueId, comment);
}
#method_after
@Override
public void addComment(String issueId, String comment) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("addComment({},{})", issueId, comment);
    }
}
#end_block

#method_before
@Override
public void addRelatedLink(String issueId, URL relatedUrl, String description) throws IOException {
    if (log.isDebugEnabled())
        log.debug("addRelatedLink({},{},{})", new Object[] { issueId, relatedUrl, description });
}
#method_after
@Override
public void addRelatedLink(String issueId, URL relatedUrl, String description) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("addRelatedLink({},{},{})", new Object[] { issueId, relatedUrl, description });
    }
}
#end_block

#method_before
@Override
public void performAction(String issueId, String actionName) throws IOException {
    if (log.isDebugEnabled())
        log.debug("performAction({},{})", issueId, actionName);
}
#method_after
@Override
public void performAction(String issueId, String actionName) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("performAction({},{})", issueId, actionName);
    }
}
#end_block

#method_before
@Override
public String healthCheck(Check check) throws IOException {
    if (log.isDebugEnabled())
        log.debug("healthCheck()");
    return "{\"status\"=\"ok\",\"system\"=\"not configured\",}";
}
#method_after
@Override
public String healthCheck(Check check) throws IOException {
    if (log.isDebugEnabled()) {
        log.debug("healthCheck()");
    }
    return "{\"status\"=\"ok\",\"system\"=\"not configured\",}";
}
#end_block

#method_before
@Override
public String createLinkForWebui(String url, String text) {
    if (log.isDebugEnabled())
        log.debug("createLinkForWebui({},{})", url, text);
    return "";
}
#method_after
@Override
public String createLinkForWebui(String url, String text) {
    if (log.isDebugEnabled()) {
        log.debug("createLinkForWebui({},{})", url, text);
    }
    return "";
}
#end_block

#method_before
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // Try to mark interested owners with TO and CC or BCC line.
        Watchers matching = getWatches(NotifyType.NEW_CHANGES);
        for (Account.Id user : Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            }
        }
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS);
}
#method_after
@Override
protected void init() throws EmailException {
    super.init();
    try {
        // Try to mark interested owners with TO and CC or BCC line.
        Watchers matching = getWatchers(NotifyType.NEW_CHANGES);
        for (Account.Id user : Iterables.concat(matching.to.accounts, matching.cc.accounts, matching.bcc.accounts)) {
            if (isOwnerOfProjectOrBranch(user)) {
                add(RecipientType.TO, user);
            }
        }
        // Add everyone else. Owners added above will not be duplicated.
        add(RecipientType.TO, matching.to);
        add(RecipientType.CC, matching.cc);
        add(RecipientType.BCC, matching.bcc);
    } catch (OrmException err) {
        // Just don't CC everyone. Better to send a partial message to those
        // we already have queued up then to fail deliver entirely to people
        // who have a lower interest in the change.
        log.warn("Cannot notify watchers for new change", err);
    }
    includeWatchers(NotifyType.NEW_PATCHSETS);
}
#end_block

#method_before
void display(final PrintWriter out) throws NoSuchGroupException {
    final ColumnFormatter formatter = new ColumnFormatter(out, '\t');
    for (final GroupInfo info : get()) {
        formatter.addColumn(info.name != null ? info.name : "n/a");
        if (verboseOutput) {
            AccountGroup o = info.ownerId != null ? groupCache.get(new AccountGroup.UUID(Url.decode(info.ownerId))) : null;
            formatter.addColumn(Url.decode(info.id));
            formatter.addColumn(Strings.nullToEmpty(info.description));
            formatter.addColumn(o != null ? o.getName() : "n/a");
            formatter.addColumn(o != null ? o.getGroupUUID().get() : "");
            formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
        }
        formatter.nextLine();
    }
    formatter.finish();
}
#method_after
void display(final PrintWriter out) throws NoSuchGroupException {
    final ColumnFormatter formatter = new ColumnFormatter(out, '\t');
    for (final GroupInfo info : get()) {
        formatter.addColumn(Objects.firstNonNull(info.name, "n/a"));
        if (verboseOutput) {
            AccountGroup o = info.ownerId != null ? groupCache.get(new AccountGroup.UUID(Url.decode(info.ownerId))) : null;
            formatter.addColumn(Url.decode(info.id));
            formatter.addColumn(Strings.nullToEmpty(info.description));
            formatter.addColumn(o != null ? o.getName() : "n/a");
            formatter.addColumn(o != null ? o.getGroupUUID().get() : "");
            formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
        }
        formatter.nextLine();
    }
    formatter.finish();
}
#end_block

#method_before
@Override
public void onKeyPress(KeyPressEvent event) {
    if (event.getSource() == newTopic && event.getCharCode() == KeyCodes.KEY_ENTER) {
        doTopicEdit();
    }
}
#method_after
@Override
public void onKeyPress(KeyPressEvent event) {
    if (event.getSource() == newTopic && event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
        doTopicEdit();
    }
}
#end_block

#method_before
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(Integer.toString(id.get()));
    }
    call.data(input).delete(cb);
}
#method_after
public static void removeMembers(AccountGroup.UUID groupUUID, Set<Account.Id> ids, AsyncCallback<VoidResult> cb) {
    RestApi call = new RestApi(membersBase(groupUUID));
    MemberInput input = MemberInput.create();
    for (Account.Id id : ids) {
        input.add_member(id.toString());
    }
    call.data(input).delete(cb);
}
#end_block

#method_before
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMembers(getGroupUUID(), Collections.singleton(nameEmail), new GerritCallback<NativeList<MemberInfo>>() {

        public void onSuccess(final NativeList<MemberInfo> memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
void doAddNewMember() {
    final String nameEmail = addMemberBox.getText();
    if (nameEmail.length() == 0) {
        return;
    }
    addMemberBox.setEnabled(false);
    GroupApi.addMember(getGroupUUID(), nameEmail, new GerritCallback<MemberInfo>() {

        public void onSuccess(final MemberInfo memberInfo) {
            Gerrit.display(Dispatcher.toGroup(getGroupUUID(), AccountGroupScreen.MEMBERS));
        }

        @Override
        public void onFailure(final Throwable caught) {
            addMemberBox.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMember.class);
    delete(GROUP_KIND, "members").to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    put(GROUP_KIND, "members").to(PutMembers.class);
    delete(GROUP_KIND, "members").to(DeleteMembers.class);
    delete(MEMBER_KIND).to(DeleteMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final String name = FormatUtil.name(account);
    String[] names = name.split("\\s+", 2);
    final InlineLabel l = new InlineLabel(names[0] + " ");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    menuRight.add(l);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    Account account = getUserAccount();
    final CurrentUserPopupPanel userPopup = new CurrentUserPopupPanel(account, canLogOut);
    final InlineLabel l = new InlineLabel(FormatUtil.name(account) + " ");
    l.setStyleName(RESOURCES.css().menuBarUserName());
    l.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (userPopup.isShowing()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(l);
            }
        }
    });
    userPopup.addAutoHidePartner(l.getElement());
    FocusPanel fp = new FocusPanel(l);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(new KeyDownHandler() {

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                if (userPopup.isShowing()) {
                    userPopup.hide();
                } else {
                    userPopup.showRelativeTo(l);
                }
                event.preventDefault();
            }
        }
    });
    menuRight.add(fp);
}
#end_block

#method_before
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + info.id), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    formatter.addColumn(info.id);
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(Objects.firstNonNull(info.ownerId, "n/a"));
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public JsonElement display(OutputStream displayOutputStream) throws NoSuchGroupException {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    try {
        List<GroupInfo> groups;
        if (user != null) {
            groups = accountGetGroups.get().apply(new AccountResource(userFactory.create(user)));
        } else {
            VisibleGroups visibleGroups = visibleGroupsFactory.create();
            visibleGroups.setOnlyVisibleToAll(visibleToAll);
            visibleGroups.setGroupType(groupType);
            visibleGroups.setMatch(matchSubstring);
            List<AccountGroup> groupList;
            if (!projects.isEmpty()) {
                groupList = visibleGroups.get(projects);
            } else {
                groupList = visibleGroups.get();
            }
            groups = Lists.newArrayListWithCapacity(groupList.size());
            for (AccountGroup group : groupList) {
                groups.add(new GroupInfo(GroupDescriptions.forAccountGroup(group)));
            }
        }
        if (stdout == null) {
            final Map<String, GroupInfo> output = Maps.newTreeMap();
            for (GroupInfo info : groups) {
                output.put(Objects.firstNonNull(info.name, "Group " + Url.decode(info.id)), info);
                info.name = null;
            }
            return OutputFormat.JSON.newGson().toJsonTree(output, new TypeToken<Map<String, GroupInfo>>() {
            }.getType());
        } else {
            final ColumnFormatter formatter = new ColumnFormatter(stdout, '\t');
            for (GroupInfo info : groups) {
                formatter.addColumn(info.name);
                if (verboseOutput) {
                    AccountGroup o = info.ownerId != null ? groupCache.get(new AccountGroup.UUID(Url.decode(info.ownerId))) : null;
                    formatter.addColumn(Url.decode(info.id));
                    formatter.addColumn(Strings.nullToEmpty(info.description));
                    formatter.addColumn(o != null ? o.getName() : "n/a");
                    formatter.addColumn(o != null ? o.getGroupUUID().get() : "");
                    formatter.addColumn(Boolean.toString(Objects.firstNonNull(info.visibleToAll, Boolean.FALSE)));
                }
                formatter.nextLine();
            }
            formatter.finish();
            return null;
        }
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final List<MemberInfo> members = Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new HashSet<AccountGroup.UUID>()).values());
    Collections.sort(members, new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            int cmp = nullToEmpty(a.fullName).compareTo(nullToEmpty(b.fullName));
            if (cmp != 0) {
                return cmp;
            }
            cmp = nullToEmpty(a.preferredEmail).compareTo(nullToEmpty(b.preferredEmail));
            if (cmp != 0) {
                return cmp;
            }
            return nullToEmpty(a.id).compareTo(nullToEmpty(b.id));
        }
    });
    return members;
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<Account.Id, MemberInfo> members = getMembers(resource.getGroupUUID(), new HashSet<AccountGroup.UUID>());
    final List<MemberInfo> memberInfos = Lists.newArrayList(members.values());
    Collections.sort(memberInfos, new Comparator<MemberInfo>() {

        @Override
        public int compare(MemberInfo a, MemberInfo b) {
            return ComparisonChain.start().compare(a.fullName, b.fullName, Ordering.natural().nullsFirst()).compare(a.preferredEmail, b.preferredEmail, Ordering.natural().nullsFirst()).compare(a.id, b.id, Ordering.natural().nullsFirst()).result();
        }
    });
    return memberInfos;
}
#end_block

#method_before
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final boolean recursive, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.put(account.getId(), MembersCollection.parse(account));
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), recursive, seenGroups));
                }
            }
        }
    }
    return members;
}
#method_after
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    if (group == null) {
        // the included group is an external group and can't be resolved
        return Collections.emptyMap();
    }
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember m : groupDetail.members) {
            if (!members.containsKey(m.getAccountId())) {
                final Account account = accountCache.get(m.getAccountId()).getAccount();
                members.put(account.getId(), MembersCollection.parse(account));
            }
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), seenGroups));
                }
            }
        }
    }
    return members;
}
#end_block

#method_before
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    return Lists.newLinkedList(getMembers(resource.getGroupUUID(), recursive, new HashSet<AccountGroup.UUID>()).values());
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final Map<Account.Id, MemberInfo> members = getMembers(resource.getGroupUUID(), new HashSet<AccountGroup.UUID>());
    return Lists.newArrayList(members.values());
}
#end_block

#method_before
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final boolean recursive, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.put(account.getId(), MembersCollection.parse(account));
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), recursive, seenGroups));
                }
            }
        }
    }
    return members;
}
#method_after
private Map<Account.Id, MemberInfo> getMembers(final AccountGroup.UUID groupUUID, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException, NoSuchGroupException {
    seenGroups.add(groupUUID);
    final Map<Account.Id, MemberInfo> members = Maps.newHashMap();
    final AccountGroup group = groupCache.get(groupUUID);
    if (group == null) {
        // the included group is an external group and can't be resolved
        return Collections.emptyMap();
    }
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember m : groupDetail.members) {
            if (!members.containsKey(m.getAccountId())) {
                final Account account = accountCache.get(m.getAccountId()).getAccount();
                members.put(account.getId(), MembersCollection.parse(account));
            }
        }
    }
    if (recursive) {
        if (groupDetail.includes != null) {
            for (final AccountGroupIncludeByUuid includedGroup : groupDetail.includes) {
                if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                    members.putAll(getMembers(includedGroup.getIncludeUUID(), seenGroups));
                }
            }
        }
    }
    return members;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    final int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branches = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branches.deleteChecked();
        }
    });
    add(branches);
    add(delBranch);
    add(addPanel);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    AvatarProvider avatarProvider = avatarProviderItem.get();
    if (avatarProvider == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String user = req.getPathInfo();
    if (user == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    // Hack off leading '/'
    user = user.substring(1);
    final Account account;
    try {
        account = accountResolver.find(user);
    } catch (OrmException e1) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String size = req.getParameter("size");
    int imageSize = 0;
    if (size != null) {
        try {
            imageSize = Integer.parseInt(size);
        } catch (NumberFormatException e) {
        // Ignore, keep size at 0.
        }
    }
    final String url = avatarProvider.getUrl(account, imageSize);
    rsp.sendRedirect(rsp.encodeRedirectURL(url));
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    AvatarProvider avatarProvider = avatarProviderItem.get();
    if (avatarProvider == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String user = req.getPathInfo();
    if (user == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    // Hack off leading '/'
    user = user.substring(1);
    final Account account;
    try {
        account = accountResolver.find(user);
    } catch (OrmException e1) {
        log.error("Exception while looking up avatar for user: " + user, e1);
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    if (account == null) {
        // Account was not found.
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
        return;
    }
    String size = req.getParameter("size");
    int imageSize = 0;
    if (size != null) {
        try {
            imageSize = Integer.parseInt(size);
        } catch (NumberFormatException e) {
        // Ignore, keep size at 0.
        }
    }
    final String url = avatarProvider.getUrl(account, imageSize);
    if (url == null) {
        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        rsp.sendRedirect(rsp.encodeRedirectURL(url));
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/avatar/*").with(AvatarServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/avatar/*").with(AvatarServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
private Key<HttpServlet> queryProjectNew() {
    return key(new HttpServlet() {

        private static final long serialVersionUID = 1L;

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            String name = req.getPathInfo();
            if (Strings.isNullOrEmpty(name)) {
                toGerrit(PageLinks.ADMIN_PROJECTS, req, rsp);
                return;
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            if (name.endsWith(".git")) {
                name = name.substring(0, name.length() - 4);
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            Project.NameKey project = new Project.NameKey(name);
            toGerrit(PageLinks.toChangeQuery(PageLinks.projectQuery(project, Change.Status.NEW)), req, rsp);
        }
    });
}
#method_after
private Key<HttpServlet> queryProjectNew() {
    return key(new HttpServlet() {

        private static final long serialVersionUID = 1L;

        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
            String name = req.getPathInfo();
            if (Strings.isNullOrEmpty(name)) {
                toGerrit(PageLinks.ADMIN_PROJECTS, req, rsp);
                return;
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            if (name.endsWith(Constants.DOT_GIT_EXT)) {
                name = // 
                name.substring(// 
                0, name.length() - Constants.DOT_GIT_EXT.length());
            }
            while (name.endsWith("/")) {
                name = name.substring(0, name.length() - 1);
            }
            Project.NameKey project = new Project.NameKey(name);
            toGerrit(PageLinks.toChangeQuery(PageLinks.projectQuery(project, Change.Status.NEW)), req, rsp);
        }
    });
}
#end_block

#method_before
public DynamicItem<T> get() {
    return new DynamicItem<T>(find(injector, type));
}
#method_after
public DynamicItem<T> get() {
    return new DynamicItem<T>(key, find(injector, type), "gerrit");
}
#end_block

#method_before
private static <T> AtomicReference<Provider<T>> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null) {
        for (Binding<T> b : bindings) {
            if (b.getKey().getAnnotation() != null) {
                // TODO: throw exception if > 1 match?
                return new AtomicReference<Provider<T>>(b.getProvider());
            }
        }
    }
    return new AtomicReference<Provider<T>>();
}
#method_after
private static <T> Provider<T> find(Injector src, TypeLiteral<T> type) {
    List<Binding<T>> bindings = src.findBindingsByType(type);
    if (bindings != null && bindings.size() == 1) {
        return bindings.get(0).getProvider();
    } else if (bindings != null && bindings.size() > 1) {
        throw new ProvisionException(String.format("Multiple providers bound for DynamicItem<%s>\n" + "This is not allowed; check the server configuration.", type));
    } else {
        return null;
    }
}
#end_block

#method_before
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider()));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#method_after
public static List<RegistrationHandle> attachItems(Injector src, Map<TypeLiteral<?>, DynamicItem<?>> items, String pluginName) {
    if (src == null || items == null || items.isEmpty()) {
        return Collections.emptyList();
    }
    List<RegistrationHandle> handles = new ArrayList<RegistrationHandle>(4);
    try {
        for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
            @SuppressWarnings("unchecked")
            TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
            @SuppressWarnings("unchecked")
            DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
            for (Binding<Object> b : bindings(src, type)) {
                if (b.getKey().getAnnotation() != null) {
                    handles.add(item.set(b.getKey(), b.getProvider(), pluginName));
                }
            }
        }
    } catch (RuntimeException e) {
        remove(handles);
        throw e;
    } catch (Error e) {
        remove(handles);
        throw e;
    }
    return handles;
}
#end_block

#method_before
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member)).in(Scopes.SINGLETON);
}
#method_after
public static <T> void itemOf(Binder binder, TypeLiteral<T> member) {
    @SuppressWarnings("unchecked")
    Key<DynamicItem<T>> key = (Key<DynamicItem<T>>) Key.get(Types.newParameterizedType(DynamicItem.class, member.getType()));
    binder.bind(key).toProvider(new DynamicItemProvider<T>(member, key)).in(Scopes.SINGLETON);
}
#end_block

#method_before
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type).annotatedWith(UniqueAnnotations.create());
}
#method_after
public static <T> LinkedBindingBuilder<T> bind(Binder binder, TypeLiteral<T> type) {
    return binder.bind(type);
}
#end_block

#method_before
public T get() {
    Provider<T> p = item.get();
    T t = null;
    if (p != null) {
        t = p.get();
    }
    return t;
}
#method_after
public T get() {
    NamedProvider<T> item = ref.get();
    return item != null ? item.impl.get() : null;
}
#end_block

#method_before
public ReloadableRegistrationHandle<T> set(Key<T> key, Provider<T> item) {
    if (!this.item.compareAndSet(null, item)) {
        // We already have an item bound.
        throw new RuntimeException("Type already provided by " + this.item.get());
    }
    return new ReloadableHandle(key, item);
}
#method_after
public RegistrationHandle set(T item, String pluginName) {
    return set(Providers.of(item), pluginName);
}
#end_block

#method_before
@Override
public void remove() {
    DynamicItem.this.item.compareAndSet(item, null);
}
#method_after
@Override
public void remove() {
    ref.compareAndSet(item, null);
}
#end_block

#method_before
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    if (DynamicItem.this.item.compareAndSet(item, newItem)) {
        return new ReloadableHandle(newKey, newItem);
    }
    return null;
}
#method_after
@Override
public ReloadableHandle replace(Key<T> newKey, Provider<T> newItem) {
    NamedProvider<T> n = new NamedProvider<T>(newItem, item.pluginName);
    if (ref.compareAndSet(item, n)) {
        return new ReloadableHandle(newKey, n);
    }
    return null;
}
#end_block

#method_before
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items)) {
        plugin.add(h);
    }
}
#method_after
private void attachItem(Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin plugin) {
    for (RegistrationHandle h : PrivateInternals_DynamicTypes.attachItems(src, items, plugin.getName())) {
        plugin.add(h);
    }
}
#end_block

#method_before
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        // Index all old handles that match this DynamicItem<T> keyed by
        // annotations. Ignore the unique annotations, thereby favoring
        // the @Named annotations or some other non-unique naming.
        Map<Annotation, ReloadableRegistrationHandle<?>> am = Maps.newHashMap();
        List<ReloadableRegistrationHandle<?>> old = oldHandles.get(type);
        Iterator<ReloadableRegistrationHandle<?>> oi = old.iterator();
        while (oi.hasNext()) {
            ReloadableRegistrationHandle<?> h = oi.next();
            Annotation a = h.getKey().getAnnotation();
            if (a != null && !UNIQUE_ANNOTATION.isInstance(a)) {
                am.put(a, h);
                oi.remove();
            }
        }
        // Replace old handles with new bindings, favoring cases where there
        // is an exact match on an @Named annotation. If there is no match
        // pick any handle and replace it. We generally expect only one
        // handle of each DynamicItem type when using unique annotations, but
        // possibly multiple ones if @Named was used. Plugin authors that want
        // atomic replacement across reloads should use @Named annotations with
        // stable names that do not change across plugin versions to ensure the
        // handles are swapped correctly.
        oi = old.iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            Key<Object> key = b.getKey();
            if (key.getAnnotation() == null) {
                continue;
            }
            @SuppressWarnings("unchecked")
            ReloadableRegistrationHandle<Object> h1 = (ReloadableRegistrationHandle<Object>) am.remove(key.getAnnotation());
            if (h1 != null) {
                replace(newPlugin, h1, b);
            } else if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h2 = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h2, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider()));
            }
        }
    }
}
#method_after
private void reattachItem(ListMultimap<TypeLiteral<?>, ReloadableRegistrationHandle<?>> oldHandles, Map<TypeLiteral<?>, DynamicItem<?>> items, @Nullable Injector src, Plugin newPlugin) {
    if (src == null || items == null || items.isEmpty()) {
        return;
    }
    for (Map.Entry<TypeLiteral<?>, DynamicItem<?>> e : items.entrySet()) {
        @SuppressWarnings("unchecked")
        TypeLiteral<Object> type = (TypeLiteral<Object>) e.getKey();
        @SuppressWarnings("unchecked")
        DynamicItem<Object> item = (DynamicItem<Object>) e.getValue();
        Iterator<ReloadableRegistrationHandle<?>> oi = oldHandles.get(type).iterator();
        for (Binding<?> binding : bindings(src, type)) {
            @SuppressWarnings("unchecked")
            Binding<Object> b = (Binding<Object>) binding;
            if (oi.hasNext()) {
                @SuppressWarnings("unchecked")
                ReloadableRegistrationHandle<Object> h = (ReloadableRegistrationHandle<Object>) oi.next();
                oi.remove();
                replace(newPlugin, h, b);
            } else {
                newPlugin.add(item.set(b.getKey(), b.getProvider(), newPlugin.getName()));
            }
        }
    }
}
#end_block

#method_before
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final String decodedId = Url.decode(id);
    if (decodedId.startsWith(GROUP_PREFIX)) {
        final String groupId = decodedId.substring(GROUP_PREFIX.length());
        final GroupControl ctl;
        try {
            if (groupId.startsWith(GroupsCollection.UUID_PREFIX)) {
                final String uuid = groupId.substring(GroupsCollection.UUID_PREFIX.length());
                ctl = groupControlFactory.controlFor(new AccountGroup.UUID(uuid));
            } else {
                try {
                    ctl = groupControlFactory.controlFor(new AccountGroup.Id(Integer.parseInt(groupId)));
                } catch (NumberFormatException e) {
                    throw new ResourceNotFoundException(id);
                }
            }
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(id);
        }
        if (!ctl.isVisible() && !ctl.isOwner()) {
            throw new ResourceNotFoundException(id);
        }
        return new MemberResource(ctl);
    } else if (decodedId.startsWith(ACCOUNT_PREFIX)) {
        final String accountId = decodedId.substring(ACCOUNT_PREFIX.length());
        try {
            final IdentifiedUser u = userGenericFactory.create(new Account.Id(Integer.parseInt(accountId)));
            return new MemberResource(u);
        } catch (NumberFormatException e) {
            throw new ResourceNotFoundException(id);
        }
    } else {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final Account.Id accountId;
    try {
        accountId = new Account.Id(Integer.parseInt(Url.decode(id)));
    } catch (NumberFormatException e) {
        throw new ResourceNotFoundException(id);
    }
    final AccountGroup group = groupCache.get(parent.getControl().getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            if (member.getAccountId().equals(accountId)) {
                return new MemberResource(userGenericFactory.create(accountId));
            }
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
@Override
public MemberResource parse(final GroupResource parent, final String id) throws ResourceNotFoundException, Exception {
    final String decodedId = Url.decode(id);
    if (decodedId.startsWith(GROUP_PREFIX)) {
        final String groupId = decodedId.substring(GROUP_PREFIX.length());
        final GroupControl ctl;
        try {
            if (groupId.startsWith(GroupsCollection.UUID_PREFIX)) {
                final String uuid = groupId.substring(GroupsCollection.UUID_PREFIX.length());
                ctl = groupControlFactory.controlFor(new AccountGroup.UUID(uuid));
            } else {
                try {
                    ctl = groupControlFactory.controlFor(new AccountGroup.Id(Integer.parseInt(groupId)));
                } catch (NumberFormatException e) {
                    throw new ResourceNotFoundException(id);
                }
            }
        } catch (NoSuchGroupException e) {
            throw new ResourceNotFoundException(id);
        }
        if (!ctl.isVisible() && !ctl.isOwner()) {
            throw new ResourceNotFoundException(id);
        }
        return new MemberResource(ctl);
    } else if (decodedId.startsWith(ACCOUNT_PREFIX)) {
        final String accountId = decodedId.substring(ACCOUNT_PREFIX.length());
        try {
            final IdentifiedUser u = userGenericFactory.create(new Account.Id(Integer.parseInt(accountId)));
            return new MemberResource(u);
        } catch (NumberFormatException e) {
            throw new ResourceNotFoundException(id);
        }
    } else {
        throw new ResourceNotFoundException(id);
    }
}
#method_after
public static MemberInfo parse(final Account account) {
    final MemberInfo accountInfo = new MemberInfo();
    accountInfo.setId(account.getId());
    accountInfo.fullName = account.getFullName();
    accountInfo.preferredEmail = account.getPreferredEmail();
    accountInfo.userName = account.getUserName();
    return accountInfo;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
}
#method_after
@Override
protected void configure() {
    bind(GroupsCollection.class);
    DynamicMap.mapOf(binder(), GROUP_KIND);
    DynamicMap.mapOf(binder(), MEMBER_KIND);
    DynamicMap.mapOf(binder(), INCLUDED_GROUP_KIND);
    get(GROUP_KIND).to(GetGroup.class);
    child(GROUP_KIND, "members").to(MembersCollection.class);
    get(MEMBER_KIND).to(GetMember.class);
    child(GROUP_KIND, "groups").to(IncludedGroupsCollection.class);
    get(INCLUDED_GROUP_KIND).to(GetIncludedGroup.class);
}
#end_block

#method_before
@Override
public Object apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final List<MemberInfo> members = Lists.newArrayList();
    final GroupControl groupControl = groupControlFactory.validateFor(resource.getGroupUUID());
    final AccountGroup group = groupCache.get(groupControl.getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            final AccountInfo accountInfo = new AccountInfo();
            accountInfo.setId(account.getId());
            accountInfo.fullName = account.getFullName();
            accountInfo.email = account.getPreferredEmail();
            accountInfo.userName = account.getUserName();
            members.add(accountInfo);
        }
    }
    if (groupDetail.includes != null) {
        for (final AccountGroupInclude groupInclude : groupDetail.includes) {
            final AccountGroup includedGroup = groupCache.get(groupInclude.getIncludeId());
            final GroupInfo groupInfo = new GroupInfo();
            groupInfo.setUuid(includedGroup.getGroupUUID());
            groupInfo.groupId = includedGroup.getId().get();
            groupInfo.name = includedGroup.getName();
            groupInfo.description = includedGroup.getDescription();
            groupInfo.isVisibleToAll = includedGroup.isVisibleToAll();
            groupInfo.ownerUuid = includedGroup.getOwnerGroupUUID().get();
            members.add(groupInfo);
        }
    }
    return members;
}
#method_after
@Override
public List<MemberInfo> apply(final GroupResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    final List<MemberInfo> members = Lists.newArrayList();
    final GroupControl groupControl = groupControlFactory.validateFor(resource.getGroupUUID());
    final AccountGroup group = groupCache.get(groupControl.getGroup().getGroupUUID());
    final GroupDetail groupDetail = groupDetailFactory.create(group.getId()).call();
    if (groupDetail.members != null) {
        for (final AccountGroupMember member : groupDetail.members) {
            final Account account = accountCache.get(member.getAccountId()).getAccount();
            members.add(MembersCollection.parse(account));
        }
    }
    return members;
}
#end_block

#method_before
public void addGroupInclude(final AccountGroup.Id groupId, final String groupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            final AccountGroup a = findGroup(groupName);
            if (!control.canAddGroup(a.getId())) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupInclude.Key key = new AccountGroupInclude.Key(groupId, a.getGroupUUID());
            AccountGroupInclude m = db.accountGroupIncludes().get(key);
            if (m == null) {
                m = new AccountGroupInclude(key);
                db.accountGroupIncludesAudit().insert(Collections.singleton(new AccountGroupIncludeAudit(m, getAccountId())));
                db.accountGroupIncludes().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(a.getGroupUUID());
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#method_after
public void addGroupInclude(final AccountGroup.Id groupId, final AccountGroup.UUID incGroupUUID, final String incGroupName, final AsyncCallback<GroupDetail> callback) {
    run(callback, new Action<GroupDetail>() {

        public GroupDetail run(ReviewDb db) throws OrmException, Failure, NoSuchGroupException {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            if (incGroupUUID == null) {
                throw new Failure(new NoSuchGroupException(incGroupName));
            }
            if (!control.canAddGroup(incGroupUUID)) {
                throw new Failure(new NoSuchEntityException());
            }
            final AccountGroupIncludeByUuid.Key key = new AccountGroupIncludeByUuid.Key(groupId, incGroupUUID);
            AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(key);
            if (m == null) {
                m = new AccountGroupIncludeByUuid(key);
                db.accountGroupIncludesByUuidAudit().insert(Collections.singleton(new AccountGroupIncludeByUuidAudit(m, getAccountId())));
                db.accountGroupIncludesByUuid().insert(Collections.singleton(m));
                groupIncludeCache.evictInclude(incGroupUUID);
            }
            return groupDetailFactory.create(groupId).call();
        }
    });
}
#end_block

#method_before
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupInclude.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupInclude.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.Id> groupsToEvict = new HashSet<AccountGroup.Id>();
            for (final AccountGroupInclude.Key k : keys) {
                final AccountGroupInclude m = db.accountGroupIncludes().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeId())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeAudit audit = null;
                    for (AccountGroupIncludeAudit a : db.accountGroupIncludesAudit().byGroupInclude(m.getGroupId(), m.getIncludeId())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludes().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeId());
                }
            }
            for (AccountGroup group : db.accountGroups().get(groupsToEvict)) {
                groupIncludeCache.evictInclude(group.getGroupUUID());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void deleteGroupIncludes(final AccountGroup.Id groupId, final Set<AccountGroupIncludeByUuid.Key> keys, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, NoSuchGroupException, Failure {
            final GroupControl control = groupControlFactory.validateFor(groupId);
            if (groupCache.get(groupId).getType() != AccountGroup.Type.INTERNAL) {
                throw new Failure(new NameAlreadyUsedException());
            }
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                if (!groupId.equals(k.getGroupId())) {
                    throw new Failure(new NoSuchEntityException());
                }
            }
            final Account.Id me = getAccountId();
            final Set<AccountGroup.UUID> groupsToEvict = new HashSet<AccountGroup.UUID>();
            for (final AccountGroupIncludeByUuid.Key k : keys) {
                final AccountGroupIncludeByUuid m = db.accountGroupIncludesByUuid().get(k);
                if (m != null) {
                    if (!control.canRemoveGroup(m.getIncludeUUID())) {
                        throw new Failure(new NoSuchEntityException());
                    }
                    AccountGroupIncludeByUuidAudit audit = null;
                    for (AccountGroupIncludeByUuidAudit a : db.accountGroupIncludesByUuidAudit().byGroupInclude(m.getGroupId(), m.getIncludeUUID())) {
                        if (a.isActive()) {
                            audit = a;
                            break;
                        }
                    }
                    if (audit != null) {
                        audit.removed(me);
                        db.accountGroupIncludesByUuidAudit().update(Collections.singleton(audit));
                    }
                    db.accountGroupIncludesByUuid().delete(Collections.singleton(m));
                    groupsToEvict.add(k.getIncludeUUID());
                }
            }
            for (AccountGroup.UUID uuid : groupsToEvict) {
                groupIncludeCache.evictInclude(uuid);
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID uuid) {
    initialGroups.add(uuid);
}
#method_after
@Option(name = "--group", aliases = "-g", metaVar = "GROUP", usage = "initial set of groups to be included in the group")
void addGroup(final AccountGroup.UUID id) {
    initialGroups.add(id);
}
#end_block

#method_before
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupInclude> includeList = new ArrayList<AccountGroupInclude>();
    final List<AccountGroupIncludeAudit> includesAudit = new ArrayList<AccountGroupIncludeAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupInclude groupInclude = new AccountGroupInclude(new AccountGroupInclude.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeAudit audit = new AccountGroupIncludeAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludes().insert(includeList);
    db.accountGroupIncludesAudit().insert(includesAudit);
    for (AccountGroup.UUID groupUUID : groups) {
        groupIncludeCache.evictInclude(groupUUID);
    }
}
#method_after
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    final List<AccountGroupIncludeByUuid> includeList = new ArrayList<AccountGroupIncludeByUuid>();
    final List<AccountGroupIncludeByUuidAudit> includesAudit = new ArrayList<AccountGroupIncludeByUuidAudit>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupIncludeByUuid groupInclude = new AccountGroupIncludeByUuid(new AccountGroupIncludeByUuid.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupIncludeByUuidAudit audit = new AccountGroupIncludeByUuidAudit(groupInclude, currentUser.getAccountId());
        includesAudit.add(audit);
    }
    db.accountGroupIncludesByUuid().insert(includeList);
    db.accountGroupIncludesByUuidAudit().insert(includesAudit);
    for (AccountGroup.UUID uuid : groups) {
        groupIncludeCache.evictInclude(uuid);
    }
}
#end_block

#method_before
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    ChangeUtil.editCommitMessage(patchSetId, control.getRefControl(), canonicalWebUrl, currentUser, message, db, hooks, gitManager, patchSetInfoFactory, replication, myIdent);
    return changeDetailFactory.create(changeId).call();
}
#method_after
@Override
public ChangeDetail call() throws NoSuchChangeException, OrmException, EmailException, NoSuchEntityException, PatchSetInfoNotAvailableException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException {
    final Change.Id changeId = patchSetId.getParentKey();
    final ChangeControl control = changeControlFactory.validateFor(changeId);
    if (!control.canAddPatchSet()) {
        throw new InvalidChangeOperationException("Not allowed to add new Patch Sets to: " + changeId.toString());
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        CommitValidators commitValidators = commitValidatorsFactory.create(control.getRefControl(), new NoSshInfo(), git);
        ChangeUtil.editCommitMessage(patchSetId, control.getRefControl(), commitValidators, currentUser, message, db, commitMessageEditedSenderFactory, hooks, git, patchSetInfoFactory, replication, myIdent);
        return changeDetailFactory.create(changeId).call();
    } finally {
        git.close();
    }
}
#end_block

#method_before
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.nextPatchSetId();
        change.setTopic(changeToRevert.getTopic());
        final PatchSet ps = new PatchSet(change.currPatchSetId());
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#method_after
public static Change.Id revert(final PatchSet.Id patchSetId, final IdentifiedUser user, final String message, final ReviewDb db, final RevertedSender.Factory revertedSenderFactory, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    final Change changeToRevert = db.changes().get(changeId);
    final Repository git;
    try {
        git = gitManager.openRepository(changeToRevert.getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent authorIdent = user.newCommitterIdent(myIdent.getWhen(), myIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(myIdent);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, myIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        RevCommit revertCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            revertCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final Change change = new Change(new Change.Key("I" + computedChangeId.name()), new Change.Id(db.nextChangeId()), user.getAccountId(), changeToRevert.getDest());
        change.setTopic(changeToRevert.getTopic());
        PatchSet.Id id = new PatchSet.Id(change.getId(), Change.INITIAL_PATCH_SET_ID);
        final PatchSet ps = new PatchSet(id);
        ps.setCreatedOn(change.getCreatedOn());
        ps.setUploader(change.getOwner());
        ps.setRevision(new RevId(revertCommit.name()));
        change.setCurrentPatchSet(patchSetInfoFactory.get(revertCommit, ps.getId()));
        ChangeUtil.updated(change);
        final RefUpdate ru = git.updateRef(ps.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(revertCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            insertAncestors(db, ps.getId(), revertCommit);
            db.patchSets().insert(Collections.singleton(ps));
            db.changes().insert(Collections.singleton(change));
            db.commit();
        } finally {
            db.rollback();
        }
        final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
        final StringBuilder msgBuf = new StringBuilder("Patch Set " + patchSetId.get() + ": Reverted");
        msgBuf.append("\n\n");
        msgBuf.append("This patchset was reverted in change: " + change.getKey().get());
        cmsg.setMessage(msgBuf.toString());
        db.changeMessages().insert(Collections.singleton(cmsg));
        final RevertedSender cm = revertedSenderFactory.create(change);
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(cmsg);
        cm.send();
        hooks.doPatchsetCreatedHook(change, ps, db);
        return change.getId();
    } finally {
        revWalk.release();
        git.close();
    }
}
#end_block

#method_before
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, final String canonicalWebUrl, final IdentifiedUser user, final String message, final ReviewDb db, final ChangeHooks hooks, GitRepositoryManager gitManager, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final Repository git;
    try {
        git = gitManager.openRepository(db.changes().get(changeId).getProject());
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(changeId, e);
    }
    try {
        final RevWalk revWalk = new RevWalk(git);
        try {
            Date now = myIdent.getWhen();
            Change change = db.changes().get(changeId);
            RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
            CommitBuilder commitBuilder = new CommitBuilder();
            commitBuilder.setTreeId(commit.getTree());
            commitBuilder.setParentIds(commit.getParents());
            commitBuilder.setAuthor(commit.getAuthorIdent());
            commitBuilder.setCommitter(authorIdent);
            commitBuilder.setMessage(message);
            RevCommit newCommit;
            final ObjectInserter oi = git.newObjectInserter();
            try {
                ObjectId id = oi.insert(commitBuilder);
                oi.flush();
                newCommit = revWalk.parseCommit(id);
            } finally {
                oi.release();
            }
            final LinkedList<String> rejectMsg = new LinkedList<String>();
            if (!CommitUtil.validateCommitSettings(refControl, newCommit, revWalk, true, canonicalWebUrl, new NoSshInfo(), myIdent, user, new LinkedList<CommitValidationMessage>(), new CommitValidationCallback() {

                @Override
                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    rejectMsg.add(rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                }
            })) {
                throw new InvalidChangeOperationException(rejectMsg.get(0));
            }
            change.nextPatchSetId();
            final PatchSet originalPS = db.patchSets().get(patchSetId);
            final PatchSet newPatchSet = new PatchSet(change.currPatchSetId());
            newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
            newPatchSet.setUploader(user.getAccountId());
            newPatchSet.setRevision(new RevId(newCommit.name()));
            newPatchSet.setDraft(originalPS.isDraft());
            final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
            final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
            ru.setExpectedOldObjectId(ObjectId.zeroId());
            ru.setNewObjectId(newCommit);
            ru.disableRefLog();
            if (ru.update(revWalk) != RefUpdate.Result.NEW) {
                throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
            }
            replication.fire(change.getProject(), ru.getName());
            db.changes().beginTransaction(change.getId());
            try {
                Change updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isOpen()) {
                            change.updateNumberOfPatchSets(newPatchSet.getPatchSetId());
                            return change;
                        } else {
                            return null;
                        }
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
                }
                ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
                db.patchSets().insert(Collections.singleton(newPatchSet));
                updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                    @Override
                    public Change update(Change change) {
                        if (change.getStatus().isClosed()) {
                            return null;
                        }
                        if (!change.currentPatchSetId().equals(patchSetId)) {
                            return null;
                        }
                        if (change.getStatus() != Change.Status.DRAFT) {
                            change.setStatus(Change.Status.NEW);
                        }
                        change.setLastSha1MergeTested(null);
                        change.setCurrentPatchSet(info);
                        ChangeUtil.updated(change);
                        return change;
                    }
                });
                if (updatedChange != null) {
                    change = updatedChange;
                } else {
                    throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
                }
                final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
                final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
                cmsg.setMessage(msg);
                db.changeMessages().insert(Collections.singleton(cmsg));
                db.commit();
            } finally {
                db.rollback();
            }
            hooks.doPatchsetCreatedHook(change, newPatchSet, db);
            return change.getId();
        } finally {
            revWalk.release();
        }
    } finally {
        git.close();
    }
}
#method_after
public static Change.Id editCommitMessage(final PatchSet.Id patchSetId, final RefControl refControl, CommitValidators commitValidators, final IdentifiedUser user, final String message, final ReviewDb db, final CommitMessageEditedSender.Factory commitMessageEditedSenderFactory, final ChangeHooks hooks, Repository git, final PatchSetInfoFactory patchSetInfoFactory, final GitReferenceUpdated replication, PersonIdent myIdent) throws NoSuchChangeException, EmailException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, PatchSetInfoNotAvailableException {
    final Change.Id changeId = patchSetId.getParentKey();
    final PatchSet patch = db.patchSets().get(patchSetId);
    if (patch == null) {
        throw new NoSuchChangeException(changeId);
    }
    if (message == null || message.length() == 0) {
        throw new InvalidChangeOperationException("The commit message cannot be empty");
    }
    final RevWalk revWalk = new RevWalk(git);
    try {
        RevCommit commit = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commit.getFullMessage().equals(message)) {
            throw new InvalidChangeOperationException("New commit message cannot be same as existing commit message");
        }
        Date now = myIdent.getWhen();
        Change change = db.changes().get(changeId);
        PersonIdent authorIdent = user.newCommitterIdent(now, myIdent.getTimeZone());
        CommitBuilder commitBuilder = new CommitBuilder();
        commitBuilder.setTreeId(commit.getTree());
        commitBuilder.setParentIds(commit.getParents());
        commitBuilder.setAuthor(commit.getAuthorIdent());
        commitBuilder.setCommitter(authorIdent);
        commitBuilder.setMessage(message);
        RevCommit newCommit;
        final ObjectInserter oi = git.newObjectInserter();
        try {
            ObjectId id = oi.insert(commitBuilder);
            oi.flush();
            newCommit = revWalk.parseCommit(id);
        } finally {
            oi.release();
        }
        final PatchSet originalPS = db.patchSets().get(patchSetId);
        PatchSet.Id id = nextPatchSetId(git, change.currentPatchSetId());
        final PatchSet newPatchSet = new PatchSet(id);
        newPatchSet.setCreatedOn(new Timestamp(now.getTime()));
        newPatchSet.setUploader(user.getAccountId());
        newPatchSet.setRevision(new RevId(newCommit.name()));
        newPatchSet.setDraft(originalPS.isDraft());
        final PatchSetInfo info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
        CommitReceivedEvent commitReceivedEvent = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), newCommit.getId(), newPatchSet.getRefName()), refControl.getProjectControl().getProject(), refControl.getRefName(), newCommit, user);
        try {
            commitValidators.validateForReceiveCommits(commitReceivedEvent);
        } catch (CommitValidationException e) {
            throw new InvalidChangeOperationException(e.getMessage());
        }
        final RefUpdate ru = git.updateRef(newPatchSet.getRefName());
        ru.setExpectedOldObjectId(ObjectId.zeroId());
        ru.setNewObjectId(newCommit);
        ru.disableRefLog();
        if (ru.update(revWalk) != RefUpdate.Result.NEW) {
            throw new IOException(String.format("Failed to create ref %s in %s: %s", newPatchSet.getRefName(), change.getDest().getParentKey().get(), ru.getResult()));
        }
        replication.fire(change.getProject(), ru.getName());
        db.changes().beginTransaction(change.getId());
        try {
            Change updatedChange = db.changes().get(change.getId());
            if (updatedChange != null && updatedChange.getStatus().isOpen()) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
            }
            ChangeUtil.insertAncestors(db, newPatchSet.getId(), commit);
            db.patchSets().insert(Collections.singleton(newPatchSet));
            updatedChange = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(patchSetId)) {
                        return null;
                    }
                    if (change.getStatus() != Change.Status.DRAFT) {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setLastSha1MergeTested(null);
                    change.setCurrentPatchSet(info);
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (updatedChange != null) {
                change = updatedChange;
            } else {
                throw new InvalidChangeOperationException(String.format("Change %s was modified", change.getId()));
            }
            final ChangeMessage cmsg = new ChangeMessage(new ChangeMessage.Key(changeId, ChangeUtil.messageUUID(db)), user.getAccountId(), patchSetId);
            final String msg = "Patch Set " + newPatchSet.getPatchSetId() + ": Commit message was updated";
            cmsg.setMessage(msg);
            db.changeMessages().insert(Collections.singleton(cmsg));
            db.commit();
            final CommitMessageEditedSender cm = commitMessageEditedSenderFactory.create(change);
            cm.setFrom(user.getAccountId());
            cm.setChangeMessage(cmsg);
            cm.send();
        } finally {
            db.rollback();
        }
        hooks.doPatchsetCreatedHook(change, newPatchSet, db);
        return change.getId();
    } finally {
        revWalk.release();
    }
}
#end_block

#method_before
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#method_after
@Override
protected void configureServlets() {
    filter("/*").through(Key.get(CacheControlFilter.class));
    bind(Key.get(CacheControlFilter.class)).in(SINGLETON);
    serve("/").with(HostPageServlet.class);
    serve("/Gerrit").with(LegacyGerritServlet.class);
    serve("/Gerrit/*").with(legacyGerritScreen());
    serve("/cat/*").with(CatServlet.class);
    serve("/logout").with(HttpLogoutServlet.class);
    serve("/signout").with(HttpLogoutServlet.class);
    serve("/ssh_info").with(SshInfoServlet.class);
    serve("/static/*").with(StaticServlet.class);
    serve("/tools/*").with(ToolServlet.class);
    serve("/Main.class").with(notFound());
    serve("/com/google/gerrit/launcher/*").with(notFound());
    serve("/servlet/*").with(notFound());
    serve("/all").with(query("status:merged"));
    serve("/mine").with(screen(PageLinks.MINE));
    serve("/open").with(query("status:open"));
    serve("/watched").with(query("is:watched status:open"));
    serve("/starred").with(query("is:starred"));
    serveRegex("^/settings/?$").with(screen(PageLinks.SETTINGS));
    serveRegex("^/register/?$").with(screen(PageLinks.REGISTER + "/"));
    serveRegex("^/([1-9][0-9]*)/?$").with(directChangeById());
    serveRegex("^/p/(.*)$").with(queryProjectNew());
    serveRegex("^/r/(.+)/?$").with(DirectChangeByCommit.class);
    filter("/a/*").through(RequireIdentifiedUserFilter.class);
    serveRegex("^/(?:a/)?accounts/(.*)$").with(AccountsRestApiServlet.class);
    serveRegex("^/(?:a/)?changes/(.*)$").with(ChangesRestApiServlet.class);
    serveRegex("^/(?:a/)?groups/(.*)?$").with(GroupsRestApiServlet.class);
    serveRegex("^/(?:a/)?projects/(.*)?$").with(ProjectsRestApiServlet.class);
    if (cfg.deprecatedQuery) {
        serve("/query").with(DeprecatedChangeQueryServlet.class);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(VisibleGroups.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    bind(AnonymousUser.class);
    factory(NotesBranchUtil.Factory.class);
}
#end_block

#method_before
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            boolean validCommit = CommitUtil.validateCommit(destBranchCtl, newChange, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewChanges() {
    final List<CreateRequest> newChanges = Lists.newArrayList();
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.TOPO);
    walk.sort(RevSort.REVERSE, true);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(newChange.getNewId()));
        for (Ref ref : allRefs.values()) {
            if (ref.getObjectId() == null) {
                continue;
            } else if (ref.getName().startsWith("refs/changes/")) {
                existing.add(ref.getObjectId());
            } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
                try {
                    walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
                } catch (IOException e) {
                    log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                    continue;
                }
            }
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<Change.Key>();
        for (; ; ) {
            final RevCommit c = walk.next();
            if (c == null) {
                break;
            }
            if (existing.contains(c) || replaceByCommit.containsKey(c)) {
                // 
                continue;
            }
            if (!validCommit(destBranchCtl, newChange, c)) {
                return Collections.emptyList();
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(newChange, "invalid Change-Id");
                return Collections.emptyList();
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(newChange, "squash commits first");
                return Collections.emptyList();
            }
            List<Change> changes = p.changes.toList();
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(newChange, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(newChange, false, changes.get(0), p.commit)) {
                    continue;
                } else {
                    return Collections.emptyList();
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(newChange, "invalid Change-Id");
                    return Collections.emptyList();
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return Collections.emptyList();
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(newChange, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(newChange, "no new changes");
        return Collections.emptyList();
    }
    for (CreateRequest create : newChanges) {
        batch.addCommand(create.cmd);
    }
    return newChanges;
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    boolean validCommit = CommitUtil.validateCommit(changeCtl.getRefControl(), inputCommand, newCommit, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

        public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
            reject(newChange, rejectReason);
        }

        @Override
        public void onAccepted(List<CommitValidationMessage> messages) {
            getMessages().addAll(messages);
        }
    });
    if (!validCommit) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    }
    if (change == null || patchSets == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet()) {
        reject(inputCommand, "cannot replace " + ontoChange);
        return false;
    }
    rp.getRevWalk().parseBody(newCommit);
    if (!validCommit(changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    for (final PatchSet ps : patchSets) {
        if (ps.getRevision() == null) {
            log.warn("Patch set " + ps.getId() + " has no revision");
            reject(inputCommand, "change state corrupt");
            return false;
        }
        final String revIdStr = ps.getRevision().get();
        final ObjectId commitId;
        try {
            commitId = ObjectId.fromString(revIdStr);
        } catch (IllegalArgumentException e) {
            log.warn("Invalid revision in " + ps.getId() + ": " + revIdStr);
            reject(inputCommand, "change state corrupt");
            return false;
        }
        try {
            final RevCommit prior = rp.getRevWalk().parseCommit(commitId);
            // 
            if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
                reject(inputCommand, "squash commits first");
                return false;
            }
            // 
            if (newCommit == prior) {
                reject(inputCommand, "commit already exists");
                return false;
            }
            // 
            if (priorPatchSet.equals(ps.getId()) && newCommit.getTree() == prior.getTree()) {
                rp.getRevWalk().parseBody(prior);
                final boolean messageEq = eq(newCommit.getFullMessage(), prior.getFullMessage());
                final boolean parentsEq = parentsEqual(newCommit, prior);
                final boolean authorEq = authorEqual(newCommit, prior);
                if (messageEq && parentsEq && authorEq && !autoClose) {
                    reject(inputCommand, "no changes made");
                    return false;
                } else {
                    ObjectReader reader = rp.getRevWalk().getObjectReader();
                    StringBuilder msg = new StringBuilder();
                    msg.append("(W) ");
                    msg.append(reader.abbreviate(newCommit).name());
                    msg.append(":");
                    msg.append(" no files changed");
                    if (!authorEq) {
                        msg.append(", author changed");
                    }
                    if (!messageEq) {
                        msg.append(", message updated");
                    }
                    if (!parentsEq) {
                        msg.append(", was rebased");
                    }
                    addMessage(msg.toString());
                }
            }
        } catch (IOException e) {
            log.error("Change " + change.getId() + " missing " + revIdStr, e);
            reject(inputCommand, "change state corrupt");
            return false;
        }
    }
    change.nextPatchSetId();
    PatchSet.Id id = change.currPatchSetId();
    while (allRefs.containsKey(id.toRefName())) {
        change.nextPatchSetId();
        id = change.currPatchSetId();
    }
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    newPatchSet.setUploader(currentUser.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    if (newChange != null && MagicBranch.isDraft(newChange.getRefName())) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
    return true;
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            boolean validCommit = CommitUtil.validateCommit(ctl, cmd, c, rp.getRevWalk(), gerritIdent, currentUser, canonicalWebUrl, projectControl, rejectCommits, repo, commitValidators, sshInfo, new CommitValidationCallback() {

                public void onRejected(String rejectReason, List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                    reject(newChange, rejectReason);
                }

                @Override
                public void onAccepted(List<CommitValidationMessage> messages) {
                    getMessages().addAll(messages);
                }
            });
            if (!validCommit) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !projectControl.getProjectState().isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    for (PatchSetApproval a : getApprovalsForCommit(args.db, n)) {
                        args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(newPatchSet.getId(), a)));
                    }
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    sort(toMerge);
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        if (newMergeTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            newMergeTip = n;
            n.statusCode = CommitMergeStatus.CLEAN_MERGE;
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.statusCode = CommitMergeStatus.CANNOT_REBASE_ROOT;
        } else if (n.getParentCount() == 1) {
            if (canFastForward(args.mergeSorter, newMergeTip, args.rw, n)) {
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else {
                try {
                    final PatchSet newPatchSet = rebaseChange.rebase(args.repo, args.rw, args.inserter, n.patchsetId, n.change, getSubmitter(args.db, n.patchsetId).getAccountId(), newMergeTip, args.useContentMerge);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : getApprovalsForCommit(args.db, n)) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    args.db.patchSetApprovals().insert(approvals);
                    newMergeTip = (CodeReviewCommit) args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    newMergeTip.copyFrom(n);
                    newMergeTip.patchsetId = newPatchSet.getId();
                    newMergeTip.change = args.db.changes().get(newPatchSet.getId().getParentKey());
                    newMergeTip.statusCode = CommitMergeStatus.CLEAN_REBASE;
                    newCommits.put(newPatchSet.getId().getParentKey(), newMergeTip);
                    setRefLogIdent(getSubmitter(args.db, n.patchsetId));
                } catch (PathConflictException e) {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                } catch (NoSuchChangeException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (OrmException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (IOException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (InvalidChangeOperationException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(newMergeTip, n)) {
                    newMergeTip = n;
                } else {
                    newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                }
                final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                setRefLogIdent(submitApproval);
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(newMergeTip);
    }
    return newMergeTip;
}
#end_block

#method_before
@VisibleForTesting
Map<String, ?> buildData(HttpServletRequest req) throws IOException {
    RepositoryDescription desc = accessFactory.forRequest(req).getRepositoryDescription();
    return ImmutableMap.of("cloneUrl", desc.cloneUrl, "description", Strings.nullToEmpty(desc.description), "branches", getRefs(req, Constants.R_HEADS, Ordering.from(RefComparator.INSTANCE)), "tags", getRefs(req, Constants.R_TAGS, tagComparator(req)));
}
#method_after
@VisibleForTesting
Map<String, ?> buildData(HttpServletRequest req) throws IOException {
    RepositoryDescription desc = accessFactory.forRequest(req).getRepositoryDescription();
    RevWalk walk = new RevWalk(ServletUtils.getRepository(req));
    List<Map<String, String>> tags;
    try {
        tags = getRefs(req, Constants.R_TAGS, tagComparator(walk));
    } finally {
        walk.release();
    }
    return ImmutableMap.of("cloneUrl", desc.cloneUrl, "description", Strings.nullToEmpty(desc.description), "branches", getRefs(req, Constants.R_HEADS, Ordering.from(RefComparator.INSTANCE)), "tags", tags);
}
#end_block

#method_before
private List<Map<String, String>> getRefs(HttpServletRequest req, String prefix, Ordering<Ref> ordering) throws IOException {
    RefDatabase refdb = ServletUtils.getRepository(req).getRefDatabase();
    Collection<Ref> refs = ordering.sortedCopy(refdb.getRefs(prefix).values());
    List<Map<String, String>> result = Lists.newArrayListWithCapacity(refs.size());
    for (Ref ref : refs) {
        String name = ref.getName().substring(prefix.length());
        boolean needPrefix = !ref.getName().equals(refdb.getRef(name).getName());
        result.add(ImmutableMap.of("url", GitilesView.log().copyFrom(req).setRevision(Revision.unpeeled(needPrefix ? ref.getName() : name, ref.getObjectId())).toUrl(), "name", name));
    }
    return result;
}
#method_after
private List<Map<String, String>> getRefs(HttpServletRequest req, String prefix, Ordering<Ref> ordering) throws IOException {
    RefDatabase refdb = ServletUtils.getRepository(req).getRefDatabase();
    Collection<Ref> refs = ordering.sortedCopy(refdb.getRefs(prefix).values());
    List<Map<String, String>> result = Lists.newArrayListWithCapacity(refs.size());
    for (Ref ref : refs) {
        String name = ref.getName().substring(prefix.length());
        boolean needPrefix = !ref.getName().equals(refdb.getRef(name).getName());
        result.add(ImmutableMap.of("url", GitilesView.revision().copyFrom(req).setRevision(Revision.unpeeled(needPrefix ? ref.getName() : name, ref.getObjectId())).toUrl(), "name", name));
    }
    return result;
}
#end_block

#method_before
private Ordering<Ref> tagComparator(HttpServletRequest req) {
    final RevWalk walk = new RevWalk(ServletUtils.getRepository(req));
    return Ordering.natural().onResultOf(new Function<Ref, Long>() {

        @Override
        public Long apply(Ref ref) {
            try {
                return timeCache.getTime(walk, ref.getObjectId());
            } catch (IOException e) {
                throw new UncheckedExecutionException(e);
            }
        }
    }).reverse().compound(RefComparator.INSTANCE);
}
#method_after
private Ordering<Ref> tagComparator(final RevWalk walk) {
    return Ordering.natural().onResultOf(new Function<Ref, Long>() {

        @Override
        public Long apply(Ref ref) {
            try {
                return timeCache.getTime(walk, ref.getObjectId());
            } catch (IOException e) {
                throw new UncheckedExecutionException(e);
            }
        }
    }).reverse().compound(RefComparator.INSTANCE);
}
#end_block

#method_before
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            if (existing != null)
                existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || ref.getName().equals(destBranchCtl.getRefName())) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#method_after
private void markHeadsAsUninteresting(final RevWalk walk, Set<ObjectId> existing) {
    for (Ref ref : repo.getAllRefs().values()) {
        if (ref.getObjectId() == null) {
            continue;
        } else if (ref.getName().startsWith("refs/changes/")) {
            existing.add(ref.getObjectId());
        } else if (ref.getName().startsWith(R_HEADS) || (destBranchCtl != null && ref.getName().equals(destBranchCtl.getRefName()))) {
            try {
                walk.markUninteresting(walk.parseCommit(ref.getObjectId()));
            } catch (IOException e) {
                log.warn(String.format("Invalid ref %s in %s", ref.getName(), project.getName()), e);
                continue;
            }
        }
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, null);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        Set<ObjectId> existing = Sets.newHashSet();
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        markHeadsAsUninteresting(walk, existing);
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (existing.contains(c)) {
                continue;
            } else if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
@Provides
@GerritPersonIdent
PersonIdent getServerIdent() {
    return serverIdent;
}
#method_after
@Provides
@GerritPersonIdent
PersonIdent getServerIdent() {
    return serverIdentProvider.get();
}
#end_block

#method_before
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    if (changeData == null) {
        return matching;
    }
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#method_after
protected final Watchers getWatches(NotifyType type) throws OrmException {
    Watchers matching = new Watchers();
    Set<Account.Id> projectWatchers = new HashSet<Account.Id>();
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(change.getProject())) {
        projectWatchers.add(w.getAccountId());
        if (w.isNotify(type)) {
            add(matching, w);
        }
    }
    for (AccountProjectWatch w : args.db.get().accountProjectWatches().byProject(args.allProjectsName)) {
        if (!projectWatchers.contains(w.getAccountId()) && w.isNotify(type)) {
            add(matching, w);
        }
    }
    ProjectState state = projectState;
    while (state != null) {
        for (NotifyConfig nc : state.getConfig().getNotifyConfigs()) {
            if (nc.isNotify(type)) {
                try {
                    add(matching, nc, state.getProject().getNameKey());
                } catch (QueryParseException e) {
                    log.warn(String.format("Project %s has invalid notify %s filter \"%s\": %s", state.getProject().getName(), nc.getName(), nc.getFilter(), e.getMessage()));
                }
            }
        }
        state = state.getParentState();
    }
    return matching;
}
#end_block

#method_before
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        return owner || canPerform(Permission.PUSH_TAG);
    } else {
        return false;
    }
}
#method_after
public boolean canCreate(RevWalk rw, RevObject object) {
    if (!canWrite()) {
        return false;
    }
    boolean owner;
    switch(getCurrentUser().getAccessPath()) {
        case REST_API:
        case JSON_RPC:
            owner = isOwner();
            break;
        default:
            owner = false;
    }
    if (object instanceof RevCommit) {
        return owner || canPerform(Permission.CREATE);
    } else if (object instanceof RevTag) {
        final RevTag tag = (RevTag) object;
        try {
            rw.parseBody(tag);
        } catch (IOException e) {
            return false;
        }
        // If tagger is present, require it matches the user's email.
        // 
        final PersonIdent tagger = tag.getTaggerIdent();
        if (tagger != null) {
            boolean valid;
            if (getCurrentUser() instanceof IdentifiedUser) {
                final IdentifiedUser user = (IdentifiedUser) getCurrentUser();
                final String addr = tagger.getEmailAddress();
                valid = user.getEmailAddresses().contains(addr);
            } else {
                valid = false;
            }
            if (!valid && !owner && !canForgeCommitter()) {
                return false;
            }
        }
        // 
        if (tag.getFullMessage().contains("-----BEGIN PGP SIGNATURE-----\n")) {
            return owner || canPerform(Permission.PUSH_SIGNED_TAG);
        } else {
            return owner || canPerform(Permission.PUSH_TAG);
        }
    } else {
        return false;
    }
}
#end_block

