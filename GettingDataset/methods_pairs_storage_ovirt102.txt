318
#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    StorageServerConnections newServerConnection = new StorageServerConnections();
    newServerConnection.setid("0cc146e8-e5ed-482c-8814-270bc48c2980");
    newServerConnection.setconnection(EXISTING_DOMAIN_STORAGE_NAME);
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.getid()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.getid());
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.getid()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.getid());
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    StorageServerConnections newServerConnection = new StorageServerConnections();
    newServerConnection.setid("0cc146e8-e5ed-482c-8814-270bc48c2980");
    newServerConnection.setconnection(EXISTING_DOMAIN_STORAGE_NAME);
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.getid()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.getid());
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getStorageServerConnectionLunMapDao();
    StorageServerConnectionDao storageServerConnectionDao = dbFacade.getStorageServerConnectionDao();
    StorageServerConnections existingConnection = storageServerConnectionDao.get("0cc146e8-e5ed-482c-8814-270bc48c297e");
    existingLUNStorageMap = dao.get(new LUNStorageServerConnectionMapId("1IET_00180001", existingConnection.getid()));
    newLUNStorageMap = new LUNStorageServerConnectionMap(FREE_LUN_ID, existingConnection.getid());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(snapshotId, clusterId, volumeId, snapshotName, status, description, status);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(snapshotId, clusterId, volumeId, snapshotName, description, status);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformNicHotPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addCanDoActionMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformNicHotPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addCanDoActionMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (failPassthroughVnicHotPlug()) {
            return false;
        }
    }
    vmDevice = getVmDeviceDao().get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addCanDoActionMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean isPlugged = getParameters().getAction() == PlugAction.PLUG;
        boolean externalNetworkIsPlugged = isPlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        try {
            if (isPlugged) {
                checkForDuplicatedPciSlot(vmDevice);
            }
            runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean isPlugged = getParameters().getAction() == PlugAction.PLUG;
        boolean externalNetworkIsPlugged = isPlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        try {
            if (isPlugged) {
                clearAddressIfPciSlotIsDuplicated(vmDevice);
            }
            runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void doInit() {
    // Store old numa node ids for deletion
    oldNumaNodeIds = LinqUtils.transformToList(getVmNumaNodesForValidation(), new Function<VmNumaNode, Guid>() {

        @Override
        public Guid eval(VmNumaNode vmNumaNode) {
            return vmNumaNode.getId();
        }
    });
    // Set new numa nodes for validation
    setVmNumaNodesForValidation(getParameters().getVmNumaNodeList());
}
#method_after
@Override
protected void doInit() {
    // Store old numa node ids for deletion
    oldNumaNodeIds = Entities.getIds(getVmNumaNodesForValidation());
    // Set new numa nodes for validation
    setVmNumaNodesForValidation(getParameters().getVmNumaNodeList());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!oldNumaNodeIds.isEmpty()) {
        getVmNumaNodeDao().massRemoveNumaNodeByNumaNodeId(oldNumaNodeIds);
    }
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    // only single dedicated host allowed
    Guid vdsId = getVm().getDedicatedVmForVdsList().get(0);
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vdsId != null) {
        vdsNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    }
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        vmNumaNode.setId(Guid.newGuid());
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getSecond() != null) {
                int index = pair.getSecond().getSecond();
                // if pinned set pNode
                if (pair.getSecond().getFirst()) {
                    for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                        if (vdsNumaNode.getIndex() == index) {
                            pair.setFirst(vdsNumaNode.getId());
                            break;
                        }
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massSaveNumaNode(nodes, null, getVm().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!oldNumaNodeIds.isEmpty()) {
        getVmNumaNodeDao().massRemoveNumaNodeByNumaNodeId(oldNumaNodeIds);
    }
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    List<VdsNumaNode> vdsNumaNodes = getVdsNumaNodes();
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        vmNumaNode.setId(Guid.newGuid());
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getSecond() != null) {
                int index = pair.getSecond().getSecond();
                // if pinned set pNode
                if (pair.getSecond().getFirst()) {
                    for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                        if (vdsNumaNode.getIndex() == index) {
                            pair.setFirst(vdsNumaNode.getId());
                            break;
                        }
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massSaveNumaNode(nodes, null, getVm().getId());
    setSucceeded(true);
}
#end_block

#method_before
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    return result;
}
#method_after
public static boolean isGraphicsAndDisplaySupported(int osId, Collection<GraphicsType> graphics, DisplayType displayType, List<String> reasons, Version clusterVersion) {
    boolean result = VmValidationUtils.isGraphicsAndDisplaySupported(osId, clusterVersion, graphics, displayType);
    if (!result) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_VM_DISPLAY_TYPE_IS_NOT_SUPPORTED_BY_OS.name());
    }
    if (graphics.size() > 1 && !FeatureSupported.multipleGraphicsSupported(clusterVersion)) {
        reasons.add(EngineMessage.ACTION_TYPE_FAILED_ONLY_ONE_GRAPHICS_SUPPORTED_IN_THIS_CLUSTER_LEVEL.name());
        result = false;
    }
    return result;
}
#end_block

#method_before
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String interfaceName, List<String> messages) {
    // Interface iface = interfaces.FirstOrDefault(i => i.name ==
    // AddVmInterfaceParameters.Interface.name);
    VmNic iface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getName().equals(interfaceName);
        }
    });
    if (iface != null) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String candidateInterfaceName, List<String> messages) {
    boolean candidateNameUsed = interfaces.stream().anyMatch(i -> i.getName().equals(candidateInterfaceName));
    if (candidateNameUsed) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    // only single dedicated host allowed
    Guid vdsId = getVm().getDedicatedVmForVdsList().get(0);
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vdsId != null) {
        vdsNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    }
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getFirst()) {
                int index = pair.getSecond().getSecond();
                for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                    if (vdsNumaNode.getIndex() == index) {
                        pair.setFirst(vdsNumaNode.getId());
                        break;
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massUpdateNumaNode(nodes);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    List<VdsNumaNode> vdsNumaNodes = getVdsNumaNodes();
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getFirst()) {
                int index = pair.getSecond().getSecond();
                for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                    if (vdsNumaNode.getIndex() == index) {
                        pair.setFirst(vdsNumaNode.getId());
                        break;
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massUpdateNumaNode(nodes);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    // only single dedicated host allowed
    Guid vdsId = getVm().getDedicatedVmForVdsList().get(0);
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vdsId != null) {
        vdsNumaNodes = getVdsNumaNodeDao().getAllVdsNumaNodeByVdsId(vdsId);
    }
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        vmNumaNode.setId(Guid.newGuid());
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getSecond() != null) {
                int index = pair.getSecond().getSecond();
                // if pinned set pNode
                if (pair.getSecond().getFirst()) {
                    for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                        if (vdsNumaNode.getIndex() == index) {
                            pair.setFirst(vdsNumaNode.getId());
                            break;
                        }
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massSaveNumaNode(nodes, null, getVm().getId());
    // Used for restful API for reture first NUMA node GUID
    setActionReturnValue(nodes.get(0).getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    List<VdsNumaNode> vdsNumaNodes = getVdsNumaNodes();
    List<VmNumaNode> nodes = new ArrayList<>();
    for (VmNumaNode vmNumaNode : vmNumaNodes) {
        vmNumaNode.setId(Guid.newGuid());
        for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
            if (pair.getSecond() != null && pair.getSecond().getSecond() != null) {
                int index = pair.getSecond().getSecond();
                // if pinned set pNode
                if (pair.getSecond().getFirst()) {
                    for (VdsNumaNode vdsNumaNode : vdsNumaNodes) {
                        if (vdsNumaNode.getIndex() == index) {
                            pair.setFirst(vdsNumaNode.getId());
                            break;
                        }
                    }
                }
            }
        }
        nodes.add(vmNumaNode);
    }
    getVmNumaNodeDao().massSaveNumaNode(nodes, null, getVm().getId());
    // Used for restful API for reture first NUMA node GUID
    setActionReturnValue(nodes.get(0).getId());
    setSucceeded(true);
}
#end_block

#method_before
public ValidationResult validate() {
    if (vmNamesList.isEmpty()) {
        return ValidationResult.VALID;
    } else if (vmNamesList.size() > 1 && removedNetworks.size() > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNamesList)));
    } else if (vmNamesList.size() > 1) {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNamesList)));
    } else if (removedNetworks.size() > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNamesList)));
    } else {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNamesList)));
    }
}
#method_after
public ValidationResult validate() {
    if (vmNamesList.isEmpty()) {
        return ValidationResult.VALID;
    }
    final int vmsAmount = vmNamesList.size();
    final int removedNetworksAmount = removedNetworks.size();
    if (vmsAmount > 1 && removedNetworksAmount > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNamesList)));
    } else if (vmsAmount > 1) {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_VMS, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAMES, vmNamesList)));
    } else if (removedNetworksAmount > 1) {
        return new ValidationResult(EngineMessage.MULTIPLE_NETWORKS_CANNOT_DETACH_NETWORKS_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAMES, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNamesList)));
    } else {
        return new ValidationResult(EngineMessage.NETWORK_CANNOT_DETACH_NETWORK_USED_BY_SINGLE_VM, LinqUtils.concat(ReplacementUtils.replaceWith(VAR_NETWORK_NAME, removedNetworks), ReplacementUtils.replaceWith(VAR_VM_NAME, vmNamesList)));
    }
}
#end_block

#method_before
public boolean isPartOfBond(String bondName) {
    return getBondName().equals(bondName);
}
#method_after
public boolean isPartOfBond(String bondName) {
    return isPartOfBond() && getBondName().equals(bondName);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof NetworkCluster)) {
        return false;
    }
    NetworkCluster other = (NetworkCluster) obj;
    return display == other.display && Objects.equals(status, other.status) && Objects.equals(id, other.id) && required == other.required && Objects.equals(migration, other.migration) && Objects.equals(management, other.management) && Objects.equals(gluster, other.gluster);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof NetworkCluster)) {
        return false;
    }
    NetworkCluster other = (NetworkCluster) obj;
    return display == other.display && status == other.status && Objects.equals(id, other.id) && required == other.required && migration == other.migration && management == other.management && gluster == other.gluster;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenstackNetworkProviderProperties)) {
        return false;
    }
    OpenstackNetworkProviderProperties other = (OpenstackNetworkProviderProperties) obj;
    return super.equals(obj) && Objects.equals(pluginType, pluginType) && Objects.equals(agentConfiguration, other.agentConfiguration);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof OpenstackNetworkProviderProperties)) {
        return false;
    }
    OpenstackNetworkProviderProperties other = (OpenstackNetworkProviderProperties) obj;
    return super.equals(obj) && Objects.equals(pluginType, other.pluginType) && Objects.equals(agentConfiguration, other.agentConfiguration);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmGuestAgentInterface)) {
        return false;
    }
    VmGuestAgentInterface other = (VmGuestAgentInterface) obj;
    return Objects.equals(getInterfaceName(), other.getInterfaceName()) && Objects.equals(getIpv4Addresses(), other.getIpv4Addresses()) && Objects.equals(getIpv6Addresses(), other.getIpv6Addresses()) && Objects.equals(getMacAddress(), other.getMacAddress()) && Objects.equals(getVmId(), other.getVmId());
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmGuestAgentInterface)) {
        return false;
    }
    VmGuestAgentInterface other = (VmGuestAgentInterface) obj;
    return Objects.equals(interfaceName, other.interfaceName) && Objects.equals(ipv4Addresses, other.ipv4Addresses) && Objects.equals(ipv6Addresses, other.ipv6Addresses) && Objects.equals(macAddress, other.macAddress) && Objects.equals(vmId, other.vmId);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String engineSessionId = null;
    try {
        byte[] s = new byte[64];
        SecureRandom.getInstance("SHA1PRNG").nextBytes(s);
        engineSessionId = new Base64(0).encodeToString(s);
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException(e);
    }
    SessionDataContainer.getInstance().setUser(engineSessionId, getParameters().getUser());
    getReturnValue().setActionReturnValue(engineSessionId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        setSucceeded(false);
    } else {
        final DbUser user = buildUser(getParameters(), profile.getAuthzName());
        boolean isAdmin = !DbFacade.getInstance().getRoleDao().getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty();
        user.setAdmin(isAdmin);
        if (getParameters().isAdminRequired() && !isAdmin) {
            setSucceeded(false);
        } else if (DbFacade.getInstance().getPermissionDao().getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) {
            setSucceeded(false);
        } else {
            String engineSessionId = sessionDataContainer.generateEngineSessionId();
            sessionDataContainer.setUser(engineSessionId, user);
            sessionDataContainer.refresh(engineSessionId);
            sessionDataContainer.setProfile(engineSessionId, profile);
            sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName());
            sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken());
            getReturnValue().setActionReturnValue(engineSessionId);
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Override
public void init() {
    init(BrandingManager.getInstance());
    ssoGetTokenUrl = getInitString("SSO_GET_TOKEN_URL") + "?";
    switchUserUrl = getInitString("SSO_SWITCH_USER_URL");
    logoutUrl = getInitString("SSO_LOGOUT_URL");
}
#method_after
@Override
public void init() {
    init(BrandingManager.getInstance(), EngineLocalConfig.getInstance().getProperty("ENGINE_URI"));
}
#end_block

#method_before
void init(final BrandingManager brandingManager) {
    this.brandingManager = brandingManager;
}
#method_after
void init(final BrandingManager brandingManager, String engineUri) {
    this.brandingManager = brandingManager;
    this.engineUri = engineUri;
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    String sso_token = request.getParameter(SessionConstants.SSO_TOKEN_KEY);
    if (!"".equals(sso_token) && !FiltersHelper.isSessionValid(request, sso_token)) {
        response.sendRedirect(String.format("%s&post_action_url=%s&version=%s", ssoGetTokenUrl, response.encodeURL(request.getRequestURL().toString() + "?"), FiltersHelper.VERSION));
    } else {
        try {
            if (StringUtils.isNotEmpty(sso_token)) {
                request.setAttribute("sso_user", FiltersHelper.getCurrentSsoSessionUser(request, sso_token));
            }
        } catch (Exception e) {
            log.error("Unable to get session user");
        }
        request.setAttribute("sso_logout_url", String.format("%s?post_action_url=%s&version=%s&invalidate=1&external=0", logoutUrl, response.encodeURL(request.getRequestURL().toString() + "?"), "0"));
        request.setAttribute("sso_switch_user_url", String.format("%s?post_action_url=%s&version=%s&invalidate=1&external=0", switchUserUrl, response.encodeURL(request.getRequestURL().toString() + "?"), "0"));
        request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()));
        String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
        request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
        request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
        RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
        response.setContentType("text/html;charset=UTF-8");
        if (dispatcher != null) {
            dispatcher.include(request, response);
        }
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    log.debug("Entered WelcomeServlet");
    String state = (String) request.getSession(true).getAttribute("state");
    try {
        if (StringUtils.isEmpty(state)) {
            state = FiltersHelper.generateState();
            request.getSession(true).setAttribute("state", state);
        }
    } catch (Exception ex) {
        log.error("Unable to generate unique state: {}", ex.getMessage());
        log.debug("Unable to generate unique state", ex);
    }
    String reauthenticate = (String) request.getSession(true).getAttribute("reauthenticate");
    if (StringUtils.isEmpty(reauthenticate)) {
        Map<String, Object> deployedResponse = isSsoWebappDeployed();
        if (deployedResponse.containsKey("error")) {
            request.getSession(true).setAttribute("error", deployedResponse.get("error"));
            request.getSession(true).setAttribute("error_code", deployedResponse.get("error_code"));
        }
    }
    String authCode = (String) request.getSession(true).getAttribute("authCode");
    String token = (String) request.getSession(true).getAttribute("token");
    String error = (String) request.getSession(true).getAttribute("error");
    if (StringUtils.isNotEmpty(token) && !isSessionValid(request, token)) {
        request.getSession(true).removeAttribute("token");
        request.getSession(true).removeAttribute("sso_user");
        token = "";
    }
    if (authCode == null && StringUtils.isEmpty(error) && StringUtils.isEmpty(reauthenticate)) {
        if (StringUtils.isNotEmpty(request.getParameter("error_code")) && !"not_authenticated".equals(request.getParameter("error_code"))) {
            request.getSession(true).setAttribute("error", request.getParameter("error"));
            request.getSession(true).setAttribute("error_code", request.getParameter("error_code"));
        }
        String url = String.format("%s/login?scope=%s", engineUri, URLEncoder.encode(identityScope, "UTF-8"));
        log.debug("redirecting to {}", url);
        response.sendRedirect(url);
    } else {
        request.getSession(true).removeAttribute("reauthenticate");
        log.debug("Displaying Welcome Page");
        try {
            setUserNameForMenu(request, response, token);
        } catch (Exception ex) {
            log.debug("Unable to set request attributed for user menu", ex);
            log.error("Unable to set request attributed for user menu: {}", ex.getMessage());
        }
        error = (String) request.getSession(true).getAttribute("error");
        if (StringUtils.isNotEmpty(error)) {
            response.sendRedirect(engineUri + "/error.html");
        } else {
            request.setAttribute(LOCALE_KEYS, UnsupportedLocaleHelper.getDisplayedLocales(LocaleFilter.getLocaleKeys()));
            String oVirtVersion = backend.runPublicQuery(VdcQueryType.GetConfigurationValue, new GetConfigurationValueParameters(ConfigurationValues.ProductRPMVersion, ConfigCommon.defaultConfigurationVersion)).getReturnValue();
            request.setAttribute(VERSION, oVirtVersion != null ? oVirtVersion : "myVersion");
            request.setAttribute(SECTIONS, brandingManager.getWelcomeSections((Locale) request.getAttribute(LocaleFilter.LOCALE)));
            log.debug("Including to ovirt-engine.jsp");
            RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp");
            response.setContentType("text/html;charset=UTF-8");
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    }
    log.debug("Exiting WelcomeServlet");
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    testServlet = new WelcomeServlet();
    testServlet.setBackend(mockBackend);
    testServlet.init(mockBrandingManager);
    mockBackendQuery(VdcQueryType.GetConfigurationValue, "oVirtVersion");
    when(mockBrandingManager.getBrandingThemes()).thenReturn(new ArrayList<BrandingTheme>());
    when(mockBrandingManager.getWelcomeSections(any(Locale.class))).thenReturn("Welcome Section HTML");
}
#method_after
@Before
public void setUp() throws Exception {
    testServlet = new WelcomeServlet() {

        private static final long serialVersionUID = 1446616158991683162L;

        @Override
        public String getCurrentSsoSessionUser(HttpServletRequest request, HttpServletResponse response, String token) {
            return "admin@internal";
        }

        @Override
        public boolean isSessionValid(HttpServletRequest request, String token) {
            return true;
        }

        @Override
        public Map<String, Object> isSsoWebappDeployed() {
            return Collections.emptyMap();
        }
    };
    testServlet.setBackend(mockBackend);
    testServlet.init(mockBrandingManager, "/ovirt-engine");
    mockBackendQuery(VdcQueryType.GetConfigurationValue, "oVirtVersion");
    when(mockBrandingManager.getBrandingThemes()).thenReturn(new ArrayList<BrandingTheme>());
    when(mockBrandingManager.getWelcomeSections(any(Locale.class))).thenReturn("Welcome Section HTML");
}
#end_block

#method_before
@Test
public void testDoGetHttpServletRequestHttpServletResponseNoDispatcher() throws IOException, ServletException {
    when(mockRequest.getAttribute(LocaleFilter.LOCALE)).thenReturn(Locale.JAPANESE);
    when(mockRequest.getParameter(SessionConstants.SSO_TOKEN_KEY)).thenReturn("");
    when(mockRequest.getRequestURL()).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/"));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute("localeKeys", localeKeys);
    // Make sure the content type contains UTF-8 so the characters display properly.
    verify(mockResponse).setContentType("text/html;charset=UTF-8");
}
#method_after
@Test
public void testDoGetHttpServletRequestHttpServletResponseNoDispatcher() throws IOException, ServletException {
    when(mockRequest.getAttribute(LocaleFilter.LOCALE)).thenReturn(Locale.JAPANESE);
    when(mockRequest.getParameterMap()).thenReturn(new HashMap<String, String[]>());
    when(mockRequest.getRequestURL()).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/"));
    when(mockRequest.getServletContext()).thenReturn(mockContext);
    when(mockRequest.getSession(true)).thenReturn(mockSession);
    when(mockSession.getAttribute("authCode")).thenReturn("aU1KZG1OUytQSktnd29SQ3NIOVhWckls");
    when(mockSession.getAttribute("token")).thenReturn("aU1KZG1OUytQSktnd29SQ3NIOVhWckls");
    when(mockSession.getAttribute("error")).thenReturn("");
    when(mockSession.getAttribute("error_code")).thenReturn("");
    when(mockRequest.getServletContext().getAttribute("sso_logout_url")).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/logout"));
    when(mockRequest.getServletContext().getAttribute("sso_switch_user_url")).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/login"));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute("localeKeys", localeKeys);
    // Make sure the content type contains UTF-8 so the characters display properly.
    verify(mockResponse).setContentType("text/html;charset=UTF-8");
}
#end_block

#method_before
@Test
public void testDoGetHttpServletRequestHttpServletResponseWithDispatcher() throws IOException, ServletException {
    when(mockRequest.getAttribute(LocaleFilter.LOCALE)).thenReturn(Locale.JAPANESE);
    when(mockRequest.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp")).thenReturn(mockDispatcher);
    when(mockRequest.getParameter(SessionConstants.SSO_TOKEN_KEY)).thenReturn("");
    when(mockRequest.getRequestURL()).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/"));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute("localeKeys", localeKeys);
    // Make sure the content type contains UTF-8 so the characters display properly.
    verify(mockResponse).setContentType("text/html;charset=UTF-8");
    // Make sure the include is called on the dispatcher.
    verify(mockDispatcher).include(mockRequest, mockResponse);
}
#method_after
@Test
public void testDoGetHttpServletRequestHttpServletResponseWithDispatcher() throws IOException, ServletException {
    when(mockRequest.getAttribute(LocaleFilter.LOCALE)).thenReturn(Locale.JAPANESE);
    when(mockRequest.getRequestDispatcher("/WEB-INF/ovirt-engine.jsp")).thenReturn(mockDispatcher);
    when(mockRequest.getParameterMap()).thenReturn(new HashMap<String, String[]>());
    when(mockRequest.getRequestURL()).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/"));
    when(mockRequest.getServletContext()).thenReturn(mockContext);
    when(mockRequest.getSession(true)).thenReturn(mockSession);
    when(mockSession.getAttribute("authCode")).thenReturn("aU1KZG1OUytQSktnd29SQ3NIOVhWckls");
    when(mockSession.getAttribute("token")).thenReturn("aU1KZG1OUytQSktnd29SQ3NIOVhWckls");
    when(mockSession.getAttribute("error")).thenReturn("");
    when(mockSession.getAttribute("error_code")).thenReturn("");
    when(mockRequest.getServletContext().getAttribute("sso_logout_url")).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/logout"));
    when(mockRequest.getServletContext().getAttribute("sso_switch_user_url")).thenReturn(new StringBuffer("http://localhost:8080/ovirt-engine/login"));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute("localeKeys", localeKeys);
    // Make sure the content type contains UTF-8 so the characters display properly.
    verify(mockResponse).setContentType("text/html;charset=UTF-8");
    // Make sure the include is called on the dispatcher.
    verify(mockDispatcher).include(mockRequest, mockResponse);
}
#end_block

#method_before
private List<String> createLocaleKeys() {
    List<String> keys = new ArrayList<String>();
    keys.add("de_DE");
    keys.add("en_US");
    keys.add("es_ES");
    keys.add("fr_FR");
    keys.add("ja_JP");
    keys.add("ko_KR");
    keys.add("pt_BR");
    keys.add("zh_CN");
    return keys;
}
#method_after
private List<String> createLocaleKeys() {
    List<String> keys = new ArrayList<String>();
    keys.add("de_DE");
    keys.add("en_US");
    keys.add("es_ES");
    keys.add("fr_FR");
    keys.add("it_IT");
    keys.add("ja_JP");
    keys.add("ko_KR");
    keys.add("pt_BR");
    keys.add("zh_CN");
    return keys;
}
#end_block

#method_before
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        VdcReturnValueBase queryRetVal = FiltersHelper.getBackend(ctx).runAction(VdcActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), req.getRemoteAddr(), (List<Map>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            throw new RuntimeException(String.format("The user %s is not authorized to perform login", username));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.getSession(true).setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.getSession(true).setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#method_after
public static String createUserSession(HttpServletRequest req, Map<String, Object> jsonResponse, boolean loginAsAdmin) {
    String engineSessionId = null;
    if (!FiltersHelper.isStatusOk(jsonResponse)) {
        throw new RuntimeException((String) jsonResponse.get("MESSAGE"));
    }
    InitialContext ctx = null;
    Map<String, Object> payload = (Map<String, Object>) jsonResponse.get("ovirt");
    String username = (String) jsonResponse.get("user_id");
    String profile = null;
    int index = username.lastIndexOf("@");
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    try {
        ctx = new InitialContext();
        VdcReturnValueBase queryRetVal = FiltersHelper.getBackend(ctx).runAction(VdcActionType.CreateUserSession, new CreateUserSessionParameters((String) jsonResponse.get(SessionConstants.SSO_TOKEN_KEY), profile, username, (String) payload.get("principal_id"), (String) payload.get("email"), req == null ? "" : req.getRemoteAddr(), (List<Map>) payload.get("group_ids"), loginAsAdmin));
        if (!queryRetVal.getSucceeded()) {
            throw new RuntimeException(String.format("The user %s is not authorized to perform login", username));
        }
        engineSessionId = queryRetVal.getActionReturnValue();
        if (req != null) {
            req.getSession(true).setAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY, engineSessionId);
            req.getSession(true).setAttribute(FiltersHelper.Constants.REQUEST_LOGIN_FILTER_AUTHENTICATION_DONE, true);
        }
    } catch (Exception ex) {
        log.error("User '{}@{}' login failed: {}", username, profile, ex.getMessage());
        log.debug("User '{}@{}' login failed", username, profile, ex);
    } finally {
        try {
            if (ctx != null) {
                ctx.close();
            }
        } catch (NamingException ex) {
            log.error("Unable to close context", ex);
        }
    }
    return engineSessionId;
}
#end_block

#method_before
private DbUser buildUser(T params, String authzName) {
    DbUser user = getDbUserDao().getByExternalId(authzName, params.getPrincipalId());
    if (user == null) {
        user = new DbUser();
        user.setId(DEFAULT_USER_ID);
    }
    user.setEmail(params.getEmail());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<ExtMap> groupExtMapIds = new ArrayList<>();
    flatGroups(params.getGroupIds(), groupExtMapIds);
    for (ExtMap group : groupExtMapIds) {
        DbGroup dbGroup = getAdGroupDao().getByExternalId(authzName, group.<String>get(Authz.GroupRecord.ID));
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    return user;
}
#method_after
private DbUser buildUser(T params, String authzName) {
    DbUser user = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    if (user == null) {
        user = new DbUser();
        user.setId(DEFAULT_USER_ID);
    }
    user.setEmail(params.getEmail());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<ExtMap> groupExtMapIds = new ArrayList<>();
    flatGroups(params.getGroupIds(), groupExtMapIds);
    for (ExtMap group : groupExtMapIds) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, group.<String>get(Authz.GroupRecord.ID));
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    return user;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        setSucceeded(false);
    } else {
        final DbUser user = buildUser(getParameters(), profile.getAuthzName());
        boolean isAdmin = !DbFacade.getInstance().getRoleDao().getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty();
        user.setAdmin(isAdmin);
        if (getParameters().isAdminRequired() && !isAdmin) {
            setSucceeded(false);
        } else if (DbFacade.getInstance().getPermissionDao().getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) {
            setSucceeded(false);
        } else {
            String engineSessionId = sessionDataContainer.generateEngineSessionId();
            sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp());
            sessionDataContainer.setUser(engineSessionId, user);
            sessionDataContainer.refresh(engineSessionId);
            sessionDataContainer.setProfile(engineSessionId, profile);
            sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName());
            sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken());
            getReturnValue().setActionReturnValue(engineSessionId);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    final AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(getParameters().getProfileName());
    if (profile == null) {
        setSucceeded(false);
    } else {
        final DbUser user = buildUser(getParameters(), profile.getAuthzName());
        boolean isAdmin = !roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty();
        user.setAdmin(isAdmin);
        if (getParameters().isAdminRequired() && !isAdmin) {
            setSucceeded(false);
        } else if (permissionDao.getEntityPermissionsForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ","), ActionGroup.LOGIN, BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true) == null) {
            setSucceeded(false);
        } else {
            String engineSessionId = sessionDataContainer.generateEngineSessionId();
            sessionDataContainer.setSourceIp(engineSessionId, getParameters().getSourceIp());
            sessionDataContainer.setUser(engineSessionId, user);
            sessionDataContainer.refresh(engineSessionId);
            sessionDataContainer.setProfile(engineSessionId, profile);
            sessionDataContainer.setPrincipalName(engineSessionId, getParameters().getPrincipalName());
            sessionDataContainer.setSsoAccessToken(engineSessionId, getParameters().getSsoToken());
            getReturnValue().setActionReturnValue(engineSessionId);
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
private static List<ExtMap> flatGroups(ExtMap entity, ExtKey key, List<ExtMap> accumulator) {
    for (ExtMap group : entity.get(key, Collections.<ExtMap>emptyList())) {
        accumulator.add(group);
        flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
    }
    return accumulator;
}
#method_after
private static List<ExtMap> flatGroups(ExtMap entity, ExtKey key, List<ExtMap> accumulator) {
    for (ExtMap group : entity.<List<ExtMap>>get(key, Collections.<ExtMap>emptyList())) {
        accumulator.add(group);
        flatGroups(group, Authz.GroupRecord.GROUPS, accumulator);
    }
    return accumulator;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EngineSession other = (EngineSession) obj;
    return ObjectUtils.objectsEqual(engineSessionId, other.engineSessionId) && ObjectUtils.objectsEqual(userId, other.userId);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    EngineSession other = (EngineSession) obj;
    return Objects.equals(engineSessionId, other.engineSessionId) && Objects.equals(userId, other.userId);
}
#end_block

#method_before
private static Map<String, Object> loginWithPasswordImpl(String username, String password, String scope, ExtMap authRecord) {
    HttpURLConnection connection = null;
    try {
        connection = createConnection("/oauth/token");
        setClientIdSecretBasicAuthHeader(connection);
        URLBuilder urlBuilder = new URLBuilder(connection.getURL()).addParameter("grant_type", "password").addParameter("username", username).addParameter("password", password).addParameter("scope", scope);
        if (authRecord != null) {
            urlBuilder.addParameter("authRecord", new JsonObjectSerializer().serialize(authRecord));
        }
        postData(connection, urlBuilder.buildURL().getQuery());
        return getData(connection);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    } finally {
        if (connection != null) {
            connection.disconnect();
        }
    }
}
#method_after
private static Map<String, Object> loginWithPasswordImpl(String username, String password, String scope, ExtMap authRecord) {
    HttpURLConnection connection = null;
    try {
        connection = createConnection("/oauth/token");
        setClientIdSecretBasicAuthHeader(connection);
        URLBuilder urlBuilder = new URLBuilder(connection.getURL()).addParameter("grant_type", "password").addParameter("username", username).addParameter("password", password).addParameter("scope", scope);
        if (authRecord != null) {
            urlBuilder.addParameter("ovirt_auth_record", new JsonObjectSerializer().serialize(authRecord));
        }
        postData(connection, urlBuilder.buildURL().getQuery());
        return getData(connection);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    } finally {
        if (connection != null) {
            connection.disconnect();
        }
    }
}
#end_block

#method_before
private static String[] getUserCredentialsFromHeader(HttpServletRequest request) {
    String header = request.getHeader("Authorization");
    String userName = "";
    String passwd = "";
    if (StringUtils.isNotEmpty(header) && header.startsWith("Basic")) {
        String[] creds = new String(Base64.decodeBase64(header.substring("Basic".length())), Charset.forName("UTF-8")).split(":", 2);
        userName = creds.length >= 1 ? creds[0] : "";
        passwd = creds.length >= 2 ? creds[1] : "";
    }
    return new String[] { userName, passwd };
}
#method_after
private static String[] getUserCredentialsFromHeader(HttpServletRequest request) {
    String header = request.getHeader("Authorization");
    String userName = "";
    String passwd = "";
    if (StringUtils.isNotEmpty(header) && header.startsWith("Basic")) {
        String[] creds = new String(Base64.decodeBase64(header.substring("Basic".length())), StandardCharsets.UTF_8).split(":", 2);
        userName = creds.length >= 1 ? creds[0] : "";
        passwd = creds.length >= 2 ? creds[1] : "";
    }
    return new String[] { userName, passwd };
}
#end_block

#method_before
private static Map getData(HttpURLConnection connection) throws Exception {
    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        try (InputStream input = connection.getInputStream()) {
            copy(input, os);
        }
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(SSOOAuthServiceUtils.class.getClassLoader());
        try {
            return new JsonObjectDeserializer().deserialize(new String(os.toByteArray(), "UTF-8"), HashMap.class);
        } finally {
            Thread.currentThread().setContextClassLoader(loader);
        }
    }
}
#method_after
private static Map getData(HttpURLConnection connection) throws Exception {
    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
        try (InputStream input = connection.getInputStream()) {
            FiltersHelper.copy(input, os);
        }
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(SSOOAuthServiceUtils.class.getClassLoader());
        try {
            return new JsonObjectDeserializer().deserialize(new String(os.toByteArray(), StandardCharsets.UTF_8.name()), HashMap.class);
        } finally {
            Thread.currentThread().setContextClassLoader(loader);
        }
    }
}
#end_block

#method_before
public static void loginOnBehalf(HttpServletRequest request, String username) throws Exception {
    log.debug("Entered AuthenticationUtils.loginOnBehalf");
    int index = username.lastIndexOf("@");
    String profile = null;
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    if (StringUtils.isEmpty(username) || StringUtils.isEmpty(profile)) {
        throw new AuthenticationException("Please provide username and profile.");
    }
    ObjectMapper mapper = new ObjectMapper().configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false).enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
    mapper.getDeserializationConfig().addMixInAnnotations(ExtMap.class, JsonExtMapMixIn.class);
    login(request, new Credentials(username, null, profile, SSOUtils.getSsoContext(request).getSsoProfiles().contains(profile)), mapper.readValue(SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_AUTH_RECORD), ExtMap.class));
}
#method_after
public static void loginOnBehalf(HttpServletRequest request, String username) throws Exception {
    log.debug("Entered AuthenticationUtils.loginOnBehalf");
    int index = username.lastIndexOf("@");
    String profile = null;
    if (index != -1) {
        profile = username.substring(index + 1);
        username = username.substring(0, index);
    }
    if (StringUtils.isEmpty(username) || StringUtils.isEmpty(profile)) {
        throw new AuthenticationException("Please provide username and profile.");
    }
    ObjectMapper mapper = new ObjectMapper().configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false).enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);
    mapper.getDeserializationConfig().addMixInAnnotations(ExtMap.class, JsonExtMapMixIn.class);
    String authRecordJson = SSOUtils.getRequestParameter(request, SSOConstants.HTTP_PARAM_AUTH_RECORD, "");
    ExtMap authRecord;
    if (StringUtils.isNotEmpty(authRecordJson)) {
        authRecord = mapper.readValue(authRecordJson, ExtMap.class);
    } else {
        authRecord = new ExtMap().mput(Authn.AuthRecord.PRINCIPAL, username);
    }
    SSOSession ssoSession = login(request, new Credentials(username, null, profile, SSOUtils.getSsoContext(request).getSsoProfiles().contains(profile)), authRecord);
    log.info("User {}@{} successfully logged in using login-on-behalf with client id : {} and scopes : {}", username, profile, ssoSession.getClientId(), ssoSession.getScope());
}
#end_block

#method_before
public static void handleCredentials(HttpServletRequest request, Credentials credentials) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException("Please provide username, password and profile.");
    }
    login(request, credentials, null);
}
#method_after
public static void handleCredentials(HttpServletRequest request, Credentials credentials) throws Exception {
    log.debug("Entered AuthenticationUtils.handleCredentials");
    if (StringUtils.isEmpty(credentials.getUsername()) || StringUtils.isEmpty(credentials.getProfile())) {
        throw new AuthenticationException("Please provide username, password and profile.");
    }
    SSOSession ssoSession = login(request, credentials, null);
    log.info("User {}@{} successfully logged in with scopes: {}", credentials.getUsername(), credentials.getProfile(), ssoSession.getScope());
}
#end_block

#method_before
private static void login(HttpServletRequest request, Credentials credentials, ExtMap authRecord) throws Exception {
    ExtensionProxy authn = null;
    ExtensionProxy authz = null;
    ExtensionProxy mapper = null;
    SSOContext ssoContext = SSOUtils.getSsoContext(request);
    for (ExtensionProxy authnExtension : ssoContext.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
        if (credentials.getProfile().equals(config.getProperty(Authn.ConfigKeys.PROFILE_NAME))) {
            String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.MAPPING_PLUGIN);
            String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.AUTHZ_PLUGIN);
            mapper = mapperName != null ? ssoContext.getSsoExtensionsManager().getExtensionByName(mapperName) : null;
            authn = authnExtension;
            authz = ssoContext.getSsoExtensionsManager().getExtensionByName(authzName);
            break;
        }
    }
    if (authn == null || authz == null) {
        log.debug("AuthenticationUtils.handleCredentials authn and authz NOT found for profile {}", credentials.getProfile());
        throw new RuntimeException(String.format("Error in obtaining profile %s", credentials.getProfile()));
    }
    log.debug("AuthenticationUtils.handleCredentials authn and authz found for profile %s", credentials.getProfile());
    String user = credentials.getUsername();
    if (mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_USER on mapper");
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).get(Mapping.InvokeKeys.USER, user);
    }
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(outputMap));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    log.info("User {}@{} successfully logged in", credentials.getUsername(), credentials.getProfile());
    SSOUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, (ExtMap) output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#method_after
private static SSOSession login(HttpServletRequest request, Credentials credentials, ExtMap authRecord) throws Exception {
    ExtensionProxy authn = null;
    ExtensionProxy authz = null;
    ExtensionProxy mapper = null;
    SSOContext ssoContext = SSOUtils.getSsoContext(request);
    for (ExtensionProxy authnExtension : ssoContext.getSsoExtensionsManager().getExtensionsByService(Authn.class.getName())) {
        Properties config = authnExtension.getContext().get(Base.ContextKeys.CONFIGURATION);
        if (credentials.getProfile().equals(config.getProperty(Authn.ConfigKeys.PROFILE_NAME))) {
            String mapperName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.MAPPING_PLUGIN);
            String authzName = authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(Authn.ConfigKeys.AUTHZ_PLUGIN);
            mapper = mapperName != null ? ssoContext.getSsoExtensionsManager().getExtensionByName(mapperName) : null;
            authn = authnExtension;
            authz = ssoContext.getSsoExtensionsManager().getExtensionByName(authzName);
            break;
        }
    }
    if (authn == null || authz == null) {
        log.debug("AuthenticationUtils.handleCredentials authn and authz NOT found for profile {}", credentials.getProfile());
        throw new RuntimeException(String.format("Error in obtaining profile %s", credentials.getProfile()));
    }
    log.debug("AuthenticationUtils.handleCredentials authn and authz found for profile %s", credentials.getProfile());
    String user = credentials.getUsername();
    if (mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_USER on mapper");
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).get(Mapping.InvokeKeys.USER, user);
    }
    if (authRecord == null) {
        log.debug("AuthenticationUtils.handleCredentials invoking AUTHENTICATE_CREDENTIALS on authn");
        ExtMap outputMap = authn.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, credentials.getPassword()));
        if (outputMap.<Integer>get(Base.InvokeKeys.RESULT) != Base.InvokeResult.SUCCESS || outputMap.<Integer>get(Authn.InvokeKeys.RESULT) != Authn.AuthResult.SUCCESS) {
            log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn failed");
            throw new AuthenticationException(AuthnMessageMapper.mapMessageErrorCode(outputMap));
        }
        log.debug("AuthenticationUtils.handleCredentials AUTHENTICATE_CREDENTIALS on authn succeeded");
        authRecord = outputMap.get(Authn.InvokeKeys.AUTH_RECORD);
    }
    if (mapper != null) {
        log.debug("AuthenticationUtils.handleCredentials invoking MAP_AUTH_RECORD on mapper");
        authRecord = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord), true).get(Authn.InvokeKeys.AUTH_RECORD, authRecord);
    }
    log.debug("AuthenticationUtils.handleCredentials invoking FETCH_PRINCIPAL_RECORD on authz");
    ExtMap output = authz.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, authRecord).mput(Authz.InvokeKeys.QUERY_FLAGS, Authz.QueryFlags.RESOLVE_GROUPS | Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE));
    log.debug("AuthenticationUtils.handleCredentials saving data in session data");
    return SSOUtils.persistAuthInfoInContextWithToken(request, credentials.getPassword(), credentials.getProfile(), authRecord, (ExtMap) output.get(Authz.InvokeKeys.PRINCIPAL_RECORD));
}
#end_block

#method_before
protected Map<String, LUNs> getLunsFromDeviceMap(StorageType storageType) {
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (getParameters().getId() == null) {
        return lunsMap;
    }
    VDSBrokerFrontend vdsBrokerFrontend = getVdsBroker();
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getId(), storageType);
    List<LUNs> lunsList = (List<LUNs>) vdsBrokerFrontend.RunVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    for (LUNs lun : lunsList) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    return lunsMap;
}
#method_after
protected Map<String, LUNs> getLunsFromDeviceMap(StorageType storageType) {
    Map<String, LUNs> lunsMap = new HashMap<>();
    if (getParameters().getId() == null) {
        return lunsMap;
    }
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getId(), storageType);
    List<LUNs> lunsList = (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    for (LUNs lun : lunsList) {
        lunsMap.put(lun.getLUN_id(), lun);
    }
    return lunsMap;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(getStorageDomainId());
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDisksByStorageDomainId, new IdQueryParameters(getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the Dao
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(getStorageDomainId());
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDisksByStorageDomainId, new IdQueryParameters(getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = runVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the Dao
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.debug("Could not get populated disk: {}", unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
protected void destroyVm() {
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        getVdsBroker().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVm().getMigratingToVds(), getVmId(), getParameters().getStopReason(), true, false, 0));
    }
    setActionReturnValue(getVdsBroker().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getStopReason(), false, false, 0)).getReturnValue());
}
#method_after
protected void destroyVm() {
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVm().getMigratingToVds(), getVmId(), getParameters().getStopReason(), true, false, 0));
    }
    setActionReturnValue(runVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getStopReason(), false, false, 0)).getReturnValue());
}
#end_block

#method_before
private void stopSpm() {
    // get the host spm status again from the database in order to test it's current state.
    VdsSpmStatus spmStatus = getDbFacade().getVdsDao().get(getVds().getId()).getSpmStatus();
    // try to stop SPM if action is Restart or Stop and the vds is SPM
    if (spmStatus != VdsSpmStatus.None) {
        getVdsBroker().RunVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(getVds().getId(), getVds().getStoragePoolId()));
    }
}
#method_after
private void stopSpm() {
    // get the host spm status again from the database in order to test it's current state.
    VdsSpmStatus spmStatus = getDbFacade().getVdsDao().get(getVds().getId()).getSpmStatus();
    // try to stop SPM if action is Restart or Stop and the vds is SPM
    if (spmStatus != VdsSpmStatus.None) {
        runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(getVds().getId(), getVds().getStoragePoolId()));
    }
}
#end_block

#method_before
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context.clone());
    }
    return new VdcReturnValueBase();
}
#method_after
protected VdcReturnValueBase attemptRollback(VdcActionType commandType, VdcActionParametersBase params, CommandContext context) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context);
    }
    return new VdcReturnValueBase();
}
#end_block

#method_before
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params) {
    return attemptRollback(commandType, params);
}
#method_after
protected VdcReturnValueBase checkAndPerformRollbackUsingCommand(VdcActionType commandType, VdcActionParametersBase params, CommandContext context) {
    return attemptRollback(commandType, params, context);
}
#end_block

#method_before
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependecyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    loadService(CpuFlagsManagerHandler.class);
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
@Override
public void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // TODO temporal solution DbFacade in Utils
    SimpleDependencyInjector.getInstance().bind(dbFacade);
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    loadService(CpuFlagsManagerHandler.class);
    // ResourceManager res = ResourceManager.Instance;
    // Initialize the AuditLogCleanupManager
    AuditLogCleanupManager.getInstance();
    // Initialize the CommandEntityCleanupManager
    CommandEntityCleanupManager.getInstance();
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    // initializes the JobRepositoryCleanupManager
    JobRepositoryCleanupManager.getInstance().initialize();
    // initialize the AutoRecoveryManager
    AutoRecoveryManager.getInstance().initialize();
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmPoolMonitor.class);
    loadService(AutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
private void registerIconDefaultsProvider() {
    final OvfVmIconDefaultsProvider ovfVmIconDefaultsProvider = new OvfVmIconDefaultsProvider() {

        @Override
        public Map<Integer, VmIconIdSizePair> getVmIconDefaults() {
            final VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase());
            return queryReturnValue.getReturnValue();
        }
    };
    SimpleDependecyInjector.getInstance().bind(OvfVmIconDefaultsProvider.class, ovfVmIconDefaultsProvider);
}
#method_after
private void registerIconDefaultsProvider() {
    final OvfVmIconDefaultsProvider ovfVmIconDefaultsProvider = new OvfVmIconDefaultsProvider() {

        @Override
        public Map<Integer, VmIconIdSizePair> getVmIconDefaults() {
            final VdcQueryReturnValue queryReturnValue = runInternalQuery(VdcQueryType.GetVmIconDefaults, new VdcQueryParametersBase());
            return queryReturnValue.getReturnValue();
        }
    };
    SimpleDependencyInjector.getInstance().bind(OvfVmIconDefaultsProvider.class, ovfVmIconDefaultsProvider);
}
#end_block

#method_before
private void initSearchDependencies() {
    SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames()));
}
#method_after
private void initSearchDependencies() {
    SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(SimpleDependencyInjector.getInstance().get(OsRepository.class).getUniqueOsNames()));
}
#end_block

#method_before
private void initVmPropertiesUtils() {
    VmPropertiesUtils vmPropertiesUtils = VmPropertiesUtils.getInstance();
    SimpleDependecyInjector.getInstance().bind(VmPropertiesUtils.class, vmPropertiesUtils);
}
#method_after
private void initVmPropertiesUtils() {
    VmPropertiesUtils vmPropertiesUtils = VmPropertiesUtils.getInstance();
    SimpleDependencyInjector.getInstance().bind(VmPropertiesUtils.class, vmPropertiesUtils);
}
#end_block

#method_before
private void initOsRepository() {
    OsInfoPreferencesLoader.INSTANCE.init(FileSystems.getDefault().getPath(EngineLocalConfig.getInstance().getEtcDir().getAbsolutePath(), Config.<String>getValue(ConfigValues.OsRepositoryConfDir)));
    OsRepositoryImpl.INSTANCE.init(OsInfoPreferencesLoader.INSTANCE.getPreferences());
    OsRepository osRepository = OsRepositoryImpl.INSTANCE;
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    dbFacade.populateDwhOsInfo(osRepository.getOsNames());
}
#method_after
private void initOsRepository() {
    OsInfoPreferencesLoader.INSTANCE.init(FileSystems.getDefault().getPath(EngineLocalConfig.getInstance().getEtcDir().getAbsolutePath(), Config.<String>getValue(ConfigValues.OsRepositoryConfDir)));
    OsRepositoryImpl.INSTANCE.init(OsInfoPreferencesLoader.INSTANCE.getPreferences());
    OsRepository osRepository = OsRepositoryImpl.INSTANCE;
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    dbFacade.populateDwhOsInfo(osRepository.getOsNames());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getFlow() == RunVmFlow.REMOVE_STATELESS_IMAGES) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (getFlow() == RunVmFlow.RESUME_PAUSE) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (getFlow() == RunVmFlow.CREATE_STATELESS_IMAGES) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? isVmRunningOnNonDefaultVds() ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : getTaskIdList().isEmpty() ? AuditLogType.USER_STARTED_VM : AuditLogType.USER_INITIATED_RUN_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    List<LUNs> returnValue = new ArrayList<>();
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getId());
    boolean filteringLUNsEnabled = Config.<Boolean>getValue(ConfigValues.FilteringLUNsEnabled, vds.getVdsGroupCompatibilityVersion().getValue());
    // Get Device List
    VDSBrokerFrontend vdsBrokerFrontend = getVdsBroker();
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getId(), getParameters().getStorageType(), getParameters().isCheckStatus(), getParameters().getLunIds());
    List<LUNs> luns = (List<LUNs>) vdsBrokerFrontend.RunVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getDbFacade().getLunDao().getAll();
    HashMap<String, LUNs> lunsFromDbById = new HashMap<>();
    for (LUNs lun : lunsFromDb) {
        lunsFromDbById.put(lun.getLUN_id(), lun);
    }
    for (LUNs lun : luns) {
        // Filtering code should be deprecated once DC level 3.0 is no longer supported
        if (filteringLUNsEnabled) {
            if (StringUtils.isNotEmpty(lun.getvolume_group_id())) {
                log.debug("LUN with GUID {} already has VG ID {}, so not returning it.", lun.getLUN_id(), lun.getvolume_group_id());
            } else if (lunsFromDbById.containsKey(lun.getLUN_id())) {
                log.debug("LUN with GUID {} already exists in the DB, so not returning it.", lun.getLUN_id());
            } else {
                returnValue.add(lun);
            }
        } else {
            // if the LUN exists in DB, update its values
            if (lunsFromDbById.containsKey(lun.getLUN_id())) {
                LUNs lunFromDb = lunsFromDbById.get(lun.getLUN_id());
                lun.setDiskId(lunFromDb.getDiskId());
                lun.setDiskAlias(lunFromDb.getDiskAlias());
                lun.setStorageDomainId(lunFromDb.getStorageDomainId());
                lun.setStorageDomainName(lunFromDb.getStorageDomainName());
            }
            returnValue.add(lun);
        }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#method_after
@Override
protected void executeQueryCommand() {
    List<LUNs> returnValue = new ArrayList<>();
    VDS vds = getDbFacade().getVdsDao().get(getParameters().getId());
    boolean filteringLUNsEnabled = Config.<Boolean>getValue(ConfigValues.FilteringLUNsEnabled, vds.getVdsGroupCompatibilityVersion().getValue());
    // Get Device List
    GetDeviceListVDSCommandParameters parameters = new GetDeviceListVDSCommandParameters(getParameters().getId(), getParameters().getStorageType(), getParameters().isCheckStatus(), getParameters().getLunIds());
    List<LUNs> luns = (List<LUNs>) runVdsCommand(VDSCommandType.GetDeviceList, parameters).getReturnValue();
    // Get LUNs from DB
    List<LUNs> lunsFromDb = getDbFacade().getLunDao().getAll();
    HashMap<String, LUNs> lunsFromDbById = new HashMap<>();
    for (LUNs lun : lunsFromDb) {
        lunsFromDbById.put(lun.getLUN_id(), lun);
    }
    for (LUNs lun : luns) {
        // Filtering code should be deprecated once DC level 3.0 is no longer supported
        if (filteringLUNsEnabled) {
            if (StringUtils.isNotEmpty(lun.getvolume_group_id())) {
                log.debug("LUN with GUID {} already has VG ID {}, so not returning it.", lun.getLUN_id(), lun.getvolume_group_id());
            } else if (lunsFromDbById.containsKey(lun.getLUN_id())) {
                log.debug("LUN with GUID {} already exists in the DB, so not returning it.", lun.getLUN_id());
            } else {
                returnValue.add(lun);
            }
        } else {
            // if the LUN exists in DB, update its values
            if (lunsFromDbById.containsKey(lun.getLUN_id())) {
                LUNs lunFromDb = lunsFromDbById.get(lun.getLUN_id());
                lun.setDiskId(lunFromDb.getDiskId());
                lun.setDiskAlias(lunFromDb.getDiskAlias());
                lun.setStorageDomainId(lunFromDb.getStorageDomainId());
                lun.setStorageDomainName(lunFromDb.getStorageDomainName());
            }
            returnValue.add(lun);
        }
    }
    getQueryReturnValue().setReturnValue(returnValue);
}
#end_block

#method_before
protected VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws EngineException {
    VDSReturnValue returnValue = getBackendResourceManager().RunVdsCommand(commandType, parameters);
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getVdsError().getCode(), returnValue.getVdsError().getMessage());
    }
    return returnValue;
}
#method_after
@Override
protected VDSReturnValue runVdsCommand(VDSCommandType commandType, VDSParametersBase parameters) throws EngineException {
    VDSReturnValue returnValue = super.runVdsCommand(commandType, parameters);
    if (!returnValue.getSucceeded()) {
        throw new EngineException(returnValue.getVdsError().getCode(), returnValue.getVdsError().getMessage());
    }
    return returnValue;
}
#end_block

#method_before
private void notifyHostsVmFailed() {
    if (!getRunVdssList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                for (Guid vdsId : getRunVdssList()) {
                    if (!vdsId.equals(getCurrentVdsId())) {
                        getVdsBroker().RunVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
                    }
                }
            }
        });
    }
}
#method_after
private void notifyHostsVmFailed() {
    if (!getRunVdssList().isEmpty()) {
        ThreadPoolUtil.execute(new Runnable() {

            @Override
            public void run() {
                for (Guid vdsId : getRunVdssList()) {
                    if (!vdsId.equals(getCurrentVdsId())) {
                        runVdsCommand(VDSCommandType.FailedToRunVm, new FailedToRunVmVDSCommandParameters(vdsId));
                    }
                }
            }
        });
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String bond = null;
    List<String> nics = new ArrayList<>();
    String baseNicName = NetworkUtils.stripVlan(iface);
    nics.add(baseNicName);
    Integer vlanId = iface.getVlanId();
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    // vlan with bond
    boolean isBond = NetworkUtils.isBondVlan(interfaces, iface);
    // or just a bond...
    isBond = isBond || (iface.getBonded() != null && iface.getBonded());
    // check if bond...
    if (isBond) {
        nics.clear();
        bond = baseNicName;
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), bond)) {
                nics.add(NetworkUtils.stripVlan(i));
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(getParameters().getVdsId(), getParameters().getNetwork().getName(), vlanId, bond, nics.toArray(new String[] {}), getParameters().getNetwork().getAddr(), getParameters().getNetwork().getSubnet(), getParameters().getNetwork().getGateway(), getParameters().getNetwork().getStp(), getParameters().getBondingOptions(), getParameters().getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.RemoveNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = getVdsBroker().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    String bond = null;
    List<String> nics = new ArrayList<>();
    String baseNicName = NetworkUtils.stripVlan(iface);
    nics.add(baseNicName);
    Integer vlanId = iface.getVlanId();
    List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(getParameters().getVdsId());
    // vlan with bond
    boolean isBond = NetworkUtils.isBondVlan(interfaces, iface);
    // or just a bond...
    isBond = isBond || (iface.getBonded() != null && iface.getBonded());
    // check if bond...
    if (isBond) {
        nics.clear();
        bond = baseNicName;
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), bond)) {
                nics.add(NetworkUtils.stripVlan(i));
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(getParameters().getVdsId(), getParameters().getNetwork().getName(), vlanId, bond, nics.toArray(new String[] {}), getParameters().getNetwork().getAddr(), getParameters().getNetwork().getSubnet(), getParameters().getNetwork().getGateway(), getParameters().getNetwork().getStp(), getParameters().getBondingOptions(), getParameters().getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.RemoveNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = runVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Test
public void statusSetInMap() {
    doReturn(mock(IStorageHelper.class)).when(cmd).getStorageHelper(any(StorageDomain.class));
    doReturn(isoMapDao).when(cmd).getStoragePoolIsoMapDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(asyncTaskDao).when(cmd).getAsyncTaskDao();
    doReturn(vdsBrokerFrontend).when(cmd).getVdsBroker();
    when(storagePoolDao.get(any(Guid.class))).thenReturn(new StoragePool());
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    doReturn(backendInternal).when(cmd).getBackend();
    when(vdsDao.getAllForStoragePoolAndStatus(any(Guid.class), any(VDSStatus.class))).thenReturn(Collections.<VDS>emptyList());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(returnValue);
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    map.setStatus(StorageDomainStatus.Active);
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#method_after
@Test
public void statusSetInMap() {
    doReturn(mock(IStorageHelper.class)).when(cmd).getStorageHelper(any(StorageDomain.class));
    doReturn(isoMapDao).when(cmd).getStoragePoolIsoMapDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(asyncTaskDao).when(cmd).getAsyncTaskDao();
    doReturn(vdsBrokerFrontend).when(cmd).getVdsBroker();
    when(storagePoolDao.get(any(Guid.class))).thenReturn(new StoragePool());
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    doReturn(backendInternal).when(cmd).getBackend();
    doReturn(Collections.<VDS>emptyList()).when(cmd).getAllRunningVdssInPool();
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setSucceeded(true);
    when(vdsBrokerFrontend.RunVdsCommand(any(VDSCommandType.class), any(VDSParametersBase.class))).thenReturn(returnValue);
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    map.setStatus(StorageDomainStatus.Active);
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    ArrayList<StorageDomain> returnValue = new ArrayList<>();
    VDSReturnValue vdsReturnValue = vdsBroker.RunVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getParameters().getId(), Guid.Empty, null, getParameters().getStorageDomainType(), getParameters().getPath()));
    if (vdsReturnValue.getSucceeded()) {
        ArrayList<Guid> guidsFromIrs = (ArrayList<Guid>) vdsReturnValue.getReturnValue();
        HashSet<Guid> guidsFromDb = new HashSet<>();
        if (guidsFromIrs.size() > 0) {
            List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAll();
            for (StorageDomain domain : domainsInDb) {
                guidsFromDb.add(domain.getId());
            }
            for (Guid domainId : guidsFromIrs) {
                if (!guidsFromDb.contains(domainId)) {
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) vdsBroker.RunVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getParameters().getId(), domainId)).getReturnValue();
                    StorageDomain domain = new StorageDomain();
                    domain.setStorageStaticData(domainFromIrs.getFirst());
                    domain.setStoragePoolId(domainFromIrs.getSecond());
                    if (getParameters().getStorageFormatType() == null || getParameters().getStorageFormatType() == domain.getStorageFormat()) {
                        if (domain.getStorageType().getValue() != getParameters().getStorageType().getValue()) {
                            log.warn("The storage type of domain {} has been changed from {} to {}", domain.getStorageName(), domain.getStorageType().toString(), getParameters().getStorageType().toString());
                            domain.setStorageType(getParameters().getStorageType());
                        }
                        returnValue.add(domain);
                    }
                }
            }
        }
        getQueryReturnValue().setReturnValue(returnValue);
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    ArrayList<StorageDomain> returnValue = new ArrayList<>();
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.HSMGetStorageDomainsList, new HSMGetStorageDomainsListVDSCommandParameters(getParameters().getId(), Guid.Empty, null, getParameters().getStorageDomainType(), getParameters().getPath()));
    if (vdsReturnValue.getSucceeded()) {
        ArrayList<Guid> guidsFromIrs = (ArrayList<Guid>) vdsReturnValue.getReturnValue();
        HashSet<Guid> guidsFromDb = new HashSet<>();
        if (guidsFromIrs.size() > 0) {
            List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAll();
            for (StorageDomain domain : domainsInDb) {
                guidsFromDb.add(domain.getId());
            }
            for (Guid domainId : guidsFromIrs) {
                if (!guidsFromDb.contains(domainId)) {
                    Pair<StorageDomainStatic, Guid> domainFromIrs = (Pair<StorageDomainStatic, Guid>) runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, new HSMGetStorageDomainInfoVDSCommandParameters(getParameters().getId(), domainId)).getReturnValue();
                    StorageDomain domain = new StorageDomain();
                    domain.setStorageStaticData(domainFromIrs.getFirst());
                    domain.setStoragePoolId(domainFromIrs.getSecond());
                    if (getParameters().getStorageFormatType() == null || getParameters().getStorageFormatType() == domain.getStorageFormat()) {
                        if (getParameters().getStorageType() != null && domain.getStorageType().getValue() != getParameters().getStorageType().getValue()) {
                            log.warn("The storage type of domain {} has been changed from {} to {}", domain.getStorageName(), domain.getStorageType().toString(), getParameters().getStorageType().toString());
                            domain.setStorageType(getParameters().getStorageType());
                        }
                        returnValue.add(domain);
                    }
                }
            }
        }
        getQueryReturnValue().setReturnValue(returnValue);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    String bond = null;
    T params = getParameters();
    String address = params.getAddress();
    String subnet = StringUtils.isEmpty(params.getSubnet()) ? logicalNetwork.getSubnet() : params.getSubnet();
    String gateway = StringUtils.isEmpty(params.getGateway()) ? "" : params.getGateway();
    ArrayList<String> nics = new ArrayList<>();
    nics.add(params.getInterface().getName());
    // check if bond...
    if (params.getInterface().getBonded() != null && params.getInterface().getBonded()) {
        nics.clear();
        bond = params.getInterface().getName();
        List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(params.getVdsId());
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), params.getInterface().getName())) {
                nics.add(i.getName());
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(params.getVdsId(), logicalNetwork, bond, nics.toArray(new String[] {}), address, subnet, gateway, params.getBondingOptions(), params.getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.AddNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = getVdsBroker().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            Guid groupId = getVdsDao().get(params.getVdsId()).getVdsGroupId();
            NetworkClusterHelper.setStatus(groupId, logicalNetwork);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    String bond = null;
    T params = getParameters();
    String address = params.getAddress();
    String subnet = StringUtils.isEmpty(params.getSubnet()) ? logicalNetwork.getSubnet() : params.getSubnet();
    String gateway = StringUtils.isEmpty(params.getGateway()) ? "" : params.getGateway();
    ArrayList<String> nics = new ArrayList<>();
    nics.add(params.getInterface().getName());
    // check if bond...
    if (params.getInterface().getBonded() != null && params.getInterface().getBonded()) {
        nics.clear();
        bond = params.getInterface().getName();
        List<VdsNetworkInterface> interfaces = getDbFacade().getInterfaceDao().getAllInterfacesForVds(params.getVdsId());
        for (VdsNetworkInterface i : interfaces) {
            if (StringUtils.equals(i.getBondName(), params.getInterface().getName())) {
                nics.add(i.getName());
            }
        }
    }
    NetworkVdsmVDSCommandParameters parameters = new NetworkVdsmVDSCommandParameters(params.getVdsId(), logicalNetwork, bond, nics.toArray(new String[] {}), address, subnet, gateway, params.getBondingOptions(), params.getBootProtocol());
    VDSReturnValue retVal = runVdsCommand(VDSCommandType.AddNetwork, parameters);
    if (retVal.getSucceeded()) {
        // update vds network data
        retVal = runVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds()));
        if (retVal.getSucceeded()) {
            Guid groupId = getVdsDao().get(params.getVdsId()).getVdsGroupId();
            NetworkClusterHelper.setStatus(groupId, logicalNetwork);
            setSucceeded(true);
        }
    }
}
#end_block

#method_before
@Before
public void InitTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    SimpleDependecyInjector.getInstance().bind(DbFacade.class, dbFacade);
}
#method_after
@Before
public void InitTest() {
    mockCpuFlagsManagerHandler();
    mockOsRepository();
    SimpleDependencyInjector.getInstance().bind(DbFacade.class, dbFacade);
}
#end_block

#method_before
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVdsGroupDaoReturnVdsGroup();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<GraphicsType, DisplayType>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    assertFalse("If the disk is too big, canDoAction should fail", cmd.canDoAction());
    assertTrue("canDoAction failed for the wrong reason", cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void create10GBVmWith11GbAvailableAndA5GbBuffer() throws Exception {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVdsGroupDaoReturnVdsGroup();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockOsRepository();
    mockOsRepositoryGraphics(0, Version.v3_3, new Pair<>(GraphicsType.SPICE, DisplayType.qxl));
    mockGraphicsDevices(vm.getId());
    mockStorageDomainDaoGetAllStoragesForPool(AVAILABLE_SPACE_GB);
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN);
}
#end_block

#method_before
private void mockGraphicsDevices(Guid vmId) {
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setDeviceId(Guid.Empty);
    graphicsDevice.setVmId(vmId);
    when(deviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.GRAPHICS)).thenReturn(Arrays.asList(graphicsDevice));
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
}
#method_after
private void mockGraphicsDevices(Guid vmId) {
    VmDevice graphicsDevice = new GraphicsDevice(VmDeviceType.SPICE);
    graphicsDevice.setDeviceId(Guid.Empty);
    graphicsDevice.setVmId(vmId);
    when(deviceDao.getVmDeviceByVmIdAndType(vmId, VmDeviceGeneralType.GRAPHICS)).thenReturn(Collections.singletonList(graphicsDevice));
    doReturn(deviceDao).when(dbFacade).getVmDeviceDao();
}
#end_block

#method_before
private void mockOsRepositoryGraphics(int osId, Version ver, Pair<GraphicsType, DisplayType> supportedGraphicsAndDisplay) {
    HashMap<Version, List<Pair<GraphicsType, DisplayType>>> value = new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>();
    value.put(ver, Collections.singletonList(supportedGraphicsAndDisplay));
    HashMap<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> g = new HashMap<>();
    g.put(osId, value);
    when(osRepository.getGraphicsAndDisplays()).thenReturn(g);
}
#method_after
private void mockOsRepositoryGraphics(int osId, Version ver, Pair<GraphicsType, DisplayType> supportedGraphicsAndDisplay) {
    Map<Version, List<Pair<GraphicsType, DisplayType>>> value = new HashMap<>();
    value.put(ver, Collections.singletonList(supportedGraphicsAndDisplay));
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> g = new HashMap<>();
    g.put(osId, value);
    when(osRepository.getGraphicsAndDisplays()).thenReturn(g);
}
#end_block

#method_before
protected void mockOsRepository() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#method_after
protected void mockOsRepository() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    VmHandler.init();
    when(osRepository.isWindows(0)).thenReturn(true);
    when(osRepository.isCpuSupported(anyInt(), any(Version.class), anyString())).thenReturn(true);
}
#end_block

#method_before
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    cmd.postConstruct();
    doReturn(true).when(cmd).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
}
#method_after
@Test
public void canAddVm() {
    ArrayList<String> reasons = new ArrayList<>();
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    cmd.postConstruct();
    doReturn(true).when(cmd).validateCustomProperties(any(VmStatic.class), anyList());
    doReturn(true).when(cmd).validateSpaceRequirements();
    assertTrue("vm could not be added", cmd.canAddVm(reasons, Collections.singletonList(createStorageDomain(domainSizeGB))));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST);
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION);
}
#end_block

#method_before
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    VDSGroup vdsGroup = createVdsGroup();
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs(), vdsGroup.getCompatibilityVersion());
    mockGraphicsDevices(vm.getId());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(any(Integer.class), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#method_after
@Test
public void canAddVmWithVirtioScsiControllerNotSupportedOs() {
    VM vm = createVm();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    vdsGroup = createVdsGroup();
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockUninterestingMethods(cmd);
    mockDisplayTypes(vm.getOs());
    mockGraphicsDevices(vm.getId());
    doReturn(true).when(cmd).checkCpuSockets();
    doReturn(vdsGroup).when(cmd).getVdsGroup();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    cmd.getParameters().setVirtioScsiEnabled(true);
    when(osRepository.isSoundDeviceEnabled(any(Integer.class), any(Version.class))).thenReturn(true);
    when(osRepository.getArchitectureFromOS(any(Integer.class))).thenReturn(ArchitectureType.x86_64);
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO")));
    mockGetAllSnapshots(cmd);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_OS_TYPE_DOES_NOT_SUPPORT_VIRTIO_SCSI);
}
#end_block

#method_before
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(0, 0);
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Arrays.asList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#method_after
@Test
public void isVirtioScsiEnabledDefaultedToTrue() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(0);
    doReturn(createVdsGroup()).when(cmd).getVdsGroup();
    when(osRepository.getDiskInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<>(Collections.singletonList("VirtIO_SCSI")));
    assertTrue("isVirtioScsiEnabled hasn't been defaulted to true on cluster >= 3.3.", cmd.isVirtioScsiEnabled());
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0, 0);
    doReturn((new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN))).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#method_after
@Test
public void validateSpaceNotWithinThreshold() throws Exception {
    AddVmCommand<AddVmParameters> command = setupCanAddVmTests(0);
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_STORAGE_DOMAIN)).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
}
#end_block

#method_before
@Test
public void testUnsupportedCpus() {
    // prepare a command to pass canDo action
    VM vm = createVm();
    vm.setVmOs(OsRepository.DEFAULT_X86_OS);
    VDSGroup vdsGroup = createVdsGroup();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockDisplayTypes(vm.getOs(), vdsGroup.getCompatibilityVersion());
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    // prepare the mock values
    HashMap<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    HashSet<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(vm.getVmOsId(), vdsGroup.getCompatibilityVersion()), value);
    when(osRepository.isCpuSupported(vm.getVmOsId(), vdsGroup.getCompatibilityVersion(), CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#method_after
@Test
public void testUnsupportedCpus() {
    // prepare a command to pass canDo action
    VM vm = createVm();
    vm.setVmOs(OsRepository.DEFAULT_X86_OS);
    vdsGroup = createVdsGroup();
    AddVmFromTemplateCommand<AddVmParameters> cmd = createVmFromTemplateCommand(vm);
    mockStorageDomainDaoGetForStoragePool();
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockVerifyAddVM(cmd);
    mockConfig();
    mockMaxPciSlots();
    mockStorageDomainDaoGetAllStoragesForPool(20);
    mockDisplayTypes(vm.getOs());
    mockUninterestingMethods(cmd);
    mockGetAllSnapshots(cmd);
    when(osRepository.getArchitectureFromOS(0)).thenReturn(ArchitectureType.x86_64);
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    // prepare the mock values
    Map<Pair<Integer, Version>, Set<String>> unsupported = new HashMap<>();
    Set<String> value = new HashSet<>();
    value.add(CPU_ID);
    unsupported.put(new Pair<>(vm.getVmOsId(), vdsGroup.getCompatibilityVersion()), value);
    when(osRepository.isCpuSupported(vm.getVmOsId(), vdsGroup.getCompatibilityVersion(), CPU_ID)).thenReturn(false);
    when(osRepository.getUnsupportedCpus()).thenReturn(unsupported);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.CPU_TYPE_UNSUPPORTED_FOR_THE_GUEST_OS);
}
#end_block

#method_before
private void mockDisplayTypes(int osId, Version clusterVersion) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Arrays.asList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#method_after
private void mockDisplayTypes(int osId) {
    Map<Integer, Map<Version, List<Pair<GraphicsType, DisplayType>>>> displayTypeMap = new HashMap<>();
    displayTypeMap.put(osId, new HashMap<Version, List<Pair<GraphicsType, DisplayType>>>());
    displayTypeMap.get(osId).put(null, Collections.singletonList(new Pair<>(GraphicsType.SPICE, DisplayType.qxl)));
    when(osRepository.getGraphicsAndDisplays()).thenReturn(displayTypeMap);
}
#end_block

#method_before
private void mockMaxPciSlots() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    doReturn(MAX_PCI_SLOTS).when(osRepository).getMaxPciDevices(anyInt(), any(Version.class));
}
#method_after
private void mockMaxPciSlots() {
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    doReturn(MAX_PCI_SLOTS).when(osRepository).getMaxPciDevices(anyInt(), any(Version.class));
}
#end_block

#method_before
protected AddVmFromTemplateCommand<AddVmParameters> createVmFromTemplateCommand(VM vm) {
    AddVmParameters param = new AddVmParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmParameters> concrete = new AddVmFromTemplateCommand<AddVmParameters>(param) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(true).when(result).validateCustomProperties(any(VmStatic.class), any(ArrayList.class));
    mockDaos(result);
    mockBackend(result);
    initCommandMethods(result);
    result.postConstruct();
    return result;
}
#method_after
protected AddVmFromTemplateCommand<AddVmParameters> createVmFromTemplateCommand(VM vm) {
    AddVmParameters param = new AddVmParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmParameters> concrete = new AddVmFromTemplateCommand<AddVmParameters>(param) {

        @Override
        protected void initUser() {
        // Stub for testing
        }

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(true).when(result).validateCustomProperties(any(VmStatic.class), anyList());
    mockDaos(result);
    mockBackend(result);
    initCommandMethods(result);
    result.postConstruct();
    return result;
}
#end_block

#method_before
protected AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> setupCanAddVmFromSnapshotTests(final int domainSizeGB, final int sizeRequired, Guid sourceSnapshotId) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    initializeVmDaoMock(vm);
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = createVmFromSnapshotCommand(vm, sourceSnapshotId);
    initCommandMethods(cmd);
    return cmd;
}
#method_after
protected AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> setupCanAddVmFromSnapshotTests(final int domainSizeGB, Guid sourceSnapshotId) {
    VM vm = initializeMock(domainSizeGB);
    initializeVmDaoMock(vm);
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = createVmFromSnapshotCommand(vm, sourceSnapshotId);
    initCommandMethods(cmd);
    return cmd;
}
#end_block

#method_before
private void initializeVmDaoMock(VM vm) {
    when(vmDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(vm);
}
#method_after
private void initializeVmDaoMock(VM vm) {
    when(vmDao.get(any(Guid.class))).thenReturn(vm);
}
#end_block

#method_before
private AddVmCommand<AddVmParameters> setupCanAddVmTests(final int domainSizeGB, final int sizeRequired) {
    VM vm = initializeMock(domainSizeGB, sizeRequired);
    AddVmCommand<AddVmParameters> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> setupCanAddVmTests(final int domainSizeGB) {
    VM vm = initializeMock(domainSizeGB);
    AddVmCommand<AddVmParameters> cmd = createCommand(vm);
    initCommandMethods(cmd);
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    doReturn(createStoragePool()).when(cmd).getStoragePool();
    return cmd;
}
#end_block

#method_before
private VM initializeMock(final int domainSizeGB, final int sizeRequired) {
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockStorageDomainDaoGetForStoragePool(domainSizeGB);
    mockStorageDomainDaoGet(domainSizeGB);
    mockConfig();
    VM vm = createVm();
    return vm;
}
#method_after
private VM initializeMock(final int domainSizeGB) {
    mockVmTemplateDaoReturnVmTemplate();
    mockDiskImageDaoGetSnapshotById();
    mockStorageDomainDaoGetForStoragePool(domainSizeGB);
    mockStorageDomainDaoGet(domainSizeGB);
    mockConfig();
    return createVm();
}
#end_block

#method_before
private void mockStorageDomainDaoGetForStoragePool(int domainSpaceGB) {
    when(sdDao.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDaoGetForStoragePool(int domainSpaceGB) {
    when(sdDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private void mockStorageDomainDaoGetAllStoragesForPool(int domainSpaceGB) {
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Arrays.asList(createStorageDomain(domainSpaceGB)));
}
#method_after
private void mockStorageDomainDaoGetAllStoragesForPool(int domainSpaceGB) {
    when(sdDao.getAllForStoragePool(any(Guid.class))).thenReturn(Collections.singletonList(createStorageDomain(domainSpaceGB)));
}
#end_block

#method_before
private void mockVmTemplateDaoReturnVmTemplate() {
    when(vmTemplateDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(createVmTemplate());
}
#method_after
private void mockVmTemplateDaoReturnVmTemplate() {
    when(vmTemplateDao.get(any(Guid.class))).thenReturn(createVmTemplate());
}
#end_block

#method_before
private void mockVdsGroupDaoReturnVdsGroup() {
    when(vdsGroupDao.get(Matchers.<Guid>any(Guid.class))).thenReturn(createVdsGroup());
}
#method_after
private void mockVdsGroupDaoReturnVdsGroup() {
    when(vdsGroupDao.get(any(Guid.class))).thenReturn(createVdsGroup());
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID_1)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<>(Collections.singletonList(STORAGE_DOMAIN_ID_1)));
    return i;
}
#end_block

#method_before
private void mockDiskImageDaoGetSnapshotById() {
    when(diskImageDao.getSnapshotById(Matchers.<Guid>any(Guid.class))).thenReturn(createDiskImage(REQUIRED_DISK_SIZE_GB));
}
#method_after
private void mockDiskImageDaoGetSnapshotById() {
    when(diskImageDao.getSnapshotById(any(Guid.class))).thenReturn(createDiskImage(REQUIRED_DISK_SIZE_GB));
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage diskImage = new DiskImage();
    diskImage.setSizeInGigabytes(size);
    diskImage.setActualSize(size);
    diskImage.setId(Guid.newGuid());
    diskImage.setImageId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID_1)));
    return diskImage;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage diskImage = new DiskImage();
    diskImage.setSizeInGigabytes(size);
    diskImage.setActualSize(size);
    diskImage.setId(Guid.newGuid());
    diskImage.setImageId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<>(Collections.singletonList(STORAGE_DOMAIN_ID_1)));
    return diskImage;
}
#end_block

#method_before
protected void generateStorageToDisksMap(AddVmCommand<? extends AddVmParameters> command) {
    command.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#method_after
protected void generateStorageToDisksMap(AddVmCommand<? extends AddVmParameters> command) {
    command.storageToDisksMap = new HashMap<>();
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_1, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_1));
    command.storageToDisksMap.put(STORAGE_DOMAIN_ID_2, generateDisksList(NUM_DISKS_STORAGE_DOMAIN_2));
}
#end_block

#method_before
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#method_after
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            return createDiskSnapshot(arg.getId(), 3);
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#end_block

#method_before
private <T extends AddVmParameters> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString(), any(Guid.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(true).when(osRepository).isSoundDeviceEnabled(any(Integer.class), any(Version.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#method_after
private <T extends AddVmParameters> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString(), any(Guid.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    doReturn(true).when(osRepository).isSoundDeviceEnabled(any(Integer.class), any(Version.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void testBeanValidations() {
    assertTrue(createCommand(initializeMock(1, 1)).validateInputs());
}
#method_after
@Test
public void testBeanValidations() {
    assertTrue(createCommand(initializeMock(1)).validateInputs());
}
#end_block

#method_before
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<AddVmParameters> cmd = createCommand(initializeMock(1, 1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#method_after
@Test
public void testPatternBasedNameFails() {
    AddVmCommand<AddVmParameters> cmd = createCommand(initializeMock(1));
    cmd.getParameters().getVm().setName("aa-??bb");
    assertFalse("Pattern-based name should not be supported for VM", cmd.validateInputs());
}
#end_block

#method_before
@Test
public void refuseBalloonOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setBalloonEnabled(true);
    when(osRepository.isBalloonEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#method_after
@Test
public void refuseBalloonOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setBalloonEnabled(true);
    when(osRepository.isBalloonEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
}
#end_block

#method_before
@Test
public void refuseSoundDeviceOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setSoundDeviceEnabled(true);
    when(osRepository.isSoundDeviceEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH.toString()));
}
#method_after
@Test
public void refuseSoundDeviceOnPPC() {
    AddVmCommand<AddVmParameters> cmd = setupCanAddPpcTest();
    cmd.getParameters().setSoundDeviceEnabled(true);
    when(osRepository.isSoundDeviceEnabled(cmd.getParameters().getVm().getVmOsId(), cmd.getVdsGroup().getCompatibilityVersion())).thenReturn(false);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
}
#end_block

#method_before
private AddVmCommand<AddVmParameters> setupCanAddPpcTest() {
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(true).when(cmd).validateSpaceRequirements();
    doReturn(true).when(cmd).buildAndCheckDestStorageDomains();
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(cmd).getVdsGroup();
    return cmd;
}
#method_after
private AddVmCommand<AddVmParameters> setupCanAddPpcTest() {
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    doReturn(true).when(cmd).validateSpaceRequirements();
    doReturn(true).when(cmd).buildAndCheckDestStorageDomains();
    cmd.getParameters().getVm().setClusterArch(ArchitectureType.ppc64);
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.ppc64);
    cluster.setCompatibilityVersion(Version.getLast());
    doReturn(cluster).when(cmd).getVdsGroup();
    return cmd;
}
#end_block

#method_before
@Test
public void testStoragePoolDoesntExist() {
    final int domainSizeGB = 20;
    final int sizeRequired = 5;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(null).when(cmd).getStoragePool();
    assertFalse(cmd.canDoAction());
    assertTrue(cmd.getReturnValue().getCanDoActionMessages().contains(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST.toString()));
}
#method_after
@Test
public void testStoragePoolDoesntExist() {
    final int domainSizeGB = 20;
    AddVmCommand<AddVmParameters> cmd = setupCanAddVmTests(domainSizeGB);
    doReturn(null).when(cmd).getStoragePool();
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
}
#end_block

#method_before
private Object getVmsFromExternalProvider() {
    try {
        return vdsBroker.RunVdsCommand(VDSCommandType.GetVmsFromExternalProvider, buildGetRemoteVmsInfoParameters()).getReturnValue();
    } catch (RuntimeException e) {
        if (!(e instanceof IllegalArgumentException)) {
            logFailureToGetVms();
        }
        throw e;
    }
}
#method_after
private Object getVmsFromExternalProvider() {
    try {
        return runVdsCommand(VDSCommandType.GetVmsFromExternalProvider, buildGetRemoteVmsInfoParameters()).getReturnValue();
    } catch (RuntimeException e) {
        if (!(e instanceof IllegalArgumentException)) {
            logFailureToGetVms();
        }
        throw e;
    }
}
#end_block

#method_before
private VDSReturnValue executeVerb(StorageDomainStatic storage) {
    try {
        return vdsBroker.RunVdsCommand(VDSCommandType.GetVmsInfo, buildGetVmsInfoParameters(storage));
    } catch (RuntimeException e) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("StorageDomainName", storage.getStorageName());
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
        throw e;
    }
}
#method_after
private VDSReturnValue executeVerb(StorageDomainStatic storage) {
    try {
        return runVdsCommand(VDSCommandType.GetVmsInfo, buildGetVmsInfoParameters(storage));
    } catch (RuntimeException e) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("StorageDomainName", storage.getStorageName());
        auditLogDirector.log(logable, AuditLogType.IMPORTEXPORT_GET_VMS_INFO_FAILED);
        throw e;
    }
}
#end_block

#method_before
protected List<LUNs> filterLUNsByTargets(List<LUNs> luns, final List<StorageServerConnections> targets) {
    // Targets should be null only when using StorageType.FCP
    if (targets == null) {
        return luns;
    }
    // For iSCSI domains, filter LUNs by the specified targets
    final Set<String> targetIQNs = Entities.connectionsByIQN(targets).keySet();
    return LinqUtils.filter(luns, new Predicate<LUNs>() {

        @Override
        public boolean eval(LUNs lun) {
            for (StorageServerConnections connection : lun.getLunConnections()) {
                if (CollectionUtils.exists(targetIQNs, new EqualPredicate(connection.getiqn()))) {
                    return true;
                }
            }
            return false;
        }
    });
}
#method_after
protected List<LUNs> filterLUNsByTargets(List<LUNs> luns, final List<StorageServerConnections> targets) {
    // Targets should be null only when using StorageType.FCP
    if (targets == null) {
        return luns;
    }
    // For iSCSI domains, filter LUNs by the specified targets
    final Set<String> targetIQNs = Entities.connectionsByIQN(targets).keySet();
    return luns.stream().filter(lun -> lun.getLunConnections().stream().anyMatch(c -> targetIQNs.contains(c.getiqn()))).collect(Collectors.toList());
}
#end_block

#method_before
protected List<LUNs> filterLUNsThatBelongToExistingStorageDomains(List<LUNs> luns) {
    List<StorageDomain> existingStorageDomains = getStorageDomainDao().getAll();
    final List<Guid> existingStorageDomainIDs = Entities.getIds(existingStorageDomains);
    return LinqUtils.filter(luns, new Predicate<LUNs>() {

        @Override
        public boolean eval(LUNs lun) {
            return !existingStorageDomainIDs.contains(lun.getStorageDomainId());
        }
    });
}
#method_after
protected List<LUNs> filterLUNsThatBelongToExistingStorageDomains(List<LUNs> luns) {
    List<StorageDomain> existingStorageDomains = getStorageDomainDao().getAll();
    final List<Guid> existingStorageDomainIDs = Entities.getIds(existingStorageDomains);
    return luns.stream().filter(lun -> !existingStorageDomainIDs.contains(lun.getStorageDomainId())).collect(Collectors.toList());
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingLunIds = Entities.getIds(getLunDao().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue = null;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> lunIdsOnStorage = Entities.getIds(luns);
        if (CollectionUtils.containsAny(lunIdsOnStorage, existingLunIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#method_after
@SuppressWarnings("unchecked")
protected List<StorageDomain> getStorageDomainsByVolumeGroupIds(List<String> vgIDs) {
    List<StorageDomain> storageDomains = new ArrayList<>();
    // Get existing PhysicalVolumes.
    List<String> existingLunIds = Entities.getIds(getLunDao().getAll());
    for (String vgID : vgIDs) {
        VDSReturnValue returnValue;
        try {
            returnValue = executeGetVGInfo(new GetVGInfoVDSCommandParameters(getParameters().getVdsId(), vgID));
        } catch (RuntimeException e) {
            log.error("Could not get info for VG ID: '{}': {}", vgID, e.getMessage());
            log.debug("Exception", e);
            continue;
        }
        ArrayList<LUNs> luns = (ArrayList<LUNs>) returnValue.getReturnValue();
        List<String> lunIdsOnStorage = Entities.getIds(luns);
        if (CollectionUtils.containsAny(lunIdsOnStorage, existingLunIds)) {
            log.info("There are existing luns in the system which are part of VG id '{}'", vgID);
            continue;
        }
        // Get storage domain ID by a representative LUN
        LUNs lun = luns.get(0);
        Guid storageDomainId = lun.getStorageDomainId();
        // Get storage domain using GetStorageDomainInfo
        StorageDomain storageDomain = getStorageDomainById(storageDomainId);
        if (storageDomain != null) {
            storageDomains.add(storageDomain);
        }
    }
    return storageDomains;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected StorageDomain getStorageDomainById(Guid storageDomainId) {
    VDSReturnValue returnValue = null;
    try {
        returnValue = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getParameters().getVdsId(), storageDomainId));
    } catch (RuntimeException e) {
        log.error("Could not get info for storage domain ID: '{}': {}", storageDomainId, e.getMessage());
        log.debug("Exception", e);
        return null;
    }
    Pair<StorageDomainStatic, SANState> result = (Pair<StorageDomainStatic, SANState>) returnValue.getReturnValue();
    StorageDomainStatic storageDomainStatic = result.getFirst();
    storageDomainStatic.setStorageType(getParameters().getStorageType());
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setStorageStaticData(storageDomainStatic);
    return storageDomain;
}
#method_after
@SuppressWarnings("unchecked")
protected StorageDomain getStorageDomainById(Guid storageDomainId) {
    VDSReturnValue returnValue;
    try {
        returnValue = executeHSMGetStorageDomainInfo(new HSMGetStorageDomainInfoVDSCommandParameters(getParameters().getVdsId(), storageDomainId));
    } catch (RuntimeException e) {
        log.error("Could not get info for storage domain ID: '{}': {}", storageDomainId, e.getMessage());
        log.debug("Exception", e);
        return null;
    }
    Pair<StorageDomainStatic, SANState> result = (Pair<StorageDomainStatic, SANState>) returnValue.getReturnValue();
    StorageDomainStatic storageDomainStatic = result.getFirst();
    storageDomainStatic.setStorageType(getParameters().getStorageType());
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setStorageStaticData(storageDomainStatic);
    return storageDomain;
}
#end_block

#method_before
protected VDSReturnValue executeGetVGInfo(GetVGInfoVDSCommandParameters parameters) {
    return getVdsBroker().RunVdsCommand(VDSCommandType.GetVGInfo, parameters);
}
#method_after
protected VDSReturnValue executeGetVGInfo(GetVGInfoVDSCommandParameters parameters) {
    return runVdsCommand(VDSCommandType.GetVGInfo, parameters);
}
#end_block

#method_before
protected VDSReturnValue executeHSMGetStorageDomainInfo(HSMGetStorageDomainInfoVDSCommandParameters parameters) {
    return getVdsBroker().RunVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, parameters);
}
#method_after
protected VDSReturnValue executeHSMGetStorageDomainInfo(HSMGetStorageDomainInfoVDSCommandParameters parameters) {
    return runVdsCommand(VDSCommandType.HSMGetStorageDomainInfo, parameters);
}
#end_block

#method_before
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = getResourceManager().RunVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#method_after
@Override
@SuppressWarnings("unchecked")
protected void executeQueryCommand() {
    Map<String, String> glusterServers = new HashMap<>();
    VDS upServer = getClusterUtils().getUpServer(getParameters().getClusterId());
    if (upServer != null) {
        VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GlusterServersList, new VdsIdVDSCommandParametersBase(upServer.getId()));
        glusterServers = getAddedGlusterServers((List<GlusterServerInfo>) returnValue.getReturnValue());
    }
    getQueryReturnValue().setReturnValue(glusterServers);
}
#end_block

#method_before
@Before
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#method_after
@Before
public void createCommand() {
    mockCpuFlagsManagerHandler();
    when(osRepository.isWindows(Mockito.anyInt())).thenReturn(false);
    when(osRepository.isCpuSupported(Mockito.anyInt(), Mockito.any(Version.class), Mockito.anyString())).thenReturn(true);
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    updateVmHandler();
    RunVmParams param = new RunVmParams(Guid.newGuid());
    command = spy(new RunVmCommand<RunVmParams>(param) {

        @Override
        protected void loadPayloadDevice() {
        }
    });
    mockIsoDomainListSyncronizer();
    mockSuccessfulRunVmValidator();
    doNothing().when(command).initParametersForExternalNetworks();
    doNothing().when(command).initParametersForPassthroughVnics();
    mockSuccessfulSnapshotValidator();
    mockBackend();
}
#end_block

#method_before
private String createVG() {
    VDSReturnValue returnValue = getVdsBroker().RunVdsCommand(VDSCommandType.CreateVG, new CreateVGVDSCommandParameters(getVds().getId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce()));
    String volumeGroupId = (String) ((returnValue.getReturnValue() instanceof String) ? returnValue.getReturnValue() : null);
    return volumeGroupId;
}
#method_after
private String createVG() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateVG, new CreateVGVDSCommandParameters(getVds().getId(), getStorageDomain().getId(), getParameters().getLunIds(), getParameters().isForce()));
    String volumeGroupId = (String) ((returnValue.getReturnValue() instanceof String) ? returnValue.getReturnValue() : null);
    return volumeGroupId;
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(vdsBroker.RunVdsCommand(VDSCommandType.DiscoverSendTargets, new DiscoverSendTargetsVDSCommandParameters(getParameters().getVdsId(), getParameters().getConnection())).getReturnValue());
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(runVdsCommand(VDSCommandType.DiscoverSendTargets, new DiscoverSendTargetsVDSCommandParameters(getParameters().getVdsId(), getParameters().getConnection())).getReturnValue());
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = vdsBroker.RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = vdsBroker.RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    StorageDomain storageDomain = getDbFacade().getStorageDomainDao().get(storageDomainId);
    if (storageDomain == null) {
        getQueryReturnValue().setExceptionString(EngineMessage.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    if (storageDomain.getStorageType().isCinderDomain()) {
        VdcQueryReturnValue returnValue = runInternalQuery(VdcQueryType.GetUnregisteredCinderDiskByIdAndStorageDomainId, new GetCinderEntityByStorageDomainIdParameters(diskId, getParameters().getStorageDomainId()));
        setReturnValue(returnValue.getReturnValue());
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = runVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = runVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    if (StringUtils.isNotEmpty(newDiskImage.getDescription())) {
        try {
            MetadataDiskDescriptionHandler.getInstance().enrichDiskByJsonDescription(newDiskImage.getDescription(), newDiskImage);
        } catch (IOException | DecoderException e) {
            log.warn("Exception while parsing JSON for disk. Exception: '{}'", e);
        }
    }
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            LockManagerFactory.getLockManager().acquireLockWait(lock);
            clearDomainCache(vds);
            StoragePool storage_pool = DbFacade.getInstance().getStoragePoolDao().get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                vdsBroker.RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                backend.runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(lock);
        }
    }
}
#method_after
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            LockManagerFactory.getLockManager().acquireLockWait(lock);
            clearDomainCache(vds);
            stopGlusterServices(vds);
            StoragePool storage_pool = storagePoolDao.get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                vdsBroker.RunVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                backend.runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(lock);
        }
    }
}
#end_block

#method_before
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(vds, false);
    return backend.runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#method_after
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    StoragePool sp = storagePoolDao.get(vds.getStoragePoolId());
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(sp, vds, false);
    return backend.runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#end_block

#method_before
private Object getVmInfoFromOvaFile() {
    return vdsBroker.RunVdsCommand(VDSCommandType.GetOvaInfo, buildGetOvaInfoParameters()).getReturnValue();
}
#method_after
private Object getVmInfoFromOvaFile() {
    return runVdsCommand(VDSCommandType.GetOvaInfo, buildGetOvaInfoParameters()).getReturnValue();
}
#end_block

#method_before
private static TemplateWithVersion computeTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, Guid previousTemplateId, boolean useLatest) {
    if (previousTemplateId == null) {
        return computeNewTemplateWithVersionToSelect(newItems);
    }
    TemplateWithVersion oldTemplateToSelect = Linq.firstOrDefault(newItems, new Linq.TemplateWithVersionPredicate(previousTemplateId, useLatest));
    return oldTemplateToSelect != null ? oldTemplateToSelect : computeNewTemplateWithVersionToSelect(newItems);
}
#method_after
private static TemplateWithVersion computeTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, Guid previousTemplateId, boolean useLatest) {
    if (previousTemplateId == null) {
        return computeNewTemplateWithVersionToSelect(newItems);
    }
    TemplateWithVersion oldTemplateToSelect = Linq.firstOrNull(newItems, new Linq.TemplateWithVersionPredicate(previousTemplateId, useLatest));
    return oldTemplateToSelect != null ? oldTemplateToSelect : computeNewTemplateWithVersionToSelect(newItems);
}
#end_block

#method_before
protected void setImagesToModel(UnitVmModel model, List<String> images) {
    String oldCdImage = model.getCdImage().getSelectedItem();
    model.getCdImage().setItems(images);
    model.getCdImage().setSelectedItem((oldCdImage != null) ? oldCdImage : Linq.firstOrDefault(images));
}
#method_after
protected void setImagesToModel(UnitVmModel model, List<String> images) {
    String oldCdImage = model.getCdImage().getSelectedItem();
    model.getCdImage().setItems(images);
    model.getCdImage().setSelectedItem((oldCdImage != null) ? oldCdImage : Linq.firstOrNull(images));
}
#end_block

#method_before
private void doUpdateTimeZone(final String selectedTimeZone) {
    final Collection<TimeZoneModel> timeZones = TimeZoneModel.getTimeZones(getTimeZoneType());
    getModel().getTimeZone().setItems(timeZones);
    getModel().getTimeZone().setSelectedItem(Linq.firstOrDefault(timeZones, new Linq.TimeZonePredicate(selectedTimeZone)));
}
#method_after
private void doUpdateTimeZone(final String selectedTimeZone) {
    final Collection<TimeZoneModel> timeZones = TimeZoneModel.getTimeZones(getTimeZoneType());
    getModel().getTimeZone().setItems(timeZones);
    getModel().getTimeZone().setSelectedItem(Linq.firstOrNull(timeZones, new Linq.TimeZonePredicate(selectedTimeZone)));
}
#end_block

#method_before
public ArrayList<StorageDomain> filterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrDefault(list, new Linq.StoragePredicate(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#method_after
public ArrayList<StorageDomain> filterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrNull(list, new Linq.IdPredicate<>(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#end_block

#method_before
protected void initVNumaNodes() {
    unassignedVNodeModelList = new ArrayList<VNodeModel>();
    p2vNumaNodesMap = new HashMap<Integer, List<VNodeModel>>();
    final Set<Integer> hostIndizes = new HashSet<>();
    for (VdsNumaNode numaNode : numaNodeList) {
        hostIndizes.add(numaNode.getIndex());
    }
    for (final VM vm : getVmsWithvNumaNodeList()) {
        if (vm.getvNumaNodeList() != null) {
            for (VmNumaNode vmNumaNode : vm.getvNumaNodeList()) {
                VNodeModel vNodeModel = new VNodeModel(this, vm, vmNumaNode, false);
                if (vmNumaNode.getVdsNumaNodeList() != null && !vmNumaNode.getVdsNumaNodeList().isEmpty()) {
                    for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
                        Integer hostIndex = pair.getSecond().getSecond();
                        if (pair.getSecond().getFirst()) {
                            if (!hostIndizes.contains(hostIndex)) {
                                vNodeModel.setPinned(false);
                                // Stop when mapping errors are detected
                                break;
                            } else {
                                vNodeModel.setPinned(true);
                                assignVNumaToPhysicalNuma(vNodeModel, hostIndex);
                                break;
                            }
                        }
                    }
                }
                if (!vNodeModel.isPinned()) {
                    unassignedVNodeModelList.add(vNodeModel);
                    if (vmNumaNode.getVdsNumaNodeList() != null) {
                        // Reset VdsNumaNodeList since the model says that the node should not be pinned
                        vmNumaNode.getVdsNumaNodeList().clear();
                    }
                }
            }
        }
    }
}
#method_after
protected void initVNumaNodes() {
    unassignedVNodeModelList = new ArrayList<VNodeModel>();
    p2vNumaNodesMap = new HashMap<Integer, List<VNodeModel>>();
    final Set<Integer> hostIndices = new HashSet<>();
    for (VdsNumaNode numaNode : numaNodeList) {
        hostIndices.add(numaNode.getIndex());
    }
    for (final VM vm : getVmsWithvNumaNodeList()) {
        if (vm.getvNumaNodeList() != null) {
            for (VmNumaNode vmNumaNode : vm.getvNumaNodeList()) {
                VNodeModel vNodeModel = new VNodeModel(this, vm, vmNumaNode, false);
                if (vmNumaNode.getVdsNumaNodeList() != null && !vmNumaNode.getVdsNumaNodeList().isEmpty()) {
                    for (Pair<Guid, Pair<Boolean, Integer>> pair : vmNumaNode.getVdsNumaNodeList()) {
                        Integer hostIndex = pair.getSecond().getSecond();
                        boolean pinned = pair.getSecond().getFirst();
                        if (pinned) {
                            if (!hostIndices.contains(hostIndex)) {
                                vNodeModel.setPinned(false);
                            } else {
                                vNodeModel.setPinned(true);
                                assignVNumaToPhysicalNuma(vNodeModel, hostIndex);
                            }
                            // Stop on mapping error and on valid pinning
                            break;
                        }
                    }
                }
                if (!vNodeModel.isPinned()) {
                    unassignedVNodeModelList.add(vNodeModel);
                    if (vmNumaNode.getVdsNumaNodeList() != null) {
                        // Reset vdsNumaNodeList since the model says that the node should not be pinned
                        vmNumaNode.getVdsNumaNodeList().clear();
                    }
                }
            }
        }
    }
}
#end_block

#method_before
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate, TSource defaultValue) {
    for (TSource item : source) {
        if (predicate.match(item)) {
            return item;
        }
    }
    return defaultValue;
}
#method_after
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate, TSource defaultValue) {
    if (source != null) {
        for (TSource item : source) {
            if (predicate.match(item)) {
                return item;
            }
        }
    }
    return defaultValue;
}
#end_block

#method_before
@Override
public boolean match(BusinessEntity<Guid> entity) {
    return entity != null && Objects.equals(entity.getId(), id);
}
#method_after
public boolean match(BusinessEntity<T> entity) {
    return entity != null && Objects.equals(entity.getId(), id);
}
#end_block

#method_before
@Override
public boolean match(BusinessEntity<Guid> entity) {
    return ids.contains(entity.getId());
}
#method_after
@Override
public boolean match(BusinessEntity<T> entity) {
    return ids.contains(entity.getId());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateQuotaCache();
    copyUnchangedStoragePoolProperties(getStoragePool(), oldStoragePool);
    getStoragePoolDao().updatePartial(getStoragePool());
    updateStoragePoolFormatType();
    moveMacsFromOldMacPoolToNewOne();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid oldMacPoolId = getOldMacPoolId();
    Guid newMacPoolId = getNewMacPoolId();
    // this should not happen, just make sure this invariant is fulfilled.
    Objects.requireNonNull(oldMacPoolId);
    // this should not happen, just make sure this invariant is fulfilled.
    Objects.requireNonNull(newMacPoolId);
    boolean needToMigrateMacs = !oldMacPoolId.equals(newMacPoolId);
    updateQuotaCache();
    copyUnchangedStoragePoolProperties(getStoragePool(), oldStoragePool);
    List<String> vmInterfaceMacs = null;
    if (needToMigrateMacs) {
        vmInterfaceMacs = vmNicDao.getAllMacsByDataCenter(getParameters().getStoragePoolId());
    }
    getStoragePoolDao().updatePartial(getStoragePool());
    if (needToMigrateMacs) {
        moveMacsOfUpdatedDataCenter(oldMacPoolId, newMacPoolId, vmInterfaceMacs);
    }
    updateStoragePoolFormatType();
    setSucceeded(true);
}
#end_block

#method_before
/**
 * All MACs of given DC are found, and all of them are {@link MacPoolManagerStrategy#freeMac(String) freed}
 * from source {@link MacPoolManagerStrategy macPool} and are
 * {@link MacPoolManagerStrategy#forceAddMac(String) added}
 * to target {@link MacPoolManagerStrategy macPool}. Because source macPool may contain duplicates and/or allow
 * duplicates, {@link MacPoolManagerStrategy#forceAddMac(String)} is used to add them override
 * <em>allowDuplicates</em> setting of target macPool.
 * @param oldMacPoolId id of macPool before update
 * @param newMacPoolId macPool Id of updated data center.
 */
private void moveMacsOfUpdatedDataCenter(Guid oldMacPoolId, Guid newMacPoolId) {
    Guid dataCenterId = getParameters().getStoragePoolId();
    MacPoolPerDc poolPerDc = MacPoolPerDcSingleton.getInstance();
    MacPoolManagerStrategy sourcePool = poolPerDc.getPoolById(oldMacPoolId);
    MacPoolManagerStrategy targetPool = poolPerDc.getPoolById(newMacPoolId);
    List<String> vmInterfaceMacs = vmNicDao.getAllMacsByDataCenter(dataCenterId);
    for (String mac : vmInterfaceMacs) {
        sourcePool.freeMac(mac);
        targetPool.forceAddMac(mac);
    }
}
#method_after
private void moveMacsOfUpdatedDataCenter(Guid oldMacPoolId, Guid newMacPoolId, List<String> vmInterfaceMacs) {
    Objects.requireNonNull(vmInterfaceMacs);
    MacPoolPerDc poolPerDc = MacPoolPerDcSingleton.getInstance();
    MacPoolManagerStrategy sourcePool = poolPerDc.getPoolById(oldMacPoolId);
    MacPoolManagerStrategy targetPool = poolPerDc.getPoolById(newMacPoolId);
    for (String mac : vmInterfaceMacs) {
        sourcePool.freeMac(mac);
        targetPool.forceAddMac(mac);
    }
}
#end_block

#method_before
private Guid getNewMacPoolId() {
    // I can get null-valued storagePool elsewhere than in getPermissionSubjects.
    return getParameters().getStoragePool().getMacPoolId();
}
#method_after
private Guid getNewMacPoolId() {
    return getParameters().getStoragePool() == null ? null : getParameters().getStoragePool().getMacPoolId();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> result = new ArrayList<>(super.getPermissionCheckSubjects());
    final Guid macPoolId = getParameters().getStoragePool() == null ? null : getParameters().getStoragePool().getMacPoolId();
    final boolean changingPoolDefinition = macPoolId != null && !macPoolId.equals(getOldMacPoolId());
    if (changingPoolDefinition) {
        result.add(new PermissionSubject(macPoolId, VdcObjectType.MacPool, ActionGroup.CONFIGURE_MAC_POOL));
    }
    return result;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    final List<PermissionSubject> result = new ArrayList<>(super.getPermissionCheckSubjects());
    final Guid macPoolId = getNewMacPoolId();
    final boolean changingPoolDefinition = macPoolId != null && !macPoolId.equals(getOldMacPoolId());
    if (changingPoolDefinition) {
        result.add(new PermissionSubject(macPoolId, VdcObjectType.MacPool, ActionGroup.CONFIGURE_MAC_POOL));
    }
    return result;
}
#end_block

#method_before
private static boolean canPlugInterface(VmNic iface, Guid vdsGroupId) {
    if (noOtherPluggedVmNicHasSameMacAddress(iface)) {
        return true;
    }
    boolean canPlugInterface = canPlugInterfaceInDc(iface.getMacAddress(), vdsGroupIdToDataCenterId(vdsGroupId));
    if (!canPlugInterface) {
        new VmInterfaceManager().auditLogMacInUseUnplug(iface);
    }
    return canPlugInterface;
}
#method_after
private static boolean canPlugInterface(VmNic iface) {
    VmInterfaceManager vmIfaceManager = new VmInterfaceManager();
    if (vmIfaceManager.existsPluggedInterfaceWithSameMac(iface)) {
        vmIfaceManager.auditLogMacInUseUnplug(iface);
        return false;
    } else {
        return true;
    }
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM dstVm, VmBase dstVmBase, boolean dstIsVm, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    VDSGroup cluster = null;
    if (dstVmBase.getVdsGroupId() != null) {
        cluster = DbFacade.getInstance().getVdsGroupDao().get(dstVmBase.getVdsGroupId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVm.getStaticData());
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM dstVm, VmBase dstVmBase, boolean dstIsVm, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    VDSGroup cluster = null;
    if (dstVmBase.getVdsGroupId() != null) {
        cluster = DbFacade.getInstance().getVdsGroupDao().get(dstVmBase.getVdsGroupId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVm.getStaticData());
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
private static void addImportedInterfaces(VmBase vmBase, List<VmDevice> vmDevicesToUpdate) {
    for (VmNic iface : vmBase.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addInterface(vmBase.getId(), deviceId, true, iface.isPassthrough(), getVmDeviceAddress(vmBase, deviceId));
        VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            vmBase.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface, vmBase.getVdsGroupId()));
        updateImportedVmDevice(vmBase, vmDevice, deviceId, vmDevicesToUpdate);
    }
}
#method_after
private static void addImportedInterfaces(VmBase vmBase, List<VmDevice> vmDevicesToUpdate) {
    for (VmNic iface : vmBase.getInterfaces()) {
        Guid deviceId = iface.getId();
        VmDevice vmDevice = addInterface(vmBase.getId(), deviceId, true, iface.isPassthrough(), getVmDeviceAddress(vmBase, deviceId));
        VmDevice exportedDevice = vmBase.getManagedDeviceMap().get(deviceId);
        if (exportedDevice == null) {
            vmBase.getManagedDeviceMap().put(deviceId, vmDevice);
            exportedDevice = vmDevice;
        }
        exportedDevice.setIsPlugged(exportedDevice.getIsPlugged() && canPlugInterface(iface));
        updateImportedVmDevice(vmBase, vmDevice, deviceId, vmDevicesToUpdate);
    }
}
#end_block

#method_before
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrNull(Linq.<StorageDomain>cast(getItems()), new Linq.IdPredicate(storage.getId())));
    }
}
#method_after
@Override
protected void itemsCollectionChanged(Object sender, NotifyCollectionChangedEventArgs e) {
    super.itemsCollectionChanged(sender, e);
    // Try to select an item corresponding to the system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        setSelectedItem(Linq.firstOrNull(Linq.<StorageDomain>cast(getItems()), new Linq.IdPredicate<>(storage.getId())));
    }
}
#end_block

#method_before
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate, TSource defaultValue) {
    for (TSource item : source) {
        if (predicate.match(item)) {
            return item;
        }
    }
    return defaultValue;
}
#method_after
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate, TSource defaultValue) {
    if (source != null) {
        for (TSource item : source) {
            if (predicate.match(item)) {
                return item;
            }
        }
    }
    return defaultValue;
}
#end_block

#method_before
@Override
public boolean match(BusinessEntity<Guid> entity) {
    return id.equals(entity.getId());
}
#method_after
@Override
public boolean match(BusinessEntity<T> entity) {
    return id.equals(entity.getId());
}
#end_block

#method_before
@Override
public boolean match(BusinessEntity<Guid> entity) {
    return ids.contains(entity.getId());
}
#method_after
@Override
public boolean match(BusinessEntity<T> entity) {
    return ids.contains(entity.getId());
}
#end_block

#method_before
public ArrayList<StorageDomain> filterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrNull(list, new Linq.IdPredicate(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#method_after
public ArrayList<StorageDomain> filterStorageDomains(ArrayList<StorageDomain> storageDomains) {
    // filter only the Active storage domains (Active regarding the relevant storage pool).
    ArrayList<StorageDomain> list = new ArrayList<StorageDomain>();
    for (StorageDomain a : storageDomains) {
        if (Linq.isDataActiveStorageDomain(a)) {
            list.add(a);
        }
    }
    // Filter according to system tree selection.
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
        StorageDomain sd = Linq.firstOrNull(list, new Linq.IdPredicate<>(selectStorage.getId()));
        list = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { sd }));
    }
    return list;
}
#end_block

#method_before
@Override
public void initStorageDomains() {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomainList = new ArrayList<StorageDomain>();
            for (StorageDomain storageDomain : storageDomains) {
                if (storageDomain.getStatus() == StorageDomainStatus.Active && storageDomain.getStorageDomainType().isDataDomain()) {
                    activeStorageDomainList.add(storageDomain);
                }
            }
            for (DiskModel diskModel : getModel().getDisks()) {
                if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) diskModel.getDisk();
                    ArrayList<StorageDomain> activeDiskStorages = Linq.getStorageDomainsByIds(diskImage.getStorageIds(), activeStorageDomainList);
                    if (activeDiskStorages.isEmpty()) {
                        behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().vmStorageDomainIsNotAccessible());
                        return;
                    }
                }
            }
            if (activeStorageDomainList.size() > 0) {
                if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
                    StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
                    StorageDomain s = Linq.firstOrNull(activeStorageDomainList, new Linq.IdPredicate(selectStorage.getId()));
                    activeStorageDomainList = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { s }));
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(false);
                    behavior.getModel().getStorageDomain().setSelectedItem(s);
                } else {
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(true);
                }
            } else {
                behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().noActiveStorageDomain());
            }
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisksAllocationModel().getDisks();
            Collections.sort(activeStorageDomainList, new NameableComparator());
            if (disks != null) {
                ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
                for (DiskModel diskModel : diskImages) {
                    diskModel.getStorageDomain().setItems(activeStorageDomainList);
                    diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                }
                ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
                if (!cinderDisks.isEmpty()) {
                    Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
                    initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
                }
            }
        }
    }), vm.getStoragePoolId(), ActionGroup.CREATE_TEMPLATE);
}
#method_after
@Override
public void initStorageDomains() {
    AsyncDataProvider.getInstance().getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            NewTemplateVmModelBehavior behavior = NewTemplateVmModelBehavior.this;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> activeStorageDomainList = new ArrayList<StorageDomain>();
            for (StorageDomain storageDomain : storageDomains) {
                if (storageDomain.getStatus() == StorageDomainStatus.Active && storageDomain.getStorageDomainType().isDataDomain()) {
                    activeStorageDomainList.add(storageDomain);
                }
            }
            for (DiskModel diskModel : getModel().getDisks()) {
                if (diskModel.getDisk().getDiskStorageType() == DiskStorageType.IMAGE) {
                    DiskImage diskImage = (DiskImage) diskModel.getDisk();
                    ArrayList<StorageDomain> activeDiskStorages = Linq.getStorageDomainsByIds(diskImage.getStorageIds(), activeStorageDomainList);
                    if (activeDiskStorages.isEmpty()) {
                        behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().vmStorageDomainIsNotAccessible());
                        return;
                    }
                }
            }
            if (activeStorageDomainList.size() > 0) {
                if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
                    StorageDomain selectStorage = (StorageDomain) getSystemTreeSelectedItem().getEntity();
                    StorageDomain s = Linq.firstOrNull(activeStorageDomainList, new Linq.IdPredicate<>(selectStorage.getId()));
                    activeStorageDomainList = new ArrayList<StorageDomain>(Arrays.asList(new StorageDomain[] { s }));
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(false);
                    behavior.getModel().getStorageDomain().setSelectedItem(s);
                } else {
                    behavior.getModel().getStorageDomain().setItems(activeStorageDomainList);
                    behavior.getModel().getStorageDomain().setIsChangeable(true);
                }
            } else {
                behavior.disableNewTemplateModel(ConstantsManager.getInstance().getMessages().noActiveStorageDomain());
            }
            ArrayList<DiskModel> disks = (ArrayList<DiskModel>) behavior.getModel().getDisksAllocationModel().getDisks();
            Collections.sort(activeStorageDomainList, new NameableComparator());
            if (disks != null) {
                ArrayList<DiskModel> diskImages = Linq.filterDisksByType(disks, DiskStorageType.IMAGE);
                for (DiskModel diskModel : diskImages) {
                    diskModel.getStorageDomain().setItems(activeStorageDomainList);
                    diskModel.getQuota().setItems(behavior.getModel().getQuota().getItems());
                }
                ArrayList<DiskModel> cinderDisks = Linq.filterDisksByType(disks, DiskStorageType.CINDER);
                if (!cinderDisks.isEmpty()) {
                    Collection<StorageDomain> cinderStorageDomains = Linq.filterStorageDomainsByStorageType(storageDomains, StorageType.CINDER);
                    initStorageDomainsForCinderDisks(cinderDisks, cinderStorageDomains);
                }
            }
        }
    }), vm.getStoragePoolId(), ActionGroup.CREATE_TEMPLATE);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    fillVolumeInformation(newImage);
    if (getParameters().getVolumeFormat() != null) {
        newImage.setvolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(newImage), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    if (getParameters().getVolumeFormat() == null || getParameters().getVolumeType() == null) {
        // At least one of the volume arguments should be copied from the ancestral image.
        fillVolumeInformation(newImage);
    }
    if (getParameters().getVolumeFormat() != null) {
        newImage.setvolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(newImage), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    saveImage(newImage);
    getBaseDiskDao().save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setactual_size(getDiskImage().getActualSizeInBytes());
    DbFacade.getInstance().getDiskImageDynamicDao().save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
private void fillVolumeInformation(DiskImage disk) {
    DiskImage ancestor = getDiskImageDao().getAncestor(getDiskImage().getImageId());
    if (ancestor == null) {
        log.warn("Can't find ancestor of Disk with ID '{}', using original disk for volume info.", getDiskImage().getImageId());
        ancestor = getDiskImage();
    }
    disk.setvolumeFormat(ancestor.getVolumeFormat());
    disk.setVolumeType(ancestor.getVolumeType());
}
#method_after
private void fillVolumeInformation(DiskImage disk) {
    DiskImage ancestor = getDiskImageDao().getAncestor(getDiskImage().getImageId());
    disk.setvolumeFormat(ancestor.getVolumeFormat());
    disk.setVolumeType(ancestor.getVolumeType());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Not relevant for import VM/VMTemplate
    if (getParameters().isImportEntity()) {
        return true;
    }
    Guid imageGroupId = Guid.isNullOrEmpty(getParameters().getImageGroupID()) ? getImageGroupId() : getParameters().getImageGroupID();
    Disk disk = getDiskDao().get(imageGroupId);
    if (disk != null) {
        DiskValidator diskValidator = new DiskValidator(disk);
        return validate(diskValidator.validateUnsupportedDiskStorageType(DiskStorageType.LUN, DiskStorageType.CINDER));
    }
    return false;
}
#method_after
@Override
protected boolean canDoAction() {
    // Not relevant for import VM/VMTemplate
    if (getParameters().isImportEntity()) {
        return true;
    }
    Guid imageGroupId = Guid.isNullOrEmpty(getParameters().getImageGroupID()) ? getImageGroupId() : getParameters().getImageGroupID();
    Disk disk = getDiskDao().get(imageGroupId);
    if (disk != null) {
        DiskValidator diskValidator = new DiskValidator(disk);
        return validate(diskValidator.validateUnsupportedDiskStorageType(DiskStorageType.LUN, DiskStorageType.CINDER));
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(getParameters());
    adjustParameters(p);
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (getParameters().getOperation() == ImageOperation.Copy && !isTemplate()) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#method_after
@Override
protected void executeCommand() {
    MoveOrCopyImageGroupParameters p = prepareChildParameters();
    VdcReturnValueBase vdcRetValue = runInternalActionWithTasksContext(getImagesActionType(), p);
    if (!vdcRetValue.getSucceeded()) {
        setSucceeded(false);
        getReturnValue().setFault(vdcRetValue.getFault());
    } else {
        setSucceeded(true);
        if (getParameters().getOperation() == ImageOperation.Copy && !isTemplate()) {
            ImagesHandler.addDiskImageWithNoVmDevice(getImage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
private void createImageForVmMetaData() {
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(storagePool.getId(), storageDomainId, vmConfImageGroupId, MemoryUtils.METADATA_SIZE_IN_BYTES, VolumeType.Sparse, VolumeFormat.RAW, vmConfVolumeId, ""));
    if (!retVal.getSucceeded()) {
        throw new EngineException(EngineError.VolumeCreationError, "Failed to create image for vm configuration!");
    }
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(CREATE_IMAGE_FOR_VM_TASK_KEY);
    Guid guid = enclosingCommand.createTask(taskId, retVal.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid);
}
#method_after
private void createImageForVmMetaData() {
    VDSReturnValue retVal = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CreateImage, new CreateImageVDSCommandParameters(storagePool.getId(), storageDomainId, vmConfImageGroupId, MemoryUtils.METADATA_SIZE_IN_BYTES, VolumeType.Preallocated, VolumeFormat.RAW, vmConfVolumeId, ""));
    if (!retVal.getSucceeded()) {
        throw new EngineException(EngineError.VolumeCreationError, "Failed to create image for vm configuration!");
    }
    Guid taskId = enclosingCommand.persistAsyncTaskPlaceHolder(CREATE_IMAGE_FOR_VM_TASK_KEY);
    Guid guid = enclosingCommand.createTask(taskId, retVal.getCreationInfo(), enclosingCommand.getActionType());
    enclosingCommand.getTaskIdList().add(guid);
}
#end_block

#method_before
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependencyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
private int getBootableDiskIndex(Disk disk) {
    int index = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetBootableDiskIndex(disk.getDiskInterface(), numOfReservedScsiIndexes)).returnValue();
    log.debug("Bootable disk '{}' set to index '{}'", disk.getId(), index);
    return index;
}
#method_after
private int getBootableDiskIndex(Disk disk) {
    int index = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetBootableDiskIndex(numOfReservedScsiIndexes)).returnValue();
    log.info("Bootable disk '{}' set to index '{}'", disk.getId(), index);
    return index;
}
#end_block

#method_before
private void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
}
#method_after
private void addNetworkVirtualFunctionProperties(Map<String, Object> struct, VmNic vmInterface, VmDevice vmDevice, String vfName) {
    struct.put(VdsProperties.Type, vmDevice.getType().getValue());
    struct.put(VdsProperties.Device, vmDevice.getDevice());
    struct.put(VdsProperties.HostDev, vfName);
    addAddress(vmDevice, struct);
    struct.put(VdsProperties.MAC_ADDR, vmInterface.getMacAddress());
    addBootOrder(vmDevice, struct);
    struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
    Map<String, Object> specParams = new HashMap<>();
    VnicProfile vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(vmInterface.getVnicProfileId());
    Network network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
    if (NetworkUtils.isVlan(network)) {
        specParams.put(VdsProperties.VLAN_ID, network.getVlanId());
    }
    struct.put(VdsProperties.SpecParams, specParams);
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#end_block

#method_before
@Override
public void runForX86_64() {
    this.diskIndex = 0;
}
#method_after
@Override
public void runForX86_64() {
    diskIndex = 0;
}
#end_block

#method_before
@Override
public void runForPPC64() {
    this.diskIndex = numOfReservedScsiIndexes;
}
#method_after
@Override
public void runForPPC64() {
    diskIndex = numOfReservedScsiIndexes;
}
#end_block

#method_before
public int returnValue() {
    return this.diskIndex;
}
#method_after
public int returnValue() {
    return diskIndex;
}
#end_block

#method_before
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (DbFacade.getInstance().getStorageDomainDao().getStorageDomains(_storagePoolId, StorageDomainType.Master).stream().anyMatch(d -> d.getStatus() == StorageDomainStatus.Active || d.getStatus() == StorageDomainStatus.Unknown)) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }
    });
}
#method_after
private void runStoragePoolUpEvent(final StoragePool storagePool) {
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            try {
                if (isMasterDomainUp()) {
                    ResourceManager.getInstance().getEventListener().storagePoolUpEvent(storagePool);
                }
            } catch (RuntimeException exp) {
                log.error("Error in StoragePoolUpEvent: {}", exp.getMessage());
                log.debug("Exception", exp);
            }
        }

        private boolean isMasterDomainUp() {
            return DbFacade.getInstance().getStorageDomainDao().getStorageDomains(_storagePoolId, StorageDomainType.Master).stream().anyMatch(d -> d.getStatus() == StorageDomainStatus.Active || d.getStatus() == StorageDomainStatus.Unknown);
        }
    });
}
#end_block

#method_before
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String interfaceName, List<String> messages) {
    boolean hasInterface = interfaces.stream().anyMatch(i -> i.getName().equals(interfaceName));
    if (hasInterface) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#method_after
public static boolean isNotDuplicateInterfaceName(List<VmNic> interfaces, final String candidateInterfaceName, List<String> messages) {
    boolean candidateNameUsed = interfaces.stream().anyMatch(i -> i.getName().equals(candidateInterfaceName));
    if (candidateNameUsed) {
        messages.add(EngineMessage.NETWORK_INTERFACE_NAME_ALREADY_IN_USE.name());
        return false;
    }
    return true;
}
#end_block

#method_before
public void setDisks(List<DiskModel> value) {
    disks = value;
    if (disks == null) {
        return;
    }
    sortDisks();
    setDefaultVolumeInformationSelection(disks);
    for (final DiskModel diskModel : disks) {
        diskModel.getStorageDomain().getSelectedItemChangedEvent().removeListener(storageDomainEventListener);
        diskModel.getStorageDomain().getSelectedItemChangedEvent().addListener(storageDomainEventListener);
        diskModel.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                DiskImage disk = (DiskImage) diskModel.getDisk();
                if (diskModel.getStorageDomain().getItems() != null && disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                    diskModel.getStorageDomain().setSelectedItem(Linq.firstOrDefault(diskModel.getStorageDomain().getItems(), new Linq.IdsPredicate(disk.getStorageIds()), diskModel.getStorageDomain().getItems().iterator().next()));
                }
            }
        });
    }
}
#method_after
public void setDisks(List<DiskModel> value) {
    disks = value;
    if (disks == null) {
        return;
    }
    sortDisks();
    setDefaultVolumeInformationSelection(disks);
    for (final DiskModel diskModel : disks) {
        diskModel.getStorageDomain().getSelectedItemChangedEvent().removeListener(storageDomainEventListener);
        diskModel.getStorageDomain().getSelectedItemChangedEvent().addListener(storageDomainEventListener);
        diskModel.getStorageDomain().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

            @Override
            public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
                DiskImage disk = (DiskImage) diskModel.getDisk();
                if (diskModel.getStorageDomain().getItems() != null && disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                    diskModel.getStorageDomain().setSelectedItem(Linq.firstOrDefault(diskModel.getStorageDomain().getItems(), new Linq.IdsPredicate<>(disk.getStorageIds()), diskModel.getStorageDomain().getItems().iterator().next()));
                }
            }
        });
    }
}
#end_block

#method_before
public static <TSource> TSource firstOrNull(Iterable<TSource> source, IPredicate<? super TSource> predicate) {
    for (TSource item : source) {
        if (predicate.match(item)) {
            return item;
        }
    }
    return null;
}
#method_after
public static <TSource> TSource firstOrNull(Iterable<TSource> source, IPredicate<? super TSource> predicate) {
    if (source != null) {
        for (TSource item : source) {
            if (predicate.match(item)) {
                return item;
            }
        }
    }
    return null;
}
#end_block

#method_before
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#method_after
protected void initGraphicsConsoles(int osType, Version compatibilityVersion) {
    Set<GraphicsTypes> graphicsTypes = new LinkedHashSet<>();
    List<Pair<GraphicsType, DisplayType>> graphicsAndDisplays = AsyncDataProvider.getInstance().getGraphicsAndDisplays(osType, compatibilityVersion);
    for (Pair<GraphicsType, DisplayType> graphicsAndDisplay : graphicsAndDisplays) {
        if (graphicsAndDisplay.getSecond() == getDisplayType().getSelectedItem()) {
            graphicsTypes.add(GraphicsTypes.fromGraphicsType(graphicsAndDisplay.getFirst()));
        }
    }
    if (graphicsTypes.contains(GraphicsTypes.SPICE) && graphicsTypes.contains(GraphicsTypes.VNC)) {
        if (AsyncDataProvider.getInstance().supportedForUnitVmModel(ConfigurationValues.MultipleGraphicsSupported, this)) {
            graphicsTypes.add(GraphicsTypes.SPICE_AND_VNC);
        }
    }
    GraphicsTypes prevSelected = getGraphicsType().getSelectedItem();
    if (prevSelected != null && graphicsTypes.contains(prevSelected)) {
        getGraphicsType().setItems(graphicsTypes, prevSelected);
    } else {
        getGraphicsType().setItems(graphicsTypes);
    }
    upgradeGraphicsRelatedModels();
}
#end_block

#method_before
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate) {
    for (TSource item : source) {
        if (predicate.match(item)) {
            return item;
        }
    }
    return null;
}
#method_after
public static <TSource> TSource firstOrDefault(Iterable<TSource> source, IPredicate<? super TSource> predicate) {
    if (source != null) {
        for (TSource item : source) {
            if (predicate.match(item)) {
                return item;
            }
        }
    }
    return null;
}
#end_block

#method_before
public boolean validate() {
    getNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), new BondNameValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    getGateway().setIsValid(true);
    if (getIsStaticAddress()) {
        getAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().validateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
        getGateway().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
    }
    // TODO elevi ask how to get the field name dynamically
    // $NON-NLS-1$
    final String customEditorParameter = " Custom mode ";
    // TODO elevi ask how to make it a const see TODO elevi at AsyncDataProvider
    if (getBondingOptions().getSelectedItem().getKey().equals("custom")) {
        // $NON-NLS-1$
        getCustomEditor().validateEntity(new IValidation[] { new NotEmptyValidation(), new KeyValueFormatValidation((customEditorParameter)) });
    }
    return getBond().getIsValid() && getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid() && getGateway().getIsValid() && getCustomEditor().getIsValid();
}
#method_after
public boolean validate() {
    getNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), new BondNameValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    getGateway().setIsValid(true);
    if (getIsStaticAddress()) {
        getAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().validateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
        getGateway().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
    }
    if (getBondingOptions().getSelectedItem().getKey().equals(CUSTOM_BONDING_MODE)) {
        getCustomBondEditor().validateEntity(new IValidation[] { new KeyValueFormatValidation() });
    }
    return getBond().getIsValid() && getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid() && getGateway().getIsValid() && getCustomBondEditor().getIsValid();
}
#end_block

#method_before
@Test
public void nullTest() {
    ValidationResult validationResult = underTest.validate(input);
    Assert.assertEquals(expectedResult, validationResult.getSuccess());
}
#method_after
@Test
public void nullTest() {
    ValidationResult validationResult = underTest.validate(null);
    Assert.assertEquals(failureValidationResultEmptyNotAllowed, validationResult);
}
#end_block

#method_before
public static void copyVmDevices(Guid srcId, Guid dstId, VM dstVm, VmBase dstVmBase, boolean dstIsVm, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    VDSGroup cluster = null;
    if (dstVmBase.getVdsGroupId() != null) {
        cluster = DbFacade.getInstance().getVdsGroupDao().get(dstVmBase.getVdsGroupId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVm.getStaticData());
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#method_after
public static void copyVmDevices(Guid srcId, Guid dstId, VM dstVm, VmBase dstVmBase, boolean dstIsVm, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    VDSGroup cluster = null;
    if (dstVmBase.getVdsGroupId() != null) {
        cluster = DbFacade.getInstance().getVdsGroupDao().get(dstVmBase.getVdsGroupId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new VmStatic params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        dao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVm.getStaticData());
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
private boolean isNetworkDeviceFree(HostDevice networkDevice) {
    // Check that there is no macvtap device on top of the VM-
    // nics with macvtap attached are not reported via the getVdsCaps
    VdsNetworkInterface vfNic = getNicByPciDevice(networkDevice);
    return vfNic != null && !isNetworkAttached(vfNic) && !isVlanDeviceAttached(vfNic) && !isPartOfBond(vfNic);
}
#method_after
private boolean isNetworkDeviceFree(HostDevice networkDevice) {
    // Check that there is no macvtap device on top of the VM-
    // nics with macvtap attached are not reported via the getVdsCaps
    VdsNetworkInterface vfNic = getNicByPciDevice(networkDevice);
    return vfNic != null && !isNetworkAttached(vfNic) && !isVlanDeviceAttached(vfNic) && !vfNic.isPartOfBond();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            if (((CinderDisk) getDisk()).getImageStatus() == ImageStatus.ILLEGAL) {
                params.setFaultTolerant(true);
            }
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, getParameters().getStorageDomainId()));
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#method_after
@Override
protected void executeCommand() {
    switch(getDisk().getDiskStorageType()) {
        case IMAGE:
            VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.RemoveImage, buildRemoveImageParameters(getDiskImage()));
            if (vdcReturnValue.getSucceeded()) {
                incrementVmsGeneration();
                getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                setSucceeded(true);
            }
            break;
        case LUN:
            removeLunDisk();
            break;
        case CINDER:
            RemoveCinderDiskParameters params = new RemoveCinderDiskParameters(getParameters().getDiskId());
            Future<VdcReturnValueBase> future = CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.RemoveCinderDisk, params, cloneContextAndDetachFromParent(), new SubjectEntity(VdcObjectType.Storage, getParameters().getStorageDomainId()));
            try {
                setReturnValue(future.get());
                setSucceeded(getReturnValue().getSucceeded());
            } catch (InterruptedException | ExecutionException e) {
                log.error("Error removing Cinder disk '{}': {}", getDiskImage().getDiskAlias(), e.getMessage());
                log.debug("Exception", e);
            }
            break;
    }
}
#end_block

#method_before
private static OsRepository getOsRepository() {
    return SimpleDependecyInjector.getInstance().get(OsRepository.class);
}
#method_after
private static OsRepository getOsRepository() {
    return SimpleDependencyInjector.getInstance().get(OsRepository.class);
}
#end_block

#method_before
public boolean isHostedEngineDirectLunDisk() {
    return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias());
}
#method_after
private boolean isHostedEngineDirectLunDisk() {
    return disk.getDiskStorageType() == DiskStorageType.LUN && StorageConstants.HOSTED_ENGINE_LUN_DISK_ALIAS.equals(disk.getDiskAlias());
}
#end_block

#method_before
protected boolean canDetachStorageDomainWithVmsAndDisks(StorageDomain storageDomain) {
    if (!storageDomain.getStorageDomainType().isDataDomain()) {
        return true;
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<String> vmsInPreview = new ArrayList<>();
    List<VM> vmRelatedToDomain = getVmDao().getAllForStorageDomain(storageDomain.getId());
    vmsInPreview.addAll(vmRelatedToDomain.stream().filter(vm -> !snapshotsValidator.vmNotInPreview(vm.getId()).isValid()).map(VM::getName).collect(Collectors.toList()));
    List<VM> vmsWithDisksOnMultipleStorageDomain = getDbFacade().getVmDao().getAllVMsWithDisksOnOtherStorageDomain(storageDomain.getId());
    vmRelatedToDomain.removeAll(vmsWithDisksOnMultipleStorageDomain);
    List<String> entitiesDeleteProtected = new ArrayList<>();
    List<String> vmsInPool = new ArrayList<>();
    for (VM vm : vmRelatedToDomain) {
        if (vm.isDeleteProtected()) {
            entitiesDeleteProtected.add(vm.getName());
        }
        if (vm.getVmPoolId() != null) {
            vmsInPool.add(vm.getName());
        }
    }
    List<VmTemplate> templatesRelatedToDomain = getVmTemplateDao().getAllForStorageDomain(storageDomain.getId());
    List<VmTemplate> vmTemplatesWithDisksOnMultipleStorageDomain = getVmTemplateDao().getAllTemplatesWithDisksOnOtherStorageDomain(storageDomain.getId());
    templatesRelatedToDomain.removeAll(vmTemplatesWithDisksOnMultipleStorageDomain);
    entitiesDeleteProtected.addAll(templatesRelatedToDomain.stream().filter(VmBase::isDeleteProtected).map(VmTemplate::getName).collect(Collectors.toList()));
    boolean succeeded = true;
    if (!entitiesDeleteProtected.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_PROTECTED);
        addCanDoActionMessageVariable("vms", StringUtils.join(entitiesDeleteProtected, ","));
        succeeded = false;
    }
    if (!vmsInPool.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_VMS_IN_POOL);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPool, ","));
        succeeded = false;
    }
    if (!vmsInPreview.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_VMS_IN_PREVIEW);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPreview, ","));
        succeeded = false;
    }
    return succeeded;
}
#method_after
protected boolean canDetachStorageDomainWithVmsAndDisks(StorageDomain storageDomain) {
    if (!storageDomain.getStorageDomainType().isDataDomain()) {
        return true;
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    List<VM> vmRelatedToDomain = getVmDao().getAllForStorageDomain(storageDomain.getId());
    List<String> vmsInPreview = vmRelatedToDomain.stream().filter(vm -> !snapshotsValidator.vmNotInPreview(vm.getId()).isValid()).map(VM::getName).collect(Collectors.toList());
    List<VM> vmsWithDisksOnMultipleStorageDomain = getDbFacade().getVmDao().getAllVMsWithDisksOnOtherStorageDomain(storageDomain.getId());
    vmRelatedToDomain.removeAll(vmsWithDisksOnMultipleStorageDomain);
    List<String> entitiesDeleteProtected = new ArrayList<>();
    List<String> vmsInPool = new ArrayList<>();
    for (VM vm : vmRelatedToDomain) {
        if (vm.isDeleteProtected()) {
            entitiesDeleteProtected.add(vm.getName());
        }
        if (vm.getVmPoolId() != null) {
            vmsInPool.add(vm.getName());
        }
    }
    List<VmTemplate> templatesRelatedToDomain = getVmTemplateDao().getAllForStorageDomain(storageDomain.getId());
    List<VmTemplate> vmTemplatesWithDisksOnMultipleStorageDomain = getVmTemplateDao().getAllTemplatesWithDisksOnOtherStorageDomain(storageDomain.getId());
    templatesRelatedToDomain.removeAll(vmTemplatesWithDisksOnMultipleStorageDomain);
    entitiesDeleteProtected.addAll(templatesRelatedToDomain.stream().filter(VmBase::isDeleteProtected).map(VmTemplate::getName).collect(Collectors.toList()));
    boolean succeeded = true;
    if (!entitiesDeleteProtected.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_PROTECTED);
        addCanDoActionMessageVariable("vms", StringUtils.join(entitiesDeleteProtected, ","));
        succeeded = false;
    }
    if (!vmsInPool.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_VMS_IN_POOL);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPool, ","));
        succeeded = false;
    }
    if (!vmsInPreview.isEmpty()) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DELETE_VMS_IN_PREVIEW);
        addCanDoActionMessageVariable("vms", StringUtils.join(vmsInPreview, ","));
        succeeded = false;
    }
    return succeeded;
}
#end_block

#method_before
@Mapping(from = VnicProfile.class, to = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class)
public static org.ovirt.engine.core.common.businessentities.network.VnicProfile map(VnicProfile model, org.ovirt.engine.core.common.businessentities.network.VnicProfile template) {
    org.ovirt.engine.core.common.businessentities.network.VnicProfile entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.VnicProfile();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetNetwork() && model.getNetwork().isSetId()) {
        entity.setNetworkId(GuidUtils.asGuid(model.getNetwork().getId()));
    }
    if (model.isSetPortMirroring()) {
        entity.setPortMirroring(model.isPortMirroring());
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperties())));
    }
    if (model.isSetQos() && model.getQos().isSetId()) {
        entity.setNetworkQosId(GuidUtils.asGuid(model.getQos().getId()));
    }
    if (model.isSetPassthrough()) {
        entity.setPassthrough(map(model.getPassthrough()));
    }
    return entity;
}
#method_after
@Mapping(from = VnicProfile.class, to = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class)
public static org.ovirt.engine.core.common.businessentities.network.VnicProfile map(VnicProfile model, org.ovirt.engine.core.common.businessentities.network.VnicProfile template) {
    org.ovirt.engine.core.common.businessentities.network.VnicProfile entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.network.VnicProfile();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetNetwork() && model.getNetwork().isSetId()) {
        entity.setNetworkId(GuidUtils.asGuid(model.getNetwork().getId()));
    }
    if (model.isSetPortMirroring()) {
        entity.setPortMirroring(model.isPortMirroring());
    }
    if (model.isSetCustomProperties()) {
        entity.setCustomProperties(DevicePropertiesUtils.getInstance().convertProperties(CustomPropertiesParser.parse(model.getCustomProperties().getCustomProperties())));
    }
    if (model.isSetQos() && model.getQos().isSetId()) {
        entity.setNetworkQosId(GuidUtils.asGuid(model.getQos().getId()));
    }
    if (model.isSetPassThrough() && model.getPassThrough().isSetMode()) {
        entity.setPassthrough(map(model.getPassThrough().getMode()));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, to = VnicProfile.class)
public static VnicProfile map(org.ovirt.engine.core.common.businessentities.network.VnicProfile entity, VnicProfile template) {
    VnicProfile model = template != null ? template : new VnicProfile();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    model.setPortMirroring(entity.isPortMirroring());
    if (entity.getCustomProperties() != null && !entity.getCustomProperties().isEmpty()) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(DevicePropertiesUtils.getInstance().convertProperties(entity.getCustomProperties()), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getNetworkQosId() != null) {
        model.setQos(new Qos());
        model.getQos().setId(entity.getNetworkQosId().toString());
    }
    model.setPassthrough(map(entity.isPassthrough()).value());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.VnicProfile.class, to = VnicProfile.class)
public static VnicProfile map(org.ovirt.engine.core.common.businessentities.network.VnicProfile entity, VnicProfile template) {
    VnicProfile model = template != null ? template : new VnicProfile();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getName() != null) {
        model.setName(entity.getName());
    }
    if (entity.getDescription() != null) {
        model.setDescription(entity.getDescription());
    }
    if (entity.getNetworkId() != null) {
        model.setNetwork(new Network());
        model.getNetwork().setId(entity.getNetworkId().toString());
    }
    model.setPortMirroring(entity.isPortMirroring());
    if (entity.getCustomProperties() != null && !entity.getCustomProperties().isEmpty()) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperties().addAll(CustomPropertiesParser.parse(DevicePropertiesUtils.getInstance().convertProperties(entity.getCustomProperties()), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getNetworkQosId() != null) {
        model.setQos(new Qos());
        model.getQos().setId(entity.getNetworkQosId().toString());
    }
    final VnicPassThrough vnicPassThrough = new VnicPassThrough();
    vnicPassThrough.setMode(map(entity.isPassthrough()).value());
    model.setPassThrough(vnicPassThrough);
    return model;
}
#end_block

#method_before
private static boolean map(String value) {
    final VnicPassthrough vnicPassthrough = VnicPassthrough.fromValue(value);
    return VnicPassthrough.TRUE == vnicPassthrough;
}
#method_after
private static boolean map(String value) {
    final VnicPassThroughMode vnicPassThroughMode = VnicPassThroughMode.fromValue(value);
    return VnicPassThroughMode.ENABLED == vnicPassThroughMode;
}
#end_block

#method_before
private static VnicPassthrough map(boolean value) {
    return value ? VnicPassthrough.TRUE : VnicPassthrough.FALSE;
}
#method_after
private static VnicPassThroughMode map(boolean value) {
    return value ? VnicPassThroughMode.ENABLED : VnicPassThroughMode.DISABLED;
}
#end_block

#method_before
@Override
public VnicProfile update(VnicProfile resource) {
    if (resource.isSetPassthrough()) {
        validateEnum(VnicPassthrough.class, resource.getPassthrough().toUpperCase());
    }
    return performUpdate(resource, new QueryIdResolver<>(VdcQueryType.GetVnicProfileById, IdQueryParameters.class), VdcActionType.UpdateVnicProfile, new UpdateParametersProvider());
}
#method_after
@Override
public VnicProfile update(VnicProfile resource) {
    validateEnums(VnicProfile.class, resource);
    return performUpdate(resource, new QueryIdResolver<>(VdcQueryType.GetVnicProfileById, IdQueryParameters.class), VdcActionType.UpdateVnicProfile, new UpdateParametersProvider());
}
#end_block

#method_before
@Override
protected HostNic addLinks(HostNic hostNic, String... subCollectionsToExclude) {
    if (hostNic.isSetVfsConfig()) {
        return super.addLinks(hostNic, subCollectionsToExclude);
    } else {
        final HostNic resultHostNic = super.addLinks(hostNic, ArrayUtils.concat(PF_SUB_COLLECTIONS, subCollectionsToExclude));
        final Iterator<Link> linkIterator = resultHostNic.getActions().getLinks().iterator();
        while (linkIterator.hasNext()) {
            final Link link = linkIterator.next();
            if (link.getRel().equals(UPDATE_VFS_CONFIG_ACTION)) {
                linkIterator.remove();
            }
        }
        return resultHostNic;
    }
}
#method_after
@Override
protected HostNic addLinks(HostNic hostNic, String... subCollectionsToExclude) {
    if (hostNic.isSetVirtualFunctionsConfiguration()) {
        return super.addLinks(hostNic, subCollectionsToExclude);
    } else {
        final HostNic resultHostNic = super.addLinks(hostNic, ArrayUtils.concat(PF_SUB_COLLECTIONS, subCollectionsToExclude));
        final Iterator<Link> linkIterator = resultHostNic.getActions().getLinks().iterator();
        while (linkIterator.hasNext()) {
            final Link link = linkIterator.next();
            if (link.getRel().equals(UPDATE_VFS_CONFIG_ACTION)) {
                linkIterator.remove();
            }
        }
        return resultHostNic;
    }
}
#end_block

#method_before
@Override
protected HostNic doPopulate(HostNic model, VdsNetworkInterface entity) {
    final HostNic hostNic = super.doPopulate(model, entity);
    final Guid nicId = entity.getId();
    final HostNicVfsConfig hostNicVfsConfig = findVfsConfig(nicId);
    if (hostNicVfsConfig == null) {
        final Map<Guid, Guid> vfMap = retriveVfMap();
        final Guid physicalFunctionNicId = vfMap.get(nicId);
        if (physicalFunctionNicId != null) {
            final HostNic physicalFunction = new HostNic();
            physicalFunction.setId(physicalFunctionNicId.toString());
            hostNic.setPhysicalFunction(physicalFunction);
        }
    } else {
        final Mapper<HostNicVfsConfig, org.ovirt.engine.api.model.HostNicVfsConfig> mapper = getMapper(HostNicVfsConfig.class, org.ovirt.engine.api.model.HostNicVfsConfig.class);
        final org.ovirt.engine.api.model.HostNicVfsConfig vfsConfigModel = mapper.map(hostNicVfsConfig, new org.ovirt.engine.api.model.HostNicVfsConfig());
        hostNic.setVfsConfig(vfsConfigModel);
    }
    return hostNic;
}
#method_after
@Override
protected HostNic doPopulate(HostNic model, VdsNetworkInterface entity) {
    final HostNic hostNic = super.doPopulate(model, entity);
    final Guid nicId = entity.getId();
    final HostNicVfsConfig hostNicVfsConfig = findVfsConfig(nicId);
    if (hostNicVfsConfig == null) {
        final Map<Guid, Guid> vfMap = retriveVfMap();
        final Guid physicalFunctionNicId = vfMap.get(nicId);
        if (physicalFunctionNicId != null) {
            final HostNic physicalFunction = new HostNic();
            physicalFunction.setId(physicalFunctionNicId.toString());
            hostNic.setPhysicalFunction(physicalFunction);
        }
    } else {
        final Mapper<HostNicVfsConfig, HostNicVirtualFunctionsConfiguration> mapper = getMapper(HostNicVfsConfig.class, HostNicVirtualFunctionsConfiguration.class);
        final HostNicVirtualFunctionsConfiguration vfsConfigModel = mapper.map(hostNicVfsConfig, new HostNicVirtualFunctionsConfiguration());
        hostNic.setVirtualFunctionsConfiguration(vfsConfigModel);
    }
    return hostNic;
}
#end_block

#method_before
private Response notAllowed() {
    throw new WebApplicationException(405);
}
#method_after
private Response notAllowed(String reason, String detail) {
    return Response.status(405).entity(fault(reason, detail)).build();
}
#end_block

#method_before
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<HostNic, VdsNetworkInterface>(entityType, guid, query));
}
#method_after
@Override
public StatisticsResource getStatisticsResource() {
    EntityIdResolver<Guid> resolver = new EntityIdResolver<Guid>() {

        @Override
        public VdsNetworkInterface lookupEntity(Guid guid) throws BackendFailureException {
            return parent.lookupInterface(id);
        }
    };
    HostNicStatisticalQuery query = new HostNicStatisticalQuery(resolver, newModel(id));
    return inject(new BackendStatisticsResource<>(entityType, guid, query));
}
#end_block

#method_before
@Override
public LabelsResource getVfAllowedLabelsResource() {
    return inject(new BackendVfAllowedLabelsResource(asGuid(id), parent.getHostId()));
}
#method_after
@Override
public LabelsResource getVfAllowedLabelsResource() {
    return inject(new BackendVirtualFunctionAllowedLabelsResource(guid, parent.getHostId()));
}
#end_block

#method_before
@Override
public VfAllowedNetworksResource getVfAllowedNetworksResource() {
    return inject(new BackendVfAllowedNetworksResource(asGuid(id), parent.getHostId()));
}
#method_after
@Override
public VirtualFunctionAllowedNetworksResource getVfAllowedNetworksResource() {
    return inject(new BackendVirtualFunctionAllowedNetworksResource(guid, parent.getHostId()));
}
#end_block

#method_before
@Mapping(from = HostNic.class, to = VdsNetworkInterface.class)
public static VdsNetworkInterface map(HostNic model, VdsNetworkInterface template) {
    VdsNetworkInterface entity;
    if (template != null) {
        entity = template;
    } else if (model.isSetBonding()) {
        entity = new Bond();
    } else if (model.isSetVlan()) {
        entity = new Vlan();
    } else {
        entity = new Nic();
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetName()) {
        entity.setNetworkName(model.getNetwork().getName());
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBaseInterface()) {
        entity.setBaseInterface(model.getBaseInterface());
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddress(model.getIp().getAddress());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
    }
    if (model.isSetMac() && model.getMac().isSetAddress()) {
        entity.setMacAddress(model.getMac().getAddress());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetOptions()) {
            StringBuffer buf = new StringBuffer();
            for (Option opt : model.getBonding().getOptions().getOptions()) {
                buf.append(opt.getName() + "=" + opt.getValue() + " ");
            }
            entity.setBondOptions(buf.toString().substring(0, buf.length() - 1));
        }
    }
    if (model.isSetBootProtocol()) {
        NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(model.getBootProtocol()), null);
        if (networkBootProtocol != null) {
            entity.setBootProtocol(networkBootProtocol);
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#method_after
@Mapping(from = HostNic.class, to = VdsNetworkInterface.class)
public static VdsNetworkInterface map(HostNic model, VdsNetworkInterface template) {
    VdsNetworkInterface entity;
    if (template != null) {
        entity = template;
    } else if (model.isSetBonding()) {
        entity = new Bond();
    } else if (model.isSetVlan()) {
        entity = new Vlan();
    } else {
        entity = new Nic();
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetName()) {
        entity.setNetworkName(model.getNetwork().getName());
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBaseInterface()) {
        entity.setBaseInterface(model.getBaseInterface());
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddress(model.getIp().getAddress());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
    }
    if (model.isSetMac() && model.getMac().isSetAddress()) {
        entity.setMacAddress(model.getMac().getAddress());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetOptions()) {
            List<Option> bondingOptions = model.getBonding().getOptions().getOptions();
            String optionsString = bondingOptions.stream().filter(Option::isSetName).map(x -> x.getName() + "=" + x.getValue()).collect(joining(" "));
            entity.setBondOptions(optionsString);
        }
    }
    if (model.isSetBootProtocol()) {
        NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(model.getBootProtocol()), null);
        if (networkBootProtocol != null) {
            entity.setBootProtocol(networkBootProtocol);
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.network.HostNicVfsConfig.class, to = UpdateHostNicVfsConfigParameters.class)
public static UpdateHostNicVfsConfigParameters map(org.ovirt.engine.core.common.businessentities.network.HostNicVfsConfig entity, UpdateHostNicVfsConfigParameters params) {
    params.setNicId(entity.getNicId());
    params.setAllNetworksAllowed(entity.isAllNetworksAllowed());
    params.setNumOfVfs(entity.getNumOfVfs());
    return params;
}
#method_after
@Mapping(from = HostNicVfsConfig.class, to = HostNicVirtualFunctionsConfiguration.class)
public static HostNicVirtualFunctionsConfiguration map(HostNicVfsConfig entity, HostNicVirtualFunctionsConfiguration apiModel) {
    apiModel.setAllNetworksAllowed(entity.isAllNetworksAllowed());
    apiModel.setMaxNumberOfVirtualFunctions(entity.getMaxNumOfVfs());
    apiModel.setNumberOfVirtualFunctions(entity.getNumOfVfs());
    return apiModel;
}
#end_block

#method_before
@Mapping(from = HostNicVfsConfig.class, to = UpdateHostNicVfsConfigParameters.class)
public static UpdateHostNicVfsConfigParameters map(HostNicVfsConfig apiModel, UpdateHostNicVfsConfigParameters params) {
    if (apiModel.isSetAllNetworksAllowed()) {
        params.setAllNetworksAllowed(apiModel.isAllNetworksAllowed());
    }
    if (apiModel.isSetNumOfVfs()) {
        params.setNumOfVfs(apiModel.getNumOfVfs());
    }
    return params;
}
#method_after
@Mapping(from = HostNicVfsConfig.class, to = UpdateHostNicVfsConfigParameters.class)
public static UpdateHostNicVfsConfigParameters map(HostNicVfsConfig entity, UpdateHostNicVfsConfigParameters params) {
    params.setNicId(entity.getNicId());
    params.setAllNetworksAllowed(entity.isAllNetworksAllowed());
    params.setNumOfVfs(entity.getNumOfVfs());
    return params;
}
#end_block

#method_before
@Mapping(from = HostNic.class, to = VdsNetworkInterface.class)
public static VdsNetworkInterface map(HostNic model, VdsNetworkInterface template) {
    VdsNetworkInterface entity;
    if (template != null) {
        entity = template;
    } else if (model.isSetBonding()) {
        entity = new Bond();
    } else if (model.isSetVlan()) {
        entity = new Vlan();
    } else {
        entity = new Nic();
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetName()) {
        entity.setNetworkName(model.getNetwork().getName());
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBaseInterface()) {
        entity.setBaseInterface(model.getBaseInterface());
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddress(model.getIp().getAddress());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
    }
    if (model.isSetMac() && model.getMac().isSetAddress()) {
        entity.setMacAddress(model.getMac().getAddress());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetOptions()) {
            StringBuilder builder = new StringBuilder();
            for (Option opt : model.getBonding().getOptions().getOptions()) {
                if (opt.isSetName()) {
                    builder.append(opt.getName()).append("=").append(opt.getValue()).append(" ");
                }
            }
            int builderLength = builder.length();
            if (builderLength > 0) {
                builder.deleteCharAt(builderLength - 1);
            }
            entity.setBondOptions(builder.toString());
        }
    }
    if (model.isSetBootProtocol()) {
        NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(model.getBootProtocol()), null);
        if (networkBootProtocol != null) {
            entity.setBootProtocol(networkBootProtocol);
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#method_after
@Mapping(from = HostNic.class, to = VdsNetworkInterface.class)
public static VdsNetworkInterface map(HostNic model, VdsNetworkInterface template) {
    VdsNetworkInterface entity;
    if (template != null) {
        entity = template;
    } else if (model.isSetBonding()) {
        entity = new Bond();
    } else if (model.isSetVlan()) {
        entity = new Vlan();
    } else {
        entity = new Nic();
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetName()) {
        entity.setNetworkName(model.getNetwork().getName());
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBaseInterface()) {
        entity.setBaseInterface(model.getBaseInterface());
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddress(model.getIp().getAddress());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
    }
    if (model.isSetMac() && model.getMac().isSetAddress()) {
        entity.setMacAddress(model.getMac().getAddress());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetOptions()) {
            List<Option> bondingOptions = model.getBonding().getOptions().getOptions();
            String optionsString = bondingOptions.stream().filter(Option::isSetName).map(x -> x.getName() + "=" + x.getValue()).collect(joining(" "));
            entity.setBondOptions(optionsString);
        }
    }
    if (model.isSetBootProtocol()) {
        NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(model.getBootProtocol()), null);
        if (networkBootProtocol != null) {
            entity.setBootProtocol(networkBootProtocol);
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = HostNic.class, to = Bond.class)
public static Bond map(HostNic model, Bond template) {
    Bond entity = template == null ? new Bond() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetSlaves()) {
            for (HostNic slave : model.getBonding().getSlaves().getHostNics()) {
                if (slave.isSetName()) {
                    entity.getSlaves().add(slave.getName());
                }
            }
        }
        if (model.getBonding().isSetOptions()) {
            entity.setBondOptions(calculateBondingOptionsString(model));
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#method_after
@Mapping(from = HostNic.class, to = Bond.class)
public static Bond map(HostNic model, Bond template) {
    Bond entity = template == null ? new Bond() : template;
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetSlaves()) {
            entity.getSlaves().clear();
            for (HostNic slave : model.getBonding().getSlaves().getHostNics()) {
                if (slave.isSetName()) {
                    entity.getSlaves().add(slave.getName());
                }
            }
        }
        if (model.getBonding().isSetOptions()) {
            entity.setBondOptions(calculateBondingOptionsString(model));
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#end_block

#method_before
public boolean validate() {
    getNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), new BondNameValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    getGateway().setIsValid(true);
    if (getIsStaticAddress()) {
        getAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().validateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
        getGateway().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
    }
    // TODO elevi ask how to make it a const see TODO elevi at AsyncDataProvider
    if (getBondingOptions().getSelectedItem().getKey().equals("custom")) {
        // $NON-NLS-1$
        getCustomEditor().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    return getBond().getIsValid() && getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid() && getGateway().getIsValid() && getCustomEditor().getIsValid();
}
#method_after
public boolean validate() {
    getNetwork().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getBond().validateSelectedItem(new IValidation[] { new NotEmptyValidation(), new LengthValidation(BusinessEntitiesDefinitions.HOST_NIC_NAME_LENGTH), new BondNameValidation() });
    getAddress().setIsValid(true);
    getSubnet().setIsValid(true);
    getGateway().setIsValid(true);
    if (getIsStaticAddress()) {
        getAddress().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
        getSubnet().validateEntity(new IValidation[] { new NotEmptyValidation(), new SubnetMaskValidation() });
        getGateway().validateEntity(new IValidation[] { new NotEmptyValidation(), new IpAddressValidation() });
    }
    if (getBondingOptions().getSelectedItem().getKey().equals(CUSTOM_BONDING_MODE)) {
        getCustomBondEditor().validateEntity(new IValidation[] { new NotEmptyValidation() });
    }
    return getBond().getIsValid() && getNetwork().getIsValid() && getAddress().getIsValid() && getSubnet().getIsValid() && getGateway().getIsValid() && getCustomBondEditor().getIsValid();
}
#end_block

#method_before
@Override
public void edit(final HostBondInterfaceModel object) {
    driver.edit(object);
    bondSuggestEditor.setVisible(false);
    if (!object.getBootProtocolAvailable()) {
        bootProtocol.asWidget().setVisible(false);
        bootProtocolLabel.setVisible(false);
    }
    bootProtocol.setEnabled(NetworkBootProtocol.NONE, object.getNoneBootProtocolAvailable());
    updateBondOptions(object.getBondingOptions());
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            HostBondInterfaceModel model = (HostBondInterfaceModel) sender;
            String propertyName = args.propertyName;
            if ("NoneBootProtocolAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                bootProtocol.setEnabled(NetworkBootProtocol.NONE, model.getNoneBootProtocolAvailable());
            } else if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                message.setText(model.getMessage());
            }
        }
    });
    object.getBondingOptions().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Map.Entry<String, EntityModel<String>>> list = (ListModel<Map.Entry<String, EntityModel<String>>>) sender;
            updateBondOptions(list);
        }
    });
    customEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            for (Map.Entry<String, EntityModel<String>> pair : object.getBondingOptions().getItems()) {
                if ("custom".equals(pair.getKey())) {
                    // $NON-NLS-1$
                    pair.getValue().setEntity(event.getValue());
                }
            }
        }
    });
    bondingModeEditor.setVisible(true);
    bondingModeEditor.asWidget().setVisible(true);
}
#method_after
@Override
public void edit(final HostBondInterfaceModel object) {
    driver.edit(object);
    bondSuggestEditor.setVisible(false);
    if (!object.getBootProtocolAvailable()) {
        bootProtocol.asWidget().setVisible(false);
        bootProtocolLabel.setVisible(false);
    }
    bootProtocol.setEnabled(NetworkBootProtocol.NONE, object.getNoneBootProtocolAvailable());
    updateBondOptions(object.getBondingOptions());
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            HostBondInterfaceModel model = (HostBondInterfaceModel) sender;
            String propertyName = args.propertyName;
            if ("NoneBootProtocolAvailable".equals(propertyName)) {
                // $NON-NLS-1$
                bootProtocol.setEnabled(NetworkBootProtocol.NONE, model.getNoneBootProtocolAvailable());
            } else if ("Message".equals(propertyName)) {
                // $NON-NLS-1$
                message.setText(model.getMessage());
            }
        }
    });
    object.getBondingOptions().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            ListModel<Map.Entry<String, EntityModel<String>>> list = (ListModel<Map.Entry<String, EntityModel<String>>>) sender;
            updateBondOptions(list);
        }
    });
    bondingModeEditor.setVisible(true);
    bondingModeEditor.asWidget().setVisible(true);
}
#end_block

#method_before
private void updateBondOptions(ListModel<Map.Entry<String, EntityModel<String>>> list) {
    Map.Entry<String, EntityModel<String>> pair = list.getSelectedItem();
    if ("custom".equals(pair.getKey())) {
        // $NON-NLS-1$
        customEditor.setVisible(true);
        String entity = pair.getValue().getEntity();
        // $NON-NLS-1$
        customEditor.asEditor().getSubEditor().setValue(entity == null ? "" : entity);
    } else {
        customEditor.setVisible(false);
    }
}
#method_after
private void updateBondOptions(ListModel<Map.Entry<String, EntityModel<String>>> list) {
    Map.Entry<String, EntityModel<String>> pair = list.getSelectedItem();
    if ("custom".equals(pair.getKey())) {
        // $NON-NLS-1$
        customBondEditor.setVisible(true);
        String entity = pair.getValue().getEntity();
        // $NON-NLS-1$
        customBondEditor.asEditor().getSubEditor().setValue(entity == null ? "" : entity);
    } else {
        customBondEditor.setVisible(false);
    }
}
#end_block

#method_before
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (originalInterface.getVlanId() == null) {
        // no vlan:
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else {
        // vlan:
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (originalInterface.getVlanId() == null) {
        // no vlan:
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (Objects.equals(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else {
        // vlan:
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (Objects.equals(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependencyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // TODO elevi ask if i can change "custom" to a constant that is share with HostBondPopup view\model, say by ApplicationConsts. enforcing by test is less recommended.
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    return getBondingOptionListDependingOnNetwork(defaultItem, false);
}
#end_block

#method_before
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#method_after
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return BondMode.BOND4.getConfigurationValue("150");
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    try {
        Map<String, Object> xmlRpcReturnValue = null;
        if (devicesList != null) {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType, devicesList);
        } else {
            xmlRpcReturnValue = vdsServer.getDeviceList(storageType);
        }
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    try {
        String[] idsList = devicesList == null ? new String[] {} : devicesList;
        Map<String, Object> xmlRpcReturnValue = vdsServer.getDeviceList(storageType, idsList, checkStatus);
        LUNListReturnForXmlRpc wrapper = new LUNListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks, memory);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.snapshot(vmId, disks, memory, frozen);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
}
#method_after
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String url, String user, String password, Map<String, Object> vm, String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.convertExternalVm(url, user, password, vm, jobUUID);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String url, String user, String password, Map<String, Object> vm, String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.convertExternalVm(url, user, password, vm, jobUUID);
        StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getConvertedVm(jobUUID);
        return new OvfReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getConvertedVm(jobUUID);
        return new OvfReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterStopProcesses();
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterProcessesStop();
        return new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDao().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
        }
    }
    logMonitorLockReleased("Activate");
    // Start glusterd service on the node, which would haven been stopped due to maintenance
    List<String> serviceList = new ArrayList<>();
    serviceList.add("glusterd");
    runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(getParameters().getVdsId(), serviceList, "restart"));
}
#method_after
@Override
protected void executeCommand() {
    final VDS vds = getVds();
    try (EngineLock monitoringLock = acquireMonitorLock()) {
        ExecutionHandler.updateSpecificActionJobCompleted(vds.getId(), VdcActionType.MaintenanceVds, false);
        setSucceeded(setVdsStatus(VDSStatus.Unassigned).getSucceeded());
        if (getSucceeded()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    // set network to operational / non-operational
                    List<Network> networks = getNetworkDao().getAllForCluster(vds.getVdsGroupId());
                    for (Network net : networks) {
                        NetworkClusterHelper.setStatus(vds.getVdsGroupId(), net);
                    }
                    return null;
                }
            });
            if (vds.getHighlyAvailableIsConfigured()) {
                SetHaMaintenanceModeVDSCommandParameters param = new SetHaMaintenanceModeVDSCommandParameters(vds, HaMaintenanceMode.LOCAL, false);
                if (!runVdsCommand(VDSCommandType.SetHaMaintenanceMode, param).getSucceeded()) {
                    haMaintenanceFailed = true;
                }
            }
            // Start glusterd service on the node, which would haven been stopped due to maintenance
            if (vds.getVdsGroupSupportsGlusterService()) {
                runVdsCommand(VDSCommandType.ManageGlusterService, new GlusterServiceVDSParameters(vds.getId(), Arrays.asList("glusterd"), "restart"));
            }
        }
    }
    logMonitorLockReleased("Activate");
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("status");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<String>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<Map<String, String>>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.stopProcesses").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
protected boolean failPassthroughVnicHotPlug() {
    if (VmInterfaceType.pciPassthrough.equals(VmInterfaceType.forValue(getParameters().getNic().getType()))) {
        addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
        return true;
    }
    return false;
}
#method_after
protected boolean failPassthroughVnicHotPlug() {
    if (VmInterfaceType.pciPassthrough == VmInterfaceType.forValue(getParameters().getNic().getType())) {
        addCanDoActionMessage(EngineMessage.HOT_PLUG_UNPLUG_PASSTHROUGH_VNIC_NOT_SUPPORTED);
        return true;
    }
    return false;
}
#end_block

#method_before
private void activateDataCenter() {
    StorageDomain masterDomain = getStorageDomainDao().getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).get(0);
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.Inactive)) {
        resetIrs();
    }
}
#method_after
private void activateDataCenter() {
    StorageDomain masterDomain = getStorageDomainDao().getStorageDomains(getStoragePool().getId(), StorageDomainType.Master).stream().findFirst().orElse(null);
    calcStoragePoolStatusByDomainsStatus();
    // fence spm if moving from not operational and master domain is active
    if (masterDomain != null && masterDomain.getStatus() != null && (masterDomain.getStatus() == StorageDomainStatus.Active || masterDomain.getStatus() == StorageDomainStatus.Unknown || masterDomain.getStatus() == StorageDomainStatus.Inactive)) {
        resetIrs();
    }
}
#end_block

#method_before
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    boolean returnValue = true;
    if (getStoragePoolIsoMap() == null) {
        returnValue = false;
        addCanDoActionMessage(EngineMessage.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    } else if (!isRemoveLast && isMaster()) {
        boolean isLastActive = getStorageDomainDao().getAllForStoragePool(getStorageDomain().getStoragePoolId()).stream().anyMatch(a -> a.getId().equals(getStorageDomain().getId()) && a.getStatus() == StorageDomainStatus.Active);
        if (!isLastActive) {
            returnValue = false;
            addCanDoActionMessage(EngineMessage.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
        }
    }
    return returnValue;
}
#method_after
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    boolean returnValue = true;
    if (getStoragePoolIsoMap() == null) {
        returnValue = false;
        addCanDoActionMessage(EngineMessage.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    } else if (!isRemoveLast && isMaster()) {
        returnValue = false;
        addCanDoActionMessage(EngineMessage.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkMasterDomainIsUp() {
    boolean returnValue = true;
    boolean hasUpMaster = getStorageDomainDao().getAllForStoragePool(getStoragePool().getId()).stream().anyMatch(a -> a.getStorageDomainType() == StorageDomainType.Master && a.getStatus() == StorageDomainStatus.Active);
    if (!hasUpMaster) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_MASTER_STORAGE_DOMAIN_NOT_ACTIVE);
        returnValue = false;
    }
    return returnValue;
}
#method_after
protected boolean checkMasterDomainIsUp() {
    boolean returnValue = true;
    boolean hasUpMaster = !getStorageDomainDao().getStorageDomains(getStoragePool().getId(), StorageDomainType.Master, StorageDomainStatus.Active).isEmpty();
    if (!hasUpMaster) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_MASTER_STORAGE_DOMAIN_NOT_ACTIVE);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    if (getStoragePoolIsoMap() == null) {
        return failCanDoAction(EngineMessage.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    }
    if (!isRemoveLast && isMaster()) {
        boolean isLastActive = getStorageDomainDao().getAllForStoragePool(getStorageDomain().getStoragePoolId()).stream().anyMatch(a -> a.getId().equals(getStorageDomain().getId()) && a.getStatus() == StorageDomainStatus.Active);
        if (!isLastActive) {
            return failCanDoAction(EngineMessage.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
        }
    }
    return true;
}
#method_after
protected boolean isDetachAllowed(final boolean isRemoveLast) {
    if (getStoragePoolIsoMap() == null) {
        return failCanDoAction(EngineMessage.STORAGE_DOMAIN_NOT_ATTACHED_TO_STORAGE_POOL);
    }
    if (!isRemoveLast && isMaster()) {
        return failCanDoAction(EngineMessage.ERROR_CANNOT_DETACH_LAST_STORAGE_DOMAIN);
    }
    return true;
}
#end_block

#method_before
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        eventQueue.submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), () -> resourceManager.getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true, getVDSReturnValue().getVdsError() != null && getVDSReturnValue().getVdsError().getCode() == EngineError.StoragePoolWrongMaster));
    } else {
        log.error("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool '{}'", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        eventQueue.submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), () -> eventListener.masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true, getVDSReturnValue().getVdsError() != null && getVDSReturnValue().getVdsError().getCode() == EngineError.StoragePoolWrongMaster));
    } else {
        log.error("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool '{}'", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
private void waitUntilSkipFencingIfSDActiveAllowed(boolean skipFencingIfSDActive) {
    if (skipFencingIfSDActive) {
        // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
        // so we need to be sure not to execute fencing before host is non responsive for longer time
        long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
        long lastUpdate = getResourceManager().getVdsManager(getVdsId()).getLastUpdate();
        long difference = System.currentTimeMillis() - lastUpdate;
        if (difference < interval) {
            int sleepMs = (int) (interval - difference);
            log.info("Sleeping {} ms before proceeding with fence execution", sleepMs);
            ThreadUtils.sleep(sleepMs);
        }
    }
}
#method_after
private void waitUntilSkipFencingIfSDActiveAllowed(boolean skipFencingIfSDActive) {
    if (skipFencingIfSDActive) {
        // host storage lease should be renewed each ConfigValues.HostStorageLeaseAliveInterval
        // so we need to be sure not to execute fencing before host is non responsive for longer time
        long interval = TimeUnit.SECONDS.toMillis(Config.<Integer>getValue(ConfigValues.HostStorageLeaseAliveCheckingInterval));
        long lastUpdate = getResourceManager().getVdsManager(getVdsId()).getLastUpdate();
        long difference = System.currentTimeMillis() - lastUpdate;
        if (difference < interval) {
            long sleepMs = interval - difference;
            log.info("Sleeping {} ms before proceeding with fence execution", sleepMs);
            ThreadUtils.sleep(sleepMs);
        }
    }
}
#end_block

#method_before
private boolean checkIfHostBecomeUp() {
    VdsManager vdsManager = getResourceManager().getVdsManager(getVdsId());
    int sleepInterval = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    while (vdsManager.isHostInGracePeriod(true)) {
        if (vdsManager.getCopyVds().getStatus() == VDSStatus.Up) {
            // host became Up during grace period
            return true;
        }
        // wait until next host monitoring attempt
        ThreadUtils.sleep(sleepInterval);
    }
    return false;
}
#method_after
private boolean checkIfHostBecomeUp() {
    VdsManager vdsManager = getResourceManager().getVdsManager(getVdsId());
    long sleepInterval = Config.<Integer>getValue(ConfigValues.VdsRefreshRate) * 1000;
    while (vdsManager.isHostInGracePeriod(true)) {
        if (vdsManager.getCopyVds().getStatus() == VDSStatus.Up) {
            // host became Up during grace period
            return true;
        }
        // wait until next host monitoring attempt
        ThreadUtils.sleep(sleepInterval);
    }
    return false;
}
#end_block

#method_before
private static <T extends Nameable> List<ClusterEditWarnings.Warning> getProblematicEntities(VDSGroup oldCluster, VDSGroup newCluster, Iterable<ClusterEditChecker<T>> checkers, ClusterEntityResolver<T> entityResolver) {
    List<ClusterEditWarnings.Warning> warnings = new ArrayList<>();
    List<ClusterEditChecker<T>> applicableChecks = stream(checkers.spliterator(), false).filter(checker -> checker.isApplicable(oldCluster, newCluster)).collect(toList());
    if (!applicableChecks.isEmpty()) {
        List<T> entities = entityResolver.getClusterEntities(oldCluster);
        for (ClusterEditChecker<T> checker : applicableChecks) {
            ClusterEditWarnings.Warning warning = new ClusterEditWarnings.Warning(checker.getMainMessage());
            entities.stream().filter(entity -> !checker.check(entity)).forEach(entity -> {
                warning.getDetailsByName().put(entity.getName(), checker.getDetailMessage(entity));
            });
            if (!warning.isEmpty()) {
                warnings.add(warning);
            }
        }
    }
    return warnings;
}
#method_after
private static <T extends Nameable> List<ClusterEditWarnings.Warning> getProblematicEntities(VDSGroup oldCluster, VDSGroup newCluster, Iterable<ClusterEditChecker<T>> checkers, ClusterEntityResolver<T> entityResolver) {
    List<ClusterEditWarnings.Warning> warnings = new ArrayList<>();
    List<ClusterEditChecker<T>> applicableChecks = stream(checkers.spliterator(), false).filter(checker -> checker.isApplicable(oldCluster, newCluster)).collect(toList());
    if (!applicableChecks.isEmpty()) {
        List<T> entities = entityResolver.getClusterEntities(oldCluster);
        for (ClusterEditChecker<T> checker : applicableChecks) {
            ClusterEditWarnings.Warning warning = new ClusterEditWarnings.Warning(checker.getMainMessage());
            entities.stream().filter(entity -> !checker.check(entity)).forEach(entity -> warning.getDetailsByName().put(entity.getName(), checker.getDetailMessage(entity)));
            if (!warning.isEmpty()) {
                warnings.add(warning);
            }
        }
    }
    return warnings;
}
#end_block

#method_before
@Override
public Guid getStorageDomainId() {
    if (cachedStorageDomainId == null) {
        List<DiskImage> diskDummiesForMemSize = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.META_DATA_SIZE_IN_BYTES);
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getStoragePoolId(), diskDummiesForMemSize, ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), false, false, false), getVm());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#method_after
@Override
public Guid getStorageDomainId() {
    if (cachedStorageDomainId == null) {
        List<DiskImage> diskDummiesForMemSize = MemoryUtils.createDiskDummies(getVm().getTotalMemorySizeInBytes(), MemoryUtils.METADATA_SIZE_IN_BYTES);
        StorageDomain storageDomain = MemoryStorageHandler.getInstance().findStorageDomainForMemory(getStoragePoolId(), diskDummiesForMemSize, ImagesHandler.filterImageDisks(getDiskDao().getAllForVm(getVmId()), false, false, false), getVm());
        if (storageDomain != null) {
            cachedStorageDomainId = storageDomain.getId();
        }
    }
    return cachedStorageDomainId;
}
#end_block

#method_before
private DiskImage getMemoryDumpDisk(List<VdcReturnValueBase> returnValues) {
    for (VdcReturnValueBase returnValue : returnValues) {
        DiskImage disk = returnValue.getActionReturnValue();
        if (disk.getSize() != MemoryUtils.META_DATA_SIZE_IN_BYTES) {
            return disk;
        }
    }
    return null;
}
#method_after
private DiskImage getMemoryDumpDisk(List<VdcReturnValueBase> returnValues) {
    for (VdcReturnValueBase returnValue : returnValues) {
        DiskImage disk = returnValue.getActionReturnValue();
        if (disk.getSize() != MemoryUtils.METADATA_SIZE_IN_BYTES) {
            return disk;
        }
    }
    return null;
}
#end_block

#method_before
private DiskImage getMemoryMetadataDisk(List<VdcReturnValueBase> returnValues) {
    for (VdcReturnValueBase returnValue : returnValues) {
        DiskImage disk = returnValue.getActionReturnValue();
        if (disk.getSize() == MemoryUtils.META_DATA_SIZE_IN_BYTES) {
            return disk;
        }
    }
    return null;
}
#method_after
private DiskImage getMemoryMetadataDisk(List<VdcReturnValueBase> returnValues) {
    for (VdcReturnValueBase returnValue : returnValues) {
        DiskImage disk = returnValue.getActionReturnValue();
        if (disk.getSize() == MemoryUtils.METADATA_SIZE_IN_BYTES) {
            return disk;
        }
    }
    return null;
}
#end_block

#method_before
public static <T extends Disk> boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.SPAPR_VSCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#method_after
public static <T extends Disk> boolean checkPciAndIdeLimit(int osId, Version clusterVersion, int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, boolean hasWatchdog, boolean isBalloonEnabled, boolean isSoundDeviceEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.spaprVlan) {
        // Do not count sPAPR VLAN devices since they are not PCI
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    // VmWatchdog controller requires one PCI slot
    pciInUse += hasWatchdog ? 1 : 0;
    // Balloon controller requires one PCI slot
    pciInUse += isBalloonEnabled ? 1 : 0;
    // Sound device controller requires one PCI slot
    pciInUse += isSoundDeviceEnabled ? 1 : 0;
    OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
    int maxPciSlots = osRepository.getMaxPciDevices(osId, clusterVersion);
    if (pciInUse > maxPciSlots) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    } else if (MAX_VIRTIO_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_VIRTIO_SCSI_DISKS.name());
    } else if (MAX_SPAPR_SCSI_DISKS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.SPAPR_VSCSI;
        }
    }).size()) {
        result = false;
        messages.add(EngineMessage.ACTION_TYPE_FAILED_EXCEEDED_MAX_SPAPR_VSCSI_DISKS.name());
    }
    return result;
}
#end_block

#method_before
public static DiskImage createMetadataDisk() {
    DiskImage image = new DiskImage();
    image.setSize(MemoryUtils.META_DATA_SIZE_IN_BYTES);
    image.setVolumeType(VolumeType.Sparse);
    image.setvolumeFormat(VolumeFormat.COW);
    image.setDiskInterface(DiskInterface.VirtIO);
    return image;
}
#method_after
public static DiskImage createMetadataDisk() {
    DiskImage image = new DiskImage();
    image.setSize(MemoryUtils.METADATA_SIZE_IN_BYTES);
    image.setVolumeType(VolumeType.Sparse);
    image.setvolumeFormat(VolumeFormat.COW);
    image.setDiskInterface(DiskInterface.VirtIO);
    return image;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        updatedLun = getLunDisk(lun, getVds());
        if (updatedLun == null) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
            return false;
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded(DiskValidator diskValidator) {
    LunDisk lunDisk = ((LunDisk) getParameters().getDiskInfo());
    LUNs lun = lunDisk.getLun();
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
        default:
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!validate(diskValidator.isDiskInterfaceSupported(getVm()))) {
        return false;
    }
    if (getVds() != null) {
        lunFromStorage = getLunDisk(lun, getVds());
        if (lunFromStorage == null) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_DISK_LUN_INVALID);
        }
    }
    if (!validate(diskValidator.isUsingScsiReservationValid(getVm(), lunDisk))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (updatedLun == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = updatedLun;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#method_after
private void createDiskBasedOnLun() {
    final LUNs lun;
    if (lunFromStorage == null) {
        lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    } else {
        lun = lunFromStorage;
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            StorageDomainCommandBase.proceedLUNInDb(lun, lun.getLunType());
            getBaseDiskDao().save(getParameters().getDiskInfo());
            getDiskLunMapDao().save(new DiskLunMap(getParameters().getDiskInfo().getId(), lun.getLUN_id()));
            if (getVm() != null) {
                addManagedDeviceForDisk(getParameters().getDiskInfo().getId(), ((LunDisk) getParameters().getDiskInfo()).isUsingScsiReservation());
            }
            return null;
        }
    });
    getReturnValue().setActionReturnValue(getParameters().getDiskInfo().getId());
    plugDiskToVmIfNeeded();
    setSucceeded(true);
}
#end_block

#method_before
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    StoragePool sp = DbFacade.getInstance().getStoragePoolDao().getForVds(vds.getId());
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(sp, vds, false);
    return backend.runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#method_after
@Override
public boolean connectHostToDomainsInActiveOrUnknownStatus(VDS vds) {
    StoragePool sp = storagePoolDao.get(vds.getStoragePoolId());
    ConnectHostToStoragePoolServersParameters params = new ConnectHostToStoragePoolServersParameters(sp, vds, false);
    return backend.runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params).getSucceeded();
}
#end_block

#method_before
@Override
protected void verify(SchedulingPolicy model, SchedulingPolicy transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.isLocked(), transform.isLocked());
    assertEquals(model.isDefaultPolicy(), transform.isDefaultPolicy());
    assertNotNull(model.getProperties());
    assertEquals(CustomPropertiesParser.toMap(model.getProperties()), CustomPropertiesParser.toMap(transform.getProperties()));
    // verify backward compatibility with policy property
    assertEquals(model.getName(), transform.getPolicy());
    assertEquals(transform.getPolicy(), transform.getName());
}
#method_after
@Override
protected void verify(SchedulingPolicy model, SchedulingPolicy transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.isLocked(), transform.isLocked());
    assertEquals(model.isDefaultPolicy(), transform.isDefaultPolicy());
    assertNotNull(model.getProperties());
    assertEquals(CustomPropertiesParser.toMap(model.getProperties()), CustomPropertiesParser.toMap(transform.getProperties()));
}
#end_block

#method_before
@Mapping(from = ClusterPolicy.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(ClusterPolicy entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setPolicy(entity.getName());
    model.setDescription(entity.getDescription());
    model.setLocked(entity.isLocked());
    model.setDefaultPolicy(entity.isDefaultPolicy());
    if (entity.getParameterMap() != null && !entity.getParameterMap().isEmpty()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getParameterMap()));
    }
    return model;
}
#method_after
@Mapping(from = ClusterPolicy.class, to = SchedulingPolicy.class)
public static SchedulingPolicy map(ClusterPolicy entity, SchedulingPolicy template) {
    SchedulingPolicy model = template != null ? template : new SchedulingPolicy();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setLocked(entity.isLocked());
    model.setDefaultPolicy(entity.isDefaultPolicy());
    if (entity.getParameterMap() != null && !entity.getParameterMap().isEmpty()) {
        model.setProperties(CustomPropertiesParser.fromMap(entity.getParameterMap()));
    }
    return model;
}
#end_block

#method_before
public boolean isVf() {
    return vf;
}
#method_after
public boolean isVf() {
    return physicalFunction != null;
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2());
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), hostSetupNetworksParametersData).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) networkCommand.getOp1(), (NetworkInterfaceModel) networkCommand.getOp2());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName, doesBondHaveVmNetworkAttached);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2(), doesBondHaveVmNetworkAttached);
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), hostSetupNetworksParametersData).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress();
        queryLabels();
        queryVfMap();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#method_after
private void initAllModels(boolean fetchFromBackend) {
    if (fetchFromBackend) {
        // run query for networks, this chains the query for nics, and also stops progress when done
        startProgress();
        queryLabels();
    } else {
        initLabelModels();
        initNetworkModels();
        initNicModels();
    }
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    final Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(allNics);
    final Map<String, VdsNetworkInterface> nicMap = Entities.entitiesByName(allNics);
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, false, null, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                NetworkAttachment existingNetworkAttachment = getExistingAttachmentByNetworkId(networkModel.getNetwork().getId());
                netToBeforeSyncParams.put(networkName, createBeforeSyncNetParams(nic, existingNetworkAttachment));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                final boolean vf = vfMap.containsKey(bonded.getId());
                final VdsNetworkInterface physicalFunction;
                if (vf) {
                    final Guid pfId = vfMap.get(bonded.getId());
                    physicalFunction = nicsById.get(pfId);
                } else {
                    physicalFunction = null;
                }
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), vf, physicalFunction, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            final boolean vf = vfMap.containsKey(nic.getId());
            final VdsNetworkInterface physicalFunction;
            if (vf) {
                final Guid pfId = vfMap.get(nic.getId());
                physicalFunction = nicsById.get(pfId);
            } else {
                physicalFunction = null;
            }
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), vf, physicalFunction, this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<>();
    labelToIface.clear();
    // map all nics
    final Map<Guid, VdsNetworkInterface> nicsById = Entities.businessEntitiesById(allNics);
    final Map<String, VdsNetworkInterface> nicMap = Entities.entitiesByName(allNics);
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final boolean isVlan = nic.getVlanId() != null;
        if (!isVlan) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (isVlan) {
            ifName = nic.getBaseInterface();
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getNetwork().setVlanId(nic.getVlanId());
                networkModel.getNetwork().setMtu(nic.getMtu());
                networkModel.getNetwork().setVmNetwork(nic.isBridged());
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<>();
            nicNetworks.add(networkModel);
            // set vlan device on the network
            if (networkModel.hasVlan()) {
                NetworkInterfaceModel existingEridge = networkModel.getVlanNicModel();
                // $NON-NLS-1$
                assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
                networkModel.setVlanNicModel(new NetworkInterfaceModel(nic, nicNetworks, null, false, null, this));
            }
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                NetworkAttachment existingNetworkAttachment = getExistingAttachmentByNetworkId(networkModel.getNetwork().getId());
                netToBeforeSyncParams.put(networkName, createBeforeSyncNetParams(nic, existingNetworkAttachment));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    nicLabels.add(labelModel);
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<>();
            for (VdsNetworkInterface bonded : bondedNics) {
                final VdsNetworkInterface physicalFunction = findPhysicalFunction(nicsById, bonded.getId());
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, nicToVfsConfig.containsKey(bonded.getId()), physicalFunction, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            BondNetworkInterfaceModel bondNetworkInterfaceModel = new BondNetworkInterfaceModel((Bond) nic, nicNetworks, nicLabels, bondedModels, this);
            nicModels.put(nicName, bondNetworkInterfaceModel);
        } else {
            final VdsNetworkInterface physicalFunction = findPhysicalFunction(nicsById, nic.getId());
            NetworkInterfaceModel nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, nicToVfsConfig.containsKey(nic.getId()), physicalFunction, this);
            nicModels.put(nicName, nicModel);
        }
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void queryVfMap() {
    final AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            vfMap = returnValue.getReturnValue();
            // chain the network attachments query
            queryNetworkAttachments();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVfMap, params, asyncQuery);
}
#method_after
private void queryVfMap() {
    final AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            VdcQueryReturnValue returnValue = (VdcQueryReturnValue) returnValueObj;
            vfMap = returnValue.getReturnValue();
            if (vfMap == null) {
                vfMap = Collections.emptyMap();
            }
            // chain the free bonds query
            queryFreeBonds();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVfToPfMapByHostId, params, asyncQuery);
}
#end_block

#method_before
private void queryVfsConfig() {
    // query for vfsConfigs
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            Object returnValue = ((VdcQueryReturnValue) returnValueObj).getReturnValue();
            List<HostNicVfsConfig> allHostVfs = (List<HostNicVfsConfig>) returnValue;
            for (HostNicVfsConfig vfsConfig : allHostVfs) {
                originalVfsConfigs.add(vfsConfig);
                nicToVfsConfig.put(vfsConfig.getNicId(), new HostNicVfsConfig(vfsConfig));
            }
            // chain the free bonds query
            queryFreeBonds();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVfsConfigByHostId, params, asyncQuery);
}
#method_after
private void queryVfsConfig() {
    // query for vfsConfigs
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValueObj) {
            Object returnValue = ((VdcQueryReturnValue) returnValueObj).getReturnValue();
            List<HostNicVfsConfig> allHostVfs = (List<HostNicVfsConfig>) returnValue;
            for (HostNicVfsConfig vfsConfig : allHostVfs) {
                originalVfsConfigs.add(vfsConfig);
                nicToVfsConfig.put(vfsConfig.getNicId(), new HostNicVfsConfig(vfsConfig));
            }
            queryVfMap();
        }
    };
    VDS vds = getEntity();
    IdQueryParameters params = new IdQueryParameters(vds.getId());
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVfsConfigByHostId, params, asyncQuery);
}
#end_block

#method_before
private HostDevice getPciDeviceByNic(final VdsNetworkInterface nic, List<HostDevice> deviceList) {
    return getPciDeviceByNic(nic, deviceList, daoHostDeviceFinder);
}
#method_after
private HostDevice getPciDeviceByNic(final VdsNetworkInterface nic, List<HostDevice> deviceList) {
    return getPciDeviceByNic(nic, deviceList, Entities.entitiesByName(deviceList));
}
#end_block

#method_before
private HostDevice getPciDeviceByNic(final VdsNetworkInterface nic, List<HostDevice> deviceList, HostDeviceFinder hostDeviceFinder) {
    final HostDevice netDevice = LinqUtils.firstOrNull(deviceList, new Predicate<HostDevice>() {

        @Override
        public boolean eval(HostDevice device) {
            return nic.getName().equals(device.getNetworkInterfaceName());
        }
    });
    Objects.requireNonNull(netDevice, "nic doesn't have a net device");
    final HostDevice pciDevice = hostDeviceFinder.findHostDevice(nic.getVdsId(), netDevice.getParentDeviceName());
    Objects.requireNonNull(pciDevice, "net device doesn't have a parent pci device");
    return pciDevice;
}
#method_after
private HostDevice getPciDeviceByNic(final VdsNetworkInterface nic, List<HostDevice> deviceList, Map<String, HostDevice> devicesByName) {
    final String nicName = nic.getName();
    final HostDevice netDevice = LinqUtils.firstOrNull(deviceList, new Predicate<HostDevice>() {

        @Override
        public boolean eval(HostDevice device) {
            return nicName.equals(device.getNetworkInterfaceName());
        }
    });
    Objects.requireNonNull(netDevice, String.format("Host \"%s\": nic \"%s\" doesn't have a net device", nic.getVdsName(), nicName));
    final String parentDeviceName = netDevice.getParentDeviceName();
    final HostDevice pciDevice = devicesByName.get(parentDeviceName);
    Objects.requireNonNull(pciDevice, String.format("Host \"%s\": net device \"%s\" doesn't have a parent pci device \"%s\"", nic.getVdsName(), netDevice.getName(), parentDeviceName));
    return pciDevice;
}
#end_block

#method_before
@Override
public Map<Guid, Guid> getVfMap(final Guid hostId) {
    final List<VdsNetworkInterface> hostNics = interfaceDao.getAllInterfacesForVds(hostId);
    final List<HostDevice> hostDevices = hostDeviceDao.getHostDevicesByHostId(hostId);
    final Map<String, HostDevice> hostDevicesByName = Entities.entitiesByName(hostDevices);
    final List<VdsNetworkInterface> vfNics = LinqUtils.filter(hostNics, new VfNicPredicate(hostDevices, hostDevicesByName));
    final Map<Guid, Guid> result = LinqUtils.toMap(vfNics, new VfNicToPfNicMapper(hostDevices, hostDevicesByName, hostNics));
    return result;
}
#method_after
@Override
public Map<Guid, Guid> getVfMap(final Guid hostId) {
    final VDS host = vdsDao.get(hostId);
    if (!FeatureSupported.sriov(host.getVdsGroupCompatibilityVersion())) {
        return Collections.emptyMap();
    }
    final List<VdsNetworkInterface> hostNics = interfaceDao.getAllInterfacesForVds(hostId);
    final List<HostDevice> hostDevices = hostDeviceDao.getHostDevicesByHostId(hostId);
    final Map<String, HostDevice> hostDevicesByName = Entities.entitiesByName(hostDevices);
    final List<VdsNetworkInterface> vfNics = LinqUtils.filter(hostNics, new VfNicPredicate(hostDevices, hostDevicesByName));
    final Map<Guid, Guid> result = LinqUtils.toMap(vfNics, new VfNicToPfNicMapper(hostDevices, hostDevicesByName, hostNics));
    return result;
}
#end_block

#method_before
@Override
public Guid createValue(VdsNetworkInterface nic) {
    final HostDevice vfPciDevice = getPciDeviceByNic(nic, hostDevices, new CacheHostDeviceFinder(hostDevicesByName));
    final HostDevice pfPciDevice = hostDevicesByName.get(vfPciDevice.getParentPhysicalFunction());
    final VdsNetworkInterface pfNic = getNicByPciDevice(pfPciDevice, hostDevices, hostNics);
    return pfNic == null ? null : pfNic.getId();
}
#method_after
@Override
public Guid createValue(VdsNetworkInterface nic) {
    final HostDevice vfPciDevice = getPciDeviceByNic(nic, hostDevices, hostDevicesByName);
    final HostDevice pfPciDevice = hostDevicesByName.get(vfPciDevice.getParentPhysicalFunction());
    final VdsNetworkInterface pfNic = getNicByPciDevice(pfPciDevice, hostDevices, hostNics);
    return pfNic == null ? null : pfNic.getId();
}
#end_block

#method_before
@Override
public boolean eval(VdsNetworkInterface nic) {
    if (nic.isBond() || NetworkUtils.isVlan(nic)) {
        return false;
    }
    final HostDevice nicPciDevice = getPciDeviceByNic(nic, hostDevices, new CacheHostDeviceFinder(hostDevicesByName));
    return isVf(nicPciDevice);
}
#method_after
@Override
public boolean eval(VdsNetworkInterface nic) {
    if (nic.isBond() || NetworkUtils.isVlan(nic)) {
        return false;
    }
    try {
        final HostDevice nicPciDevice = getPciDeviceByNic(nic, hostDevices, hostDevicesByName);
        return isVf(nicPciDevice);
    } catch (Exception e) {
        return false;
    }
}
#end_block

#method_before
@Before
public void setUp() {
    networkDeviceHelper = new NetworkDeviceHelperImpl(interfaceDao, hostDeviceDao, hostNicVfsConfigDao);
    when(netDevice.getHostId()).thenReturn(HOST_ID);
    when(netDevice.getDeviceName()).thenReturn(NET_DEVICE_NAME);
    when(netDevice.getName()).thenReturn(NET_DEVICE_NAME);
    when(netDevice.getNetworkInterfaceName()).thenReturn(NIC_NAME);
    when(netDevice.getParentDeviceName()).thenReturn(PCI_DEVICE_NAME);
    when(pciDevice.getHostId()).thenReturn(HOST_ID);
    when(pciDevice.getDeviceName()).thenReturn(PCI_DEVICE_NAME);
    when(pciDevice.getName()).thenReturn(PCI_DEVICE_NAME);
    when(hostDeviceDao.getHostDeviceByHostIdAndDeviceName(HOST_ID, PCI_DEVICE_NAME)).thenReturn(pciDevice);
    List<HostDevice> devices = new ArrayList<>();
    devices.add(netDevice);
    devices.add(pciDevice);
    mockHostDevices(devices);
    when(nic.getId()).thenReturn(NIC_ID);
    when(nic.getName()).thenReturn(NIC_NAME);
    when(nic.getVdsId()).thenReturn(HOST_ID);
    when(interfaceDao.get(NIC_ID)).thenReturn(nic);
    when(nic.getName()).thenReturn(NIC_NAME);
    when(hostNicVfsConfig.getNicId()).thenReturn(NIC_ID);
    when(hostNicVfsConfigDao.getByNicId(NIC_ID)).thenReturn(hostNicVfsConfig);
}
#method_after
@Before
public void setUp() {
    networkDeviceHelper = new NetworkDeviceHelperImpl(interfaceDao, hostDeviceDao, hostNicVfsConfigDao, vdsDao);
    when(netDevice.getHostId()).thenReturn(HOST_ID);
    when(netDevice.getDeviceName()).thenReturn(NET_DEVICE_NAME);
    when(netDevice.getName()).thenReturn(NET_DEVICE_NAME);
    when(netDevice.getNetworkInterfaceName()).thenReturn(NIC_NAME);
    when(netDevice.getParentDeviceName()).thenReturn(PCI_DEVICE_NAME);
    when(pciDevice.getHostId()).thenReturn(HOST_ID);
    when(pciDevice.getDeviceName()).thenReturn(PCI_DEVICE_NAME);
    when(pciDevice.getName()).thenReturn(PCI_DEVICE_NAME);
    List<HostDevice> devices = new ArrayList<>();
    devices.add(netDevice);
    devices.add(pciDevice);
    mockHostDevices(devices);
    when(nic.getId()).thenReturn(NIC_ID);
    when(nic.getName()).thenReturn(NIC_NAME);
    when(nic.getVdsId()).thenReturn(HOST_ID);
    when(interfaceDao.get(NIC_ID)).thenReturn(nic);
    when(nic.getName()).thenReturn(NIC_NAME);
    when(hostNicVfsConfig.getNicId()).thenReturn(NIC_ID);
    when(hostNicVfsConfigDao.getByNicId(NIC_ID)).thenReturn(hostNicVfsConfig);
}
#end_block

#method_before
private List<HostDevice> freeVfCommon(int numOfFreeVfs, int numOfVfsAttachedToVm, int numOfVfsHasNoNic, int numOfVfsHasNetworkAttached, int numOfVfsHasVlanDeviceAttached) {
    networkDeviceHelper = spy(new NetworkDeviceHelperImpl(interfaceDao, hostDeviceDao, hostNicVfsConfigDao));
    List<HostDevice> devices = new ArrayList<>();
    List<HostDevice> freeVfs = new ArrayList<>();
    int numOfVfs = numOfFreeVfs + numOfVfsAttachedToVm + numOfVfsHasNoNic + numOfVfsHasNetworkAttached + numOfVfsHasVlanDeviceAttached;
    List<HostDevice> vfs = mockVfsOnNetDevice(numOfVfs);
    List<VdsNetworkInterface> nics = new ArrayList<>();
    devices.addAll(vfs);
    for (HostDevice vfPciDevice : vfs) {
        HostDevice vfNetDevice = mockNetworkDeviceForPciDevice(vfPciDevice);
        devices.add(vfNetDevice);
        if (numOfVfsHasNoNic != 0) {
            --numOfVfsHasNoNic;
        } else {
            VdsNetworkInterface vfNic = mockNicForNetDevice(vfNetDevice);
            nics.add(vfNic);
            if (numOfVfsAttachedToVm != 0) {
                --numOfVfsAttachedToVm;
                vfPciDevice.setVmId(Guid.newGuid());
            } else if (numOfVfsHasNetworkAttached != 0) {
                --numOfVfsHasNetworkAttached;
                vfNic.setNetworkName("netName");
            } else if (numOfVfsHasVlanDeviceAttached != 0) {
                --numOfVfsHasVlanDeviceAttached;
                doReturn(true).when(networkDeviceHelper).isVlanDeviceAttached(vfNic);
            } else {
                doReturn(false).when(networkDeviceHelper).isVlanDeviceAttached(vfNic);
                freeVfs.add(vfPciDevice);
            }
        }
    }
    mockHostDevices(devices);
    mockNics(nics, true);
    return freeVfs;
}
#method_after
private List<HostDevice> freeVfCommon(int numOfFreeVfs, int numOfVfsAttachedToVm, int numOfVfsHasNoNic, int numOfVfsHasNetworkAttached, int numOfVfsHasVlanDeviceAttached) {
    networkDeviceHelper = spy(new NetworkDeviceHelperImpl(interfaceDao, hostDeviceDao, hostNicVfsConfigDao, vdsDao));
    List<HostDevice> devices = new ArrayList<>();
    List<HostDevice> freeVfs = new ArrayList<>();
    int numOfVfs = numOfFreeVfs + numOfVfsAttachedToVm + numOfVfsHasNoNic + numOfVfsHasNetworkAttached + numOfVfsHasVlanDeviceAttached;
    List<HostDevice> vfs = mockVfsOnNetDevice(numOfVfs);
    List<VdsNetworkInterface> nics = new ArrayList<>();
    devices.addAll(vfs);
    for (HostDevice vfPciDevice : vfs) {
        HostDevice vfNetDevice = mockNetworkDeviceForPciDevice(vfPciDevice);
        devices.add(vfNetDevice);
        if (numOfVfsHasNoNic != 0) {
            --numOfVfsHasNoNic;
        } else {
            VdsNetworkInterface vfNic = mockNicForNetDevice(vfNetDevice);
            nics.add(vfNic);
            if (numOfVfsAttachedToVm != 0) {
                --numOfVfsAttachedToVm;
                vfPciDevice.setVmId(Guid.newGuid());
            } else if (numOfVfsHasNetworkAttached != 0) {
                --numOfVfsHasNetworkAttached;
                vfNic.setNetworkName("netName");
            } else if (numOfVfsHasVlanDeviceAttached != 0) {
                --numOfVfsHasVlanDeviceAttached;
                doReturn(true).when(networkDeviceHelper).isVlanDeviceAttached(vfNic);
            } else {
                doReturn(false).when(networkDeviceHelper).isVlanDeviceAttached(vfNic);
                freeVfs.add(vfPciDevice);
            }
        }
    }
    mockHostDevices(devices);
    mockNics(nics, true);
    return freeVfs;
}
#end_block

#method_before
@Test
public void testGetVfMap() {
    final HostDevice pfNetDevice = new HostDevice();
    final HostDevice pfPciDevice = new HostDevice();
    final Guid pfNicId = Guid.newGuid();
    final String pfNicName = "pf" + NIC_NAME;
    final String pfPciDeviceName = "pf" + PCI_DEVICE_NAME;
    pfNetDevice.setHostId(HOST_ID);
    pfNetDevice.setDeviceName("pf" + NET_DEVICE_NAME);
    pfNetDevice.setNetworkInterfaceName(pfNicName);
    pfNetDevice.setParentDeviceName(pfPciDeviceName);
    pfPciDevice.setHostId(HOST_ID);
    pfPciDevice.setDeviceName(pfPciDeviceName);
    pfPciDevice.setDeviceName(pfPciDeviceName);
    when(pciDevice.getParentPhysicalFunction()).thenReturn(pfPciDeviceName);
    mockHostDevices(Arrays.asList(pfNetDevice, pfPciDevice, new HostDevice()));
    when(nic.getVlanId()).thenReturn(null);
    final VdsNetworkInterface pfNic = new VdsNetworkInterface();
    pfNic.setId(pfNicId);
    pfNic.setName(pfNetDevice.getNetworkInterfaceName());
    final VdsNetworkInterface bondNic = new VdsNetworkInterface();
    bondNic.setBonded(true);
    final VdsNetworkInterface vlanNic = new VdsNetworkInterface();
    vlanNic.setVlanId(666);
    mockNics(Arrays.asList(pfNic, bondNic, vlanNic), true);
    final Map<Guid, Guid> actual = networkDeviceHelper.getVfMap(HOST_ID);
    assertEquals(1, actual.size());
    assertThat(actual, hasEntry(NIC_ID, pfNicId));
}
#method_after
@Test
public void testGetVfMap() {
    final HostDevice pfNetDevice = new HostDevice();
    final HostDevice pfPciDevice = new HostDevice();
    final Guid pfNicId = Guid.newGuid();
    final String pfNicName = "pf" + NIC_NAME;
    final String pfPciDeviceName = "pf" + PCI_DEVICE_NAME;
    pfNetDevice.setHostId(HOST_ID);
    pfNetDevice.setDeviceName("pf" + NET_DEVICE_NAME);
    pfNetDevice.setNetworkInterfaceName(pfNicName);
    pfNetDevice.setParentDeviceName(pfPciDeviceName);
    pfPciDevice.setHostId(HOST_ID);
    pfPciDevice.setDeviceName(pfPciDeviceName);
    pfPciDevice.setDeviceName(pfPciDeviceName);
    when(pciDevice.getParentPhysicalFunction()).thenReturn(pfPciDeviceName);
    mockHostDevices(Arrays.asList(pfNetDevice, pfPciDevice, new HostDevice()));
    when(nic.getVlanId()).thenReturn(null);
    final VdsNetworkInterface pfNic = new VdsNetworkInterface();
    pfNic.setId(pfNicId);
    pfNic.setName(pfNetDevice.getNetworkInterfaceName());
    final VdsNetworkInterface bondNic = new VdsNetworkInterface();
    bondNic.setBonded(true);
    final VdsNetworkInterface vlanNic = new VdsNetworkInterface();
    vlanNic.setVlanId(666);
    mockNics(Arrays.asList(pfNic, bondNic, vlanNic), true);
    mockHostSupportsSriov(true);
    final Map<Guid, Guid> actual = networkDeviceHelper.getVfMap(HOST_ID);
    assertEquals(1, actual.size());
    assertThat(actual, hasEntry(NIC_ID, pfNicId));
}
#end_block

#method_before
@Override
public Host get() {
    // the "refresh" action and removed in the future.
    if (isForce()) {
        performAction(VdcActionType.RefreshHost, new VdsActionParameters(guid));
    }
    Host host = getVdsByVdsId();
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host get() {
    return getVdsByVdsId();
}
#end_block

#method_before
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    deprecatedAddLinksToAgents(host);
    return host;
}
#method_after
@Override
public Host update(Host incoming) {
    validateEnums(Host.class, incoming);
    QueryIdResolver<Guid> hostResolver = new QueryIdResolver<Guid>(VdcQueryType.GetVdsByVdsId, IdQueryParameters.class);
    VDS entity = getEntity(hostResolver, true);
    if (incoming.isSetCluster() && (incoming.getCluster().isSetId() || incoming.getCluster().isSetName())) {
        Guid clusterId = lookupClusterId(incoming);
        if (!clusterId.equals(entity.getVdsGroupId())) {
            performAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(clusterId, guid));
            // After changing the cluster with the specialized command we need to reload the entity, so that it
            // contains the new cluster id. If we don't do this the next command will think that we are trying
            // to change the cluster, and it will explicitly refuse to perform the update.
            entity = getEntity(hostResolver, true);
        }
    }
    Host host = performUpdate(incoming, entity, map(entity), hostResolver, VdcActionType.UpdateVds, new UpdateParametersProvider());
    return host;
}
#end_block

#method_before
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetModifiedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getModifiedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetSynchronizedNetworkAttachments()) {
        Map<Guid, NetworkAttachment> networkAttachmentFromParams = Entities.businessEntitiesById(parameters.getNetworkAttachments());
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getSynchronizedNetworkAttachments().getNetworkAttachments()) {
            if (model.isSetId()) {
                Guid networkAttachmentId = asGuid(model.getId());
                if (networkAttachmentFromParams.containsKey(networkAttachmentId)) {
                    networkAttachmentFromParams.get(networkAttachmentId).setOverrideConfiguration(true);
                } else if (attachmentsById.containsKey(networkAttachmentId)) {
                    NetworkAttachment networkAttachment = attachmentsById.get(networkAttachmentId);
                    networkAttachment.setOverrideConfiguration(true);
                    parameters.getNetworkAttachments().add(networkAttachment);
                } else {
                    return handleError(new EntityNotFoundException("NetworkAttachment.id: " + model.getId()), true);
                }
            }
        }
    }
    if (action.isSetModifiedLabels()) {
        for (Label label : action.getModifiedLabels().getLabels()) {
            NicLabel nicLabel = new NicLabel();
            nicLabel.setLabel(label.getId());
            if (label.isSetHostNic()) {
                nicLabel.setNicId(label.getHostNic().isSetId() ? asGuid(label.getHostNic().getId()) : null);
                nicLabel.setNicName(label.getHostNic().getName());
            }
            parameters.getLabels().add(nicLabel);
        }
    }
    if (action.isSetRemovedLabels()) {
        for (Label label : action.getRemovedLabels().getLabels()) {
            parameters.getRemovedLabels().add(label.getId());
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment.getId());
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    BusinessEntityMap<VdsNetworkInterface> nics = getBackendNics();
    if (action.isSetModifiedBonds()) {
        for (HostNIC bond : action.getModifiedBonds().getHostNics()) {
            if (bond.getBonding().isSetSlaves()) {
                Set<String> slaveNamesSet = new HashSet<String>();
                for (HostNIC slave : bond.getBonding().getSlaves().getSlaves()) {
                    if (!slave.isSetName() && slave.isSetId()) {
                        VdsNetworkInterface nic = nics.get(new Guid(slave.getId()));
                        slave.setName(nic.getName());
                        if (slaveNamesSet.contains(slave.getName()))
                            return handleError(new DuplicatedEntityException("Network Interface: " + slave.getId()), true);
                    }
                    if (slaveNamesSet.contains(slave.getName()))
                        return handleError(new DuplicatedEntityException("Network Interface: " + slave.getName()), true);
                    slaveNamesSet.add(slave.getName());
                }
            }
            parameters.getBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNIC bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond).getId());
        }
    }
    if (action.isSetCheckConnectivity()) {
        parameters.setRollbackOnFailure(action.isCheckConnectivity());
    }
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#method_after
private HostSetupNetworksParameters toParameters(Action action) {
    HostSetupNetworksParameters parameters = new HostSetupNetworksParameters(guid);
    Map<Guid, NetworkAttachment> attachmentsById = getBackendNetworkAttachments();
    if (action.isSetModifiedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getModifiedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getNetworkAttachments().add(attachment);
        }
    }
    if (action.isSetSynchronizedNetworkAttachments()) {
        Map<Guid, NetworkAttachment> networkAttachmentFromParams = Entities.businessEntitiesById(parameters.getNetworkAttachments());
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getSynchronizedNetworkAttachments().getNetworkAttachments()) {
            if (model.isSetId()) {
                Guid networkAttachmentId = asGuid(model.getId());
                if (networkAttachmentFromParams.containsKey(networkAttachmentId)) {
                    networkAttachmentFromParams.get(networkAttachmentId).setOverrideConfiguration(true);
                } else if (attachmentsById.containsKey(networkAttachmentId)) {
                    NetworkAttachment networkAttachment = attachmentsById.get(networkAttachmentId);
                    networkAttachment.setOverrideConfiguration(true);
                    parameters.getNetworkAttachments().add(networkAttachment);
                } else {
                    return handleError(new EntityNotFoundException("NetworkAttachment.id: " + model.getId()), true);
                }
            }
        }
    }
    if (action.isSetModifiedLabels()) {
        for (Label label : action.getModifiedLabels().getLabels()) {
            NicLabel nicLabel = new NicLabel();
            nicLabel.setLabel(label.getId());
            if (label.isSetHostNic()) {
                nicLabel.setNicId(label.getHostNic().isSetId() ? asGuid(label.getHostNic().getId()) : null);
                nicLabel.setNicName(label.getHostNic().getName());
            }
            parameters.getLabels().add(nicLabel);
        }
    }
    if (action.isSetRemovedLabels()) {
        for (Label label : action.getRemovedLabels().getLabels()) {
            parameters.getRemovedLabels().add(label.getId());
        }
    }
    if (action.isSetRemovedNetworkAttachments()) {
        for (org.ovirt.engine.api.model.NetworkAttachment model : action.getRemovedNetworkAttachments().getNetworkAttachments()) {
            NetworkAttachment attachment = mapNetworkAttachment(attachmentsById, model);
            parameters.getRemovedNetworkAttachments().add(attachment.getId());
        }
    }
    BusinessEntityMap<Bond> bonds = getBackendHostBonds();
    if (action.isSetModifiedBonds()) {
        BusinessEntityMap<VdsNetworkInterface> nicsFromBackend = getBackendNics();
        for (HostNic bond : action.getModifiedBonds().getHostNics()) {
            completeSlaveNames(nicsFromBackend, bond);
            parameters.getBonds().add(mapBonds(bonds, bond));
        }
    }
    if (action.isSetRemovedBonds()) {
        for (HostNic bond : action.getRemovedBonds().getHostNics()) {
            parameters.getRemovedBonds().add(mapBonds(bonds, bond).getId());
        }
    }
    if (action.isSetCheckConnectivity()) {
        parameters.setRollbackOnFailure(action.isCheckConnectivity());
    }
    if (action.isSetConnectivityTimeout()) {
        parameters.setConectivityTimeout(action.getConnectivityTimeout());
    }
    return parameters;
}
#end_block

#method_before
public Bond mapBonds(BusinessEntityMap<Bond> bonds, HostNIC model) {
    Mapper<HostNIC, Bond> hostNicMapper = getMapper(HostNIC.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond template = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, template);
    }
    return bond;
}
#method_after
public Bond mapBonds(BusinessEntityMap<Bond> bonds, HostNic model) {
    Mapper<HostNic, Bond> hostNicMapper = getMapper(HostNic.class, Bond.class);
    Bond bond;
    if (model.isSetId()) {
        Guid nicId = asGuid(model.getId());
        bond = hostNicMapper.map(model, bonds.get(nicId));
    } else {
        Bond template = model.isSetName() ? bonds.get(model.getName()) : null;
        bond = hostNicMapper.map(model, template);
    }
    return bond;
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(guid));
}
#method_after
@Override
public Response remove() {
    get();
    boolean force = QueryHelper.getBooleanMatrixParameter(uriInfo, FORCE, true, false);
    return performAction(VdcActionType.RemoveVds, new RemoveVdsParameters(guid, force));
}
#end_block

#method_before
@Mapping(from = InterfaceStatus.class, to = NicStatus.class)
public static NicStatus map(InterfaceStatus interfaceStatus, NicStatus template) {
    if (interfaceStatus != null) {
        switch(interfaceStatus) {
            case UP:
                return NicStatus.UP;
            case DOWN:
                return NicStatus.DOWN;
            default:
                return null;
        }
    }
    return null;
}
#method_after
@Mapping(from = HostNic.class, to = VdsNetworkInterface.class)
public static VdsNetworkInterface map(HostNic model, VdsNetworkInterface template) {
    VdsNetworkInterface entity;
    if (template != null) {
        entity = template;
    } else if (model.isSetBonding()) {
        entity = new Bond();
    } else if (model.isSetVlan()) {
        entity = new Vlan();
    } else {
        entity = new Nic();
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetNetwork() && model.getNetwork().isSetName()) {
        entity.setNetworkName(model.getNetwork().getName());
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetBaseInterface()) {
        entity.setBaseInterface(model.getBaseInterface());
    }
    if (model.isSetIp()) {
        if (model.getIp().isSetAddress()) {
            entity.setAddress(model.getIp().getAddress());
        }
        if (model.getIp().isSetGateway()) {
            entity.setGateway(model.getIp().getGateway());
        }
        if (model.getIp().isSetNetmask()) {
            entity.setSubnet(model.getIp().getNetmask());
        }
    }
    if (model.isSetMac() && model.getMac().isSetAddress()) {
        entity.setMacAddress(model.getMac().getAddress());
    }
    if (model.isSetBonding()) {
        entity.setBonded(true);
        if (model.getBonding().isSetOptions()) {
            StringBuffer buf = new StringBuffer();
            for (Option opt : model.getBonding().getOptions().getOptions()) {
                buf.append(opt.getName() + "=" + opt.getValue() + " ");
            }
            entity.setBondOptions(buf.toString().substring(0, buf.length() - 1));
        }
    }
    if (model.isSetBootProtocol()) {
        NetworkBootProtocol networkBootProtocol = BootProtocolMapper.map(BootProtocol.fromValue(model.getBootProtocol()), null);
        if (networkBootProtocol != null) {
            entity.setBootProtocol(networkBootProtocol);
        }
    }
    if (model.isSetQos()) {
        entity.setQos((HostNetworkQos) QosMapper.map(model.getQos(), null));
    }
    return entity;
}
#end_block

#method_before
private static String calculateBondingOptionsString(HostNIC model) {
    List<Option> bondingOptions = model.getBonding().getOptions().getOptions();
    if (bondingOptions.isEmpty()) {
        return "";
    }
    StringBuilder builder = new StringBuilder();
    appendBondingOption(builder, bondingOptions.get(0));
    for (int i = 1; i < bondingOptions.size(); i++) {
        builder.append(" ");
        appendBondingOption(builder, bondingOptions.get(i));
    }
    return builder.toString();
}
#method_after
private static String calculateBondingOptionsString(HostNic model) {
    List<Option> bondingOptions = model.getBonding().getOptions().getOptions();
    if (bondingOptions.isEmpty()) {
        return "";
    }
    StringBuilder builder = new StringBuilder();
    appendBondingOption(builder, bondingOptions.get(0));
    for (int i = 1; i < bondingOptions.size(); i++) {
        builder.append(" ");
        appendBondingOption(builder, bondingOptions.get(i));
    }
    return builder.toString();
}
#end_block

#method_before
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    return vr;
}
#method_after
public ValidationResult validate() {
    Collection<NetworkAttachment> attachmentsToConfigure = getAttachmentsToConfigure();
    ValidationResult vr = ValidationResult.VALID;
    vr = skipValidation(vr) ? vr : new NicLabelValidator(params, existingInterfacesMap, bondsMap, hostSetupNetworksValidatorHelper).validate();
    vr = skipValidation(vr) ? vr : validNewOrModifiedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validRemovedNetworkAttachments();
    vr = skipValidation(vr) ? vr : validNewOrModifiedBonds();
    vr = skipValidation(vr) ? vr : validRemovedBonds(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : attachmentsDontReferenceSameNetworkDuplicately(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : networksUniquelyConfiguredOnHost(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateNetworkExclusiveOnNics(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : new NetworkMtuValidator(networkBusinessEntityMap).validateMtu(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateCustomProperties();
    vr = skipValidation(vr) ? vr : validateQos(attachmentsToConfigure);
    vr = skipValidation(vr) ? vr : validateBondModeVsNetworksAttachedToIt(attachmentsToConfigure);
    return vr;
}
#end_block

#method_before
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
        ValidationResult validateInvlaidBondMode = validateBondMode(modifiedOrNewBond);
        if (!validateInvlaidBondMode.isValid()) {
            return validateInvlaidBondMode;
        }
    }
    return ValidationResult.VALID;
}
#method_after
ValidationResult validNewOrModifiedBonds() {
    for (Bond modifiedOrNewBond : params.getBonds()) {
        String bondName = modifiedOrNewBond.getName();
        ValidationResult validateCoherentNicIdentification = validateCoherentNicIdentification(modifiedOrNewBond);
        if (!validateCoherentNicIdentification.isValid()) {
            return validateCoherentNicIdentification;
        }
        // does not test, whether interface exists, but only if the instance is non-null and its name is set.
        ValidationResult interfaceByNameExists = createHostInterfaceValidator(modifiedOrNewBond).interfaceByNameExists();
        if (!interfaceByNameExists.isValid()) {
            return interfaceByNameExists;
        }
        boolean validBondName = bondName != null && bondName.matches(BusinessEntitiesDefinitions.BOND_NAME_PATTERN);
        if (!validBondName) {
            return new ValidationResult(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BOND_NAME_BAD_FORMAT, bondName));
        }
        // either it's newly create bond, thus non existing, or given name must reference existing bond.
        ValidationResult interfaceIsBondOrNull = createHostInterfaceValidator(existingInterfacesMap.get(bondName)).interfaceIsBondOrNull();
        if (!interfaceIsBondOrNull.isValid()) {
            return interfaceIsBondOrNull;
        }
        // count of bond slaves must be at least two.
        if (modifiedOrNewBond.getSlaves().size() < 2) {
            return new ValidationResult(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, ReplacementUtils.getVariableAssignmentString(EngineMessage.NETWORK_BONDS_INVALID_SLAVE_COUNT, bondName));
        }
        ValidationResult validateModifiedBondSlaves = validateModifiedBondSlaves(modifiedOrNewBond);
        if (!validateModifiedBondSlaves.isValid()) {
            return validateModifiedBondSlaves;
        }
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : networkIdIsSet(attachment);
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        vr = skipValidation(vr) ? vr : validateBondOptionsForNewAttachement(attachment);
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#method_after
private ValidationResult validNewOrModifiedNetworkAttachments() {
    ValidationResult vr = ValidationResult.VALID;
    Iterator<NetworkAttachment> iterator = params.getNetworkAttachments().iterator();
    while (iterator.hasNext() && vr.isValid()) {
        NetworkAttachment attachment = iterator.next();
        NetworkAttachmentValidator validator = createNetworkAttachmentValidator(attachment);
        vr = skipValidation(vr) ? vr : validator.networkAttachmentIsSet();
        vr = skipValidation(vr) ? vr : referencedNetworkAttachmentActuallyExists(attachment.getId());
        vr = skipValidation(vr) ? vr : networkIdIsSet(attachment);
        vr = skipValidation(vr) ? vr : validator.networkExists();
        vr = skipValidation(vr) ? vr : validateCoherentNicIdentification(attachment);
        vr = skipValidation(vr) ? vr : validateCoherentNetworkIdentification(attachment);
        vr = skipValidation(vr) ? vr : modifiedAttachmentExists(attachment.getId());
        vr = skipValidation(vr) ? vr : modifiedAttachmentNotRemoved(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentNotReferenceVlanDevice(attachment);
        vr = skipValidation(vr) ? vr : validateAttachmentAndNicReferenceSameLabelNotConflict(attachment);
        vr = skipValidation(vr) ? vr : validator.notExternalNetwork();
        vr = skipValidation(vr) ? vr : validator.networkAttachedToCluster();
        vr = skipValidation(vr) ? vr : validator.ipConfiguredForStaticBootProtocol();
        vr = skipValidation(vr) ? vr : validator.bootProtocolSetForRoleNetwork();
        // this is not nic exist, but only nic is set.
        vr = skipValidation(vr) ? vr : validator.nicExists();
        vr = skipValidation(vr) ? vr : nicActuallyExistsOrReferencesNewBond(attachment);
        vr = skipValidation(vr) ? vr : validator.networkIpAddressWasSameAsHostnameAndChanged(existingInterfacesMap);
        vr = skipValidation(vr) ? vr : validator.networkNotChanged(attachmentsById.get(attachment.getId()));
        vr = skipValidation(vr) ? vr : validator.validateGateway();
        boolean attachmentUpdated = !isNewAttachment(attachment.getId());
        if (attachmentUpdated) {
            vr = skipValidation(vr) ? vr : validator.networkNotUsedByVms();
            vr = skipValidation(vr) ? vr : notMovingLabeledNetworkToDifferentNic(attachment);
        }
    }
    return vr;
}
#end_block

#method_before
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getHostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                BondMode bondMode = BondMode.getBondMode(((Bond) dst.getIface()).getBondOptions());
                if (!bondMode.isBondModeValidForVmNetwork()) {
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getHostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                if (!BondMode.isBondModeValidForVmNetwork(((Bond) dst.getIface()).getBondOptions())) {
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
private void addBondOptionIfMissing(String candidateOption, boolean doesBondHaveVmNetworkAttached) {
    BondMode bondMode = BondMode.getBondMode(candidateOption);
    if (doesBondHaveVmNetworkAttached && bondMode.isBondModeValidForVmNetwork()) {
        return;
    }
    if (!pairForBondOption.containsKey(candidateOption)) {
        EntityModel<String> entityModel = new EntityModel<String>();
        entityModel.setEntity(candidateOption);
        // $NON-NLS-1$
        Entry<String, EntityModel<String>> newPair = new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel);
        bondOptions.add(newPair);
        pairForBondOption.put(candidateOption, newPair);
    }
}
#method_after
private void addBondOptionIfMissing(String candidateOption, boolean doesBondHaveVmNetworkAttached) {
    if (doesBondHaveVmNetworkAttached && BondMode.isBondModeValidForVmNetwork(candidateOption)) {
        return;
    }
    if (!pairForBondOption.containsKey(candidateOption)) {
        EntityModel<String> entityModel = new EntityModel<String>();
        entityModel.setEntity(candidateOption);
        // $NON-NLS-1$
        Entry<String, EntityModel<String>> newPair = new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel);
        bondOptions.add(newPair);
        pairForBondOption.put(candidateOption, newPair);
    }
}
#end_block

#method_before
@Override
public void invoke(ExtMap input, ExtMap output) {
    Integer baseResult = null;
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
    output.put(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR);
    try {
        if (tasks != null) {
            tasks.execute();
        }
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.LOAD)) {
            doLoad(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.TERMINATE)) {
        // Nothing to do.
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD)) {
            doFetchPrincipalRecord(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_OPEN)) {
            doQueryOpen(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_EXECUTE)) {
            doQueryExecute(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_CLOSE)) {
            doQueryClose(input, output);
        } else {
            baseResult = Base.InvokeResult.UNSUPPORTED;
            throw new IllegalArgumentException();
        }
    } catch (Throwable e) {
        LOG.error("Unexpected Exception invoking: {}", input.get(Base.InvokeKeys.COMMAND));
        LOG.debug("Exception:", e);
        output.put(Base.InvokeKeys.RESULT, baseResult != null ? baseResult : Authz.Status.GENERAL_ERROR);
        output.put(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR);
    }
}
#method_after
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        if (tasks != null) {
            tasks.execute();
        }
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.LOAD)) {
            doLoad(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.TERMINATE)) {
        // Nothing to do.
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.FETCH_PRINCIPAL_RECORD)) {
            doFetchPrincipalRecord(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_OPEN)) {
            doQueryOpen(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_EXECUTE)) {
            doQueryExecute(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Authz.InvokeCommands.QUERY_CLOSE)) {
            doQueryClose(input, output);
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
            throw new IllegalArgumentException();
        }
        output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
        output.put(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
    } catch (Throwable e) {
        LOG.error("Unexpected Exception invoking: {}", input.get(Base.InvokeKeys.COMMAND));
        LOG.debug("Exception:", e);
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
        output.put(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR);
        output.put(Base.InvokeKeys.MESSAGE, e.getMessage());
    }
}
#end_block

#method_before
private void doLoad(ExtMap input, ExtMap output) throws Exception {
    input.get(Base.InvokeKeys.CONTEXT, ExtMap.class).mput(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList(Global.NAMESPACE)).mput(Base.ContextKeys.EXTENSION_NAME, Config.PACKAGE_NAME.concat(".authz")).mput(Authz.ContextKeys.CAPABILITIES, Authz.Capabilities.RECURSIVE_GROUP_RESOLUTION).mput(Authz.ContextKeys.QUERY_MAX_FILTER_SIZE, MAX_FILTER_SIZE).mput(ExtensionUtils.JDBC_INFO);
    configuration = ExtensionUtils.loadIncludedConfiguration(input.get(Base.InvokeKeys.CONTEXT, ExtMap.class));
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
}
#method_after
private void doLoad(ExtMap input, ExtMap output) throws Exception {
    input.get(Base.InvokeKeys.CONTEXT, ExtMap.class).mput(Authz.ContextKeys.AVAILABLE_NAMESPACES, Arrays.asList(Global.NAMESPACE)).mput(Base.ContextKeys.EXTENSION_NAME, Config.PACKAGE_NAME.concat(".authz")).mput(Authz.ContextKeys.CAPABILITIES, Authz.Capabilities.RECURSIVE_GROUP_RESOLUTION).mput(Authz.ContextKeys.QUERY_MAX_FILTER_SIZE, MAX_FILTER_SIZE).mput(ExtensionUtils.JDBC_INFO);
    configuration = ExtensionUtils.loadIncludedConfiguration(input.get(Base.InvokeKeys.CONTEXT, ExtMap.class));
}
#end_block

#method_before
private void doInit(ExtMap input, ExtMap output) {
    try {
        this.ds = new DataSourceProvider(configuration).provide();
        this.authorization = new Authorization(ds);
        this.tasks = new Tasks(ds, this.authorization);
        ExtensionUtils.checkDbVersion(ds.getConnection(), input.<ExtMap>get(Base.InvokeKeys.CONTEXT).<String>get(Base.ContextKeys.CONFIGURATION_FILE));
        output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Exception ex) {
        LOG.debug("Exception", ex);
        output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
        output.put(Base.InvokeKeys.MESSAGE, ex.getMessage());
    }
}
#method_after
private void doInit(ExtMap input, ExtMap output) throws SQLException, IOException {
    this.ds = new DataSourceProvider(configuration).provide();
    this.authorization = new Authorization(ds);
    this.tasks = new Tasks(ds, this.authorization);
    ExtensionUtils.checkDbVersion(ds.getConnection(), input.<ExtMap>get(Base.InvokeKeys.CONTEXT).<String>get(Base.ContextKeys.CONFIGURATION_FILE));
}
#end_block

#method_before
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
    Collection<ExtMap> principals = authorization.getResults(Formatter.format("{} = {}", Schema.SEARCH_KEYS.get(Authz.PrincipalRecord.NAME), Formatter.escapeString(input.containsKey(Authz.InvokeKeys.PRINCIPAL) ? input.get(Authz.InvokeKeys.PRINCIPAL, String.class) : input.get(Authn.InvokeKeys.AUTH_RECORD, ExtMap.class).get(Authn.AuthRecord.PRINCIPAL, String.class))), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, true).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.PAGE_SIZE, 1).mput(Global.SearchContext.ALL_ATTRIBUTES, false));
    output.put(Authz.InvokeKeys.PRINCIPAL_RECORD, principals.size() > 0 ? principals.iterator().next() : null);
    ExtMap principalRecord = output.get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    if (principalRecord != null && (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0) {
        resolveNestedGroups(principalRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS), new HashSet<String>());
    }
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    output.put(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#method_after
private void doFetchPrincipalRecord(ExtMap input, ExtMap output) throws SQLException, IOException {
    int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
    Collection<ExtMap> principals = authorization.getResults(Formatter.format("{} = {}", Schema.SEARCH_KEYS.get(Authz.PrincipalRecord.NAME), Formatter.escapeString(input.containsKey(Authz.InvokeKeys.PRINCIPAL) ? input.get(Authz.InvokeKeys.PRINCIPAL, String.class) : input.get(Authn.InvokeKeys.AUTH_RECORD, ExtMap.class).get(Authn.AuthRecord.PRINCIPAL, String.class))), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, true).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.PAGE_SIZE, 1).mput(Global.SearchContext.ALL_ATTRIBUTES, false));
    output.put(Authz.InvokeKeys.PRINCIPAL_RECORD, principals.size() > 0 ? principals.iterator().next() : null);
    ExtMap principalRecord = output.get(Authz.InvokeKeys.PRINCIPAL_RECORD);
    if (principalRecord != null && (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0) {
        resolveNestedGroups(principalRecord.<List<ExtMap>>get(Authz.PrincipalRecord.GROUPS), new HashSet<String>());
    }
}
#end_block

#method_before
private void doQueryOpen(ExtMap input, ExtMap output) throws SQLException {
    try {
        int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
        output.mput(Authz.InvokeKeys.QUERY_OPAQUE, authorization.openQuery(parse(input.get(Authz.InvokeKeys.QUERY_FILTER, ExtMap.class), false), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, input.get(Authz.InvokeKeys.QUERY_ENTITY, ExtUUID.class).equals(Authz.QueryEntity.PRINCIPAL)).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.ALL_ATTRIBUTES, false))).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (IllegalArgumentException e) {
        output.mput(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, e.getMessage());
    }
    output.mput(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#method_after
private void doQueryOpen(ExtMap input, ExtMap output) throws SQLException {
    try {
        int flags = input.get(Authz.InvokeKeys.QUERY_FLAGS, Integer.class, 0);
        output.mput(Authz.InvokeKeys.QUERY_OPAQUE, authorization.openQuery(parse(input.get(Authz.InvokeKeys.QUERY_FILTER, ExtMap.class), false), new ExtMap().mput(Global.SearchContext.IS_PRINCIPAL, input.get(Authz.InvokeKeys.QUERY_ENTITY, ExtUUID.class).equals(Authz.QueryEntity.PRINCIPAL)).mput(Global.SearchContext.WITH_GROUPS, (flags & Authz.QueryFlags.RESOLVE_GROUPS) != 0).mput(Global.SearchContext.RECURSIVE, (flags & Authz.QueryFlags.RESOLVE_GROUPS_RECURSIVE) != 0).mput(Global.SearchContext.ALL_ATTRIBUTES, false))).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (IllegalArgumentException e) {
        output.mput(Authz.InvokeKeys.STATUS, Authz.Status.GENERAL_ERROR).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED).mput(Base.InvokeKeys.MESSAGE, e.getMessage());
    }
}
#end_block

#method_before
private void doQueryExecute(ExtMap input, ExtMap output) throws SQLException {
    output.mput(Authz.InvokeKeys.QUERY_RESULT, authorization.executeQuery(input.get(Authz.InvokeKeys.QUERY_OPAQUE, String.class), input.get(Authz.InvokeKeys.PAGE_SIZE, Integer.class, Integer.MAX_VALUE))).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS).mput(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#method_after
private void doQueryExecute(ExtMap input, ExtMap output) throws SQLException {
    output.mput(Authz.InvokeKeys.QUERY_RESULT, authorization.executeQuery(input.get(Authz.InvokeKeys.QUERY_OPAQUE, String.class), input.get(Authz.InvokeKeys.PAGE_SIZE, Integer.class, Integer.MAX_VALUE)));
}
#end_block

#method_before
private void doQueryClose(ExtMap input, ExtMap output) throws SQLException {
    authorization.closeQuery(input.get(Authz.InvokeKeys.QUERY_OPAQUE, String.class));
    output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    output.put(Authz.InvokeKeys.STATUS, Authz.Status.SUCCESS);
}
#method_after
private void doQueryClose(ExtMap input, ExtMap output) throws SQLException {
    authorization.closeQuery(input.get(Authz.InvokeKeys.QUERY_OPAQUE, String.class));
}
#end_block

#method_before
private static Path getDbScriptsDir(String configurationFile) {
    // ext cfg file is located in ${PREFIX}/etc/ovirt-engine/extension.d/${NAME}.properties
    Path prefixDir = Paths.get(configurationFile).normalize().getParent().getParent().getParent().getParent();
    if (prefixDir.getNameCount() == 0) {
        // RPM installation, ${PREFIX} should be /usr instead of /
        prefixDir = Paths.get("/usr");
    }
    // dbscripts are located in ${PREFIX}/share/ovirt-engine-extension-aaa-jdbc/dbscripts/upgrade
    return Paths.get(prefixDir.toString(), "share/ovirt-engine-extension-aaa-jdbc/dbscripts/upgrade");
}
#method_after
private static Path getDbScriptsDir(String configurationFile) {
    // config file is located in ${PREFIX}/etc/ovirt-engine/extension.d/${NAME}.properties (for API calls) or
    // in ${PREFIX}/etc/ovirt-engine/aaa/${NAME}.properties (for CLI calls)
    Path prefixDir = Paths.get(configurationFile).normalize().getParent().getParent().getParent().getParent();
    if (prefixDir.getNameCount() == 0) {
        // RPM installation, ${PREFIX} should be /usr instead of /
        prefixDir = Paths.get("/usr");
    }
    // dbscripts are located in ${PREFIX}/share/ovirt-engine-extension-aaa-jdbc/dbscripts/upgrade
    return Paths.get(prefixDir.toString(), "share/ovirt-engine-extension-aaa-jdbc/dbscripts/upgrade");
}
#end_block

#method_before
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        if (tasks != null) {
            tasks.execute();
        }
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.LOAD)) {
            doLoad(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input, output);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.TERMINATE)) {
        // Nothing to do.
        } else if ((input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS)) || (input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.CREDENTIALS_CHANGE))) {
            doAuth(input, output);
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
            throw new IllegalArgumentException("unsupported:" + input.get(Base.InvokeKeys.COMMAND));
        }
    } catch (Throwable e) {
        LOG.error("Unexpected Exception invoking: {}", input.get(Base.InvokeKeys.COMMAND));
        LOG.debug("Exception:", e);
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
    }
}
#method_after
@Override
public void invoke(ExtMap input, ExtMap output) {
    try {
        if (tasks != null) {
            tasks.execute();
        }
        if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.LOAD)) {
            doLoad(input);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.INITIALIZE)) {
            doInit(input);
        } else if (input.get(Base.InvokeKeys.COMMAND).equals(Base.InvokeCommands.TERMINATE)) {
        // Nothing to do.
        } else if ((input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS)) || (input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.CREDENTIALS_CHANGE))) {
            doAuth(input, output);
        } else {
            output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.UNSUPPORTED);
            throw new IllegalArgumentException("unsupported:" + input.get(Base.InvokeKeys.COMMAND));
        }
        output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Throwable e) {
        LOG.error("Unexpected Exception invoking: {}", input.get(Base.InvokeKeys.COMMAND));
        LOG.debug("Exception:", e);
        output.putIfAbsent(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
        output.put(Base.InvokeKeys.MESSAGE, e.getMessage());
    }
}
#end_block

#method_before
private void doLoad(ExtMap input, ExtMap output) throws Exception {
    input.get(Base.InvokeKeys.CONTEXT, ExtMap.class).mput(Base.ContextKeys.EXTENSION_NAME, Config.PACKAGE_NAME.concat(".authn")).mput(Authn.ContextKeys.CAPABILITIES, (Authn.Capabilities.AUTHENTICATE_CREDENTIALS | Authn.Capabilities.CREDENTIALS_CHANGE | Authn.Capabilities.AUTHENTICATE_PASSWORD | 0)).mput(ExtensionUtils.JDBC_INFO);
    configuration = ExtensionUtils.loadIncludedConfiguration(input.get(Base.InvokeKeys.CONTEXT, ExtMap.class));
    output.mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
}
#method_after
private void doLoad(ExtMap input) throws Exception {
    input.get(Base.InvokeKeys.CONTEXT, ExtMap.class).mput(Base.ContextKeys.EXTENSION_NAME, Config.PACKAGE_NAME.concat(".authn")).mput(Authn.ContextKeys.CAPABILITIES, (Authn.Capabilities.AUTHENTICATE_CREDENTIALS | Authn.Capabilities.CREDENTIALS_CHANGE | Authn.Capabilities.AUTHENTICATE_PASSWORD | 0)).mput(ExtensionUtils.JDBC_INFO);
    configuration = ExtensionUtils.loadIncludedConfiguration(input.get(Base.InvokeKeys.CONTEXT, ExtMap.class));
}
#end_block

#method_before
private void doInit(ExtMap input, ExtMap output) {
    try {
        DataSource ds = new DataSourceProvider(configuration).provide();
        this.authentication = new Authentication(ds);
        this.tasks = new Tasks(ds, this.authentication);
        ExtensionUtils.checkDbVersion(ds.getConnection(), input.<ExtMap>get(Base.InvokeKeys.CONTEXT).<String>get(Base.ContextKeys.CONFIGURATION_FILE));
        output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
    } catch (Exception ex) {
        LOG.debug("Exception", ex);
        output.put(Base.InvokeKeys.RESULT, Base.InvokeResult.FAILED);
        output.put(Base.InvokeKeys.MESSAGE, ex.getMessage());
    }
}
#method_after
private void doInit(ExtMap input) throws SQLException, IOException {
    DataSource ds = new DataSourceProvider(configuration).provide();
    this.authentication = new Authentication(ds);
    this.tasks = new Tasks(ds, this.authentication);
    ExtensionUtils.checkDbVersion(ds.getConnection(), input.<ExtMap>get(Base.InvokeKeys.CONTEXT).<String>get(Base.ContextKeys.CONFIGURATION_FILE));
}
#end_block

#method_before
private void doAuth(ExtMap input, ExtMap output) throws GeneralSecurityException, SQLException, IOException {
    Authentication.AuthResponse response = authentication.doAuth(input.get(Authn.InvokeKeys.USER, String.class), input.get(Authn.InvokeKeys.CREDENTIALS, String.class), input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.CREDENTIALS_CHANGE), input.get(Authn.InvokeKeys.CREDENTIALS_NEW, String.class));
    output.mput(Authn.InvokeKeys.AUTH_RECORD, (response.authRecord != null) ? new ExtMap().mput(Authn.AuthRecord.PRINCIPAL, response.authRecord.principal).mput(Authn.AuthRecord.VALID_TO, new SimpleDateFormat("yyyyMMddHHmmssZ", Locale.ROOT).format(response.authRecord.validTo)) : null).mput(Authn.InvokeKeys.PRINCIPAL, response.principal).mput(Authn.InvokeKeys.RESULT, response.result).mput(Authn.InvokeKeys.USER_MESSAGE, response.dailyMsg).mput(Base.InvokeKeys.MESSAGE, response.baseMsg).mput(Base.InvokeKeys.RESULT, Base.InvokeResult.SUCCESS);
}
#method_after
private void doAuth(ExtMap input, ExtMap output) throws GeneralSecurityException, SQLException, IOException {
    Authentication.AuthResponse response = authentication.doAuth(input.get(Authn.InvokeKeys.USER, String.class), input.get(Authn.InvokeKeys.CREDENTIALS, String.class), input.get(Base.InvokeKeys.COMMAND).equals(Authn.InvokeCommands.CREDENTIALS_CHANGE), input.get(Authn.InvokeKeys.CREDENTIALS_NEW, String.class));
    output.mput(Authn.InvokeKeys.AUTH_RECORD, (response.authRecord != null) ? new ExtMap().mput(Authn.AuthRecord.PRINCIPAL, response.authRecord.principal).mput(Authn.AuthRecord.VALID_TO, new SimpleDateFormat("yyyyMMddHHmmssZ", Locale.ROOT).format(response.authRecord.validTo)) : null).mput(Authn.InvokeKeys.PRINCIPAL, response.principal).mput(Authn.InvokeKeys.RESULT, response.result).mput(Authn.InvokeKeys.USER_MESSAGE, response.dailyMsg).mput(Base.InvokeKeys.MESSAGE, response.baseMsg);
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, item.getSetupModel());
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(nic.getCustomProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getCustomPropertiesModel().getIsAvailable()) {
                    nic.setCustomProperties(KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()));
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, nic, getOverridingHostNetworkQos(displayedQos));
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) item);
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        editPopup = new SetupNetworksEditBondModel(entity, doesBondHaveVmNetworkAttached);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondDialogModel.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                setBondOptions(entity, bondDialogModel);
                Bond bond = (Bond) entity;
                onBondEditUpdateParams(bond);
            }
        };
    } else if (item instanceof NetworkInterfaceModel) {
        /**
         * ****************
         *  VFs Config Dialog
         * *****************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getIface();
        final HostNicVfsConfig hostNicVfsConfig = nicToVfsConfig.get(entity.getId());
        if (hostNicVfsConfig != null) {
            final VfsConfigModel vfsConfigPopupModel = new VfsConfigModel(hostNicVfsConfig, allNetworks, dcLabels);
            vfsConfigPopupModel.setTitle(ConstantsManager.getInstance().getMessages().editHostNicVfsConfigTitle(entity.getName()));
            editPopup = vfsConfigPopupModel;
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand uiCommand) {
                    if (!vfsConfigPopupModel.validate()) {
                        return;
                    }
                    sourceListModel.setConfirmWindow(null);
                    commitVfsConfigChanges(hostNicVfsConfig, vfsConfigPopupModel);
                }
            };
        }
    } else if (item instanceof LogicalNetworkModel) {
        /**
         * **************
         *  Network Dialog
         * ***************
         */
        final LogicalNetworkModel logicalNetworkModel = (LogicalNetworkModel) item;
        final VdsNetworkInterface nic = logicalNetworkModel.hasVlan() ? logicalNetworkModel.getVlanNicModel().getIface() : logicalNetworkModel.getAttachedToNic().getIface();
        final HostInterfaceModel networkDialogModel;
        String version = getEntity().getVdsGroupCompatibilityVersion().getValue();
        final Network network = logicalNetworkModel.getNetwork();
        final String logicalNetworkModelName = network.getName();
        if (logicalNetworkModel.isManagement()) {
            networkDialogModel = new HostManagementNetworkModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            networkDialogModel.setEntity(network);
            networkDialogModel.setNoneBootProtocolAvailable(false);
            networkDialogModel.getInterface().setIsAvailable(false);
        } else {
            networkDialogModel = new HostInterfaceModel(true);
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetworkModelName));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangeable(false);
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, version));
        }
        networkDialogModel.getNetwork().setSelectedItem(network);
        networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetworkModelName));
        networkDialogModel.getAddress().setEntity(nic.getAddress());
        networkDialogModel.getSubnet().setEntity(nic.getSubnet());
        networkDialogModel.getGateway().setEntity(nic.getGateway());
        networkDialogModel.setStaticIpChangeAllowed(!getEntity().getHostName().equals(nic.getAddress()));
        networkDialogModel.getBondingOptions().setIsAvailable(false);
        networkDialogModel.setBootProtocol(nic.getBootProtocol());
        NetworkAttachment networkAttachment = getNetworkAttachmentForNetwork(network.getId());
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.HostNetworkQosSupported, version)) {
            networkDialogModel.getQosOverridden().setIsAvailable(true);
            networkDialogModel.getQosModel().setIsAvailable(true);
            networkDialogModel.getQosOverridden().setEntity(networkAttachment != null && networkAttachment.isQosOverridden());
            networkDialogModel.getQosModel().init(nic.getQos());
        }
        if ((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.NetworkCustomPropertiesSupported, version)) {
            KeyValueModel customPropertiesModel = networkDialogModel.getCustomPropertiesModel();
            customPropertiesModel.setIsAvailable(true);
            Map<String, String> validProperties = KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.PreDefinedNetworkCustomProperties, version));
            // to backend and frontend (lvernia)
            if (!network.isVmNetwork()) {
                // $NON-NLS-1$
                validProperties.remove("bridge_opts");
            }
            validProperties.putAll(KeyValueModel.convertProperties((String) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigurationValues.UserDefinedNetworkCustomProperties, version)));
            customPropertiesModel.setKeyValueMap(validProperties);
            customPropertiesModel.deserialize(KeyValueModel.convertProperties(networkAttachment.getProperties()));
        }
        networkDialogModel.getIsToSync().setIsChangeable(!logicalNetworkModel.isInSync());
        networkDialogModel.getIsToSync().setEntity(networksToSync.contains(logicalNetworkModelName));
        editPopup = networkDialogModel;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!networkDialogModel.validate()) {
                    return;
                }
                nic.setBootProtocol(networkDialogModel.getBootProtocol());
                if (networkDialogModel.getIsStaticAddress()) {
                    nic.setAddress(networkDialogModel.getAddress().getEntity());
                    nic.setSubnet(networkDialogModel.getSubnet().getEntity());
                    nic.setGateway(networkDialogModel.getGateway().getEntity());
                }
                HostNetworkQos displayedQos = getDisplayedQos();
                if (displayedQos != null) {
                    nic.setQos(displayedQos);
                }
                if (networkDialogModel.getIsToSync().getEntity()) {
                    networksToSync.add(logicalNetworkModelName);
                } else {
                    networksToSync.remove(logicalNetworkModelName);
                }
                boolean customPropertiesAvailable = networkDialogModel.getCustomPropertiesModel().getIsAvailable();
                Map<String, String> customProperties = customPropertiesAvailable ? KeyValueModel.convertProperties(networkDialogModel.getCustomPropertiesModel().serialize()) : null;
                removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(logicalNetworkModel, getOverridingHostNetworkQos(displayedQos), customProperties);
                sourceListModel.setConfirmWindow(null);
            }

            private HostNetworkQos getDisplayedQos() {
                HostNetworkQos displayedQos = null;
                if (networkDialogModel.getQosModel().getIsAvailable()) {
                    displayedQos = new HostNetworkQos();
                    networkDialogModel.getQosModel().flush(displayedQos);
                }
                return displayedQos;
            }

            private HostNetworkQos getOverridingHostNetworkQos(HostNetworkQos displayedQos) {
                boolean qosAvailableAndSet = displayedQos != null && networkDialogModel.getQosOverridden().getEntity();
                if (qosAvailableAndSet) {
                    if (networkDialogModel.getQosModel().getIsChangable()) {
                        return displayedQos;
                    } else {
                        return getNetworkAttachmentForNetwork(network.getId()).getHostNetworkQos();
                    }
                } else {
                    return null;
                }
            }
        };
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = UICommand.createDefaultOkUiCommand("OK", okTarget);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public NetworkAttachment getNetworkAttachmentForNetwork(Guid networkId) {
    // unset networkId may mean a bug, but also it can be unmanaged network, which does not have ids.
    if (networkId == null) {
        return null;
    }
    NetworkAttachment updatedAttachment = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId().get(networkId);
    if (updatedAttachment != null) {
        return updatedAttachment;
    }
    NetworkAttachment existingAttachment = getExistingAttachmentByNetworkId(networkId);
    if (existingAttachment != null && !shouldBeRemoved(existingAttachment.getId())) {
        return existingAttachment;
    }
    throw new IllegalArgumentException(// $NON-NLS-1$
    "Unable to find network attachment for network id " + networkId);
}
#method_after
public NetworkAttachment getNetworkAttachmentForNetwork(Guid networkId) {
    // unset networkId may mean a bug, but also it can be unmanaged network, which does not have ids.
    if (networkId == null) {
        return null;
    }
    NetworkAttachment updatedAttachment = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId().get(networkId);
    if (updatedAttachment != null) {
        return updatedAttachment;
    }
    NetworkAttachment existingAttachment = getExistingAttachmentByNetworkId(networkId);
    if (existingAttachment != null && !shouldBeRemoved(existingAttachment.getId())) {
        return existingAttachment;
    }
    return null;
}
#end_block

#method_before
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, VdsNetworkInterface entity, HostNetworkQos overridingQos) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel() == null ? null : logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData.networksToSync, overridingQos);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#method_after
public void removePreviousNetworkAttachmentInstanceFromRequestAndAddNewOne(LogicalNetworkModel logicalNetwork, HostNetworkQos overridingQos, Map<String, String> customProperties) {
    Network updatedNetwork = logicalNetwork.getNetwork();
    Guid updatedNetworkId = updatedNetwork.getId();
    Map<Guid, NetworkAttachment> networkIdToPreexistingNetworkAttachment = new MapNetworkAttachments(existingNetworkAttachments).byNetworkId();
    Map<Guid, NetworkAttachment> networkIdToNewOrUpdatedNetworkAttachments = new MapNetworkAttachments(hostSetupNetworksParametersData.newOrModifiedNetworkAttachments).byNetworkId();
    NetworkAttachment preexistingNetworkAttachment = networkIdToPreexistingNetworkAttachment.get(updatedNetworkId);
    Guid networkAttachmentId = preexistingNetworkAttachment == null ? null : preexistingNetworkAttachment.getId();
    NetworkAttachment previousUpdate = networkIdToNewOrUpdatedNetworkAttachments.get(updatedNetworkId);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.remove(previousUpdate);
    NetworkAttachment updatedNetworkAttachment = NetworkOperation.newNetworkAttachment(updatedNetwork, logicalNetwork.getAttachedToNic().getIface(), logicalNetwork.getVlanNicModel() == null ? null : logicalNetwork.getVlanNicModel().getIface(), networkAttachmentId, hostSetupNetworksParametersData.networksToSync, overridingQos, customProperties);
    hostSetupNetworksParametersData.newOrModifiedNetworkAttachments.add(updatedNetworkAttachment);
}
#end_block

#method_before
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2());
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), hostSetupNetworksParametersData).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#method_after
public void onOperation(NetworkOperation operation, final NetworkCommand networkCommand) {
    Model popupWindow;
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (operation.isNullOperation()) {
        return;
    } else if (operation == NetworkOperation.BOND_WITH || operation == NetworkOperation.JOIN_BONDS) {
        final SetupNetworksBondModel bondPopup;
        final List<VdsNetworkInterface> srcIfaces = new ArrayList<>();
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp1()).getIface());
        srcIfaces.add(((NetworkInterfaceModel) networkCommand.getOp2()).getIface());
        boolean doesBondHaveVmNetworkAttached = doesBondHaveVmNetworkAttached((NetworkInterfaceModel) networkCommand.getOp1(), (NetworkInterfaceModel) networkCommand.getOp2());
        if (operation == NetworkOperation.BOND_WITH) {
            bondPopup = new SetupNetworksAddBondModel(getFreeBonds(), nextBondName, doesBondHaveVmNetworkAttached);
        } else {
            bondPopup = new SetupNetworksJoinBondsModel(getFreeBonds(), (BondNetworkInterfaceModel) networkCommand.getOp1(), (BondNetworkInterfaceModel) networkCommand.getOp2(), doesBondHaveVmNetworkAttached);
        }
        bondPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                if (!bondPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                VdsNetworkInterface bond = new Bond(bondPopup.getBond().getSelectedItem());
                setBondOptions(bond, bondPopup);
                NetworkInterfaceModel nic1 = (NetworkInterfaceModel) networkCommand.getOp1();
                NetworkInterfaceModel nic2 = (NetworkInterfaceModel) networkCommand.getOp2();
                List<LogicalNetworkModel> networks = new ArrayList<>();
                networks.addAll(nic1.getItems());
                networks.addAll(nic2.getItems());
                networkCommand.execute(bond);
                redraw();
                // Attach the previous networks
                commitNetworkChanges(bond, networks);
                // Attach previous labels
                commitLabelChanges(srcIfaces, bond);
                redraw();
            }
        }));
        popupWindow = bondPopup;
    } else if (networkCommand.getOp1() == getNewNetworkLabelModel()) {
        final SetupNetworksLabelModel labelPopup = new SetupNetworksLabelModel(dcLabels);
        labelPopup.getCommands().add(new UICommand("OK", new // $NON-NLS-1$
        BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand uiCommand) {
                if (!labelPopup.validate()) {
                    return;
                }
                sourceListModel.setConfirmWindow(null);
                String label = labelPopup.getLabel().getEntity();
                dcLabels.add(label);
                NetworkOperation.LABEL.getCommand(new NetworkLabelModel(label, HostSetupNetworksModel.this), networkCommand.getOp2(), hostSetupNetworksParametersData).execute();
                redraw();
            }
        }));
        popupWindow = labelPopup;
    } else {
        // just execute the command
        networkCommand.execute();
        redraw();
        return;
    }
    // add cancel
    popupWindow.getCommands().add(cancelCommand);
    // set window
    sourceListModel.setConfirmWindow(popupWindow);
}
#end_block

#method_before
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initNicModels();
            hostSetupNetworksParametersData.allNics = allNics;
            hostSetupNetworksParametersData.existingNetworkAttachments = existingNetworkAttachments;
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#method_after
private void queryFreeBonds() {
    // query for all unused, existing bonds on the host
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allBonds = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initNetworkModels();
            initDcNetworkParams();
            initNicModels();
            hostSetupNetworksParametersData.allNics = allNics;
            hostSetupNetworksParametersData.existingNetworkAttachments = existingNetworkAttachments;
            stopProgress();
        }
    };
    VDS vds = getEntity();
    Frontend.getInstance().runQuery(VdcQueryType.GetVdsFreeBondsByVdsId, new IdQueryParameters(vds.getId()), asyncQuery);
}
#end_block

#method_before
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            initNetworkModels();
            initDcNetworkParams();
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#method_after
private void queryNetworks() {
    // query for networks
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            allNetworks = (List<Network>) returnValue;
            // chain the nic query
            queryInterfaces();
        }
    };
    VDS vds = getEntity();
    AsyncDataProvider.getInstance().getClusterNetworkList(asyncQuery, vds.getVdsGroupId());
}
#end_block

#method_before
protected void setBondingOptions(ListModel<Map.Entry<String, EntityModel<String>>> value) {
    privateBondingOptions = value;
}
#method_after
private void setBondingOptions(ListModel<Map.Entry<String, EntityModel<String>>> value) {
    privateBondingOptions = value;
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
}
#end_block

#method_before
private void cacheConfigValues(AsyncQuery aQuery) {
    getDefaultConfigurationVersion();
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#method_after
private void cacheConfigValues(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object returnValue, AsyncQuery _asyncQuery) {
            if (returnValue != null) {
                cachedConfigValuesPreConvert.putAll((HashMap<KeyValuePairCompat<ConfigurationValues, String>, Object>) returnValue);
            }
            return cachedConfigValuesPreConvert;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetConfigurationValues, new VdcQueryParametersBase(), aQuery);
}
#end_block

#method_before
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionListDependingOnNetwork(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem, boolean hasNetworkAttached) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    if (!hasNetworkAttached) {
        entityModel = new EntityModel<String>();
        // $NON-NLS-1$
        entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
        // $NON-NLS-1$
        list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    }
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#method_after
public ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionListDependingOnNetwork(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem, boolean hasVmNetworkAttached) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    for (BondMode mode : BondMode.values()) {
        if (!BondMode.BOND_MODES_VALID_FOR_VM_NETWORK.contains(mode.getValue()) && hasVmNetworkAttached) {
            continue;
        }
        KeyValuePairCompat<String, EntityModel<String>> bondOption = getBondOption(mode);
        list.add(bondOption);
        if (mode.equals(BondMode.BOND4)) {
            defaultItem.argvalue = bondOption;
        }
    }
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return "mode=802.3ad miimon=150";
}
#method_after
public String getDefaultBondingOption() {
    // $NON-NLS-1$
    return BondMode.BOND4.getConfigurationValue("150");
}
#end_block

#method_before
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getHostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                if (dst.getIface().getBondOptions() != null && (// $NON-NLS-1$
                dst.getIface().getBondOptions().contains("mode=0") || // $NON-NLS-1$
                dst.getIface().getBondOptions().contains("mode=5") || // $NON-NLS-1$
                dst.getIface().getBondOptions().contains("mode=6")))
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#method_after
private static NetworkOperation binaryOperationWithNetworkInterfaceModelAsSecondOperand(NetworkItemModel<?> op1, NetworkInterfaceModel dst) {
    // first collect the networks into one set
    Set<LogicalNetworkModel> networks = new HashSet<>();
    networks.addAll(dst.getItems());
    // op1 is a NIC, verify that it isn't already part of a bond or dragged unto itself
    if (op1 instanceof NetworkInterfaceModel) {
        NetworkInterfaceModel src = (NetworkInterfaceModel) op1;
        if (src.isBonded() || src.equals(dst)) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getItems());
    } else if (op1 instanceof LogicalNetworkModel) {
        // op1 is a network, verify that it isn't dragged unto the NIC already containing it
        if (!networks.add((LogicalNetworkModel) op1)) {
            return NetworkOperation.NULL_OPERATION;
        }
    } else if (op1 instanceof NetworkLabelModel) {
        // op1 is a label, verify that it's not applied to the interface already labelled by it
        NetworkLabelModel src = (NetworkLabelModel) op1;
        if (dst.equals(src.getInterface())) {
            return NetworkOperation.NULL_OPERATION;
        }
        networks.addAll(src.getNetworks());
    }
    final String hostMaxSupportedClusterVersion = getHostMaxSupportedClusterVersion(op1);
    final boolean permissiveValidation = AsyncDataProvider.getInstance().isNetworkExclusivenessPermissiveValidation(hostMaxSupportedClusterVersion);
    // go over the networks and check whether they comply, if not - the reason is important
    boolean vlanFound = false;
    String nonVlanVmNetwork = null;
    int nonVlanCounter = 0;
    for (LogicalNetworkModel network : networks) {
        if (!network.isManaged()) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_UNMANAGED;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_UNMANAGED;
            }
        } else {
            if (!network.isInSync()) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_OUT_OF_SYNC;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(network.getName());
                    return NetworkOperation.NULL_OPERATION_BATCH_OUT_OF_SYNC;
                }
            }
        }
        if (network.hasVlan()) {
            vlanFound = true;
        } else {
            ++nonVlanCounter;
            if (network.getNetwork().isVmNetwork()) {
                nonVlanVmNetwork = network.getName();
            }
        }
        if (nonVlanCounter > 1) {
            if (op1 instanceof LogicalNetworkModel) {
                return NetworkOperation.NULL_OPERATION_TOO_MANY_NON_VLANS;
            }
            if (op1.aggregatesNetworks()) {
                dst.setCulpritNetwork(network.getName());
                return NetworkOperation.NULL_OPERATION_BATCH_TOO_MANY_NON_VLANS;
            }
        } else {
            if (!permissiveValidation && nonVlanVmNetwork != null && vlanFound) {
                if (op1 instanceof LogicalNetworkModel) {
                    return NetworkOperation.NULL_OPERATION_VM_WITH_VLANS;
                }
                if (op1.aggregatesNetworks()) {
                    dst.setCulpritNetwork(nonVlanVmNetwork);
                    return NetworkOperation.NULL_OPERATION_BATCH_VM_WITH_VLANS;
                }
            }
        }
        if (network.getNetwork().isVmNetwork()) {
            if (dst instanceof BondNetworkInterfaceModel) {
                String bondMode = BondMode.getBondMode((Bond) dst.getIface());
                if (!BondMode.isBondModeValidForVmNetwork(bondMode)) {
                    return NetworkOperation.NULL_OPERATION_INVALID_BOND_MODE;
                }
            }
        }
    }
    // networks comply, all that's left is to return the correct operation
    if (op1 instanceof LogicalNetworkModel) {
        return NetworkOperation.ATTACH_NETWORK;
    }
    if (op1 instanceof BondNetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.JOIN_BONDS;
        } else {
            return NetworkOperation.EXTEND_BOND_WITH;
        }
    }
    if (op1 instanceof NetworkInterfaceModel) {
        if (dst instanceof BondNetworkInterfaceModel) {
            return NetworkOperation.ADD_TO_BOND;
        } else {
            return NetworkOperation.BOND_WITH;
        }
    }
    if (op1 instanceof NetworkLabelModel) {
        return NetworkOperation.LABEL;
    }
    return NetworkOperation.NULL_OPERATION;
}
#end_block

#method_before
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#method_after
public void initCache(LoginModel loginModel) {
    cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initOsDefaultIconIds();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initBalloonSupportMap();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
    initSoundDeviceSupportMap();
}
#end_block

#method_before
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.error("Illegal architecture type, error: %s", ex.getMessage());
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#method_after
public static VM buildVmsDataFromExternalProvider(Map<String, Object> xmlRpcStruct) {
    VmStatic vmStatic = buildVmStaticDataFromExternalProvider(xmlRpcStruct);
    if (vmStatic == null) {
        return null;
    }
    VmDynamic vmDynamic = buildVMDynamicDataFromList(xmlRpcStruct);
    VM vm = new VM(vmStatic, vmDynamic, new VmStatistics());
    for (DiskImage image : vm.getImages()) {
        vm.getDiskMap().put(Guid.newGuid(), image);
    }
    try {
        vm.setClusterArch(parseArchitecture(xmlRpcStruct));
    } catch (IllegalArgumentException ex) {
        log.error("Illegal architecture type: %s, replacing with x86_64", xmlRpcStruct.get(VdsProperties.vm_arch));
        vm.setClusterArch(ArchitectureType.x86_64);
    }
    return vm;
}
#end_block

#method_before
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
            Map<Integer, Integer> distanceMap = new HashMap<>(distances.size());
            for (int i = 0; i < distances.size(); i++) {
                distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#method_after
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            } else {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    if (!isSystemSuperUser()) {
        getQueryReturnValue().setReturnValue(getDbFacade().getRoleDao().getAllNonAdmin());
    } else {
        getQueryReturnValue().setReturnValue(getDbFacade().getRoleDao().getAll());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    if (!isAdminUser()) {
        setReturnValue(getDbFacade().getRoleDao().getAllNonAdminRoles());
    } else {
        setReturnValue(getDbFacade().getRoleDao().getAll());
    }
}
#end_block

#method_before
@Override
protected void initQuery(GetAllRolesQuery<MultilevelAdministrationsQueriesParameters> query) {
    doReturn(Boolean.TRUE).when(query).isSystemSuperUser();
}
#method_after
@Override
protected void initQuery(GetAllRolesQuery<MultilevelAdministrationsQueriesParameters> query) {
    doReturn(Boolean.TRUE).when(query).isAdminUser();
}
#end_block

#method_before
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.error("Unable to detach storage domain '{}' '{}'", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    handleDestroyStoragePoolCommand();
    detachStorageEntitiesAndMarkAsData(masterDomain);
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            runVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (EngineException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    return retVal;
}
#method_after
private boolean regularRemoveStorageDomains(List<StorageDomain> storageDomains) {
    boolean retVal = true;
    List<StorageDomain> temp = LinqUtils.filter(storageDomains, new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain storage_domain) {
            return storage_domain.getStorageDomainType() == StorageDomainType.Master;
        }
    });
    final StorageDomain masterDomain = LinqUtils.first(temp);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(masterDomain.getStoragePoolIsoMapData());
            masterDomain.setStatus(StorageDomainStatus.Locked);
            getDbFacade().getStoragePoolIsoMapDao().update(masterDomain.getStoragePoolIsoMapData());
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // destroying a pool is an SPM action. We need to connect all hosts
    // to the pool. Later on, during spm election, one of the hosts will
    // lock the pool
    // and the spm status will be FREE. Only then we can invoke the
    // destroy verb.
    connectAllHostToPoolAndDomain(masterDomain);
    List<VDS> vdss = getAllRunningVdssInPool();
    for (StorageDomain storageDomain : storageDomains) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            if (!removeDomainFromPool(storageDomain, vdss.get(0))) {
                log.error("Unable to detach storage domain '{}' '{}'", storageDomain.getStorageName(), storageDomain.getId());
                retVal = false;
            }
        }
    }
    handleDestroyStoragePoolCommand();
    handleMasterDomain(masterDomain);
    runSynchronizeOperation(new DisconnectStoragePoolAsyncOperationFactory());
    setSucceeded(true);
    if (!getStoragePool().isLocal()) {
        for (VDS vds : vdss) {
            StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vds.getId());
        }
    } else {
        try {
            runVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vdss.get(0).getId(), masterDomain.getId()));
        } catch (EngineException e) {
        // Do nothing, exception already printed at logs
        }
        StorageHelperDirector.getInstance().getItem(masterDomain.getStorageType()).disconnectStorageFromDomainByVdsId(masterDomain, vdss.get(0).getId());
        removeDomainFromDb(masterDomain);
    }
    return retVal;
}
#end_block

#method_before
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    RemoveVmPoolCommand<? extends VmPoolParametersBase> command = getCommand(cmdId);
    boolean anyFailed = false;
    for (Guid childCmdId : childCmdIds) {
        CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId);
        switch(entity.getCommandStatus()) {
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
                break;
            default:
                break;
        }
        if (entity.isExecuted() && !entity.getReturnValue().getSucceeded()) {
            anyFailed = true;
        }
    }
    if (anyFailed) {
        command.setCommandStatus(CommandStatus.FAILED);
    } else {
        VmPool pool = DbFacade.getInstance().getVmPoolDao().get(command.getVmPoolId());
        if (pool.getRunningVmsCount() == 0) {
            command.setCommandStatus(CommandStatus.SUCCEEDED);
        }
    }
}
#method_after
@Override
public void doPolling(Guid cmdId, List<Guid> childCmdIds) {
    RemoveVmPoolCommand<? extends VmPoolParametersBase> command = getCommand(cmdId);
    boolean anyFailed = false;
    for (Guid childCmdId : childCmdIds) {
        CommandEntity entity = CommandCoordinatorUtil.getCommandEntity(childCmdId);
        switch(entity.getCommandStatus()) {
            case FAILED:
            case FAILED_RESTARTED:
            case UNKNOWN:
                anyFailed = true;
                break;
            default:
                break;
        }
    }
    if (anyFailed) {
        command.setCommandStatus(CommandStatus.FAILED);
    } else {
        VmPool pool = DbFacade.getInstance().getVmPoolDao().get(command.getVmPoolId());
        if (pool == null || pool.getRunningVmsCount() == 0) {
            command.setCommandStatus(CommandStatus.SUCCEEDED);
        }
    }
}
#end_block

#method_before
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    getCommand(cmdId).onStopVmsFailed();
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#method_after
@Override
public void onFailed(Guid cmdId, List<Guid> childCmdIds) {
    RemoveVmPoolCommand<? extends VmPoolParametersBase> cmd = getCommand(cmdId);
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
    cmd.getParameters().setTaskGroupSuccess(false);
    cmd.endAction();
}
#end_block

#method_before
@Override
public void onSucceeded(Guid cmdId, List<Guid> childCmdIds) {
    getCommand(cmdId).onStopVmsSucceeded();
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
}
#method_after
@Override
public void onSucceeded(Guid cmdId, List<Guid> childCmdIds) {
    RemoveVmPoolCommand<? extends VmPoolParametersBase> cmd = getCommand(cmdId);
    CommandCoordinatorUtil.removeAllCommandsInHierarchy(cmdId);
    cmd.getParameters().setTaskGroupSuccess(true);
    cmd.endAction();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getVmPool());
            setPoolBeingDestroyed();
            setPrestartedToZero();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    setCommandShouldBeLogged(false);
    if (stopVms()) {
        onStopVmsSucceeded();
    } else {
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getCompensationContext().snapshotEntity(getVmPool());
            setPoolBeingDestroyed();
            setPrestartedToZero();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    // disable logging at the end of command execution
    setCommandShouldBeLogged(false);
    // and log the message now
    log();
    stopVms();
    if (allVmsDown) {
        endSuccessfully();
    } else {
        setSucceeded(true);
    }
}
#end_block

#method_before
private boolean stopVms() {
    boolean allDown = true;
    for (VM vm : getCachedVmsInPool()) {
        if (!vm.isDown()) {
            CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.StopVm, withRootCommandInfo(new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL), getActionType()), cloneContextAndDetachFromParent());
            allDown = false;
        }
    }
    return allDown;
}
#method_after
private void stopVms() {
    allVmsDown = true;
    for (VM vm : getCachedVmsInPool()) {
        if (!vm.isDown()) {
            CommandCoordinatorUtil.executeAsyncCommand(VdcActionType.StopVm, withRootCommandInfo(new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL)), cloneContextAndDetachFromParent());
            allVmsDown = false;
        } else {
            removeVm(vm);
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.USER_REMOVE_VM_POOL : AuditLogType.USER_REMOVE_VM_POOL_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getActionState() == CommandActionState.EXECUTE) {
        return AuditLogType.USER_REMOVE_VM_POOL_INITIATED;
    } else {
        return getSucceeded() ? AuditLogType.USER_REMOVE_VM_POOL : AuditLogType.USER_REMOVE_VM_POOL_FAILED;
    }
}
#end_block

#method_before
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(((CinderDisk) getDiskDao().get(cinderDisk.getId())).getImageId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty() || getMemoryImageBuilder().isCreateTasks());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDescription(getParameters().getDescription());
    return withRootCommandInfo(createParams, getActionType());
}
#method_after
private ImagesContainterParametersBase buildChildCommandParameters(DiskImage cinderDisk) {
    ImagesContainterParametersBase createParams = new ImagesContainterParametersBase(((CinderDisk) getDiskDao().get(cinderDisk.getId())).getImageId());
    createParams.setVmSnapshotId(newActiveSnapshotId);
    createParams.setParentHasTasks(!cachedImagesDisks.isEmpty() || getMemoryImageBuilder().isCreateTasks());
    createParams.setStorageDomainId(cinderDisk.getStorageIds().get(0));
    createParams.setDescription(getParameters().getDescription());
    return withRootCommandInfo(createParams);
}
#end_block

#method_before
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    confirmModel.setVmUnpinned(isVmUnpinned());
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                    // currentl only hot plug memory is supported here (no hot unplug)
                    confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < getcurrentVm().getMemSizeMb());
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    if (confirmModel.isVmUnpinned()) {
                        // disable OK button, till warning is confirmed
                        confirmModel.getCommands().get(0).setIsExecutionAllowed(false);
                    }
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#method_after
@Override
protected void updateVM(final UnitVmModel model) {
    final VM selectedItem = getSelectedItem();
    // explicitly pass non-editable field from the original VM
    getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
    getcurrentVm().setUseLatestVersion(model.getTemplateWithVersion().getSelectedItem().isLatest());
    if (selectedItem.isRunningOrPaused()) {
        AsyncDataProvider.getInstance().getVmChangedFieldsForNextRun(editedVm, getcurrentVm(), getUpdateVmParameters(false), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object thisModel, Object returnValue) {
                List<String> changedFields = ((VdcQueryReturnValue) returnValue).<List<String>>getReturnValue();
                // provide warnings if isVmUnpinned()
                if (!changedFields.isEmpty() || isVmUnpinned()) {
                    VmNextRunConfigurationModel confirmModel = new VmNextRunConfigurationModel();
                    if (isVmUnpinned()) {
                        confirmModel.setVmUnpinned();
                    }
                    confirmModel.setTitle(ConstantsManager.getInstance().getConstants().editNextRunConfigurationTitle());
                    confirmModel.setHelpTag(HelpTag.edit_next_run_configuration);
                    // $NON-NLS-1$
                    confirmModel.setHashName("edit_next_run_configuration");
                    confirmModel.setChangedFields(changedFields);
                    confirmModel.setCpuPluggable(selectedItem.getCpuPerSocket() == getcurrentVm().getCpuPerSocket() && selectedItem.getNumOfSockets() != getcurrentVm().getNumOfSockets());
                    // currentl only hot plug memory is supported here (no hot unplug)
                    confirmModel.setMemoryPluggable(selectedItem.getMemSizeMb() < getcurrentVm().getMemSizeMb());
                    confirmModel.getCommands().add(// $NON-NLS-1$
                    new UICommand("updateExistingVm", VmListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
                    // $NON-NLS-1$
                    confirmModel.getCommands().add(UICommand.createCancelUiCommand("CancelConfirmation", VmListModel.this));
                    setConfirmWindow(confirmModel);
                } else {
                    updateExistingVm(false);
                }
            }

            private boolean isVmUnpinned() {
                if (selectedItem.isRunning()) {
                    if (selectedItem.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST && getcurrentVm().getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
                        return true;
                    }
                }
                return false;
            }
        }));
    } else {
        updateExistingVm(false);
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getImportVmCommand()) {
        importVms();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export();
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if ("OnAssignTags".equals(command.getName())) {
        // $NON-NLS-1$
        onAssignTags();
    } else if ("Cancel".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnSave".equals(command.getName())) {
        // $NON-NLS-1$
        preSave();
    } else if ("PreSavePhase2".equals(command.getName())) {
        // $NON-NLS-1$
        preSavePhase2();
        cancelConfirmation();
    } else if ("OnRemove".equals(command.getName())) {
        // $NON-NLS-1$
        onRemove();
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    } else if ("OnExport".equals(command.getName())) {
        // $NON-NLS-1$
        onExport();
    } else if ("OnExportNoTemplates".equals(command.getName())) {
        // $NON-NLS-1$
        onExportNoTemplates();
    } else if ("CancelConfirmation".equals(command.getName())) {
        // $NON-NLS-1$
        cancelConfirmation();
    } else if ("OnRunOnce".equals(command.getName())) {
        // $NON-NLS-1$
        cancel();
    } else if ("OnNewTemplate".equals(command.getName())) {
        // $NON-NLS-1$
        onNewTemplate();
    } else if ("OnMigrate".equals(command.getName())) {
        // $NON-NLS-1$
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (command == getCancelConvertCommand()) {
        cancelConversion();
    } else if ("OnShutdown".equals(command.getName())) {
        // $NON-NLS-1$
        onShutdown();
    } else if ("OnStop".equals(command.getName())) {
        // $NON-NLS-1$
        onStop();
    } else if ("OnReboot".equals(command.getName())) {
        // $NON-NLS-1$
        onReboot();
    } else if ("OnChangeCD".equals(command.getName())) {
        // $NON-NLS-1$
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("updateExistingVm".equals(command.getName())) {
        // $NON-NLS-1$
        VmNextRunConfigurationModel model = (VmNextRunConfigurationModel) getConfirmWindow();
        if (!model.validate()) {
            return;
        }
        updateExistingVm(model.getApplyCpuLater().getEntity());
        cancelConfirmation();
    } else if (CMD_CONFIGURE_VMS_TO_IMPORT.equals(command.getName())) {
        onConfigureVmsToImport();
    }
}
#end_block

#method_before
void localize() {
    changedFieldsPanelTitle.setHTML(messages.nextRunConfigurationExists());
    applyNowTitleMessage.setHTML(messages.nextRunConfigurationCanBeAppliedImmediately());
    applyNowCpuMessage.setHTML(bulletedItem(messages.nextRunConfigurationCpuValue()));
    applyNowMemoryMessage.setHTML(bulletedItem(messages.nextRunConfigurationMemoryValue()));
    applyCpuLaterEditor.setLabel(constants.applyLater());
    vmUnpinnedPanelTitle.setHTML(messages.unpinnedRunningVmWarningTitle());
    vmUnpinnedMessage1.setHTML(bulletedItem(messages.unpinnedRunningVmWarningIncompatability()));
    vmUnpinnedMessage2.setHTML(bulletedItem(messages.unpinnedRunningVmWarningSecurity()));
    vmUnpinnedLatchEditor.setLabel(constants.latchApproveOperationLabel());
}
#method_after
void localize() {
    changedFieldsPanelTitle.setHTML(messages.nextRunConfigurationExists());
    applyNowTitleMessage.setHTML(messages.nextRunConfigurationCanBeAppliedImmediately());
    applyNowCpuMessage.setHTML(bulletedItem(messages.nextRunConfigurationCpuValue()));
    applyNowMemoryMessage.setHTML(bulletedItem(messages.nextRunConfigurationMemoryValue()));
    applyCpuLaterEditor.setLabel(constants.applyLater());
    warningSectionTitle.setHTML(messages.warningSectionTitle());
    vmUnpinnedPanelTitle.setHTML(messages.unpinnedRunningVmWarningTitle());
    vmUnpinnedMessage1.setHTML(bulletedItem(messages.unpinnedRunningVmWarningIncompatability()));
    vmUnpinnedMessage2.setHTML(bulletedItem(messages.unpinnedRunningVmWarningSecurity()));
    vmUnpinnedLatchEditor.setLabel(constants.latchApproveUnpinningLabel());
}
#end_block

#method_before
public void setVmUnpinned(boolean pinningFlag) {
    this.vmUnpinned = pinningFlag;
}
#method_after
public void setVmUnpinned() {
    getLatch().setIsAvailable(true);
    getLatch().setIsChangeable(true);
    vmUnpinned = true;
}
#end_block

#method_before
private void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    Map<Guid, DiskImage> diskImagesMap = new HashMap<>();
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        DiskImage diskImage = (DiskImage) diskModel.getDisk();
        diskImagesMap.put(diskImage.getImageId(), diskImage);
        diskModelsMap.put(diskImage.getImageId(), diskModel);
    }
    Model model = getContainer() != null ? getContainer() : this;
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Guid, DiskImage> imagesAncestorsMap = (Map<Guid, DiskImage>) returnValue;
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestorsMap.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
            }
        }
    }), diskImagesMap);
}
#method_after
private void setDefaultVolumeInformationSelection(List<DiskModel> diskModels) {
    final Map<Guid, DiskModel> diskModelsMap = new HashMap<>();
    for (DiskModel diskModel : diskModels) {
        diskModelsMap.put(((DiskImage) diskModel.getDisk()).getImageId(), diskModel);
    }
    Model model = getContainer() != null ? getContainer() : this;
    AsyncDataProvider.getInstance().getAncestorImagesByImagesIds(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Guid, DiskImage> imagesAncestors = (Map<Guid, DiskImage>) returnValue;
            for (Map.Entry<Guid, DiskImage> entry : imagesAncestors.entrySet()) {
                DiskModel diskModel = diskModelsMap.get(entry.getKey());
                diskModel.getVolumeType().setSelectedItem(entry.getValue().getVolumeType());
                diskModel.getVolumeFormat().setSelectedItem(entry.getValue().getVolumeFormat());
            }
        }
    }), new ArrayList<>(diskModelsMap.keySet()));
}
#end_block

#method_before
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    initializeImages();
    when(getDbFacadeMockInstance().getDiskImageDao()).thenReturn(diskImageDao);
    diskImagesMap = new HashMap<>();
    when(getQueryParameters().getDiskImagesMap()).thenReturn(diskImagesMap);
}
#method_after
@Override
@Before
public void setUp() throws Exception {
    super.setUp();
    initializeImages();
    when(getDbFacadeMockInstance().getDiskImageDao()).thenReturn(diskImageDao);
    imagesIds = new ArrayList<>();
    when(getQueryParameters().getIds()).thenReturn(imagesIds);
}
#end_block

#method_before
@Test
public void executeQueryCommandWithSnapshots() {
    diskImagesMap.put(image1.getImageId(), image1);
    diskImagesMap.put(image2.getImageId(), image2);
    diskImagesMap.put(image3.getImageId(), image3);
    Map<Guid, DiskImage> queryReturnValue = runQuery();
    assertEquals(3, queryReturnValue.size());
    assertEquals(image1, queryReturnValue.get(image1.getImageId()));
    assertEquals(image1, queryReturnValue.get(image2.getImageId()));
    assertEquals(image1, queryReturnValue.get(image3.getImageId()));
}
#method_after
@Test
public void executeQueryCommandWithSnapshots() {
    imagesIds.add(image1.getImageId());
    imagesIds.add(image2.getImageId());
    imagesIds.add(image3.getImageId());
    Map<Guid, DiskImage> queryReturnValue = runQuery();
    assertEquals(3, queryReturnValue.size());
    assertEquals(image1, queryReturnValue.get(image1.getImageId()));
    assertEquals(image1, queryReturnValue.get(image2.getImageId()));
    assertEquals(image1, queryReturnValue.get(image3.getImageId()));
}
#end_block

#method_before
private void initializeImages() {
    image1 = new DiskImage();
    image1.setImageId(Guid.newGuid());
    when(diskImageDao.getAncestor(image1.getImageId())).thenReturn(image1);
    image2 = new DiskImage();
    image2.setImageId(Guid.newGuid());
    when(diskImageDao.getAncestor(image2.getImageId())).thenReturn(image1);
    image3 = new DiskImage();
    image3.setImageId(Guid.newGuid());
    when(diskImageDao.getAncestor(image3.getImageId())).thenReturn(image1);
}
#method_after
private void initializeImages() {
    image1 = new DiskImage();
    image1.setImageId(Guid.newGuid());
    mockImageAncestor(image1, image1);
    image2 = new DiskImage();
    image2.setImageId(Guid.newGuid());
    mockImageAncestor(image2, image1);
    image3 = new DiskImage();
    image3.setImageId(Guid.newGuid());
    mockImageAncestor(image3, image1);
}
#end_block

#method_before
public void getAncestorImagesByImagesIds(AsyncQuery aQuery, Map<Guid, DiskImage> diskImagesMap) {
    aQuery.converterCallback = new IAsyncConverter<Map<Guid, DiskImage>>() {

        @Override
        public Map<Guid, DiskImage> Convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Map<Guid, DiskImage>) returnValue;
        }
    };
    GetAncestorImagesByImagesIdsParameters params = new GetAncestorImagesByImagesIdsParameters(diskImagesMap);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#method_after
public void getAncestorImagesByImagesIds(AsyncQuery aQuery, List<Guid> imagesIds) {
    aQuery.converterCallback = new IAsyncConverter<Map<Guid, DiskImage>>() {

        @Override
        public Map<Guid, DiskImage> Convert(Object returnValue, AsyncQuery asyncQuery) {
            return (Map<Guid, DiskImage>) returnValue;
        }
    };
    IdsQueryParameters params = new IdsQueryParameters(imagesIds);
    Frontend.getInstance().runQuery(VdcQueryType.GetAncestorImagesByImagesIds, params, aQuery);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    for (Map.Entry<Guid, DiskImage> entry : getParameters().getDiskImagesMap().entrySet()) {
        DiskImage ancestor = getDbFacade().getDiskImageDao().getAncestor(entry.getKey());
        if (ancestor != null) {
            entry.setValue(ancestor);
        }
    }
    getQueryReturnValue().setReturnValue(getParameters().getDiskImagesMap());
}
#method_after
@Override
protected void executeQueryCommand() {
    Map<Guid, DiskImage> imagesAncestors = new HashMap<>();
    for (Guid id : getParameters().getIds()) {
        DiskImage ancestor = getDbFacade().getDiskImageDao().getAncestor(id, getUserID(), getParameters().isFiltered());
        imagesAncestors.put(id, ancestor);
    }
    getQueryReturnValue().setReturnValue(imagesAncestors);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.error("Illegal vm hash '{}'.", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setVmIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guest_mem_stats)) {
        Map<String, Object> sub = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.vm_guest_mem_stats);
        if (sub.containsKey(VdsProperties.vm_guest_mem_buffered)) {
            vm.setGuestMemoryBuffered(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_buffered).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_cached)) {
            vm.setGuestMemoryCached(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_cached).toString()));
        }
        if (sub.containsKey(VdsProperties.vm_guest_mem_free)) {
            vm.setGuestMemoryFree(Long.parseLong(sub.get(VdsProperties.vm_guest_mem_free).toString()));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.valueOf(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#method_after
public static void updateNumaStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    List<VdsNumaNode> vdsNumaNodes = new ArrayList<>();
    if (vds.getNumaNodeList() != null && !vds.getNumaNodeList().isEmpty()) {
        vdsNumaNodes.addAll(vds.getNumaNodeList());
    }
    List<CpuStatistics> cpuStatsData = new ArrayList<>();
    if (xmlRpcStruct.containsKey(VdsProperties.CPU_STATS)) {
        Map<String, Map<String, Object>> cpuStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.CPU_STATS);
        Map<Integer, List<CpuStatistics>> numaNodeCpuStats = new HashMap<>();
        for (Map.Entry<String, Map<String, Object>> item : cpuStats.entrySet()) {
            CpuStatistics data = buildVdsCpuStatistics(item);
            cpuStatsData.add(data);
            int numaNodeIndex = assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_INDEX);
            if (!numaNodeCpuStats.containsKey(numaNodeIndex)) {
                numaNodeCpuStats.put(numaNodeIndex, new ArrayList<CpuStatistics>());
            }
            numaNodeCpuStats.get(numaNodeIndex).add(data);
        }
        DecimalFormat percentageFormatter = new DecimalFormat("#.##");
        for (Map.Entry<Integer, List<CpuStatistics>> item : numaNodeCpuStats.entrySet()) {
            VdsNumaNode nodeWithStatistics = buildVdsNumaNodeStatistics(percentageFormatter, item);
            if (vdsNumaNodes.isEmpty()) {
                vdsNumaNodes.add(nodeWithStatistics);
            } else {
                boolean foundNumaNode = false;
                // append the statistics to the correct numaNode (search by its Index.)
                for (VdsNumaNode currNumaNode : vdsNumaNodes) {
                    if (currNumaNode.getIndex() == nodeWithStatistics.getIndex()) {
                        currNumaNode.setNumaNodeStatistics(nodeWithStatistics.getNumaNodeStatistics());
                        foundNumaNode = true;
                        break;
                    }
                }
                // append new numaNode (contains only statistics) if not found existing
                if (!foundNumaNode) {
                    vdsNumaNodes.add(nodeWithStatistics);
                }
            }
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODE_FREE_MEM_STAT)) {
        Map<String, Map<String, Object>> memStats = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_FREE_MEM_STAT);
        for (Map.Entry<String, Map<String, Object>> item : memStats.entrySet()) {
            VdsNumaNode node = NumaUtils.getVdsNumaNodeByIndex(vdsNumaNodes, Integer.parseInt(item.getKey()));
            if (node != null && node.getNumaNodeStatistics() != null) {
                node.getNumaNodeStatistics().setMemFree(assignLongValue(item.getValue(), VdsProperties.NUMA_NODE_FREE_MEM));
                node.getNumaNodeStatistics().setMemUsagePercent(assignIntValue(item.getValue(), VdsProperties.NUMA_NODE_MEM_PERCENT));
            }
        }
    }
    vds.getNumaNodeList().clear();
    vds.getNumaNodeList().addAll(vdsNumaNodes);
    vds.getStatisticsData().getCpuCoreStatistics().clear();
    vds.getStatisticsData().getCpuCoreStatistics().addAll(cpuStatsData);
}
#end_block

#method_before
private static VdsNumaNode buildVdsNumaNodeStatistics(DecimalFormat percentageFormatter, Map.Entry<Integer, List<CpuStatistics>> item) {
    VdsNumaNode node = new VdsNumaNode();
    NumaNodeStatistics nodeStat = new NumaNodeStatistics();
    double nodeCpuUser = 0.0;
    double nodeCpuSys = 0.0;
    double nodeCpuIdle = 0.0;
    for (CpuStatistics cpuStat : item.getValue()) {
        nodeCpuUser += cpuStat.getCpuUser();
        nodeCpuSys += cpuStat.getCpuSys();
        nodeCpuIdle += cpuStat.getCpuIdle();
    }
    nodeStat.setCpuUser(Double.valueOf(percentageFormatter.format(nodeCpuUser / item.getValue().size())));
    nodeStat.setCpuSys(Double.valueOf(percentageFormatter.format(nodeCpuSys / item.getValue().size())));
    nodeStat.setCpuIdle(Double.valueOf(percentageFormatter.format(nodeCpuIdle / item.getValue().size())));
    nodeStat.setCpuUsagePercent((int) (nodeStat.getCpuSys() + nodeStat.getCpuUser()));
    node.setIndex(item.getKey());
    node.setNumaNodeStatistics(nodeStat);
    return node;
}
#method_after
private static VdsNumaNode buildVdsNumaNodeStatistics(DecimalFormat percentageFormatter, Map.Entry<Integer, List<CpuStatistics>> item) {
    VdsNumaNode node = new VdsNumaNode();
    NumaNodeStatistics nodeStat = new NumaNodeStatistics();
    double nodeCpuUser = 0.0;
    double nodeCpuSys = 0.0;
    double nodeCpuIdle = 0.0;
    for (CpuStatistics cpuStat : item.getValue()) {
        nodeCpuUser += cpuStat.getCpuUser();
        nodeCpuSys += cpuStat.getCpuSys();
        nodeCpuIdle += cpuStat.getCpuIdle();
    }
    nodeStat.setCpuUser(Double.parseDouble(percentageFormatter.format(nodeCpuUser / item.getValue().size())));
    nodeStat.setCpuSys(Double.parseDouble(percentageFormatter.format(nodeCpuSys / item.getValue().size())));
    nodeStat.setCpuIdle(Double.parseDouble(percentageFormatter.format(nodeCpuIdle / item.getValue().size())));
    nodeStat.setCpuUsagePercent((int) (nodeStat.getCpuSys() + nodeStat.getCpuUser()));
    node.setIndex(item.getKey());
    node.setNumaNodeStatistics(nodeStat);
    return node;
}
#end_block

#method_before
private static CpuStatistics buildVdsCpuStatistics(Map.Entry<String, Map<String, Object>> item) {
    CpuStatistics data = new CpuStatistics();
    data.setCpuId(Integer.valueOf(item.getKey()));
    data.setCpuUser(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_USER));
    data.setCpuSys(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_SYS));
    data.setCpuIdle(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_IDLE));
    data.setCpuUsagePercent((int) (data.getCpuSys() + data.getCpuUser()));
    return data;
}
#method_after
private static CpuStatistics buildVdsCpuStatistics(Map.Entry<String, Map<String, Object>> item) {
    CpuStatistics data = new CpuStatistics();
    data.setCpuId(Integer.parseInt(item.getKey()));
    data.setCpuUser(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_USER));
    data.setCpuSys(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_SYS));
    data.setCpuIdle(assignDoubleValue(item.getValue(), VdsProperties.NUMA_CPU_IDLE));
    data.setCpuUsagePercent((int) (data.getCpuSys() + data.getCpuUser()));
    return data;
}
#end_block

#method_before
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.valueOf(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        if (numaNodeDistanceMap != null) {
            for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
                int index = vdsNumaNode.getIndex();
                List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                Map<Integer, Integer> distanceMap = new HashMap<>(distances.size());
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
                VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
                if (newNumaNode != null) {
                    newNumaNode.setNumaNodeDistances(distanceMap);
                }
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#method_after
private static void updateNumaNodesData(VDS vds, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.AUTO_NUMA)) {
        vds.getDynamicData().setAutoNumaBalancing(AutoNumaBalanceStatus.forValue(assignIntValue(xmlRpcStruct, VdsProperties.AUTO_NUMA)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.NUMA_NODES)) {
        Map<String, Map<String, Object>> numaNodeMap = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NUMA_NODES);
        Map<String, Object> numaNodeDistanceMap = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NUMA_NODE_DISTANCE);
        List<VdsNumaNode> newNumaNodeList = new ArrayList<>(numaNodeMap.size());
        for (Map.Entry<String, Map<String, Object>> item : numaNodeMap.entrySet()) {
            int index = Integer.parseInt(item.getKey());
            Map<String, Object> itemMap = item.getValue();
            List<Integer> cpuIds = extractIntegerList(itemMap, VdsProperties.NUMA_NODE_CPU_LIST);
            long memTotal = assignLongValue(itemMap, VdsProperties.NUMA_NODE_TOTAL_MEM);
            VdsNumaNode numaNode = new VdsNumaNode();
            numaNode.setIndex(index);
            if (cpuIds != null) {
                numaNode.setCpuIds(cpuIds);
            }
            numaNode.setMemTotal(memTotal);
            newNumaNodeList.add(numaNode);
        }
        Collections.sort(newNumaNodeList, numaNodeComparator);
        for (VdsNumaNode vdsNumaNode : newNumaNodeList) {
            int index = vdsNumaNode.getIndex();
            Map<Integer, Integer> distanceMap = new HashMap<>();
            if (numaNodeDistanceMap != null) {
                // Save the received NUMA node distances
                List<Integer> distances = extractIntegerList(numaNodeDistanceMap, String.valueOf(index));
                for (int i = 0; i < distances.size(); i++) {
                    distanceMap.put(newNumaNodeList.get(i).getIndex(), distances.get(i));
                }
            } else {
                // Save faked distances
                for (VdsNumaNode otherNumaNode : newNumaNodeList) {
                    // There is no distance if the node is the same one
                    if (otherNumaNode.getIndex() == vdsNumaNode.getIndex()) {
                        continue;
                    }
                    distanceMap.put(otherNumaNode.getIndex(), 0);
                }
            }
            VdsNumaNode newNumaNode = NumaUtils.getVdsNumaNodeByIndex(newNumaNodeList, index);
            if (newNumaNode != null) {
                newNumaNode.setNumaNodeDistances(distanceMap);
            }
        }
        vds.getDynamicData().setNumaNodeList(newNumaNodeList);
        vds.setNumaSupport(newNumaNodeList.size() > 1);
    }
}
#end_block

#method_before
private static void updateVmNumaNodesRuntimeInfo(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    Map<String, Object[]> vNodesRunInfo = (Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO);
    for (Map.Entry<String, Object[]> item : vNodesRunInfo.entrySet()) {
        VmNumaNode vNode = new VmNumaNode();
        vNode.setIndex(Integer.valueOf(item.getKey()));
        for (Object pNodeIndex : item.getValue()) {
            vNode.getVdsNumaNodeList().add(new Pair<>(Guid.Empty, new Pair<>(false, (Integer) pNodeIndex)));
        }
        vm.getvNumaNodeStatisticsList().add(vNode);
    }
}
#method_after
private static void updateVmNumaNodesRuntimeInfo(VmStatistics vm, Map<String, Object> xmlRpcStruct) {
    Map<String, Object[]> vNodesRunInfo = (Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.VM_NUMA_NODES_RUNTIME_INFO);
    for (Map.Entry<String, Object[]> item : vNodesRunInfo.entrySet()) {
        VmNumaNode vNode = new VmNumaNode();
        vNode.setIndex(Integer.parseInt(item.getKey()));
        for (Object pNodeIndex : item.getValue()) {
            vNode.getVdsNumaNodeList().add(new Pair<>(Guid.Empty, new Pair<>(false, (Integer) pNodeIndex)));
        }
        vm.getvNumaNodeStatisticsList().add(vNode);
    }
}
#end_block

#method_before
protected void setOsId(Map vmInfo, VmStatic vmStatic) {
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    String osName = (String) vmInfo.get(VdsProperties.guest_os);
    if (osName == null) {
        // OS not provided by VDS, let's get default for the VdsGroup
        VDSGroup vdsGroup = getVdsGroup(vmStatic.getVdsGroupId());
        ArchitectureType vdsArchitecture = vdsGroup.getArchitecture();
        Integer defaultArchOs = osRepository.getDefaultOSes().get(vdsArchitecture);
        if (defaultArchOs != null) {
            vmStatic.setOsId(defaultArchOs);
        }
    // otherwise keep default (0 - DEFAULT_X86_OS)
    }
// recently guest_os (osName) for the VM is not provided by VDS.
}
#method_after
protected void setOsId(VmStatic vmStatic, String guestOsNameFromVdsm, int defaultArchOsId) {
    if (StringUtils.isEmpty(guestOsNameFromVdsm)) {
        log.debug("VM '{}': setting default OS ID: '{}'", vmStatic.getName(), defaultArchOsId);
        vmStatic.setOsId(defaultArchOsId);
    }
}
#end_block

#method_before
protected void setDisplayType(Map vmInfo, VmStatic vmStatic) {
    OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    int osId = vmStatic.getOsId();
    VDSGroup vdsGroup = getVdsGroup(vmStatic.getVdsGroupId());
    Version clusterVersion = vdsGroup.getCompatibilityVersion();
    String displayType = (String) vmInfo.get(VdsProperties.displayType);
    if (displayType == null) {
        List<Pair<GraphicsType, DisplayType>> pairs = osRepository.getGraphicsAndDisplays(osId, clusterVersion);
        Pair<GraphicsType, DisplayType> graphicsDisplayPair = pairs.get(0);
        if (graphicsDisplayPair != null) {
            DisplayType defaultDisplayType = graphicsDisplayPair.getSecond();
            vmStatic.setDefaultDisplayType(defaultDisplayType);
        }
    }
// Recently graphics is not provided by VDS. Extend here otherwise.
}
#method_after
protected void setDisplayType(VmStatic vmStatic, String displayTypeFromVdsm, DisplayType defaultDisplayType) {
    if (StringUtils.isEmpty(displayTypeFromVdsm)) {
        log.debug("VM '{}': setting default display type: '{}'", vmStatic.getName(), defaultDisplayType.getValue());
        vmStatic.setDefaultDisplayType(defaultDisplayType);
    }
}
#end_block

#method_before
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(Config.<String>getValue(ConfigValues.HostedEngineVmName), vmNameOnHost)) {
                // its a hosted engine VM -> import it and skip the external VM phase
                importHostedEngineVM(vmInfo);
                continue;
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            setOsId(vmInfo, vmStatic);
            setDisplayType(vmInfo, vmStatic);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    // Fetching for details from the host
    // and marking the VMs for addition
    List<String> vmsToQuery = new ArrayList<>(externalVms.size());
    for (Pair<VM, VmInternalData> pair : externalVms) {
        vmsToQuery.add(pair.getSecond().getVmDynamic().getId().toString());
    }
    if (!vmsToQuery.isEmpty()) {
        VDSGroup vdsGroup = getDbFacade().getVdsGroupDao().get(vdsManager.getVdsGroupId());
        int defaultOsId = getDefaultOsId(vdsGroup.getArchitecture());
        DisplayType defaultDisplayType = getDefaultDisplayType(defaultOsId, vdsGroup.getCompatibilityVersion());
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(vdsManager.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(Config.<String>getValue(ConfigValues.HostedEngineVmName), vmNameOnHost)) {
                // its a hosted engine VM -> import it and skip the external VM phase
                importHostedEngineVM(vmInfo);
                continue;
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(VdsBrokerObjectsBuilder.parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            setOsId(vmStatic, (String) vmInfo.get(VdsProperties.guest_os), defaultOsId);
            setDisplayType(vmStatic, (String) vmInfo.get(VdsProperties.displayType), defaultDisplayType);
            externalVmsToAdd.add(vmStatic);
            log.info("Importing VM '{}' as '{}', as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setCpuName(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm()) {
        if (model.getKsm().isSetEnabled()) {
            entity.setEnableKsm(model.getKsm().isEnabled());
        }
        if (model.getKsm().isSetMergeAcrossNodes()) {
            entity.setKsmMergeAcrossNumaNodes(model.getKsm().isMergeAcrossNodes());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources(), null));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetType()) {
        entity.setCpuName(model.getCpu().getType());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setCompatibilityVersion(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
    if (schedulingPolicy != null) {
        if (schedulingPolicy.isSetName()) {
            entity.setClusterPolicyName(schedulingPolicy.getName());
        }
        if (schedulingPolicy.isSetId()) {
            entity.setClusterPolicyId(GuidUtils.asGuid(schedulingPolicy.getId()));
        }
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetOptionalReason()) {
        entity.setOptionalReasonRequired(model.isOptionalReason());
    }
    if (model.isSetMaintenanceReasonRequired()) {
        entity.setMaintenanceReasonRequired(model.isMaintenanceReasonRequired());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm()) {
        if (model.getKsm().isSetEnabled()) {
            entity.setEnableKsm(model.getKsm().isEnabled());
        }
        if (model.getKsm().isSetMergeAcrossNodes()) {
            entity.setKsmMergeAcrossNumaNodes(model.getKsm().isMergeAcrossNodes());
        }
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    if (model.isSetRequiredRngSources()) {
        entity.getRequiredRngSources().clear();
        entity.getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(model.getRequiredRngSources().getRequiredRngSources()));
    }
    if (model.isSetFencingPolicy()) {
        entity.setFencingPolicy(FencingPolicyMapper.map(model.getFencingPolicy(), null));
    }
    if (model.isSetMigration()) {
        MigrationOptionsMapper.copyMigrationOptions(model.getMigration(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        CPU cpu = new CPU();
        cpu.setId(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    model.setSchedulingPolicy(map(entity, (SchedulingPolicy) null));
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    KSM ksm = model.getKsm();
    if (ksm == null) {
        ksm = new KSM();
        model.setKsm(ksm);
    }
    ksm.setEnabled(entity.isEnableKsm());
    ksm.setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources(), null));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#method_after
@Mapping(from = VDSGroup.class, to = Cluster.class)
public static Cluster map(VDSGroup entity, Cluster template) {
    Cluster model = template != null ? template : new Cluster();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getDescription());
    model.setComment(entity.getComment());
    if (entity.getCpuName() != null) {
        Cpu cpu = new Cpu();
        cpu.setType(entity.getCpuName());
        cpu.setArchitecture(CPUMapper.map(entity.getArchitecture(), null));
        model.setCpu(cpu);
    }
    if (entity.getStoragePoolId() != null) {
        DataCenter dataCenter = new DataCenter();
        dataCenter.setId(entity.getStoragePoolId().toString());
        model.setDataCenter(dataCenter);
    }
    if (entity.getCompatibilityVersion() != null) {
        model.setVersion(new Version());
        model.getVersion().setMajor(entity.getCompatibilityVersion().getMajor());
        model.getVersion().setMinor(entity.getCompatibilityVersion().getMinor());
    }
    model.setMemoryPolicy(map(entity, (MemoryPolicy) null));
    Guid clusterPolicyId = entity.getClusterPolicyId();
    if (clusterPolicyId != null) {
        SchedulingPolicy schedulingPolicy = model.getSchedulingPolicy();
        if (schedulingPolicy == null) {
            schedulingPolicy = new SchedulingPolicy();
            model.setSchedulingPolicy(schedulingPolicy);
        }
        schedulingPolicy.setId(clusterPolicyId.toString());
    }
    model.setErrorHandling(map(entity.getMigrateOnError(), (ErrorHandling) null));
    model.setVirtService(entity.supportsVirtService());
    model.setGlusterService(entity.supportsGlusterService());
    model.setThreadsAsCores(entity.getCountThreadsAsCores());
    model.setTunnelMigration(entity.isTunnelMigration());
    model.setTrustedService(entity.supportsTrustedService());
    model.setHaReservation(entity.supportsHaReservation());
    model.setOptionalReason(entity.isOptionalReasonRequired());
    model.setMaintenanceReasonRequired(entity.isMaintenanceReasonRequired());
    model.setBallooningEnabled(entity.isEnableBallooning());
    Ksm ksm = model.getKsm();
    if (ksm == null) {
        ksm = new Ksm();
        model.setKsm(ksm);
    }
    ksm.setEnabled(entity.isEnableKsm());
    ksm.setMergeAcrossNodes(entity.isKsmMergeAcrossNumaNodes());
    if (StringUtils.isNotBlank(entity.getSpiceProxy())) {
        Display display = new Display();
        display.setProxy(entity.getSpiceProxy());
        model.setDisplay(display);
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity, null));
    }
    if (entity.getRequiredRngSources() != null) {
        model.setRequiredRngSources(new Cluster.RequiredRngSourcesList());
        model.getRequiredRngSources().getRequiredRngSources().addAll(RngDeviceMapper.mapRngSources(entity.getRequiredRngSources()));
    }
    model.setMigration(MigrationOptionsMapper.map(entity, null));
    if (entity.getFencingPolicy() != null) {
        model.setFencingPolicy(FencingPolicyMapper.map(entity.getFencingPolicy(), null));
    }
    return model;
}
#end_block

#method_before
public T getMaximum() {
    return privateMaximum;
}
#method_after
public T getMaximum() {
    return maximum;
}
#end_block

#method_before
public void setMaximum(T value) {
    privateMaximum = value;
}
#method_after
public void setMaximum(T value) {
    maximum = value;
}
#end_block

#method_before
public T getMinimum() {
    return privateMinimum;
}
#method_after
public T getMinimum() {
    return minimum;
}
#end_block

#method_before
public void setMinimum(T value) {
    privateMinimum = value;
}
#method_after
public void setMinimum(T value) {
    minimum = value;
}
#end_block

#method_before
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    if (value != null && ((value instanceof String && !((String) value).equals("")) || valueTypeCheck(value))) {
        // $NON-NLS-1$
        T pasredValue = value instanceof String ? parse((String) value) : (T) value;
        // $NON-NLS-1$
        String msg = "";
        String prefixMsg = getNumberTypeErrorMessage();
        if (pasredValue == null) {
            result.setSuccess(false);
            msg = getNumberRangeErrorMessage(prefixMsg);
            validationFailedWith(result, msg);
        } else if (belowMinimum(pasredValue)) {
            msg = getNumberBellowMinimumErrorMessage(prefixMsg);
            validationFailedWith(result, msg);
        } else if (aboveMaximum(pasredValue)) {
            msg = getNumberAboveMaximumErrorMessage(prefixMsg);
            validationFailedWith(result, msg);
        }
    } else {
        validationFailedWith(result, getNumberTypeErrorMessage());
    }
    return result;
}
#method_after
@Override
public ValidationResult validate(Object value) {
    ValidationResult result = new ValidationResult();
    T parsedValue = null;
    if (value instanceof String && !StringUtils.isEmpty((String) value)) {
        parsedValue = parse((String) value);
    } else {
        try {
            parsedValue = (T) value;
        } catch (Exception ex) {
            validationFailedWith(result, getNumberTypeErrorMessage());
            return result;
        }
    }
    // $NON-NLS-1$
    String message = "";
    String prefixMsg = getNumberTypeErrorMessage();
    if (parsedValue == null) {
        message = getNumberTypeErrorMessage();
        validationFailedWith(result, message);
    } else if (belowMinimum(parsedValue)) {
        message = getNumberBellowMinimumErrorMessage(prefixMsg);
        validationFailedWith(result, message);
    } else if (aboveMaximum(parsedValue)) {
        message = getNumberAboveMaximumErrorMessage(prefixMsg);
        validationFailedWith(result, message);
    }
    return result;
}
#end_block

#method_before
public void checkNumberRangeOrType() {
    runTest(NUMBER_RANGE);
}
#method_after
public void checkNumberRangeOrType() {
    runTest(NOT_A_NUMBER);
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = (privateSuccess ? 1 : 0);
    result = 31 * result + privateReasons.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(privateSuccess, privateReasons);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    ValidationResult that = (ValidationResult) o;
    if (privateSuccess != that.privateSuccess)
        return false;
    if (!privateReasons.equals(that.privateReasons))
        return false;
    return true;
}
#method_after
@Override
public boolean equals(Object o) {
    if (this == o) {
        return true;
    }
    if (o == null || getClass() != o.getClass()) {
        return false;
    }
    ValidationResult that = (ValidationResult) o;
    return Objects.equals(privateSuccess, that.privateSuccess) && Objects.equals(privateReasons, that.privateReasons);
}
#end_block

#method_before
private void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = createAuditLog(auditLogable, logType, loggerString, severity);
    if (auditLog == null) {
        log.warn("Unable to create AuditLog");
    } else {
        setPropertiesFromAuditLogableBase(auditLogable, auditLog);
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        logMessage(severity, getMessageToLog(loggerString, auditLog));
    }
}
#method_after
private void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = createAuditLog(auditLogable, logType, loggerString, severity);
    if (auditLog == null) {
        log.warn("Unable to create AuditLog");
    } else {
        setPropertiesFromAuditLogableBase(auditLogable, auditLog);
        // truncate user name
        auditLog.setUserName(StringUtils.abbreviate(auditLog.getUserName(), USERNAME_LENGTH));
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        logMessage(severity, getMessageToLog(loggerString, auditLog));
    }
}
#end_block

#method_before
private boolean connectStorageServer(Map<StorageType, List<StorageServerConnections>> connectionsByType) {
    boolean connectSucceeded = true;
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : connectionsByType.entrySet()) {
        StorageType connectionsType = connectionToType.getKey();
        List<StorageServerConnections> connections = connectionToType.getValue();
        connectSucceeded = connectStorageServersByType(connectionsType, connections) && connectSucceeded;
    }
    CINDERStorageHelper CINDERStorageHelper = new CINDERStorageHelper();
    if (CINDERStorageHelper.isActiveCinderDomainAvailable(getStoragePool().getId())) {
        connectSucceeded &= connectStorageServersByType(StorageType.CINDER, null);
    }
    log.info("Host '{}' storage connection was {} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    return connectSucceeded;
}
#method_after
private boolean connectStorageServer(Map<StorageType, List<StorageServerConnections>> connectionsByType) {
    boolean connectSucceeded = true;
    for (Map.Entry<StorageType, List<StorageServerConnections>> connectionToType : connectionsByType.entrySet()) {
        StorageType connectionsType = connectionToType.getKey();
        List<StorageServerConnections> connections = connectionToType.getValue();
        connectSucceeded = connectStorageServersByType(connectionsType, connections) && connectSucceeded;
    }
    CINDERStorageHelper CINDERStorageHelper = new CINDERStorageHelper();
    if (CINDERStorageHelper.isActiveCinderDomainAvailable(getStoragePool().getId())) {
        connectSucceeded &= CINDERStorageHelper.prepareConnectHostToStoragePoolServers(getContext(), getParameters(), null);
    }
    log.info("Host '{}' storage connection was {} ", getVds().getName(), connectSucceeded ? "succeeded" : "failed");
    return connectSucceeded;
}
#end_block

#method_before
private static String getPassword(String what) {
    String[] keyValue = what.split(":", 2);
    String type = keyValue[0];
    String value = keyValue[1];
    String password = null;
    if ("pass".equals(type)) {
        password = value;
    } else if ("file".equals(type)) {
        try (InputStream is = new FileInputStream(value);
            Reader reader = new InputStreamReader(is, Charset.forName("UTF-8"));
            BufferedReader breader = new BufferedReader(reader)) {
            password = breader.readLine();
        } catch (IOException ex) {
            throw new IllegalArgumentException(String.format("Unable to read file '%s'.", value));
        }
    } else if ("env".equals(type)) {
        password = System.getenv(value);
    } else if ("interactive".equals(type)) {
        if (System.console() == null) {
            throw new RuntimeException("Console is not available, interactive password prompt is impossible");
        }
        System.out.print("Password: ");
        char[] passwordChars = System.console().readPassword();
        if (passwordChars == null) {
            throw new RuntimeException("Cannot read password");
        }
        password = new String(passwordChars);
    } else {
        throw new IllegalArgumentException(String.format("Invalid type: '%s'", type));
    }
    return password;
}
#method_after
private static String getPassword(String what) {
    String[] keyValue = what.split(":", 2);
    String type = keyValue[0];
    String value = keyValue[1];
    String password = null;
    if ("pass".equals(type)) {
        password = value;
    } else if ("file".equals(type)) {
        try (InputStream is = new FileInputStream(value);
            Reader reader = new InputStreamReader(is, StandardCharsets.UTF_8);
            BufferedReader breader = new BufferedReader(reader)) {
            password = breader.readLine();
        } catch (IOException ex) {
            throw new IllegalArgumentException(String.format("Unable to read file '%s'.", value));
        }
    } else if ("env".equals(type)) {
        password = System.getenv(value);
    } else if ("interactive".equals(type)) {
        if (System.console() == null) {
            throw new RuntimeException("Console is not available, interactive password prompt is impossible");
        }
        System.out.print("Password: ");
        char[] passwordChars = System.console().readPassword();
        if (passwordChars == null) {
            throw new RuntimeException("Cannot read password");
        }
        password = new String(passwordChars);
    } else {
        throw new IllegalArgumentException(String.format("Invalid type: '%s'", type));
    }
    return password;
}
#end_block

#method_before
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = AAAServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in, Charset.forName("UTF-8"))) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    argModuleMap = parser.getParsedArgs();
    if ((Boolean) argModuleMap.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            log.error(t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        log.error("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        log.error("Invalid action '{}'", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#method_after
@Override
public void parseArguments(List<String> args) throws Exception {
    args.remove(0);
    Properties props = new Properties();
    try (InputStream in = AAAServiceImpl.class.getResourceAsStream("arguments.properties");
        Reader reader = new InputStreamReader(in, StandardCharsets.UTF_8)) {
        props.load(reader);
    }
    Map<String, String> substitutions = (Map) context.get(ContextKeys.CLI_PARSER_SUBSTITUTIONS);
    ArgumentsParser parser = new ArgumentsParser(props, "module");
    parser.getSubstitutions().putAll(substitutions);
    parser.parse(args);
    argModuleMap = parser.getParsedArgs();
    if ((Boolean) argModuleMap.get("help")) {
        System.out.format("Usage: %s", parser.getUsage());
        throw new ExitException("Help", 0);
    }
    if (!parser.getErrors().isEmpty()) {
        for (Throwable t : parser.getErrors()) {
            log.error(t.getMessage());
        }
        throw new ExitException("Parsing error", 1);
    }
    if (args.size() < 1) {
        log.error("Action not provided");
        throw new ExitException("Action not provided", 1);
    }
    try {
        action = Action.valueOf(args.get(0).toUpperCase().replace("-", "_"));
    } catch (IllegalArgumentException e) {
        log.error("Invalid action '{}'", args.get(0));
        throw new ExitException("Invalid action", 1);
    }
    argMap = action.parse(substitutions, props, args);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (getEmulatedMachineOfHostInCluster(vds) == null) {
                return failCanDoAction(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getVdsGroup().getCompatibilityVersion()) >= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForVdsGroup) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDao().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(EngineMessage.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDao().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getCompatibilityVersion().compareTo(oldGroup.getCompatibilityVersion()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            ClusterValidator validator = new ClusterValidator(getDbFacade(), oldGroup, getCpuFlagsManagerHandler());
            if (!validate(validator.dataCenterVersionMismatch())) {
                result = false;
                addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getCpuName() != null || getVdsGroup().getCpuName() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(EngineMessage.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getCpuName()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDao().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getCpuName(), getVdsGroup().getCpuName());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getCpuName());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<>();
        isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        if (isAddedToStoragePool && !validateManagementNetworkAttachement()) {
            return false;
        }
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getCompatibilityVersion(), vds)) {
                result = false;
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
            if (!isSupportedEmulatedMachinesMatchClusterLevel(vds)) {
                return failCanDoAction(EngineMessage.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_INCOMPATIBLE_EMULATED_MACHINE);
            }
        }
        if (result) {
            Set<SupportedAdditionalClusterFeature> additionalClusterFeaturesAdded = getAdditionalClusterFeaturesAdded();
            // New Features cannot be enabled if all up hosts are not supporting the selected feature
            if (CollectionUtils.isNotEmpty(additionalClusterFeaturesAdded) && !checkClusterFeaturesSupported(vdss, additionalClusterFeaturesAdded)) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_SUPPORTED_FEATURES_WITH_LOWER_HOSTS);
                result = false;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        auditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDao().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDao().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(EngineMessage.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(EngineMessage.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getCompatibilityVersion() != null && Version.v3_3.compareTo(getVdsGroup().getCompatibilityVersion()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(EngineMessage.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessageVariable("compatibilityVersion", getVdsGroup().getCompatibilityVersion().getValue());
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(EngineMessage.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result && !FeatureSupported.isMigrationSupported(getArchitecture(), getVdsGroup().getCompatibilityVersion()) && getVdsGroup().getMigrateOnError() != MigrateOnErrorOptions.NO) {
        return failCanDoAction(EngineMessage.MIGRATION_ON_ERROR_IS_NOT_SUPPORTED);
    }
    if (result) {
        result = validateClusterPolicy();
    }
    // non-empty required sources list and rng-unsupported cluster version
    if (result && !getVdsGroup().getRequiredRngSources().isEmpty() && !FeatureSupported.virtIoRngSupported(getVdsGroup().getCompatibilityVersion())) {
        addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
        result = false;
    }
    if (result && getParameters().isForceResetEmulatedMachine()) {
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                addCanDoActionMessage(EngineMessage.VDS_GROUP_HOSTS_MUST_BE_DOWN);
                result = false;
                break;
            }
        }
    }
    if (result && Version.v3_6.compareTo(getVdsGroup().getCompatibilityVersion()) >= 0) {
        List<String> names = new ArrayList<>();
        for (VDS host : allForVdsGroup) {
            if (VdsProtocol.XML == host.getProtocol()) {
                names.add(host.getName());
            }
        }
        if (!names.isEmpty()) {
            return failCanDoAction(EngineMessage.ACTION_TYPE_FAILED_WRONG_PROTOCOL_FOR_CLUSTER_VERSION);
        }
    }
    return result;
}
#end_block

#method_before
private StorageDomainSharedStatus getStorageDomainSharedStatus() {
    StorageDomainSharedStatus status = null;
    if (getStorageDomain() != null) {
        status = getStorageDomain().getStorageDomainSharedStatus();
    }
    return status;
}
#method_after
private StorageDomainSharedStatus getStorageDomainSharedStatus() {
    return getStorageDomain() == null ? null : getStorageDomain().getStorageDomainSharedStatus();
}
#end_block

#method_before
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    StorageDomainStatus status = getStorageDomainStatus();
    StorageDomainSharedStatus sharedStatus = getStorageDomainSharedStatus();
    Object messageParameter;
    if (status == StorageDomainStatus.Unknown && sharedStatus != null) {
        // We got more informative information than "Unknown".
        messageParameter = sharedStatus;
    } else {
        messageParameter = status;
    }
    addCanDoActionMessageVariable("status", messageParameter);
}
#method_after
protected void addStorageDomainStatusIllegalMessage() {
    addCanDoActionMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL2);
    StorageDomainStatus status = getStorageDomainStatus();
    StorageDomainSharedStatus sharedStatus = getStorageDomainSharedStatus();
    Object messageParameter = status;
    if (status == StorageDomainStatus.Unknown && sharedStatus != null) {
        // We got more informative information than "Unknown".
        messageParameter = sharedStatus;
    }
    addCanDoActionMessageVariable("status", messageParameter);
}
#end_block

#method_before
private void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = createAuditLog(auditLogable, logType, loggerString, severity);
    if (auditLog == null) {
        log.warn("Unable to create AuditLog");
    } else {
        setPropertiesFromAuditLogableBase(auditLogable, auditLog);
        try {
            getDbFacadeInstance().getAuditLogDao().save(auditLog);
        } catch (Exception ex) {
            log.error("Unable to save audit log : {} to database : {}", getMessageToLog(loggerString, auditLog), ex.getMessage());
        }
        logMessage(severity, getMessageToLog(loggerString, auditLog));
    }
}
#method_after
private void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    AuditLogSeverity severity = logType.getSeverity();
    AuditLog auditLog = createAuditLog(auditLogable, logType, loggerString, severity);
    if (auditLog == null) {
        log.warn("Unable to create AuditLog");
    } else {
        setPropertiesFromAuditLogableBase(auditLogable, auditLog);
        // truncate user name
        auditLog.setUserName(StringUtils.abbreviate(auditLog.getUserName(), USERNAME_LENGTH));
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        logMessage(severity, getMessageToLog(loggerString, auditLog));
    }
}
#end_block

#method_before
protected VmPayload getVmPayloadByDeviceType(VmDeviceType deviceType) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVm().getId(), VmDeviceGeneralType.DISK, deviceType.getName());
    for (VmDevice vmDevice : vmDevices) {
        if (VmPayload.isPayload(vmDevice.getSpecParams())) {
            return new VmPayload(vmDevice);
        }
    }
    return null;
}
#method_after
protected VmPayload getVmPayloadByDeviceType(VmDeviceType deviceType) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVm().getId(), VmDeviceGeneralType.DISK, deviceType.getName());
    for (VmDevice vmDevice : vmDevices) {
        if (vmDevice.getIsManaged() && VmPayload.isPayload(vmDevice.getSpecParams())) {
            return new VmPayload(vmDevice);
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    /*
         * hotfix, https://bugzilla.redhat.com/show_bug.cgi?id=1269828
         * win 10 is only allowed to run on rhel 7.2 host && cpu Westmere+ && machine type rhel6.5.0
         */
    final OsRepository osRepository = SimpleDependecyInjector.getInstance().get(OsRepository.class);
    if (osRepository.isWindows10(getVm().getOs())) {
        /* # virsh -r capabilities */
        final String rhel65MachineType = "rhel6.5.0";
        final boolean westmereCpuOrHigher = isWestmereCpuOrHigher();
        if (!westmereCpuOrHigher) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TO_RUN_WINDOWS_10_CPU_WESTMERE_REQUIRED);
        }
        final boolean isRhel65MachineType = rhel65MachineType.equals(getVdsGroup().getEmulatedMachine());
        if (!isRhel65MachineType) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TO_RUN_WINDOWS_10_65_MACHINE_TYPE_REQUIRED);
        }
        final List<Guid> rhel72HostsIds = getRhel72HostsIds();
        if (rhel72HostsIds.isEmpty()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TO_RUN_WINDOWS_10_RHEL_72_HOST_REQUIRED);
        }
        vdsWhiteList = rhel72HostsIds;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getCanDoActionMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), getVdsGroup())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (!VmHandler.isCpuSupported(getVm().getVmOsId(), getVdsGroup().getcompatibility_version(), getVdsGroup().getcpu_name(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected List<Guid> getVdsWhiteList() {
    return vdsWhiteList;
}
#method_after
protected List<Guid> getVdsWhiteList() {
    return null;
}
#end_block

#method_before
protected void initCommands(Model m) {
    m.getCommands().add(UICommand.createDefaultOkUiCommand(CLOSE, this));
}
#method_after
protected void initCommands(Model m) {
    UICommand closeCommand = UICommand.createDefaultOkUiCommand(CLOSE, this);
    closeCommand.setIsCancel(true);
    m.getCommands().add(closeCommand);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    for (int i = 0; i < (Integer) argModuleMap.get("iterations"); i++) {
        log.info("Interation: {}", i);
        action.execute(this);
    }
}
#method_after
@Override
public void run() throws Exception {
    int iterations = (Integer) argModuleMap.get("iterations");
    for (int i = 0; i < iterations; i++) {
        log.info("Iteration: {}", i);
        action.execute(this);
    }
}
#end_block

#method_before
public void searchMyGroups() {
    stopRefresh();
    if (getIsQueryFirstTime()) {
        setSelectedItem(null);
        setSelectedItems(null);
    }
    if (getIsTimerDisabled() == false) {
        setIsQueryFirstTime(true);
        onPropertyChanged(new PropertyChangedEventArgs(PropertyChangedEventArgs.PROGRESS));
        searchMyGroupsImpl();
        setIsQueryFirstTime(false);
        startGridTimer();
    } else {
        searchMyGroupsImpl();
    }
}
#method_after
public void searchMyGroups() {
    getSearchInProgress().setEntity(true);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.setHandleFailure(true);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<String> excludeUsers = new HashSet<String>();
            if (adElementListModel.getExcludeItems() != null) {
                for (DbUser item : adElementListModel.getExcludeItems()) {
                    excludeUsers.add(item.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel<DbUser>>());
            addGroupsToModel(queryReturnValue, excludeUsers);
            adElementListModel.setusers(new ArrayList<EntityModel<DbUser>>());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetDirectoryGroupsForUser, new VdcQueryParametersBase(), asyncQuery);
}
#end_block

#method_before
@Override
public void init(final M model) {
    // Let the parent do its work
    super.init(model);
    getView().getSearchButton().setCommand(model.getSearchCommand());
    registerHandler(getView().getSearchButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getSearchButton().getCommand().execute();
        }
    }));
    model.getSearchInProgress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().getSearchButton().getCommand().setIsExecutionAllowed(!(Boolean) model.getSearchInProgress().getEntity());
        }
    });
    registerHandler(getView().getKeyPressSearchInputBox().addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                model.setSearchString(getView().getSearchString().getValue());
                getView().getSearchButton().getCommand().execute();
            }
        }
    }));
    registerHandler(getView().getEveryoneRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(true);
            model.setIsMyGroupsSelected(false);
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(true, false);
        // Disable relevant elements
        }
    }));
    registerHandler(getView().getMyGroupsRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(false);
            model.setIsMyGroupsSelected(true);
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(false, true);
            getModel().getSearchMyGroupsCommand().execute();
        // Disable relevant elements
        }
    }));
    registerHandler(getView().getSpecificUserOrGroupRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(false);
            model.setIsMyGroupsSelected(false);
            model.clearUsersAndGroups();
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(false, false);
        }
    }));
    model.getProfile().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            model.populateNamespaces();
        }
    });
    model.getNamespace().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().getSearchButton().getCommand().setIsExecutionAllowed(model.availableNamespaces());
        }
    });
    model.getIsRoleListHiddenModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().hideRoleSelection(Boolean.parseBoolean(model.getIsRoleListHiddenModel().getEntity().toString()));
        }
    });
    getView().hideEveryoneSelection(model.getIsEveryoneSelectionHidden().getEntity());
    model.getIsEveryoneSelectionHidden().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().hideEveryoneSelection(Boolean.parseBoolean(model.getIsRoleListHiddenModel().getEntity().toString()));
        }
    });
    PermissionPopupNativeKeyPressHandler keyPressHandler = new PermissionPopupNativeKeyPressHandler(getView().getNativeKeyPressHandler(), model);
    getView().setPopupKeyPressHandler(keyPressHandler);
}
#method_after
@Override
public void init(final M model) {
    // Let the parent do its work
    super.init(model);
    getView().getSearchButton().setCommand(model.getSearchCommand());
    registerHandler(getView().getSearchButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getView().getSearchButton().getCommand().execute();
        }
    }));
    model.getSearchInProgress().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().getSearchButton().getCommand().setIsExecutionAllowed(!(Boolean) model.getSearchInProgress().getEntity());
        }
    });
    registerHandler(getView().getKeyPressSearchInputBox().addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (KeyCodes.KEY_ENTER == event.getNativeEvent().getKeyCode()) {
                model.setSearchString(getView().getSearchString().getValue());
                getView().getSearchButton().getCommand().execute();
            }
        }
    }));
    registerHandler(getView().getEveryoneRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(true);
            model.setIsMyGroupsSelected(false);
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(true, false);
        // Disable relevant elements
        }
    }));
    registerHandler(getView().getMyGroupsRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(false);
            model.setIsMyGroupsSelected(true);
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(false, true);
            getModel().getSearchMyGroupsCommand().execute();
        }
    }));
    registerHandler(getView().getSpecificUserOrGroupRadio().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.setIsEveryoneSelected(false);
            model.setIsMyGroupsSelected(false);
            getView().changeStateOfElementsWhenAccessIsForEveryoneOrMyGroups(false, false);
        }
    }));
    model.getProfile().getSelectedItemChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            model.populateNamespaces();
        }
    });
    model.getNamespace().getItemsChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            getView().getSearchButton().getCommand().setIsExecutionAllowed(model.availableNamespaces());
        }
    });
    model.getIsRoleListHiddenModel().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().hideRoleSelection(Boolean.parseBoolean(model.getIsRoleListHiddenModel().getEntity().toString()));
        }
    });
    getView().hideEveryoneSelection(model.getIsEveryoneSelectionHidden().getEntity());
    model.getIsEveryoneSelectionHidden().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            getView().hideEveryoneSelection(Boolean.parseBoolean(model.getIsRoleListHiddenModel().getEntity().toString()));
        }
    });
    PermissionPopupNativeKeyPressHandler keyPressHandler = new PermissionPopupNativeKeyPressHandler(getView().getNativeKeyPressHandler(), model);
    getView().setPopupKeyPressHandler(keyPressHandler);
}
#end_block

